# 采样策略详解

> **OpenTelemetry版本**: v1.20+  
> **最后更新**: 2025年10月8日

---

## 目录

- [采样策略详解](#采样策略详解)
  - [目录](#目录)
  - [1. 为什么需要采样](#1-为什么需要采样)
    - [1.1 成本问题](#11-成本问题)
    - [1.2 性能影响](#12-性能影响)
  - [2. 采样基本概念](#2-采样基本概念)
    - [2.1 采样决策](#21-采样决策)
    - [2.2 采样率](#22-采样率)
    - [2.3 采样一致性](#23-采样一致性)
  - [3. Head-based采样](#3-head-based采样)
    - [3.1 AlwaysOn/AlwaysOff](#31-alwaysonalwaysoff)
    - [3.2 TraceIDRatioBased](#32-traceidratiobased)
    - [3.3 ParentBased](#33-parentbased)
    - [3.4 RateLimiting](#34-ratelimiting)
  - [4. Tail-based采样](#4-tail-based采样)
    - [4.1 定义与优势](#41-定义与优势)
    - [4.2 实现架构](#42-实现架构)
    - [4.3 采样策略](#43-采样策略)
  - [5. 采样决策传播](#5-采样决策传播)
    - [5.1 W3C Trace Context](#51-w3c-trace-context)
    - [5.2 决策传播流程](#52-决策传播流程)
  - [6. 形式化定义](#6-形式化定义)
  - [7. 实现示例](#7-实现示例)
    - [7.1 配置Head-based采样 (Go)](#71-配置head-based采样-go)
    - [7.2 自定义采样器](#72-自定义采样器)
    - [7.3 Tail-based采样 (Collector)](#73-tail-based采样-collector)
  - [8. 采样最佳实践](#8-采样最佳实践)
  - [9. 采样对可观测性的影响](#9-采样对可观测性的影响)
  - [10. 参考资源](#10-参考资源)

## 1. 为什么需要采样

### 1.1 成本问题

**追踪数据量**：

```text
假设:
- 服务: 100 RPS (每秒100个请求)
- 每个请求: 平均10个span
- 每个span: 平均2KB

计算:
每秒span数: 100 * 10 = 1,000 spans/s
每秒数据量: 1,000 * 2KB = 2MB/s
每天数据量: 2MB * 86,400s = 172GB/天
每月数据量: 172GB * 30 = 5.16TB/月

成本:
存储: $0.10/GB/月 → $516/月
传输: $0.10/GB → $516/月
查询: 按使用量 → 额外成本
总计: >$1,000/月 (单服务)

如果采样10%:
数据量: 517GB/月
成本: ~$100/月
节省: 90%
```

### 1.2 性能影响

**未采样的影响**：

```text
1. CPU开销
   - Span创建和操作
   - 序列化
   - 压缩
   典型: 5-15% CPU开销

2. 内存开销
   - Span缓存
   - 批处理队列
   - 导出器缓冲
   典型: 100-500MB内存

3. 网络开销
   - 导出到Collector
   - 持续带宽消耗
   典型: 2-10Mbps

4. 后端压力
   - 接收压力
   - 存储压力
   - 查询压力

采样10%后:
- CPU: 0.5-1.5%
- 内存: 10-50MB
- 网络: 0.2-1Mbps
- 后端压力: 降低90%
```

---

## 2. 采样基本概念

### 2.1 采样决策

**SamplingResult**：

```text
采样决策结果:

1. DROP
   - 不记录span
   - 不导出
   - 节省所有开销

2. RECORD_ONLY
   - 记录span (本地)
   - 不导出
   - 用于本地调试

3. RECORD_AND_SAMPLE
   - 记录span
   - 导出到后端
   - 完整追踪

决策时机:
- Span创建时 (Start)
- 可以在Span结束前更改
```

**决策属性**：

```text
SamplingResult包含:
- Decision: DROP | RECORD_ONLY | RECORD_AND_SAMPLE
- Attributes: 附加到span的属性
- TraceState: W3C tracestate更新

示例:
{
  decision: RECORD_AND_SAMPLE,
  attributes: {
    "sampling.strategy": "TraceIDRatioBased",
    "sampling.probability": 0.1
  },
  tracestate: "otel=th:8"  // threshold
}
```

### 2.2 采样率

**采样率定义**：

```text
采样率 (Sampling Rate): 被采样的trace百分比

表示:
- 分数: 0.1 (10%)
- 百分比: 10%
- 比例: 1:10

计算:
sampled_traces / total_traces = sampling_rate

示例:
- 1.0 = 100% (全部采样)
- 0.1 = 10% (采样10%)
- 0.01 = 1% (采样1%)
- 0.001 = 0.1% (采样0.1%)

权衡:
高采样率:
  + 更完整的数据
  + 更少丢失问题
  - 高成本
  - 高性能影响

低采样率:
  + 低成本
  + 低性能影响
  - 可能丢失重要trace
  - 统计精度降低
```

### 2.3 采样一致性

**Trace级别一致性**：

```text
定理: 同一trace内的所有span采样决策一致

原因:
- trace是完整的请求链路
- 部分采样会导致链路不完整
- 丢失关键span无法分析

实现:
- 基于trace_id的一致性哈希
- 父span决策传播到子span
- 跨服务传播采样决策

示例:
trace_id: abc123
hash(abc123) mod 100 = 42

如果采样率10% (阈值<10):
42 >= 10 → 不采样

该trace的所有span都不采样,保证一致性
```

---

## 3. Head-based采样

### 3.1 AlwaysOn/AlwaysOff

**AlwaysOn采样器**：

```text
定义: 总是采样

决策: RECORD_AND_SAMPLE

用途:
- 开发环境
- 低流量服务
- 关键服务 (必须完整追踪)

配置:
sampler: AlwaysOn

优点:
- 简单
- 完整数据

缺点:
- 高成本
- 高性能影响
```

**AlwaysOff采样器**：

```text
定义: 总是不采样

决策: DROP

用途:
- 禁用追踪
- 测试环境 (不需要追踪)
- 临时关闭追踪

配置:
sampler: AlwaysOff

优点:
- 零开销

缺点:
- 无数据
```

### 3.2 TraceIDRatioBased

**基于TraceID比例采样**：

```text
原理:
1. 计算trace_id的哈希值
2. 转换为[0, 1)范围的数值
3. 与采样率阈值比较

算法:
hash = trace_id的低8字节转uint64
probability = hash / 2^64
if probability < sampling_rate:
    SAMPLE
else:
    DROP

特性:
- 一致性: 相同trace_id总是相同决策
- 均匀性: 哈希分布均匀
- 无状态: 不需要记录历史

示例:
trace_id: 0x5b8efff798038103d269b633813fc60c
低8字节: 0xd269b633813fc60c
uint64: 15107958756631495180
probability: 15107958756631495180 / 2^64 ≈ 0.819

采样率10%:
0.819 >= 0.1 → 不采样

采样率90%:
0.819 < 0.9 → 采样
```

**配置示例**：

```go
import "go.opentelemetry.io/otel/sdk/trace"

// 10%采样率
sampler := trace.TraceIDRatioBased(0.1)

tp := trace.NewTracerProvider(
    trace.WithSampler(sampler),
)
```

### 3.3 ParentBased

**基于父span的采样**：

```text
定义: 根据父span的采样决策决定子span

逻辑:
if parent.sampled == true:
    SAMPLE (子span也采样)
else:
    使用root采样器 (无父span或父未采样)

用途:
- 保持trace级别一致性
- 跨服务传播决策
- 标准推荐配置

配置:
ParentBased(root=TraceIDRatioBased(0.1))

流程:
┌──────────────────────────────────────┐
│ 检查父span采样决策?                   │
└──────────┬───────────────────────────┘
           │
    ┌──────▼──────┐
    │ 有父span?   │
    └──────┬──────┘
           │
    ┌──────▼──────────────────────┐
    │ YES                          │
    │ → 使用父span采样决策         │
    └──────────────────────────────┘
           │
    ┌──────▼──────────────────────┐
    │ NO                           │
    │ → 使用root采样器             │
    └──────────────────────────────┘

优势:
- 自动一致性
- 跨服务工作
- 简化配置
```

**实现示例**：

```go
// 推荐配置
sampler := trace.ParentBased(
    trace.TraceIDRatioBased(0.1),  // root采样器: 10%
    trace.WithRemoteParentSampled(trace.AlwaysSample()),      // 远程父采样 → 采样
    trace.WithRemoteParentNotSampled(trace.NeverSample()),    // 远程父不采样 → 不采样
    trace.WithLocalParentSampled(trace.AlwaysSample()),       // 本地父采样 → 采样
    trace.WithLocalParentNotSampled(trace.NeverSample()),     // 本地父不采样 → 不采样
)

tp := trace.NewTracerProvider(
    trace.WithSampler(sampler),
)
```

### 3.4 RateLimiting

**速率限制采样器**：

```text
定义: 限制每秒采样的trace数

算法:
- 维护计数器: traces_sampled_this_second
- 检查: traces_sampled_this_second < max_traces_per_second
- 采样: 如果未超限
- 重置: 每秒重置计数器

用途:
- 控制采样流量
- 防止突发流量
- 保护后端

配置:
max_traces_per_second: 100

示例:
00:00:00 - 00:00:01: 采样100个trace
00:00:01 - 00:00:02: 采样100个trace
(即使总流量1000 trace/s)

注意:
- 不保证trace级别一致性
- 可能采样部分span
- 推荐与ParentBased组合
```

---

## 4. Tail-based采样

### 4.1 定义与优势

**Tail-based采样**：

```text
定义: 在trace完成后做采样决策

流程:
1. 收集完整trace (所有span)
2. 分析trace特征
3. 决定是否保留

优势:
+ 基于完整信息决策
+ 总是采样错误trace
+ 总是采样慢trace
+ 智能采样

劣势:
- 需要缓存所有trace (内存)
- 延迟决策 (等待trace完成)
- 需要Collector支持
- 复杂度高

对比Head-based:
Head-based: 开始时决策,快速,无完整信息
Tail-based: 结束后决策,慢,有完整信息
```

### 4.2 实现架构

**Collector-based Tail采样**：

```text
架构:
┌──────────┐
│ Service  │ (AlwaysOn采样)
└────┬─────┘
     │ 所有trace
     ▼
┌──────────────────┐
│ Collector        │
│ ┌──────────────┐ │
│ │ Tail Sampler │ │
│ │ - 缓存trace  │ │
│ │ - 等待完成   │ │
│ │ - 应用策略   │ │
│ │ - 采样决策   │ │
│ └──────────────┘ │
└────┬─────────────┘
     │ 采样后的trace
     ▼
┌──────────────────┐
│ Backend          │
│ (Jaeger/Tempo)   │
└──────────────────┘

组件:
1. Agent/SDK:
   - AlwaysOn采样
   - 导出所有span到Collector

2. Collector:
   - Tail Sampling Processor
   - 缓存trace
   - 应用策略

3. Backend:
   - 仅接收采样后的trace
   - 降低存储压力
```

### 4.3 采样策略

**常见Tail-based策略**：

```text
1. 错误采样
   - 总是采样有错误的trace
   - span.status == ERROR

2. 慢trace采样
   - 总是采样超过阈值的trace
   - duration > 1s

3. 属性采样
   - 基于特定属性采样
   - http.status_code == 500
   - user.tier == "premium"

4. 组合策略
   - 错误 OR 慢 OR 10%随机
   - 复杂布尔逻辑

5. 比例策略
   - 按trace特征调整采样率
   - 快速请求: 1%
   - 慢请求: 100%
```

**策略示例**：

```yaml
# Collector配置
processors:
  tail_sampling:
    decision_wait: 10s  # 等待trace完成
    num_traces: 100000  # 缓存trace数
    expected_new_traces_per_sec: 1000
    policies:
      # 总是采样错误
      - name: error-sampling
        type: status_code
        status_code: {status_codes: [ERROR]}
      
      # 总是采样慢trace
      - name: slow-sampling
        type: latency
        latency: {threshold_ms: 1000}
      
      # 10%随机采样
      - name: random-sampling
        type: probabilistic
        probabilistic: {sampling_percentage: 10}
      
      # 组合: 错误 OR 慢 OR 10%随机
      # (至少满足一个)
```

---

## 5. 采样决策传播

### 5.1 W3C Trace Context

**traceparent sampled标志**:

```text
W3C traceparent格式:
00-{trace-id}-{parent-id}-{trace-flags}

trace-flags (1字节):
bit 0: sampled
  - 0: 未采样
  - 1: 已采样
bit 1-7: 保留

示例:
traceparent: 00-5b8efff798038103d269b633813fc60c-eee19b7ec3c1b174-01
                                                                        ^^
                                                                        01 = 采样

traceparent: 00-5b8efff798038103d269b633813fc60c-eee19b7ec3c1b174-00
                                                                        ^^
                                                                        00 = 未采样
```

### 5.2 决策传播流程

**跨服务采样传播**：

```text
场景: Service A → Service B → Service C

Service A (root):
1. 创建span
2. 采样器决策: TraceIDRatioBased(0.1)
3. trace_id hash → 采样
4. 设置 sampled=1
5. 注入traceparent: ...-01

Service B:
1. 提取traceparent: ...-01
2. 检查 sampled=1
3. ParentBased采样器 → 采样 (继承)
4. 创建span, sampled=1
5. 注入traceparent: ...-01

Service C:
1. 提取traceparent: ...-01
2. 检查 sampled=1
3. ParentBased采样器 → 采样 (继承)
4. 创建span, sampled=1

结果: 整个trace一致采样

流程图:
[Service A]     [Service B]     [Service C]
    │               │               │
    ├─ Sample       │               │
    │  (决策)       │               │
    │               │               │
    ├──sampled=1───>│               │
    │               ├─ Sample       │
    │               │  (继承)       │
    │               │               │
    │               ├──sampled=1───>│
    │               │               ├─ Sample
    │               │               │  (继承)
    │               │               │
```

---

## 6. 形式化定义

**采样数学模型**：

```text
定义 (Sampler):
Sampler: SamplingParameters → SamplingResult

SamplingParameters = {
  trace_id,
  span_name,
  span_kind,
  attributes,
  parent_span_context
}

SamplingResult = {
  decision ∈ {DROP, RECORD_ONLY, RECORD_AND_SAMPLE},
  attributes,
  trace_state
}

定理 (Trace一致性):
∀ span_i, span_j ∈ Trace(tid),
  sampled(span_i) = sampled(span_j)

证明: 通过ParentBased采样器和trace_id一致性哈希保证

定义 (采样率):
sampling_rate = P(SAMPLE | trace)
              = |{traces | sampled}| / |{traces}|

定理 (TraceIDRatioBased均匀性):
∀ r ∈ [0, 1],
  P(SAMPLE | rate=r) ≈ r

证明: trace_id均匀分布 + 一致性哈希
```

---

## 7. 实现示例

### 7.1 配置Head-based采样 (Go)

```go
package main

import (
    "context"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/sdk/trace"
)

func initTracer() (*trace.TracerProvider, error) {
    // 1. TraceIDRatioBased采样 (10%)
    sampler1 := trace.TraceIDRatioBased(0.1)
    
    // 2. ParentBased采样 (推荐)
    sampler2 := trace.ParentBased(
        trace.TraceIDRatioBased(0.1),  // root: 10%
    )
    
    // 3. 自定义采样: 总是采样错误
    sampler3 := NewErrorSampler(0.1)  // 正常10%, 错误100%
    
    tp := trace.NewTracerProvider(
        trace.WithSampler(sampler2),  // 使用ParentBased
        // ... 其他配置
    )
    
    otel.SetTracerProvider(tp)
    return tp, nil
}
```

### 7.2 自定义采样器

```go
type ErrorSampler struct {
    baseSampler trace.Sampler
}

func NewErrorSampler(baseRate float64) *ErrorSampler {
    return &ErrorSampler{
        baseSampler: trace.TraceIDRatioBased(baseRate),
    }
}

func (s *ErrorSampler) ShouldSample(p trace.SamplingParameters) trace.SamplingResult {
    // 检查是否有error属性
    for _, attr := range p.Attributes {
        if attr.Key == "error" && attr.Value.AsBool() {
            // 总是采样错误
            return trace.SamplingResult{
                Decision:   trace.RecordAndSample,
                Attributes: []attribute.KeyValue{
                    attribute.String("sampling.rule", "error"),
                },
            }
        }
    }
    
    // 否则使用基础采样器
    return s.baseSampler.ShouldSample(p)
}

func (s *ErrorSampler) Description() string {
    return "ErrorSampler(always_sample_errors)"
}
```

### 7.3 Tail-based采样 (Collector)

**Collector配置**：

```yaml
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317

processors:
  # Tail Sampling Processor
  tail_sampling:
    # 等待trace完成的时间
    decision_wait: 10s
    
    # 缓存trace数量
    num_traces: 100000
    
    # 预期新trace速率
    expected_new_traces_per_sec: 1000
    
    # 采样策略
    policies:
      # 策略1: 总是采样错误
      - name: errors-policy
        type: status_code
        status_code:
          status_codes: [ERROR]
      
      # 策略2: 总是采样慢trace (>1s)
      - name: slow-policy
        type: latency
        latency:
          threshold_ms: 1000
      
      # 策略3: 采样特定HTTP状态码
      - name: http-5xx-policy
        type: string_attribute
        string_attribute:
          key: http.status_code
          values: ["500", "502", "503", "504"]
      
      # 策略4: 10%随机采样 (其他情况)
      - name: random-policy
        type: probabilistic
        probabilistic:
          sampling_percentage: 10

exporters:
  otlp:
    endpoint: jaeger:4317

service:
  pipelines:
    traces:
      receivers: [otlp]
      processors: [tail_sampling]
      exporters: [otlp]
```

---

## 8. 采样最佳实践

```text
1. 采样器选择
   ✅ 生产: ParentBased(TraceIDRatioBased(0.1))
   ✅ 开发: AlwaysOn
   ✅ 测试: AlwaysOff

2. 采样率
   ✅ 高流量服务: 1-10%
   ✅ 中流量服务: 10-50%
   ✅ 低流量服务: 50-100%
   ✅ 关键服务: 总是采样错误

3. Head vs Tail
   ✅ Head: 简单, 低开销, 推荐起点
   ✅ Tail: 智能, 需Collector, 高级用例

4. 错误采样
   ✅ 总是采样错误trace
   ✅ 使用自定义采样器
   ✅ 或使用Tail-based采样

5. 监控
   ✅ 监控采样率
   ✅ 监控丢弃的trace数
   ✅ 定期调整采样率

6. 一致性
   ✅ 使用ParentBased保证一致性
   ✅ 正确传播traceparent
   ✅ 避免中途改变采样决策

7. 成本控制
   ✅ 根据预算调整采样率
   ✅ 监控后端存储使用
   ✅ 考虑使用Tail采样降低成本
```

---

## 9. 采样对可观测性的影响

**权衡分析**：

```text
优势:
+ 降低成本 (线性)
+ 降低性能影响 (线性)
+ 降低后端压力 (线性)

劣势:
- 丢失部分trace
- 统计精度降低
- 可能丢失重要问题

缓解措施:
1. 总是采样错误
   - 自定义采样器
   - Tail-based采样

2. 智能采样
   - 关键路径: 高采样率
   - 普通路径: 低采样率

3. 动态调整
   - 根据错误率调整
   - 根据成本调整

4. 补充Metrics
   - Metrics不采样
   - 提供统计全貌
   - 配合Traces分析
```

---

## 10. 参考资源

- **Sampling Spec**: <https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/sdk.md#sampling>
- **Tail Sampling**: <https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/tailsamplingprocessor>
- **W3C Trace Context**: <https://www.w3.org/TR/trace-context/>

---

**文档状态**: ✅ 完成  
**审核状态**: 待审核  
**下一步**: [02_性能优化.md](./02_性能优化.md)
