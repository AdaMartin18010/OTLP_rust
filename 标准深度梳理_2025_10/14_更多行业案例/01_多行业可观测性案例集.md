# 多行业可观测性案例集

> **标准版本**: v1.27.0  
> **状态**: Stable  
> **最后更新**: 2025年10月8日

---

## 目录

- [多行业可观测性案例集](#多行业可观测性案例集)
  - [目录](#目录)
  - [1. 概述](#1-概述)
  - [2. 医疗行业](#2-医疗行业)
    - [2.1 医院信息系统（HIS）](#21-医院信息系统his)
    - [2.2 远程医疗平台](#22-远程医疗平台)
    - [2.3 医疗设备监控](#23-医疗设备监控)
  - [3. 游戏行业](#3-游戏行业)
    - [3.1 在线游戏服务器](#31-在线游戏服务器)
    - [3.2 玩家行为追踪](#32-玩家行为追踪)
    - [3.3 游戏资产服务](#33-游戏资产服务)
  - [4. 能源行业](#4-能源行业)
    - [4.1 智能电网监控](#41-智能电网监控)
    - [4.2 风电场数据采集](#42-风电场数据采集)
    - [4.3 能源管理系统](#43-能源管理系统)
  - [5. 零售行业](#5-零售行业)
    - [5.1 新零售POS系统](#51-新零售pos系统)
    - [5.2 供应链追踪](#52-供应链追踪)
    - [5.3 客户体验监控](#53-客户体验监控)
  - [6. 教育行业](#6-教育行业)
    - [6.1 在线教育平台](#61-在线教育平台)
    - [6.2 学习行为分析](#62-学习行为分析)
  - [7. 交通运输](#7-交通运输)
    - [7.1 智慧交通系统](#71-智慧交通系统)
    - [7.2 物流追踪平台](#72-物流追踪平台)
  - [8. 媒体娱乐](#8-媒体娱乐)
    - [8.1 流媒体服务](#81-流媒体服务)
    - [8.2 内容推荐系统](#82-内容推荐系统)
  - [9. 参考资源](#9-参考资源)

---

## 1. 概述

本文档汇总了不同行业领域中OpenTelemetry可观测性的实践案例，涵盖医疗、游戏、能源、零售、教育、交通和媒体等多个行业。

**共同目标**：

```text
✅ 提升系统可靠性
✅ 优化用户体验
✅ 降低运维成本
✅ 满足合规要求
✅ 支持业务决策
```

---

## 2. 医疗行业

### 2.1 医院信息系统（HIS）

**场景描述**：
医院信息系统需要追踪患者就诊流程、药品配发、检查检验等关键业务流程，确保医疗数据的准确性和及时性。

**关键监控点**：

```text
- 患者注册与登记
- 医生诊断流程
- 药品处方开具
- 检查检验预约与结果
- 医疗数据同步
- 系统响应时间
```

**实现示例（Go）**：

```go
package main

import (
    "context"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

type HospitalService struct {
    tracer trace.Tracer
}

func NewHospitalService() *HospitalService {
    return &HospitalService{
        tracer: otel.Tracer("hospital-his"),
    }
}

// 患者就诊流程追踪
func (h *HospitalService) ProcessPatientVisit(ctx context.Context, patientID, doctorID string) error {
    ctx, span := h.tracer.Start(ctx, "patient.visit")
    defer span.End()
    
    // 脱敏患者ID（HIPAA合规）
    hashedPatientID := hashID(patientID)
    
    span.SetAttributes(
        attribute.String("patient.id.hashed", hashedPatientID),
        attribute.String("doctor.id", doctorID),
        attribute.String("department", "internal_medicine"),
    )
    
    // 1. 挂号
    if err := h.registerVisit(ctx, patientID); err != nil {
        span.RecordError(err)
        return err
    }
    
    // 2. 诊断
    diagnosis, err := h.conductDiagnosis(ctx, patientID, doctorID)
    if err != nil {
        span.RecordError(err)
        return err
    }
    
    span.SetAttribute("diagnosis.result", diagnosis)
    
    // 3. 开药
    if err := h.prescribeMedication(ctx, patientID, diagnosis); err != nil {
        span.RecordError(err)
        return err
    }
    
    span.AddEvent("visit_completed")
    return nil
}

// 医疗数据同步追踪
func (h *HospitalService) SyncMedicalRecords(ctx context.Context, recordID string) error {
    ctx, span := h.tracer.Start(ctx, "records.sync")
    defer span.End()
    
    span.SetAttributes(
        attribute.String("record.id", hashID(recordID)),
        attribute.String("sync.destination", "regional_health_bureau"),
    )
    
    // 记录同步开始时间
    startTime := time.Now()
    
    // 执行同步
    if err := syncToExternalSystem(recordID); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "Sync failed")
        return err
    }
    
    duration := time.Since(startTime)
    span.SetAttribute("sync.duration_ms", duration.Milliseconds())
    
    return nil
}
```

**合规性考虑**：

```text
✅ HIPAA合规: 患者数据脱敏
✅ GDPR合规: 数据最小化原则
✅ 数据保留: 7年医疗记录保留
✅ 审计追踪: 完整的操作日志
```

### 2.2 远程医疗平台

**Python实现示例**：

```python
from opentelemetry import trace
from opentelemetry.trace import Status, StatusCode

tracer = trace.get_tracer(__name__)

class TelemedicineService:
    def __init__(self):
        self.tracer = tracer
    
    def start_video_consultation(self, patient_id, doctor_id):
        """开始视频问诊"""
        with self.tracer.start_as_current_span("consultation.video_call") as span:
            # 脱敏处理
            span.set_attribute("patient.id.hashed", hash_id(patient_id))
            span.set_attribute("doctor.id", doctor_id)
            span.set_attribute("consultation.type", "video")
            
            try:
                # 建立WebRTC连接
                session = self.establish_webrtc_connection(patient_id, doctor_id)
                span.set_attribute("session.id", session.id)
                
                # 监控视频质量
                self.monitor_video_quality(span, session)
                
                span.set_status(Status(StatusCode.OK))
                return session
            except Exception as e:
                span.record_exception(e)
                span.set_status(Status(StatusCode.ERROR, str(e)))
                raise
    
    def monitor_video_quality(self, span, session):
        """监控视频质量指标"""
        quality_metrics = session.get_quality_metrics()
        
        span.set_attribute("video.bitrate_kbps", quality_metrics['bitrate'])
        span.set_attribute("video.frame_rate", quality_metrics['fps'])
        span.set_attribute("video.latency_ms", quality_metrics['latency'])
        span.set_attribute("video.packet_loss_rate", quality_metrics['packet_loss'])
```

### 2.3 医疗设备监控

**医疗设备遥测数据采集**：

```python
class MedicalDeviceMonitor:
    def __init__(self):
        self.tracer = trace.get_tracer(__name__)
        self.meter = metrics.get_meter(__name__)
        self.setup_metrics()
    
    def setup_metrics(self):
        """设置医疗设备指标"""
        # 设备状态
        self.device_status = self.meter.create_observable_gauge(
            "medical.device.status",
            callbacks=[self._observe_device_status],
            description="Medical device operational status"
        )
        
        # 设备告警
        self.device_alerts = self.meter.create_counter(
            "medical.device.alerts",
            description="Medical device alert count"
        )
    
    def monitor_ventilator(self, device_id):
        """监控呼吸机"""
        with self.tracer.start_as_current_span("device.ventilator") as span:
            span.set_attribute("device.id", device_id)
            span.set_attribute("device.type", "ventilator")
            
            # 读取设备参数
            params = self.read_ventilator_params(device_id)
            
            span.set_attribute("ventilator.tidal_volume", params['tidal_volume'])
            span.set_attribute("ventilator.respiratory_rate", params['respiratory_rate'])
            span.set_attribute("ventilator.oxygen_concentration", params['o2_concentration'])
            
            # 检查告警条件
            if params['o2_concentration'] < 21:
                span.add_event("low_oxygen_alert", {
                    "severity": "critical",
                    "value": params['o2_concentration']
                })
                self.device_alerts.add(1, {"device_id": device_id, "alert_type": "low_oxygen"})
```

---

## 3. 游戏行业

### 3.1 在线游戏服务器

**游戏服务器性能监控**：

```go
type GameServer struct {
    tracer trace.Tracer
    meter  metric.Meter
}

func (g *GameServer) HandlePlayerAction(ctx context.Context, playerID, action string) error {
    ctx, span := g.tracer.Start(ctx, "game.player_action")
    defer span.End()
    
    span.SetAttributes(
        attribute.String("player.id", playerID),
        attribute.String("action.type", action),
        attribute.String("server.region", "us-west-1"),
    )
    
    // 记录玩家动作开始
    startTime := time.Now()
    
    // 执行游戏逻辑
    result, err := g.processGameAction(ctx, playerID, action)
    if err != nil {
        span.RecordError(err)
        return err
    }
    
    // 记录响应时间
    duration := time.Since(startTime)
    span.SetAttribute("action.duration_ms", duration.Milliseconds())
    
    // 记录结果
    span.SetAttribute("action.result", result.Status)
    span.SetAttribute("action.rewards", result.Rewards)
    
    return nil
}

// 监控游戏房间
func (g *GameServer) MonitorGameRoom(ctx context.Context, roomID string) {
    ctx, span := g.tracer.Start(ctx, "game.room")
    defer span.End()
    
    span.SetAttributes(
        attribute.String("room.id", roomID),
        attribute.Int("room.player_count", g.getRoomPlayerCount(roomID)),
        attribute.String("room.map", g.getRoomMap(roomID)),
    )
    
    // 监控游戏房间指标
    playerCount := g.getRoomPlayerCount(roomID)
    avgLatency := g.getRoomAvgLatency(roomID)
    
    span.SetAttribute("room.avg_latency_ms", avgLatency)
    
    // 检测延迟异常
    if avgLatency > 100 {
        span.AddEvent("high_latency_detected", trace.WithAttributes(
            attribute.String("severity", "warning"),
            attribute.Int64("latency_ms", avgLatency),
        ))
    }
}
```

### 3.2 玩家行为追踪

**玩家旅程追踪**：

```python
class PlayerAnalytics:
    def __init__(self):
        self.tracer = trace.get_tracer(__name__)
    
    def track_player_session(self, player_id, session_id):
        """追踪玩家游戏会话"""
        with self.tracer.start_as_current_span("player.session") as span:
            span.set_attribute("player.id", player_id)
            span.set_attribute("session.id", session_id)
            
            # 记录会话开始
            session_start = time.time()
            span.add_event("session_started")
            
            # 追踪关键事件
            self.track_level_progression(span, player_id)
            self.track_purchases(span, player_id)
            self.track_social_interactions(span, player_id)
            
            # 会话结束
            session_duration = time.time() - session_start
            span.set_attribute("session.duration_seconds", session_duration)
            span.add_event("session_ended")
    
    def track_purchases(self, parent_span, player_id):
        """追踪玩家内购"""
        with self.tracer.start_as_current_span("player.purchase", parent_span) as span:
            purchases = get_player_purchases(player_id)
            
            span.set_attribute("purchases.count", len(purchases))
            span.set_attribute("purchases.total_amount", sum(p.amount for p in purchases))
            
            for purchase in purchases:
                span.add_event("item_purchased", {
                    "item.id": purchase.item_id,
                    "item.type": purchase.item_type,
                    "amount": purchase.amount,
                    "currency": purchase.currency
                })
```

### 3.3 游戏资产服务

**游戏资产加载追踪**：

```javascript
const { trace } = require('@opentelemetry/api');

class AssetService {
    constructor() {
        this.tracer = trace.getTracer('game-assets');
    }
    
    async loadGameAssets(sceneId) {
        const span = this.tracer.startSpan('assets.load_scene');
        span.setAttribute('scene.id', sceneId);
        
        try {
            const startTime = Date.now();
            
            // 加载不同类型资产
            const [models, textures, sounds] = await Promise.all([
                this.loadModels(span, sceneId),
                this.loadTextures(span, sceneId),
                this.loadSounds(span, sceneId)
            ]);
            
            const loadTime = Date.now() - startTime;
            span.setAttribute('assets.load_time_ms', loadTime);
            span.setAttribute('assets.models_count', models.length);
            span.setAttribute('assets.textures_count', textures.length);
            span.setAttribute('assets.sounds_count', sounds.length);
            
            span.end();
            return { models, textures, sounds };
        } catch (error) {
            span.recordException(error);
            span.setStatus({ code: SpanStatusCode.ERROR });
            span.end();
            throw error;
        }
    }
}
```

---

## 4. 能源行业

### 4.1 智能电网监控

**电网节点监控**：

```go
type SmartGridMonitor struct {
    tracer trace.Tracer
    meter  metric.Meter
}

func (s *SmartGridMonitor) MonitorGridNode(ctx context.Context, nodeID string) {
    ctx, span := s.tracer.Start(ctx, "grid.node")
    defer span.End()
    
    span.SetAttributes(
        attribute.String("node.id", nodeID),
        attribute.String("node.type", "transformer"),
        attribute.String("node.region", "east-grid"),
    )
    
    // 读取电网节点数据
    voltage := s.readVoltage(nodeID)
    current := s.readCurrent(nodeID)
    power := voltage * current
    
    span.SetAttributes(
        attribute.Float64("grid.voltage_v", voltage),
        attribute.Float64("grid.current_a", current),
        attribute.Float64("grid.power_kw", power/1000),
    )
    
    // 检测异常
    if voltage < 220 || voltage > 240 {
        span.AddEvent("voltage_anomaly", trace.WithAttributes(
            attribute.String("severity", "warning"),
            attribute.Float64("voltage", voltage),
        ))
    }
    
    // 记录负载指标
    loadPercentage := s.calculateLoadPercentage(power)
    span.SetAttribute("grid.load_percentage", loadPercentage)
}
```

### 4.2 风电场数据采集

**风力发电机组监控**：

```python
class WindTurbineMonitor:
    def __init__(self):
        self.tracer = trace.get_tracer(__name__)
    
    def monitor_turbine(self, turbine_id):
        """监控风力发电机组"""
        with self.tracer.start_as_current_span("turbine.monitor") as span:
            span.set_attribute("turbine.id", turbine_id)
            span.set_attribute("turbine.location", self.get_turbine_location(turbine_id))
            
            # 采集运行数据
            data = self.collect_turbine_data(turbine_id)
            
            span.set_attribute("turbine.wind_speed_ms", data['wind_speed'])
            span.set_attribute("turbine.rotor_speed_rpm", data['rotor_speed'])
            span.set_attribute("turbine.power_output_kw", data['power_output'])
            span.set_attribute("turbine.blade_angle_deg", data['blade_angle'])
            span.set_attribute("turbine.generator_temp_c", data['generator_temp'])
            
            # 计算效率
            efficiency = self.calculate_efficiency(data)
            span.set_attribute("turbine.efficiency_percentage", efficiency)
            
            # 检测故障
            if data['generator_temp'] > 80:
                span.add_event("high_temperature_alert", {
                    "severity": "critical",
                    "temperature": data['generator_temp']
                })
            
            # 预测性维护
            maintenance_score = self.predict_maintenance_need(data)
            span.set_attribute("turbine.maintenance_score", maintenance_score)
```

### 4.3 能源管理系统

**能源消耗追踪**：

```python
class EnergyManagementSystem:
    def track_energy_consumption(self, building_id):
        """追踪建筑能源消耗"""
        with self.tracer.start_as_current_span("energy.building") as span:
            span.set_attribute("building.id", building_id)
            span.set_attribute("building.type", "commercial")
            
            # 采集各类能源消耗
            electricity = self.get_electricity_consumption(building_id)
            gas = self.get_gas_consumption(building_id)
            water = self.get_water_consumption(building_id)
            
            span.set_attribute("energy.electricity_kwh", electricity)
            span.set_attribute("energy.gas_m3", gas)
            span.set_attribute("energy.water_m3", water)
            
            # 计算碳排放
            carbon_footprint = self.calculate_carbon_footprint(electricity, gas)
            span.set_attribute("energy.carbon_footprint_kg", carbon_footprint)
            
            # 能效评分
            efficiency_score = self.calculate_energy_efficiency(building_id)
            span.set_attribute("building.efficiency_score", efficiency_score)
```

---

## 5. 零售行业

### 5.1 新零售POS系统

**收银流程追踪**：

```java
public class POSSystem {
    private final Tracer tracer;
    
    public void processTransaction(String transactionId, List<Item> items) {
        Span span = tracer.spanBuilder("pos.transaction")
            .setAttribute("transaction.id", transactionId)
            .setAttribute("transaction.item_count", items.size())
            .startSpan();
        
        try (Scope scope = span.makeCurrent()) {
            // 1. 扫描商品
            for (Item item : items) {
                scanItem(item);
            }
            
            // 2. 计算总价
            double totalPrice = calculateTotal(items);
            span.setAttribute("transaction.total_amount", totalPrice);
            
            // 3. 处理支付
            processPayment(transactionId, totalPrice);
            
            // 4. 打印小票
            printReceipt(transactionId);
            
            span.addEvent("transaction_completed");
        } catch (Exception e) {
            span.recordException(e);
            span.setStatus(StatusCode.ERROR, e.getMessage());
            throw e;
        } finally {
            span.end();
        }
    }
}
```

### 5.2 供应链追踪

**商品配送追踪**：

```go
func TrackOrderDelivery(ctx context.Context, orderID string) {
    tracer := otel.Tracer("supply-chain")
    ctx, span := tracer.Start(ctx, "order.delivery")
    defer span.End()
    
    span.SetAttributes(
        attribute.String("order.id", orderID),
        attribute.String("order.status", "in_transit"),
    )
    
    // 追踪配送节点
    deliverySteps := []string{
        "warehouse_picked",
        "sorting_center",
        "distribution_center",
        "last_mile_delivery",
        "delivered"
    }
    
    for _, step := range deliverySteps {
        span.AddEvent(step, trace.WithTimestamp(time.Now()))
        
        // 更新位置
        location := getPackageLocation(orderID)
        span.SetAttribute(fmt.Sprintf("location.%s", step), location)
    }
}
```

### 5.3 客户体验监控

**用户购物旅程追踪**：

```python
class CustomerJourneyTracker:
    def track_shopping_journey(self, customer_id):
        """追踪客户购物旅程"""
        with self.tracer.start_as_current_span("customer.journey") as span:
            span.set_attribute("customer.id", hash_id(customer_id))
            
            # 1. 浏览商品
            browsed_products = self.track_product_browsing(span, customer_id)
            span.set_attribute("journey.products_viewed", len(browsed_products))
            
            # 2. 加入购物车
            cart_items = self.track_cart_additions(span, customer_id)
            span.set_attribute("journey.cart_items", len(cart_items))
            
            # 3. 结算
            checkout_result = self.track_checkout(span, customer_id)
            span.set_attribute("journey.checkout_completed", checkout_result.success)
            
            if checkout_result.success:
                span.set_attribute("journey.order_value", checkout_result.order_value)
                span.add_event("purchase_completed")
```

---

## 6. 教育行业

### 6.1 在线教育平台

**课程学习追踪**：

```javascript
class OnlineLearningPlatform {
    trackCourseProgress(studentId, courseId) {
        const span = this.tracer.startSpan('learning.course_progress');
        span.setAttribute('student.id', hashId(studentId));
        span.setAttribute('course.id', courseId);
        
        try {
            // 追踪学习活动
            const activities = this.getStudentActivities(studentId, courseId);
            
            span.setAttribute('learning.total_time_minutes', activities.totalTime);
            span.setAttribute('learning.videos_watched', activities.videosWatched);
            span.setAttribute('learning.quizzes_completed', activities.quizzesCompleted);
            span.setAttribute('learning.progress_percentage', activities.progressPercentage);
            
            // 记录里程碑
            if (activities.progressPercentage >= 50) {
                span.addEvent('milestone_50_percent');
            }
            
            if (activities.progressPercentage === 100) {
                span.addEvent('course_completed');
            }
            
            span.end();
        } catch (error) {
            span.recordException(error);
            span.setStatus({ code: SpanStatusCode.ERROR });
            span.end();
        }
    }
}
```

### 6.2 学习行为分析

```python
class LearningAnalytics:
    def analyze_engagement(self, student_id, course_id):
        """分析学生参与度"""
        with self.tracer.start_as_current_span("analytics.engagement") as span:
            span.set_attribute("student.id", hash_id(student_id))
            span.set_attribute("course.id", course_id)
            
            # 计算参与度指标
            engagement_metrics = self.calculate_engagement(student_id, course_id)
            
            span.set_attribute("engagement.login_frequency", engagement_metrics['login_frequency'])
            span.set_attribute("engagement.avg_session_duration_min", engagement_metrics['avg_session'])
            span.set_attribute("engagement.discussion_posts", engagement_metrics['discussion_posts'])
            span.set_attribute("engagement.score", engagement_metrics['overall_score'])
            
            # 预警低参与度
            if engagement_metrics['overall_score'] < 30:
                span.add_event("low_engagement_alert", {
                    "severity": "warning",
                    "score": engagement_metrics['overall_score']
                })
```

---

## 7. 交通运输

### 7.1 智慧交通系统

**交通流量监控**：

```go
func MonitorTrafficFlow(ctx context.Context, intersectionID string) {
    tracer := otel.Tracer("smart-traffic")
    ctx, span := tracer.Start(ctx, "traffic.intersection")
    defer span.End()
    
    span.SetAttributes(
        attribute.String("intersection.id", intersectionID),
        attribute.String("intersection.location", getIntersectionLocation(intersectionID)),
    )
    
    // 监控各方向车流量
    northFlow := getVehicleCount(intersectionID, "north")
    southFlow := getVehicleCount(intersectionID, "south")
    eastFlow := getVehicleCount(intersectionID, "east")
    westFlow := getVehicleCount(intersectionID, "west")
    
    span.SetAttributes(
        attribute.Int64("traffic.north_flow", northFlow),
        attribute.Int64("traffic.south_flow", southFlow),
        attribute.Int64("traffic.east_flow", eastFlow),
        attribute.Int64("traffic.west_flow", westFlow),
    )
    
    // 计算拥堵指数
    congestionIndex := calculateCongestion(northFlow, southFlow, eastFlow, westFlow)
    span.SetAttribute("traffic.congestion_index", congestionIndex)
    
    // 优化信号灯
    if congestionIndex > 0.8 {
        span.AddEvent("adjust_traffic_lights", trace.WithAttributes(
            attribute.String("action", "extend_green_time"),
        ))
    }
}
```

### 7.2 物流追踪平台

```python
class LogisticsTracker:
    def track_shipment(self, shipment_id):
        """追踪货运包裹"""
        with self.tracer.start_as_current_span("logistics.shipment") as span:
            span.set_attribute("shipment.id", shipment_id)
            
            # 获取当前状态
            status = self.get_shipment_status(shipment_id)
            span.set_attribute("shipment.status", status.current_state)
            span.set_attribute("shipment.location", status.current_location)
            span.set_attribute("shipment.carrier", status.carrier)
            
            # 预计送达时间
            eta = self.calculate_eta(shipment_id)
            span.set_attribute("shipment.eta", eta.isoformat())
            
            # 异常检测
            if status.is_delayed:
                span.add_event("shipment_delayed", {
                    "delay_reason": status.delay_reason,
                    "delay_hours": status.delay_hours
                })
```

---

## 8. 媒体娱乐

### 8.1 流媒体服务

**视频播放监控**：

```javascript
class VideoStreamingService {
    trackVideoPlayback(userId, videoId) {
        const span = this.tracer.startSpan('video.playback');
        span.setAttribute('user.id', hashId(userId));
        span.setAttribute('video.id', videoId);
        
        try {
            const startTime = Date.now();
            
            // 追踪播放事件
            this.trackPlayerEvents(span, userId, videoId);
            
            // 监控播放质量
            const qualityMetrics = this.getQualityMetrics(userId);
            span.setAttribute('video.bitrate_kbps', qualityMetrics.bitrate);
            span.setAttribute('video.resolution', qualityMetrics.resolution);
            span.setAttribute('video.buffer_ratio', qualityMetrics.bufferRatio);
            span.setAttribute('video.startup_time_ms', qualityMetrics.startupTime);
            
            // 检测卡顿
            if (qualityMetrics.bufferRatio > 0.05) {
                span.addEvent('buffering_detected', {
                    buffer_ratio: qualityMetrics.bufferRatio
                });
            }
            
            const playbackDuration = Date.now() - startTime;
            span.setAttribute('video.playback_duration_ms', playbackDuration);
            
            span.end();
        } catch (error) {
            span.recordException(error);
            span.setStatus({ code: SpanStatusCode.ERROR });
            span.end();
        }
    }
}
```

### 8.2 内容推荐系统

```python
class RecommendationEngine:
    def generate_recommendations(self, user_id):
        """生成个性化推荐"""
        with self.tracer.start_as_current_span("recommendation.generate") as span:
            span.set_attribute("user.id", hash_id(user_id))
            
            # 获取用户画像
            user_profile = self.get_user_profile(user_id)
            span.set_attribute("user.segment", user_profile.segment)
            
            # 候选内容生成
            candidates = self.fetch_candidates(user_profile)
            span.set_attribute("candidates.count", len(candidates))
            
            # 排序与过滤
            ranked_items = self.rank_items(candidates, user_profile)
            span.set_attribute("recommendations.count", len(ranked_items))
            
            # 记录推荐质量
            diversity_score = self.calculate_diversity(ranked_items)
            span.set_attribute("recommendations.diversity_score", diversity_score)
            
            return ranked_items
```

---

## 9. 参考资源

**官方文档**：

- OpenTelemetry Specification: <https://opentelemetry.io/docs/specs/otel/>
- Semantic Conventions: <https://opentelemetry.io/docs/specs/semconv/>

**行业最佳实践**：

- Healthcare: <https://opentelemetry.io/docs/use-cases/healthcare/>
- Gaming: <https://opentelemetry.io/docs/use-cases/gaming/>
- Energy: <https://opentelemetry.io/docs/use-cases/energy/>

---

**文档维护**: OTLP深度梳理项目组  
**最后更新**: 2025年10月8日  
**文档版本**: v1.0  
**质量等级**: ⭐⭐⭐⭐⭐
