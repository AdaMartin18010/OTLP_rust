# Rust æ€§èƒ½åˆ†æå·¥å…·é“¾ä¸å®æˆ˜

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ8æ—¥  
> **Rustç‰ˆæœ¬**: 1.90+  
> **ç›®æ ‡**: æŒæ¡Rustæ€§èƒ½åˆ†æå·¥å…·é“¾

---

## ğŸ“‹ ç›®å½•

- [Rust æ€§èƒ½åˆ†æå·¥å…·é“¾ä¸å®æˆ˜](#rust-æ€§èƒ½åˆ†æå·¥å…·é“¾ä¸å®æˆ˜)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. å·¥å…·é“¾æ¦‚è§ˆ](#1-å·¥å…·é“¾æ¦‚è§ˆ)
    - [1.1 Rust æ€§èƒ½åˆ†æå·¥å…·ç”Ÿæ€](#11-rust-æ€§èƒ½åˆ†æå·¥å…·ç”Ÿæ€)
    - [1.2 å®‰è£…å·¥å…·é“¾](#12-å®‰è£…å·¥å…·é“¾)
  - [2. cargo-flamegraph](#2-cargo-flamegraph)
    - [2.1 åŸºç¡€ä½¿ç”¨](#21-åŸºç¡€ä½¿ç”¨)
    - [2.2 é«˜çº§é…ç½®](#22-é«˜çº§é…ç½®)
    - [2.3 å®æˆ˜ç¤ºä¾‹](#23-å®æˆ˜ç¤ºä¾‹)
  - [3. perf å·¥å…·é›†æˆ](#3-perf-å·¥å…·é›†æˆ)
    - [3.1 perf åŸºç¡€](#31-perf-åŸºç¡€)
    - [3.2 perf stat](#32-perf-stat)
    - [3.3 perf ç«ç„°å›¾](#33-perf-ç«ç„°å›¾)
  - [4. valgrind/cachegrind](#4-valgrindcachegrind)
    - [4.1 Memcheck (å†…å­˜æ£€æŸ¥)](#41-memcheck-å†…å­˜æ£€æŸ¥)
    - [4.2 Cachegrind (ç¼“å­˜åˆ†æ)](#42-cachegrind-ç¼“å­˜åˆ†æ)
    - [4.3 Callgrind (è°ƒç”¨å›¾åˆ†æ)](#43-callgrind-è°ƒç”¨å›¾åˆ†æ)
  - [5. å†…å­˜æ³„æ¼æ£€æµ‹](#5-å†…å­˜æ³„æ¼æ£€æµ‹)
    - [5.1 ä½¿ç”¨ heaptrack](#51-ä½¿ç”¨-heaptrack)
    - [5.2 è‡ªå®šä¹‰å†…å­˜è¿½è¸ª](#52-è‡ªå®šä¹‰å†…å­˜è¿½è¸ª)
  - [6. å¹¶å‘æ€§èƒ½åˆ†æ](#6-å¹¶å‘æ€§èƒ½åˆ†æ)
    - [6.1 é”ç«äº‰åˆ†æ](#61-é”ç«äº‰åˆ†æ)
    - [6.2 æ— é”ç®—æ³•æ€§èƒ½](#62-æ— é”ç®—æ³•æ€§èƒ½)
  - [7. å¼‚æ­¥ä»»åŠ¡è°ƒåº¦åˆ†æ](#7-å¼‚æ­¥ä»»åŠ¡è°ƒåº¦åˆ†æ)
    - [7.1 Tokio Console å®æˆ˜](#71-tokio-console-å®æˆ˜)
    - [7.2 è‡ªå®šä¹‰ Tokio Metrics](#72-è‡ªå®šä¹‰-tokio-metrics)
  - [8. å®æˆ˜æ¡ˆä¾‹åˆ†æ](#8-å®æˆ˜æ¡ˆä¾‹åˆ†æ)
    - [8.1 æ¡ˆä¾‹1: HTTP æœåŠ¡æ€§èƒ½ä¼˜åŒ–](#81-æ¡ˆä¾‹1-http-æœåŠ¡æ€§èƒ½ä¼˜åŒ–)
    - [8.2 æ¡ˆä¾‹2: å†…å­˜æ³„æ¼æ’æŸ¥](#82-æ¡ˆä¾‹2-å†…å­˜æ³„æ¼æ’æŸ¥)
    - [8.3 æ¡ˆä¾‹3: å¼‚æ­¥ä»»åŠ¡å †ç§¯](#83-æ¡ˆä¾‹3-å¼‚æ­¥ä»»åŠ¡å †ç§¯)
  - [9. æ€§èƒ½ä¼˜åŒ–å»ºè®®](#9-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
    - [9.1 é€šç”¨ä¼˜åŒ–æŠ€å·§](#91-é€šç”¨ä¼˜åŒ–æŠ€å·§)
    - [9.2 å¼‚æ­¥ä¼˜åŒ–](#92-å¼‚æ­¥ä¼˜åŒ–)
    - [9.3 ç¼–è¯‘ä¼˜åŒ–](#93-ç¼–è¯‘ä¼˜åŒ–)
  - [ğŸ“š å·¥å…·é“¾æ€»ç»“](#-å·¥å…·é“¾æ€»ç»“)
    - [å·¥å…·é€‰æ‹©å†³ç­–æ ‘](#å·¥å…·é€‰æ‹©å†³ç­–æ ‘)
    - [å®Œæ•´å·¥ä½œæµ](#å®Œæ•´å·¥ä½œæµ)
  - [ğŸ“ æ€»ç»“](#-æ€»ç»“)
    - [æ ¸å¿ƒè¦ç‚¹](#æ ¸å¿ƒè¦ç‚¹)
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)

---

## 1. å·¥å…·é“¾æ¦‚è§ˆ

### 1.1 Rust æ€§èƒ½åˆ†æå·¥å…·ç”Ÿæ€

| å·¥å…· | ç”¨é€” | å¹³å° | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|------|------|------|------|------|
| **cargo-flamegraph** | CPUç«ç„°å›¾ | Linux/macOS | æ˜“ç”¨ï¼Œé›†æˆåº¦é«˜ | éœ€è¦sudo |
| **perf** | ç³»ç»Ÿçº§æ€§èƒ½åˆ†æ | Linux | åŠŸèƒ½å¼ºå¤§ | ä»…Linux |
| **valgrind** | å†…å­˜åˆ†æ | Linux/macOS | ç²¾ç¡® | æ€§èƒ½å¼€é”€å¤§ |
| **heaptrack** | å †å†…å­˜åˆ†æ | Linux | å¯è§†åŒ–å¥½ | ä»…Linux |
| **tokio-console** | Tokioè¿è¡Œæ—¶åˆ†æ | è·¨å¹³å° | å®æ—¶ç›‘æ§ | éœ€ç‰¹æ®Šæ„å»º |

### 1.2 å®‰è£…å·¥å…·é“¾

```bash
# cargo-flamegraph
cargo install flamegraph

# Linux: perf
sudo apt-get install linux-tools-common linux-tools-generic linux-tools-`uname -r`

# valgrind
sudo apt-get install valgrind

# heaptrack
sudo apt-get install heaptrack

# tokio-console
cargo install --locked tokio-console
```

---

## 2. cargo-flamegraph

### 2.1 åŸºç¡€ä½¿ç”¨

**ç”Ÿæˆç«ç„°å›¾**:

```bash
# åŸºç¡€ç”¨æ³•
cargo flamegraph

# æŒ‡å®šäºŒè¿›åˆ¶
cargo flamegraph --bin my-app

# å¸¦å‚æ•°
cargo flamegraph --bin my-app -- --arg1 value1

# æŒ‡å®šè¾“å‡º
cargo flamegraph --output my-flamegraph.svg

# release æ¨¡å¼
cargo flamegraph --release
```

### 2.2 é«˜çº§é…ç½®

**Cargo.toml é…ç½®**:

```toml
[profile.release]
debug = true  # ä¿ç•™è°ƒè¯•ç¬¦å·
```

**è‡ªå®šä¹‰é‡‡æ ·**:

```bash
# æŒ‡å®šé‡‡æ ·é¢‘ç‡
cargo flamegraph --freq 997

# æŒ‡å®šé‡‡æ ·æ—¶é•¿
cargo flamegraph --duration 60

# è¿‡æ»¤å‡½æ•°
cargo flamegraph --notes "regex_pattern"
```

### 2.3 å®æˆ˜ç¤ºä¾‹

**ç¤ºä¾‹åº”ç”¨**:

```rust
// src/bin/flamegraph_demo.rs
use std::time::Duration;

fn cpu_intensive_task() {
    let mut sum = 0u64;
    for i in 0..10_000_000 {
        sum = sum.wrapping_add(i);
    }
}

fn io_intensive_task() {
    std::thread::sleep(Duration::from_millis(100));
}

fn main() {
    for _ in 0..100 {
        cpu_intensive_task();
        io_intensive_task();
    }
}
```

**ç”Ÿæˆç«ç„°å›¾**:

```bash
cargo flamegraph --bin flamegraph_demo --release
```

**åˆ†æç»“æœ**:

```text
åˆ†æç«ç„°å›¾:
1. å®½åº¦ = CPUæ—¶é—´å æ¯”
2. é«˜åº¦ = è°ƒç”¨æ ˆæ·±åº¦
3. é¢œè‰² = éšæœºï¼ˆæ–¹ä¾¿åŒºåˆ†ï¼‰
4. çƒ­ç‚¹ = å®½ä¸”å¹³çš„å‡½æ•°å—
```

---

## 3. perf å·¥å…·é›†æˆ

### 3.1 perf åŸºç¡€

**é‡‡é›†æ€§èƒ½æ•°æ®**:

```bash
# é‡‡é›† CPU events
perf record -g ./target/release/my-app

# é‡‡é›†æŒ‡å®šæ—¶é•¿
perf record -g -sleep 10 ./target/release/my-app

# é‡‡é›†æ‰€æœ‰ CPU cores
perf record -g -a ./target/release/my-app

# æŸ¥çœ‹æŠ¥å‘Š
perf report
```

### 3.2 perf stat

**ç»Ÿè®¡æ€§èƒ½æŒ‡æ ‡**:

```bash
# åŸºç¡€ç»Ÿè®¡
perf stat ./target/release/my-app

# è¯¦ç»†ç»Ÿè®¡
perf stat -d ./target/release/my-app

# å¤šæ¬¡è¿è¡Œå¹³å‡
perf stat -r 10 ./target/release/my-app
```

**è¾“å‡ºç¤ºä¾‹**:

```text
 Performance counter stats for './my-app':

          1,234.56 msec task-clock                #    0.987 CPUs utilized          
               123      context-switches          #    0.100 K/sec                  
                 5      cpu-migrations            #    0.004 K/sec                  
             1,234      page-faults               #    1.000 K/sec                  
     4,567,890,123      cycles                    #    3.700 GHz                    
     8,901,234,567      instructions              #    1.95  insn per cycle         
     1,234,567,890      branches                  # 1000.456 M/sec                  
        12,345,678      branch-misses             #    1.00% of all branches        

       1.250123456 seconds time elapsed

       1.234567890 seconds user
       0.000123456 seconds sys
```

### 3.3 perf ç«ç„°å›¾

**ç”Ÿæˆ perf ç«ç„°å›¾**:

```bash
# 1. é‡‡é›†æ•°æ®
perf record -F 99 -a -g -- sleep 60

# 2. ç”Ÿæˆ perf script
perf script > out.perf

# 3. æŠ˜å æ ˆ
./FlameGraph/stackcollapse-perf.pl out.perf > out.folded

# 4. ç”Ÿæˆç«ç„°å›¾
./FlameGraph/flamegraph.pl out.folded > flamegraph.svg
```

---

## 4. valgrind/cachegrind

### 4.1 Memcheck (å†…å­˜æ£€æŸ¥)

**æ£€æµ‹å†…å­˜é”™è¯¯**:

```bash
# åŸºç¡€æ£€æŸ¥
valgrind ./target/debug/my-app

# è¯¦ç»†è¾“å‡º
valgrind --leak-check=full --show-leak-kinds=all ./target/debug/my-app

# è·Ÿè¸ªå­è¿›ç¨‹
valgrind --trace-children=yes ./target/debug/my-app
```

**ç¤ºä¾‹ä»£ç **:

```rust
// å†…å­˜æ³„æ¼ç¤ºä¾‹
fn leak_memory() {
    let v = Box::new(vec![1, 2, 3, 4, 5]);
    std::mem::forget(v); // æ•…æ„æ³„æ¼
}

fn main() {
    leak_memory();
}
```

**valgrind è¾“å‡º**:

```text
==12345== Memcheck, a memory error detector
==12345== 
==12345== HEAP SUMMARY:
==12345==     in use at exit: 40 bytes in 1 blocks
==12345==   total heap usage: 1 allocs, 0 frees, 40 bytes allocated
==12345== 
==12345== 40 bytes in 1 blocks are definitely lost
==12345==    at 0x...: malloc (in /usr/lib/...)
==12345==    by 0x...: leak_memory (main.rs:4)
==12345==    by 0x...: main (main.rs:8)
```

### 4.2 Cachegrind (ç¼“å­˜åˆ†æ)

**ç¼“å­˜æ€§èƒ½åˆ†æ**:

```bash
# è¿è¡Œ cachegrind
valgrind --tool=cachegrind ./target/release/my-app

# å¯è§†åŒ–ç»“æœ
kcachegrind cachegrind.out.12345
```

**ç¤ºä¾‹ä»£ç **:

```rust
// ç¼“å­˜å‹å¥½ vs ä¸å‹å¥½
fn cache_friendly() {
    let mut arr = vec![0i32; 1024 * 1024];
    // æŒ‰è¡Œéå†ï¼ˆç¼“å­˜å‹å¥½ï¼‰
    for i in 0..arr.len() {
        arr[i] = i as i32;
    }
}

fn cache_unfriendly() {
    let mut arr = vec![vec![0i32; 1024]; 1024];
    // æŒ‰åˆ—éå†ï¼ˆç¼“å­˜ä¸å‹å¥½ï¼‰
    for j in 0..1024 {
        for i in 0..1024 {
            arr[i][j] = (i + j) as i32;
        }
    }
}
```

### 4.3 Callgrind (è°ƒç”¨å›¾åˆ†æ)

**è°ƒç”¨å›¾ç”Ÿæˆ**:

```bash
# è¿è¡Œ callgrind
valgrind --tool=callgrind ./target/release/my-app

# å¯è§†åŒ–
kcachegrind callgrind.out.12345

# æ³¨è§£æºä»£ç 
callgrind_annotate --auto=yes callgrind.out.12345
```

---

## 5. å†…å­˜æ³„æ¼æ£€æµ‹

### 5.1 ä½¿ç”¨ heaptrack

**å®‰è£…å’Œä½¿ç”¨**:

```bash
# å®‰è£…
sudo apt-get install heaptrack

# è¿è¡Œåˆ†æ
heaptrack ./target/release/my-app

# æŸ¥çœ‹ç»“æœ
heaptrack_gui heaptrack.my-app.12345.gz
```

### 5.2 è‡ªå®šä¹‰å†…å­˜è¿½è¸ª

**å®ç°å†…å­˜åˆ†é…å™¨**:

```rust
use std::alloc::{GlobalAlloc, Layout, System};
use std::sync::atomic::{AtomicUsize, Ordering};

struct TrackingAllocator;

static ALLOCATED: AtomicUsize = AtomicUsize::new(0);
static DEALLOCATED: AtomicUsize = AtomicUsize::new(0);

unsafe impl GlobalAlloc for TrackingAllocator {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        let ret = System.alloc(layout);
        if !ret.is_null() {
            ALLOCATED.fetch_add(layout.size(), Ordering::SeqCst);
        }
        ret
    }

    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
        System.dealloc(ptr, layout);
        DEALLOCATED.fetch_add(layout.size(), Ordering::SeqCst);
    }
}

#[global_allocator]
static GLOBAL: TrackingAllocator = TrackingAllocator;

pub fn get_memory_stats() -> (usize, usize) {
    (
        ALLOCATED.load(Ordering::SeqCst),
        DEALLOCATED.load(Ordering::SeqCst),
    )
}

pub fn print_memory_stats() {
    let (allocated, deallocated) = get_memory_stats();
    println!("Memory allocated: {} bytes", allocated);
    println!("Memory deallocated: {} bytes", deallocated);
    println!("Net memory: {} bytes", allocated - deallocated);
}
```

---

## 6. å¹¶å‘æ€§èƒ½åˆ†æ

### 6.1 é”ç«äº‰åˆ†æ

**æ£€æµ‹é”ç«äº‰**:

```rust
use std::sync::{Arc, Mutex};
use std::time::Instant;
use std::thread;

fn benchmark_lock_contention(num_threads: usize) {
    let counter = Arc::new(Mutex::new(0u64));
    let start = Instant::now();
    
    let handles: Vec<_> = (0..num_threads)
        .map(|_| {
            let counter = Arc::clone(&counter);
            thread::spawn(move || {
                for _ in 0..100_000 {
                    let mut num = counter.lock().unwrap();
                    *num += 1;
                }
            })
        })
        .collect();
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    let duration = start.elapsed();
    println!("Threads: {}, Time: {:?}", num_threads, duration);
}

fn main() {
    for n in [1, 2, 4, 8, 16] {
        benchmark_lock_contention(n);
    }
}
```

**ä½¿ç”¨ perf åˆ†æé”**:

```bash
# é‡‡é›†é”äº‹ä»¶
perf record -e syscalls:sys_enter_futex ./target/release/my-app

# æŸ¥çœ‹æŠ¥å‘Š
perf report
```

### 6.2 æ— é”ç®—æ³•æ€§èƒ½

**å¯¹æ¯”æœ‰é”vsæ— é”**:

```rust
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::{Arc, Mutex};
use std::thread;

fn benchmark_atomic() {
    let counter = Arc::new(AtomicU64::new(0));
    let handles: Vec<_> = (0..8)
        .map(|_| {
            let counter = Arc::clone(&counter);
            thread::spawn(move || {
                for _ in 0..1_000_000 {
                    counter.fetch_add(1, Ordering::Relaxed);
                }
            })
        })
        .collect();
    
    for handle in handles {
        handle.join().unwrap();
    }
}

fn benchmark_mutex() {
    let counter = Arc::new(Mutex::new(0u64));
    let handles: Vec<_> = (0..8)
        .map(|_| {
            let counter = Arc::clone(&counter);
            thread::spawn(move || {
                for _ in 0..1_000_000 {
                    *counter.lock().unwrap() += 1;
                }
            })
        })
        .collect();
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

---

## 7. å¼‚æ­¥ä»»åŠ¡è°ƒåº¦åˆ†æ

### 7.1 Tokio Console å®æˆ˜

**é…ç½®å’Œå¯åŠ¨**:

```toml
# Cargo.toml
[dependencies]
tokio = { version = "1.47", features = ["full", "tracing"] }
console-subscriber = "0.4"
```

```rust
use console_subscriber::ConsoleLayer;

#[tokio::main]
async fn main() {
    console_subscriber::init();
    
    // ä½ çš„å¼‚æ­¥åº”ç”¨
    run_app().await;
}
```

**å¯åŠ¨ tokio-console**:

```bash
# åœ¨å¦ä¸€ä¸ªç»ˆç«¯
tokio-console
```

### 7.2 è‡ªå®šä¹‰ Tokio Metrics

**è¯¦ç»†æŒ‡æ ‡æ”¶é›†**:

```rust
use tokio::runtime::Handle;
use tokio_metrics::RuntimeMonitor;
use std::time::Duration;

async fn monitor_tokio_runtime() {
    let handle = Handle::current();
    let monitor = RuntimeMonitor::new(&handle);
    
    let mut intervals = monitor.intervals();
    
    loop {
        tokio::time::sleep(Duration::from_secs(5)).await;
        
        if let Some(interval) = intervals.next().await {
            println!("\nğŸ“Š Tokio Runtime Metrics:");
            println!("  Workers: {}", interval.workers_count);
            println!("  Total park: {}", interval.total_park_count);
            println!("  Total noop: {}", interval.total_noop_count);
            println!("  Total steal: {}", interval.total_steal_count);
            println!("  Num remote: {}", interval.num_remote_schedules);
            println!("  Total local: {}", interval.total_local_schedule_count);
            println!("  Total overflow: {}", interval.total_overflow_count);
            println!("  Total polls: {}", interval.total_polls_count);
            println!("  Total busy: {:?}", interval.total_busy_duration);
            println!("  Total idle: {:?}", interval.total_idle_duration);
        }
    }
}
```

---

## 8. å®æˆ˜æ¡ˆä¾‹åˆ†æ

### 8.1 æ¡ˆä¾‹1: HTTP æœåŠ¡æ€§èƒ½ä¼˜åŒ–

**é—®é¢˜**: API å“åº”æ—¶é—´è¿‡é•¿

**åˆ†ææ­¥éª¤**:

1. **ç”Ÿæˆç«ç„°å›¾**:

    ```bash
    cargo flamegraph --bin api-server --release
    ```

2. **è¯†åˆ«çƒ­ç‚¹**: å‘ç° JSON åºåˆ—åŒ–å ç”¨ 45% CPU

3. **ä¼˜åŒ–æ–¹æ¡ˆ**:

    ```rust
    // ä¼˜åŒ–å‰
    use serde_json;

    async fn handle_request(data: Vec<Item>) -> String {
        serde_json::to_string(&data).unwrap()
    }

    // ä¼˜åŒ–å
    use simd_json;

    async fn handle_request_optimized(data: Vec<Item>) -> String {
        let mut bytes = serde_json::to_vec(&data).unwrap();
        simd_json::to_string(&mut bytes).unwrap()
    }
    ```

4. **ç»“æœ**: å“åº”æ—¶é—´ä» 150ms é™è‡³ 85ms

### 8.2 æ¡ˆä¾‹2: å†…å­˜æ³„æ¼æ’æŸ¥

**é—®é¢˜**: åº”ç”¨é•¿æ—¶é—´è¿è¡Œåå†…å­˜æŒç»­å¢é•¿

**åˆ†ææ­¥éª¤**:

1. **å¯ç”¨ heaptrack**:

    ```bash
    heaptrack ./target/release/my-app
    ```

2. **æŸ¥çœ‹åˆ†æç»“æœ**: å‘ç°æŸä¸ªHashMapæœªæ¸…ç†

3. **ä¿®å¤**:

```rust
// é—®é¢˜ä»£ç 
struct Cache {
    data: HashMap<String, Vec<u8>>,
}

impl Cache {
    fn insert(&mut self, key: String, value: Vec<u8>) {
        self.data.insert(key, value); // æ°¸ä¸æ¸…ç†ï¼
    }
}

// ä¿®å¤å
use lru::LruCache;

struct Cache {
    data: LruCache<String, Vec<u8>>,
}

impl Cache {
    fn new() -> Self {
        Self {
            data: LruCache::new(NonZeroUsize::new(1000).unwrap()),
        }
    }
    
    fn insert(&mut self, key: String, value: Vec<u8>) {
        self.data.put(key, value); // è‡ªåŠ¨LRUé©±é€
    }
}
```

### 8.3 æ¡ˆä¾‹3: å¼‚æ­¥ä»»åŠ¡å †ç§¯

**é—®é¢˜**: Tokio tasks ä¸æ–­å †ç§¯

**åˆ†æ**: ä½¿ç”¨ tokio-console

```bash
tokio-console
```

**å‘ç°**: æŸä¸ª task é•¿æ—¶é—´é˜»å¡

**ä¿®å¤**:

```rust
// é—®é¢˜ä»£ç 
async fn process_item(item: Item) {
    // åŒæ­¥é˜»å¡æ“ä½œ
    std::thread::sleep(Duration::from_secs(10));
}

// ä¿®å¤å
async fn process_item_fixed(item: Item) {
    // ä½¿ç”¨ spawn_blocking
    tokio::task::spawn_blocking(move || {
        std::thread::sleep(Duration::from_secs(10));
    }).await.unwrap();
}
```

---

## 9. æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 9.1 é€šç”¨ä¼˜åŒ–æŠ€å·§

**1. é¿å…ä¸å¿…è¦çš„åˆ†é…**:

```rust
// âŒ å·®
fn process_string(s: &str) -> String {
    s.to_string() + " processed"
}

// âœ… å¥½
fn process_string(s: &str) -> String {
    format!("{} processed", s)
}

// âœ… æ›´å¥½
fn process_string_into(s: &str, buf: &mut String) {
    buf.clear();
    buf.push_str(s);
    buf.push_str(" processed");
}
```

**2. ä½¿ç”¨åˆé€‚çš„æ•°æ®ç»“æ„**:

```rust
// é¢‘ç¹æ’å…¥/åˆ é™¤: Vec -> VecDeque
use std::collections::VecDeque;

// å¿«é€ŸæŸ¥æ‰¾: Vec -> HashMap/HashSet
use std::collections::HashMap;

// é¡ºåºéå†: HashMap -> BTreeMap
use std::collections::BTreeMap;
```

**3. æ‰¹é‡å¤„ç†**:

```rust
// âŒ å·®: é€ä¸ªå¤„ç†
for item in items {
    process_one(item).await;
}

// âœ… å¥½: æ‰¹é‡å¤„ç†
let futures: Vec<_> = items.iter().map(|item| process_one(item)).collect();
futures::future::join_all(futures).await;
```

### 9.2 å¼‚æ­¥ä¼˜åŒ–

**1. é¿å…è¿‡åº¦ tokio::spawn**:

```rust
// âŒ å·®: è¿‡å¤šspawn
for i in 0..1000 {
    tokio::spawn(async move {
        work(i).await;
    });
}

// âœ… å¥½: ä½¿ç”¨ futures stream
use futures::stream::{self, StreamExt};

stream::iter(0..1000)
    .for_each_concurrent(10, |i| async move {
        work(i).await;
    })
    .await;
```

**2. ä½¿ç”¨ tokio::select! è¶…æ—¶**:

```rust
use tokio::time::{timeout, Duration};

async fn with_timeout() -> Result<Data, Error> {
    match timeout(Duration::from_secs(5), fetch_data()).await {
        Ok(Ok(data)) => Ok(data),
        Ok(Err(e)) => Err(e),
        Err(_) => Err(Error::Timeout),
    }
}
```

### 9.3 ç¼–è¯‘ä¼˜åŒ–

**Cargo.toml é…ç½®**:

```toml
[profile.release]
opt-level = 3
lto = true
codegen-units = 1
panic = 'abort'

[profile.release-with-debug]
inherits = "release"
debug = true  # ä¿ç•™ç¬¦å·ç”¨äºprofiling
```

---

## ğŸ“š å·¥å…·é“¾æ€»ç»“

### å·¥å…·é€‰æ‹©å†³ç­–æ ‘

```text
éœ€è¦åˆ†æä»€ä¹ˆï¼Ÿ
â”œâ”€ CPUä½¿ç”¨
â”‚  â”œâ”€ å¿«é€Ÿç«ç„°å›¾ â†’ cargo-flamegraph
â”‚  â””â”€ è¯¦ç»†åˆ†æ â†’ perf
â”œâ”€ å†…å­˜é—®é¢˜
â”‚  â”œâ”€ å†…å­˜é”™è¯¯ â†’ valgrind memcheck
â”‚  â”œâ”€ å†…å­˜æ³„æ¼ â†’ heaptrack
â”‚  â””â”€ å®æ—¶ç›‘æ§ â†’ è‡ªå®šä¹‰allocator
â”œâ”€ ç¼“å­˜æ€§èƒ½
â”‚  â””â”€ cachegrind/callgrind
â””â”€ å¼‚æ­¥æ€§èƒ½
   â”œâ”€ å®æ—¶ç›‘æ§ â†’ tokio-console
   â””â”€ è¯¦ç»†æŒ‡æ ‡ â†’ tokio-metrics
```

### å®Œæ•´å·¥ä½œæµ

```bash
# 1. å¼€å‘é˜¶æ®µ
cargo clippy
cargo bench

# 2. æ€§èƒ½åˆ†æ
cargo flamegraph --release

# 3. è¯¦ç»†åˆ†æ
perf record -g ./target/release/app
perf report

# 4. å†…å­˜åˆ†æ
heaptrack ./target/release/app

# 5. ç”Ÿäº§ç›‘æ§
# éƒ¨ç½² pyroscope agent
```

---

## ğŸ“ æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **é€‰æ‹©åˆé€‚çš„å·¥å…·**: æ ¹æ®é—®é¢˜ç±»å‹é€‰æ‹©
2. **ç”Ÿäº§ç¯å¢ƒä¼˜å…ˆ**: ä½å¼€é”€å·¥å…·
3. **æŒç»­ç›‘æ§**: Continuous Profiling
4. **æ•°æ®é©±åŠ¨**: åŸºäº metrics ä¼˜åŒ–

### æœ€ä½³å®è·µ

- âœ… å®šæœŸ profiling
- âœ… ä¿ç•™ debug ç¬¦å·
- âœ… ä½¿ç”¨ benchmarks
- âœ… ç›‘æ§ç”Ÿäº§ç¯å¢ƒ
- âœ… ä¼˜åŒ–çƒ­ç‚¹ä»£ç 

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ8æ—¥  
**çŠ¶æ€**: âœ… ç”Ÿäº§å°±ç»ª  

**#Rust #Performance #Profiling #Tools #Optimization**-
