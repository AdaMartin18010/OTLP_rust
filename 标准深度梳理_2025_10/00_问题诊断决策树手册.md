# OpenTelemetry 问题诊断决策树手册

> **最后更新**: 2025年10月8日  
> **适用版本**: OpenTelemetry v1.27.0+  
> **用途**: 系统化故障诊断与问题解决

---

## 📋 目录

- [OpenTelemetry 问题诊断决策树手册](#opentelemetry-问题诊断决策树手册)
  - [📋 目录](#-目录)
  - [使用指南](#使用指南)
    - [如何使用本手册](#如何使用本手册)
    - [符号说明](#符号说明)
  - [决策树总览](#决策树总览)
  - [1. 数据未上报问题诊断](#1-数据未上报问题诊断)
    - [症状识别](#症状识别)
    - [决策树](#决策树)
    - [详细检查步骤](#详细检查步骤)
      - [步骤1: 验证SDK初始化](#步骤1-验证sdk初始化)
      - [步骤2: 检查Exporter配置](#步骤2-检查exporter配置)
      - [步骤3: 检查Collector](#步骤3-检查collector)
      - [步骤4: 验证端到端流程](#步骤4-验证端到端流程)
    - [常见解决方案](#常见解决方案)
      - [解决方案1: 正确初始化SDK](#解决方案1-正确初始化sdk)
      - [解决方案2: 采样配置](#解决方案2-采样配置)
      - [解决方案3: Collector配置修复](#解决方案3-collector配置修复)
      - [解决方案4: 后端配置检查](#解决方案4-后端配置检查)
  - [2. 性能问题诊断](#2-性能问题诊断)
    - [症状识别2](#症状识别2)
    - [决策树2](#决策树2)
    - [性能诊断检查清单](#性能诊断检查清单)
      - [SDK性能检查](#sdk性能检查)
      - [Collector性能检查](#collector性能检查)
    - [性能优化解决方案](#性能优化解决方案)
      - [解决方案1: SDK性能优化](#解决方案1-sdk性能优化)
      - [解决方案2: 内存优化](#解决方案2-内存优化)
      - [解决方案3: Collector吞吐量优化](#解决方案3-collector吞吐量优化)
      - [解决方案4: Collector内存优化](#解决方案4-collector内存优化)
      - [解决方案5: 网络优化](#解决方案5-网络优化)
  - [3. 连接与网络问题诊断](#3-连接与网络问题诊断)
    - [症状识别3](#症状识别3)
    - [决策树3](#决策树3)
    - [连接诊断命令](#连接诊断命令)
    - [连接问题解决方案](#连接问题解决方案)
      - [解决方案1: 防火墙配置](#解决方案1-防火墙配置)
      - [解决方案2: 端口配置](#解决方案2-端口配置)
      - [解决方案3: TLS配置](#解决方案3-tls配置)
      - [解决方案4: 基础配置修复](#解决方案4-基础配置修复)
  - [4. 数据质量问题诊断](#4-数据质量问题诊断)
    - [症状识别4](#症状识别4)
    - [决策树4](#决策树4)
    - [数据质量检查清单](#数据质量检查清单)
    - [数据质量修复方案](#数据质量修复方案)
      - [解决方案1: Trace完整性修复](#解决方案1-trace完整性修复)
      - [解决方案2: Context传播修复](#解决方案2-context传播修复)
      - [解决方案3: 属性补充](#解决方案3-属性补充)
      - [解决方案4: 使用Processor修复属性](#解决方案4-使用processor修复属性)
  - [5. Collector问题诊断](#5-collector问题诊断)
  - [快速索引](#快速索引)
    - [按症状查找](#按症状查找)
    - [按组件查找](#按组件查找)
  - [相关文档](#相关文档)

---

## 使用指南

### 如何使用本手册

1. **识别症状** - 根据问题表现选择对应的决策树
2. **按步骤诊断** - 按照决策树从上到下逐步检查
3. **记录结果** - 记录每步检查的结果
4. **应用解决方案** - 根据诊断结果应用对应的解决方案
5. **验证修复** - 确认问题已解决

### 符号说明

```text
◆ 决策点 - 需要判断是/否
□ 检查点 - 需要执行检查
→ 下一步 - 导向下一个步骤
✓ 解决方案 - 问题解决方法
⚠ 注意事项 - 需要特别注意的点
📄 参考文档 - 相关详细文档链接
```

---

## 决策树总览

| 决策树编号 | 问题类别 | 常见症状 | 优先级 |
|-----------|---------|---------|--------|
| **1** | 数据未上报 | 后端看不到trace/metrics/logs | 🔴 高 |
| **2** | 性能问题 | 延迟高、吞吐量低、资源消耗大 | 🟡 中 |
| **3** | 连接与网络 | 连接超时、连接拒绝、TLS错误 | 🔴 高 |
| **4** | 数据质量 | 数据不完整、属性缺失、乱码 | 🟡 中 |
| **5** | Collector问题 | Collector崩溃、内存溢出、丢数据 | 🔴 高 |
| **6** | SDK集成 | SDK报错、初始化失败、数据格式错误 | 🟡 中 |
| **7** | 云平台集成 | IAM权限、端点配置、区域问题 | 🟡 中 |

---

## 1. 数据未上报问题诊断

### 症状识别

```text
✗ 后端看不到任何trace/metrics/logs
✗ 部分数据丢失
✗ 数据延迟过大
```

### 决策树

```text
【数据未上报】
    │
    ◆ 应用有生成trace吗？
    ├─ 否 →
    │     □ 检查SDK是否正确初始化
    │     □ 检查TracerProvider是否设置
    │     □ 检查是否创建了Tracer和Span
    │     ✓ 解决方案1: 正确初始化SDK
    │     📄 参考: [SDK概述](./04_核心组件/01_SDK概述.md)
    │
    └─ 是 →
          ◆ SDK是否尝试导出？
          ├─ 否 →
          │     □ 检查Exporter是否配置
          │     □ 检查采样配置(sampler)
          │     □ 检查是否调用shutdown()
          │     ✓ 解决方案2: 配置Exporter和采样
          │     📄 参考: [采样策略](./05_采样与性能/01_采样策略.md)
          │
          └─ 是 →
                ◆ SDK导出时有错误吗？
                ├─ 是 →
                │     □ 检查日志中的导出错误
                │     □ 检查网络连接
                │     □ 检查端点配置
                │     └→ 转【连接与网络问题诊断】
                │
                └─ 否 →
                      ◆ Collector收到数据了吗？
                      ├─ 否 →
                      │     □ 检查Collector是否运行
                      │     □ 检查Collector端点配置
                      │     □ 检查防火墙/安全组
                      │     ✓ 解决方案3: 修复Collector配置
                      │     📄 参考: [Collector配置](./04_核心组件/06_Collector生产环境完整配置示例.md)
                      │
                      └─ 是 →
                            ◆ Collector成功导出了吗？
                            ├─ 否 →
                            │     □ 检查Collector日志
                            │     □ 检查后端连接
                            │     □ 检查exporter配置
                            │     └→ 转【Collector问题诊断】
                            │
                            └─ 是 →
                                  ◆ 后端配置正确吗？
                                  └─ 检查后端日志
                                     检查数据保留策略
                                     检查查询条件
                                     ✓ 解决方案4: 修复后端配置
```

### 详细检查步骤

#### 步骤1: 验证SDK初始化

**Go示例**:

```go
// 检查TracerProvider是否设置
tp := otel.GetTracerProvider()
if tp == nil || reflect.TypeOf(tp).String() == "*global.tracerProvider" {
    log.Fatal("TracerProvider未正确设置")
}

// 启用调试日志
otel.SetLogger(logr.New(logSink).WithName("otel"))
otel.SetErrorHandler(otel.ErrorHandlerFunc(func(err error) {
    log.Printf("OTEL Error: %v", err)
}))
```

**Python示例**:

```python
from opentelemetry import trace

# 检查TracerProvider
tracer_provider = trace.get_tracer_provider()
print(f"TracerProvider: {type(tracer_provider)}")

# 启用调试日志
import logging
logging.basicConfig(level=logging.DEBUG)
```

**检查清单**:

```text
□ TracerProvider已创建并设置
□ Exporter已添加到TracerProvider
□ Resource属性已配置(service.name等)
□ 采样器已配置
□ Span已正确创建和结束
```

#### 步骤2: 检查Exporter配置

```bash
# 环境变量检查
echo $OTEL_EXPORTER_OTLP_ENDPOINT
echo $OTEL_EXPORTER_OTLP_PROTOCOL

# 测试端点连通性
curl http://${OTEL_EXPORTER_OTLP_ENDPOINT}/v1/traces

# 检查导出日志(启用debug)
export OTEL_LOG_LEVEL=debug
```

#### 步骤3: 检查Collector

```bash
# 检查Collector运行状态
curl http://localhost:13133/

# 检查Collector metrics
curl http://localhost:8888/metrics | grep -E "(receiver_accepted|exporter_sent|refused)"

# 查看Collector日志
kubectl logs -f deployment/otel-collector | grep -i error
```

**关键指标**:

```text
otelcol_receiver_accepted_spans > 0   # 收到数据
otelcol_receiver_refused_spans = 0    # 无拒绝
otelcol_exporter_sent_spans > 0       # 成功导出
otelcol_exporter_send_failed_spans = 0 # 无失败
```

#### 步骤4: 验证端到端流程

**使用telemetrygen生成测试数据**:

```bash
# 生成测试trace
docker run --rm -it ghcr.io/open-telemetry/opentelemetry-collector-contrib/telemetrygen:latest \
    traces --otlp-insecure --otlp-endpoint localhost:4317 --traces 10

# 在后端查询
# Jaeger: http://localhost:16686
# Tempo: tempo-query:3100
```

### 常见解决方案

#### 解决方案1: 正确初始化SDK

```go
package main

import (
    "context"
    "log"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp"
    "go.opentelemetry.io/otel/sdk/resource"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.21.0"
)

func initTracer() func() {
    ctx := context.Background()

    // 1. 创建Exporter
    exporter, err := otlptracehttp.New(ctx,
        otlptracehttp.WithEndpoint("localhost:4318"),
        otlptracehttp.WithInsecure(),
    )
    if err != nil {
        log.Fatal(err)
    }

    // 2. 创建Resource
    res, err := resource.New(ctx,
        resource.WithAttributes(
            semconv.ServiceName("my-service"),
            semconv.ServiceVersion("1.0.0"),
        ),
    )
    if err != nil {
        log.Fatal(err)
    }

    // 3. 创建TracerProvider
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithBatcher(exporter),
        sdktrace.WithResource(res),
        sdktrace.WithSampler(sdktrace.AlwaysOn()),
    )

    // 4. 设置全局TracerProvider
    otel.SetTracerProvider(tp)

    // 返回cleanup函数
    return func() {
        if err := tp.Shutdown(ctx); err != nil {
            log.Printf("Error shutting down tracer provider: %v", err)
        }
    }
}

func main() {
    cleanup := initTracer()
    defer cleanup()

    // 使用tracer
    tracer := otel.Tracer("my-app")
    ctx, span := tracer.Start(context.Background(), "main")
    defer span.End()

    // 业务逻辑...
}
```

#### 解决方案2: 采样配置

**生产环境采样配置**:

```go
// 10%采样率
sampler := sdktrace.ParentBased(
    sdktrace.TraceIDRatioBased(0.1),
)

tp := sdktrace.NewTracerProvider(
    sdktrace.WithSampler(sampler),
    // ... 其他配置
)
```

**环境变量方式**:

```bash
export OTEL_TRACES_SAMPLER=parentbased_traceidratio
export OTEL_TRACES_SAMPLER_ARG=0.1
```

#### 解决方案3: Collector配置修复

**最小可用Collector配置**:

```yaml
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317
      http:
        endpoint: 0.0.0.0:4318

processors:
  batch:

exporters:
  logging:
    loglevel: debug
  otlp:
    endpoint: jaeger:4317
    tls:
      insecure: true

service:
  pipelines:
    traces:
      receivers: [otlp]
      processors: [batch]
      exporters: [logging, otlp]  # logging用于调试
```

#### 解决方案4: 后端配置检查

**Jaeger检查**:

```bash
# 检查Jaeger运行状态
curl http://localhost:16686/api/services

# 检查数据保留
# 查看Jaeger配置中的 --span-storage.cassandra.max-traces-ttl
```

**Tempo检查**:

```yaml
# tempo.yaml
storage:
  trace:
    backend: local
    local:
      path: /tmp/tempo/traces
    wal:
      path: /tmp/tempo/wal

# 检查存储路径
ls -lh /tmp/tempo/traces
```

---

## 2. 性能问题诊断

### 症状识别2

```text
✗ 应用延迟增加
✗ CPU/内存使用率过高
✗ Collector吞吐量不足
✗ 数据导出延迟大
```

### 决策树2

```text
【性能问题】
    │
    ◆ 问题发生在哪里？
    ├─ SDK层 →
    │     ◆ CPU使用率高？
    │     ├─ 是 →
    │     │     □ 检查采样率配置
    │     │     □ 检查Span创建频率
    │     │     □ 检查属性数量
    │     │     ✓ 解决方案1: SDK性能优化
    │     │
    │     └─ 内存使用率高？
    │           □ 检查队列大小配置
    │           □ 检查批处理配置
    │           □ 检查导出频率
    │           ✓ 解决方案2: 内存优化
    │
    ├─ Collector层 →
    │     ◆ 吞吐量不足？
    │     ├─ 是 →
    │     │     □ 检查batch processor配置
    │     │     □ 检查并发导出数
    │     │     □ 检查资源限制
    │     │     ✓ 解决方案3: Collector性能优化
    │     │
    │     └─ 内存溢出？
    │           □ 检查memory_limiter配置
    │           □ 检查队列大小
    │           □ 检查数据堆积
    │           ✓ 解决方案4: Collector内存优化
    │
    └─ 网络层 →
          □ 检查带宽使用
          □ 检查压缩配置
          □ 检查协议选择(gRPC vs HTTP)
          ✓ 解决方案5: 网络优化
```

### 性能诊断检查清单

#### SDK性能检查

```text
□ 采样率合理(生产环境1-10%)
□ 批处理已启用
  - batch_timeout: 5s
  - max_export_batch_size: 512
  - max_queue_size: 2048
□ 异步导出(不阻塞业务)
□ 压缩已启用(gzip)
□ Span属性数量合理(< 20个)
□ 避免高频Span(< 1000/s per instance)
```

#### Collector性能检查

```text
□ Batch Processor配置
  - send_batch_size: 8192
  - timeout: 200ms
  - send_batch_max_size: 10000
□ 并发导出配置
  - sending_queue.num_consumers: 10
□ 内存限制器
  - limit_mib: 1500 (容器2GB时)
  - check_interval: 1s
□ 资源分配充足
  - CPU: 至少2 cores
  - Memory: 至少2GB
□ 持久化队列(高可用场景)
```

### 性能优化解决方案

#### 解决方案1: SDK性能优化

```go
// 优化的SDK配置
exporter, _ := otlptracehttp.New(ctx,
    otlptracehttp.WithCompression(otlptracehttp.GzipCompression), // 启用压缩
    otlptracehttp.WithTimeout(10*time.Second),
)

tp := sdktrace.NewTracerProvider(
    // 优化的批处理配置
    sdktrace.WithBatcher(exporter,
        sdktrace.WithBatchTimeout(5*time.Second),        // 5秒批处理
        sdktrace.WithMaxExportBatchSize(512),            // 批次大小512
        sdktrace.WithMaxQueueSize(2048),                 // 队列2048
    ),
    // 合理采样率
    sdktrace.WithSampler(sdktrace.ParentBased(
        sdktrace.TraceIDRatioBased(0.01), // 1%采样
    )),
    sdktrace.WithResource(res),
)
```

#### 解决方案2: 内存优化

```go
// 控制队列大小
tp := sdktrace.NewTracerProvider(
    sdktrace.WithBatcher(exporter,
        sdktrace.WithMaxQueueSize(1024),  // 减小队列
        sdktrace.WithExportTimeout(5*time.Second), // 减少超时
    ),
)

// 定期强制GC (仅在必要时)
import "runtime"
runtime.GC()
```

#### 解决方案3: Collector吞吐量优化

```yaml
processors:
  batch:
    # 优化批处理
    timeout: 200ms
    send_batch_size: 8192
    send_batch_max_size: 10000

  # 限流保护
  memory_limiter:
    check_interval: 1s
    limit_mib: 1500
    spike_limit_mib: 512

exporters:
  otlp:
    endpoint: backend:4317
    # 优化并发导出
    sending_queue:
      enabled: true
      num_consumers: 10
      queue_size: 5000
    # 重试配置
    retry_on_failure:
      enabled: true
      initial_interval: 1s
      max_interval: 30s
      max_elapsed_time: 5m
```

#### 解决方案4: Collector内存优化

```yaml
extensions:
  memory_ballast:
    size_mib: 512  # 预分配内存

processors:
  memory_limiter:
    check_interval: 1s
    limit_mib: 1500      # 容器2GB时，设置为75%
    spike_limit_mib: 512

receivers:
  otlp:
    protocols:
      grpc:
        max_recv_msg_size_mib: 4
```

**Kubernetes资源限制**:

```yaml
resources:
  requests:
    cpu: 500m
    memory: 1Gi
  limits:
    cpu: 1000m
    memory: 2Gi
```

#### 解决方案5: 网络优化

```yaml
receivers:
  otlp:
    protocols:
      grpc:
        max_recv_msg_size_mib: 4
        max_concurrent_streams: 100
        # 启用压缩
        compression: gzip

exporters:
  otlp:
    # 使用gRPC (性能最佳)
    endpoint: backend:4317
    compression: gzip
    # 连接池
    balancer_name: round_robin
```

**SDK端使用gRPC**:

```go
import "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"

exporter, _ := otlptracegrpc.New(ctx,
    otlptracegrpc.WithEndpoint("collector:4317"),
    otlptracegrpc.WithInsecure(),
    otlptracegrpc.WithCompressor("gzip"),
)
```

---

## 3. 连接与网络问题诊断

### 症状识别3

```text
✗ connection refused
✗ connection timeout
✗ TLS handshake failed
✗ DNS resolution failed
```

### 决策树3

```text
【连接问题】
    │
    ◆ 能ping通目标主机吗？
    ├─ 否 →
    │     □ 检查网络连通性
    │     □ 检查防火墙规则
    │     □ 检查安全组配置
    │     ✓ 解决方案1: 修复网络配置
    │
    └─ 是 →
          ◆ 端口是否开放？
          ├─ 否 →
          │     □ 使用telnet/nc测试端口
          │     □ 检查服务是否监听
          │     □ 检查端口配置
          │     ✓ 解决方案2: 修复端口配置
          │
          └─ 是 →
                ◆ 使用TLS吗？
                ├─ 是 →
                │     ◆ TLS握手成功？
                │     ├─ 否 →
                │     │     □ 检查证书有效性
                │     │     □ 检查证书链完整性
                │     │     □ 检查域名匹配
                │     │     └→ 转【TLS问题诊断】
                │     │
                │     └─ 是 →
                │           □ 检查认证配置
                │           □ 检查授权策略
                │           ✓ 解决方案3: 修复认证配置
                │
                └─ 否 →
                      □ 检查DNS解析
                      □ 检查端点URL格式
                      □ 检查协议匹配(gRPC vs HTTP)
                      ✓ 解决方案4: 修复基础配置
```

### 连接诊断命令

```bash
# 1. 网络连通性测试
ping collector.example.com

# 2. 端口连通性测试
telnet collector.example.com 4317
nc -zv collector.example.com 4317

# 3. DNS解析测试
nslookup collector.example.com
dig collector.example.com

# 4. TLS连接测试
openssl s_client -connect collector.example.com:4317 -servername collector.example.com

# 5. HTTP端点测试
curl -v http://collector.example.com:4318/

# 6. gRPC健康检查
grpcurl -plaintext collector.example.com:4317 list
```

### 连接问题解决方案

#### 解决方案1: 防火墙配置

**Linux iptables**:

```bash
# 允许OTLP端口
sudo iptables -A INPUT -p tcp --dport 4317 -j ACCEPT
sudo iptables -A INPUT -p tcp --dport 4318 -j ACCEPT

# 保存规则
sudo iptables-save > /etc/iptables/rules.v4
```

**AWS安全组**:

```bash
# 添加入站规则
aws ec2 authorize-security-group-ingress \
    --group-id sg-xxxxxxxxx \
    --protocol tcp \
    --port 4317 \
    --cidr 0.0.0.0/0
```

**Kubernetes NetworkPolicy**:

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-otlp
spec:
  podSelector:
    matchLabels:
      app: otel-collector
  ingress:
  - from:
    - podSelector: {}
    ports:
    - protocol: TCP
      port: 4317
    - protocol: TCP
      port: 4318
```

#### 解决方案2: 端口配置

**检查Collector监听**:

```bash
# 检查端口监听
netstat -tlnp | grep 4317
ss -tlnp | grep 4317

# 检查进程
ps aux | grep otelcol
```

**Collector配置**:

```yaml
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317  # 监听所有接口
      http:
        endpoint: 0.0.0.0:4318
```

**Kubernetes Service**:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: otel-collector
spec:
  type: ClusterIP  # 或 LoadBalancer
  ports:
  - name: otlp-grpc
    port: 4317
    targetPort: 4317
    protocol: TCP
  - name: otlp-http
    port: 4318
    targetPort: 4318
    protocol: TCP
  selector:
    app: otel-collector
```

#### 解决方案3: TLS配置

**生成自签名证书(测试用)**:

```bash
# 生成CA
openssl genrsa -out ca.key 2048
openssl req -new -x509 -days 365 -key ca.key -out ca.crt \
    -subj "/CN=OpenTelemetry CA"

# 生成服务器证书
openssl genrsa -out server.key 2048
openssl req -new -key server.key -out server.csr \
    -subj "/CN=collector.example.com"
openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key \
    -CAcreateserial -out server.crt -days 365
```

**Collector TLS配置**:

```yaml
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317
        tls:
          cert_file: /etc/otel/server.crt
          key_file: /etc/otel/server.key
          client_ca_file: /etc/otel/ca.crt  # mTLS
```

**SDK TLS配置 (Go)**:

```go
import (
    "crypto/tls"
    "crypto/x509"
    "io/ioutil"
    "google.golang.org/grpc/credentials"
)

// 加载CA证书
caCert, _ := ioutil.ReadFile("/etc/otel/ca.crt")
caCertPool := x509.NewCertPool()
caCertPool.AppendCertsFromPEM(caCert)

// 创建TLS配置
tlsConfig := &tls.Config{
    RootCAs: caCertPool,
    ServerName: "collector.example.com",
}

// 创建exporter
exporter, _ := otlptracegrpc.New(ctx,
    otlptracegrpc.WithEndpoint("collector.example.com:4317"),
    otlptracegrpc.WithTLSCredentials(credentials.NewTLS(tlsConfig)),
)
```

#### 解决方案4: 基础配置修复

**端点格式检查**:

```bash
# 正确格式
OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4318       # HTTP
OTEL_EXPORTER_OTLP_ENDPOINT=localhost:4317              # gRPC

# 错误格式
OTEL_EXPORTER_OTLP_ENDPOINT=grpc://localhost:4317       # ✗ 不需要协议前缀
OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4317       # ✗ gRPC不需要http://
```

**DNS解析修复**:

```bash
# /etc/hosts
127.0.0.1   localhost
10.0.1.100  otel-collector

# Kubernetes DNS
otel-collector.default.svc.cluster.local
```

---

## 4. 数据质量问题诊断

### 症状识别4

```text
✗ Trace不完整(缺少span)
✗ 属性缺失或错误
✗ 时间戳异常
✗ Trace断链
```

### 决策树4

```text
【数据质量问题】
    │
    ◆ Trace完整吗？
    ├─ 否 →
    │     ◆ 部分Span丢失？
    │     ├─ 是 →
    │     │     □ 检查采样配置
    │     │     □ 检查Context传播
    │     │     □ 检查Span是否正确关闭
    │     │     ✓ 解决方案1: 修复Trace完整性
    │     │
    │     └─ Trace断链？
    │           □ 检查Propagator配置
    │           □ 检查跨服务传播
    │           □ 检查异步调用处理
    │           ✓ 解决方案2: 修复Context传播
    │
    └─ 属性正确吗？
          ◆ 属性缺失？
          ├─ 是 →
          │     □ 检查SDK版本
          │     □ 检查Semantic Conventions
          │     □ 检查自定义属性设置
          │     ✓ 解决方案3: 补充属性
          │
          └─ 属性值错误？
                □ 检查属性类型
                □ 检查属性转换
                □ 检查Processor配置
                ✓ 解决方案4: 修复属性值
```

### 数据质量检查清单

```text
□ Trace完整性
  □ 所有预期Span都存在
  □ Parent-Child关系正确
  □ Root Span存在
  □ SpanID/TraceID有效

□ 属性完整性
  □ 必需的Resource属性(service.name等)
  □ HTTP/gRPC/DB等协议属性
  □ 自定义业务属性
  □ 属性类型正确

□ 时间戳准确性
  □ Span开始时间 < 结束时间
  □ Child Span时间在Parent范围内
  □ 时间戳单位正确(纳秒)

□ Context传播
  □ TraceID在整个链路保持一致
  □ Baggage正确传播
  □ Propagator配置正确
```

### 数据质量修复方案

#### 解决方案1: Trace完整性修复

**确保所有Span正确创建和关闭**:

```go
func processRequest(ctx context.Context) error {
    tracer := otel.Tracer("my-service")
    
    // 创建Span
    ctx, span := tracer.Start(ctx, "processRequest")
    defer span.End()  // ✓ 确保调用End()
    
    // 子操作
    if err := subOperation(ctx); err != nil {
        span.RecordError(err)  // ✓ 记录错误
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    return nil
}
```

**异步操作的Span处理**:

```go
func asyncOperation(ctx context.Context) {
    tracer := otel.Tracer("my-service")
    ctx, span := tracer.Start(ctx, "asyncOperation")
    
    go func() {
        defer span.End()  // ✓ 在goroutine中End
        
        // 异步逻辑...
    }()
}
```

#### 解决方案2: Context传播修复

**HTTP服务端**:

```go
import (
    "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
)

// 自动传播Context
http.Handle("/api", otelhttp.NewHandler(
    http.HandlerFunc(apiHandler),
    "api",
))
```

**HTTP客户端**:

```go
import (
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
)

// 配置Propagator
otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
    propagation.TraceContext{},
    propagation.Baggage{},
))

// 使用instrumented client
client := http.Client{
    Transport: otelhttp.NewTransport(http.DefaultTransport),
}

req, _ := http.NewRequestWithContext(ctx, "GET", url, nil)
resp, _ := client.Do(req)  // Context自动传播
```

**gRPC传播**:

```go
import (
    "go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc"
)

// gRPC Server
grpcServer := grpc.NewServer(
    grpc.UnaryInterceptor(otelgrpc.UnaryServerInterceptor()),
    grpc.StreamInterceptor(otelgrpc.StreamServerInterceptor()),
)

// gRPC Client
conn, _ := grpc.Dial(addr,
    grpc.WithUnaryInterceptor(otelgrpc.UnaryClientInterceptor()),
    grpc.WithStreamInterceptor(otelgrpc.StreamClientInterceptor()),
)
```

#### 解决方案3: 属性补充

**Resource属性**:

```go
res, _ := resource.New(ctx,
    resource.WithAttributes(
        // 必需属性
        semconv.ServiceName("my-service"),
        semconv.ServiceVersion("1.0.0"),
        semconv.DeploymentEnvironment("production"),
        
        // 推荐属性
        semconv.ServiceNamespace("ecommerce"),
        semconv.ServiceInstanceID("instance-1"),
        
        // Kubernetes属性
        semconv.K8SPodName("my-pod-abc123"),
        semconv.K8SNamespaceName("default"),
        semconv.K8SDeploymentName("my-deployment"),
    ),
)
```

**Span属性**:

```go
span.SetAttributes(
    // HTTP属性
    semconv.HTTPMethod("GET"),
    semconv.HTTPTarget("/api/users"),
    semconv.HTTPStatusCode(200),
    
    // 数据库属性
    semconv.DBSystem("postgresql"),
    semconv.DBName("users_db"),
    semconv.DBStatement("SELECT * FROM users WHERE id = $1"),
    
    // 自定义属性
    attribute.String("user.id", "12345"),
    attribute.Int64("items.count", 10),
)
```

#### 解决方案4: 使用Processor修复属性

**Collector Attributes Processor**:

```yaml
processors:
  attributes:
    actions:
      # 添加缺失属性
      - key: deployment.environment
        value: production
        action: insert
      
      # 修复错误值
      - key: http.status_code
        action: convert
        converted_type: int
      
      # 删除敏感属性
      - key: http.request.header.authorization
        action: delete
      
      # 重命名属性
      - key: old_attribute
        action: update
        new_key: new_attribute
```

---

## 5. Collector问题诊断

[继续...]

---

## 快速索引

### 按症状查找

| 症状 | 决策树 | 快速解决方案 |
|------|-------|-------------|
| 后端无数据 | [数据未上报](#1-数据未上报问题诊断) | 检查SDK→Collector→后端链路 |
| 应用延迟高 | [性能问题](#2-性能问题诊断) | 优化采样率+批处理配置 |
| 连接超时 | [连接问题](#3-连接与网络问题诊断) | 检查网络+防火墙+端口 |
| Trace断链 | [数据质量](#4-数据质量问题诊断) | 修复Context传播 |
| Collector崩溃 | [Collector问题](#5-collector问题诊断) | 添加memory_limiter |
| SDK报错 | [SDK集成](#6-sdk集成问题诊断) | 检查SDK版本+配置 |
| 云平台认证失败 | [云平台集成](#7-云平台集成问题诊断) | 检查IAM权限 |

### 按组件查找

- **SDK**: [SDK集成问题](#6-sdk集成问题诊断)
- **Collector**: [Collector问题](#5-collector问题诊断)
- **Network**: [连接问题](#3-连接与网络问题诊断)
- **Backend**: [数据未上报](#1-数据未上报问题诊断)

---

## 相关文档

- 📄 [综合快速参考手册](./00_综合快速参考手册.md)
- 📄 [故障排查完整手册](./16_故障排查手册/01_OpenTelemetry故障排查完整手册.md)
- 📄 [最佳实践清单](./17_最佳实践清单/01_OpenTelemetry最佳实践完整清单.md)

---

**最后更新**: 2025年10月8日  
**维护者**: OTLP深度梳理项目组  
**版本**: v1.0

[🏠 返回首页](./README.md) | [🗺️ 实战场景快速查找](./19_综合实战手册/01_OpenTelemetry实战场景快速查找指南.md)
