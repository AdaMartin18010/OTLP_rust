# 微服务追踪实战

> **OpenTelemetry版本**: v1.20+  
> **最后更新**: 2025年10月8日

---

## 目录

- [微服务追踪实战](#微服务追踪实战)
  - [目录](#目录)
  - [1. 场景概述](#1-场景概述)
    - [1.1 系统架构](#11-系统架构)
    - [1.2 技术栈](#12-技术栈)
  - [2. 服务实现](#2-服务实现)
    - [2.1 API Gateway (Go)](#21-api-gateway-go)
    - [2.2 Order Service (Go)](#22-order-service-go)
    - [2.3 Inventory Service (Python)](#23-inventory-service-python)
    - [2.4 Payment Service (Java)](#24-payment-service-java)
  - [3. 数据库追踪](#3-数据库追踪)
    - [3.1 PostgreSQL追踪](#31-postgresql追踪)
    - [3.2 Redis追踪](#32-redis追踪)
  - [4. 消息队列追踪](#4-消息队列追踪)
    - [4.1 Kafka Producer](#41-kafka-producer)
    - [4.2 Kafka Consumer](#42-kafka-consumer)
  - [5. Collector配置](#5-collector配置)
  - [6. 可视化分析](#6-可视化分析)
    - [6.1 正常请求链路](#61-正常请求链路)
    - [6.2 错误诊断](#62-错误诊断)
    - [6.3 性能瓶颈分析](#63-性能瓶颈分析)
  - [7. 生产环境最佳实践](#7-生产环境最佳实践)
  - [8. 故障排查案例](#8-故障排查案例)
    - [8.1 案例1: 订单创建慢](#81-案例1-订单创建慢)
    - [8.2 案例2: 间歇性失败](#82-案例2-间歇性失败)
  - [9. 参考资源](#9-参考资源)

## 1. 场景概述

### 1.1 系统架构

**电商订单系统架构**：

```text
┌─────────────┐
│   Browser   │
└──────┬──────┘
       │ HTTP
       ▼
┌─────────────────────┐
│   API Gateway       │ (Go)
│   - 认证            │
│   - 路由            │
│   - 限流            │
└──────┬──────────────┘
       │ gRPC
       ▼
┌─────────────────────┐
│   Order Service     │ (Go)
│   - 创建订单         │
│   - 订单管理         │
└──┬────────┬─────────┘
   │        │
   │ gRPC   │ Kafka
   │        │
   ▼        ▼
┌──────────────┐  ┌────────────────┐
│ Inventory    │  │ Notification   │
│ Service      │  │ Service        │
│ (Python)     │  │ (Node.js)      │
│ - 库存检查    │  │ - 发送通知      │
│ - 库存扣减    │  └────────────────┘
└──────┬───────┘
       │ HTTP
       ▼
┌─────────────────────┐
│   Payment Service   │ (Java)
│   - 支付处理         │
└─────────────────────┘

数据存储:
- PostgreSQL: 订单、库存
- Redis: 缓存、会话
- Kafka: 消息队列
```

### 1.2 技术栈

**组件清单**：

```text
服务:
- API Gateway: Go + net/http
- Order Service: Go + gRPC
- Inventory Service: Python + FastAPI
- Payment Service: Java + Spring Boot
- Notification Service: Node.js + Express

数据库:
- PostgreSQL 14
- Redis 7
- Kafka 3.0

可观测性:
- OpenTelemetry SDK (各语言)
- OpenTelemetry Collector
- Jaeger (追踪后端)
- Prometheus (指标)
- Grafana (可视化)
```

---

## 2. 服务实现

### 2.1 API Gateway (Go)

**完整实现**：

```go
package main

import (
    "context"
    "net/http"
    "time"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/sdk/resource"
    "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
)

var tracer = otel.Tracer("api-gateway")

func main() {
    // 初始化追踪
    tp, err := initTracer()
    if err != nil {
        panic(err)
    }
    defer tp.Shutdown(context.Background())
    
    // 设置路由
    http.HandleFunc("/api/orders", handleCreateOrder)
    http.HandleFunc("/api/orders/", handleGetOrder)
    
    // 启动服务器
    http.ListenAndServe(":8080", TracingMiddleware(http.DefaultServeMux))
}

func initTracer() (*trace.TracerProvider, error) {
    // 创建OTLP exporter
    exporter, err := otlptracegrpc.New(context.Background(),
        otlptracegrpc.WithEndpoint("otel-collector:4317"),
        otlptracegrpc.WithInsecure(),
    )
    if err != nil {
        return nil, err
    }
    
    // 定义Resource
    res, err := resource.New(context.Background(),
        resource.WithAttributes(
            semconv.ServiceNameKey.String("api-gateway"),
            semconv.ServiceVersionKey.String("1.0.0"),
            semconv.DeploymentEnvironmentKey.String("production"),
        ),
    )
    if err != nil {
        return nil, err
    }
    
    // 创建TracerProvider
    tp := trace.NewTracerProvider(
        trace.WithBatcher(exporter),
        trace.WithResource(res),
        trace.WithSampler(trace.ParentBased(trace.TraceIDRatioBased(0.1))),
    )
    
    otel.SetTracerProvider(tp)
    otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
        propagation.TraceContext{},
        propagation.Baggage{},
    ))
    
    return tp, nil
}

// TracingMiddleware: HTTP追踪中间件
func TracingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 提取上游追踪上下文
        ctx := otel.GetTextMapPropagator().Extract(r.Context(),
            propagation.HeaderCarrier(r.Header))
        
        // 创建SERVER span
        ctx, span := tracer.Start(ctx, r.Method+" "+r.URL.Path,
            trace.WithSpanKind(trace.SpanKindServer),
            trace.WithAttributes(
                semconv.HTTPMethodKey.String(r.Method),
                semconv.HTTPTargetKey.String(r.URL.Path),
                semconv.HTTPSchemeKey.String(getScheme(r)),
                semconv.HTTPClientIPKey.String(getClientIP(r)),
                semconv.UserAgentOriginalKey.String(r.UserAgent()),
            ),
        )
        defer span.End()
        
        // 包装ResponseWriter
        wrapped := &responseWriter{ResponseWriter: w, statusCode: 200}
        
        // 处理请求
        next.ServeHTTP(wrapped, r.WithContext(ctx))
        
        // 记录响应
        span.SetAttributes(
            semconv.HTTPStatusCodeKey.Int(wrapped.statusCode),
        )
        
        if wrapped.statusCode >= 400 {
            span.SetStatus(codes.Error, http.StatusText(wrapped.statusCode))
        } else {
            span.SetStatus(codes.Ok, "")
        }
    })
}

type responseWriter struct {
    http.ResponseWriter
    statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
    rw.statusCode = code
    rw.ResponseWriter.WriteHeader(code)
}

// handleCreateOrder: 创建订单
func handleCreateOrder(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    
    // 业务逻辑span
    ctx, span := tracer.Start(ctx, "CreateOrder")
    defer span.End()
    
    // 解析请求
    var req CreateOrderRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "Invalid request")
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    
    span.SetAttributes(
        attribute.String("order.user_id", req.UserID),
        attribute.Int("order.item_count", len(req.Items)),
    )
    
    // 调用Order Service
    orderID, err := callOrderService(ctx, &req)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "Order service failed")
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    span.SetAttributes(attribute.String("order.id", orderID))
    span.SetStatus(codes.Ok, "")
    
    // 返回响应
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(map[string]string{
        "order_id": orderID,
    })
}

// callOrderService: 调用Order Service (gRPC)
func callOrderService(ctx context.Context, req *CreateOrderRequest) (string, error) {
    // gRPC连接 (使用自动追踪拦截器)
    conn, err := grpc.Dial("order-service:50051",
        grpc.WithTransportCredentials(insecure.NewCredentials()),
        grpc.WithUnaryInterceptor(otelgrpc.UnaryClientInterceptor()),
    )
    if err != nil {
        return "", err
    }
    defer conn.Close()
    
    client := pb.NewOrderServiceClient(conn)
    
    // 调用gRPC (自动创建CLIENT span)
    resp, err := client.CreateOrder(ctx, &pb.CreateOrderRequest{
        UserId: req.UserID,
        Items:  convertItems(req.Items),
    })
    if err != nil {
        return "", err
    }
    
    return resp.OrderId, nil
}

func getScheme(r *http.Request) string {
    if r.TLS != nil {
        return "https"
    }
    return "http"
}

func getClientIP(r *http.Request) string {
    if xff := r.Header.Get("X-Forwarded-For"); xff != "" {
        return strings.Split(xff, ",")[0]
    }
    host, _, _ := net.SplitHostPort(r.RemoteAddr)
    return host
}
```

### 2.2 Order Service (Go)

**gRPC服务实现**：

```go
package main

import (
    "context"
    "net"
    
    "go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "google.golang.org/grpc"
)

type orderServiceServer struct {
    pb.UnimplementedOrderServiceServer
    db              *sql.DB
    inventoryClient pb.InventoryServiceClient
    kafkaProducer   *kafka.Producer
}

func (s *orderServiceServer) CreateOrder(ctx context.Context, req *pb.CreateOrderRequest) (*pb.CreateOrderResponse, error) {
    // ctx已包含SERVER span (通过拦截器)
    span := trace.SpanFromContext(ctx)
    
    span.SetAttributes(
        attribute.String("user.id", req.UserId),
        attribute.Int("items.count", len(req.Items)),
    )
    
    // 1. 验证库存
    ctx, checkSpan := tracer.Start(ctx, "CheckInventory")
    available, err := s.checkInventory(ctx, req.Items)
    checkSpan.End()
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "Inventory check failed")
        return nil, err
    }
    
    if !available {
        span.SetStatus(codes.Error, "Insufficient inventory")
        return nil, status.Error(codes.FailedPrecondition, "Insufficient inventory")
    }
    
    // 2. 创建订单 (数据库)
    ctx, dbSpan := tracer.Start(ctx, "CreateOrderInDB",
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            semconv.DBSystemPostgreSQL,
            semconv.DBName("orders"),
            semconv.DBOperation("INSERT"),
        ),
    )
    
    orderID, err := s.createOrderInDB(ctx, req)
    dbSpan.End()
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "Database error")
        return nil, err
    }
    
    span.SetAttributes(attribute.String("order.id", orderID))
    
    // 3. 扣减库存
    ctx, deductSpan := tracer.Start(ctx, "DeductInventory")
    err = s.deductInventory(ctx, req.Items)
    deductSpan.End()
    
    if err != nil {
        // 补偿: 删除订单
        s.deleteOrder(ctx, orderID)
        span.RecordError(err)
        span.SetStatus(codes.Error, "Inventory deduction failed")
        return nil, err
    }
    
    // 4. 发送订单创建事件 (Kafka)
    ctx, kafkaSpan := tracer.Start(ctx, "PublishOrderCreated",
        trace.WithSpanKind(trace.SpanKindProducer),
        trace.WithAttributes(
            semconv.MessagingSystemKafka,
            semconv.MessagingDestinationKindTopic,
            semconv.MessagingDestination("order.events"),
        ),
    )
    
    err = s.publishOrderCreatedEvent(ctx, orderID, req)
    kafkaSpan.End()
    
    if err != nil {
        // 非关键错误, 记录但继续
        span.AddEvent("Failed to publish event", trace.WithAttributes(
            attribute.String("error", err.Error()),
        ))
    }
    
    span.SetStatus(codes.Ok, "")
    
    return &pb.CreateOrderResponse{
        OrderId: orderID,
        Status:  "CREATED",
    }, nil
}

func (s *orderServiceServer) checkInventory(ctx context.Context, items []*pb.OrderItem) (bool, error) {
    // 调用Inventory Service (gRPC)
    resp, err := s.inventoryClient.CheckAvailability(ctx, &pb.CheckAvailabilityRequest{
        Items: items,
    })
    if err != nil {
        return false, err
    }
    
    return resp.Available, nil
}

func (s *orderServiceServer) createOrderInDB(ctx context.Context, req *pb.CreateOrderRequest) (string, error) {
    span := trace.SpanFromContext(ctx)
    
    orderID := generateOrderID()
    
    // SQL执行
    query := `INSERT INTO orders (id, user_id, status, created_at) VALUES ($1, $2, $3, $4)`
    
    span.SetAttributes(
        semconv.DBStatement(query),
        semconv.DBSQLTable("orders"),
    )
    
    _, err := s.db.ExecContext(ctx, query, orderID, req.UserId, "CREATED", time.Now())
    if err != nil {
        span.RecordError(err)
        return "", err
    }
    
    return orderID, nil
}

func main() {
    // 初始化追踪
    tp, _ := initTracer("order-service")
    defer tp.Shutdown(context.Background())
    
    // 创建gRPC服务器 (使用自动追踪拦截器)
    server := grpc.NewServer(
        grpc.UnaryInterceptor(otelgrpc.UnaryServerInterceptor()),
        grpc.StreamInterceptor(otelgrpc.StreamServerInterceptor()),
    )
    
    pb.RegisterOrderServiceServer(server, &orderServiceServer{
        db:              initDB(),
        inventoryClient: createInventoryClient(),
        kafkaProducer:   createKafkaProducer(),
    })
    
    lis, _ := net.Listen("tcp", ":50051")
    server.Serve(lis)
}
```

### 2.3 Inventory Service (Python)

**FastAPI实现**：

```python
from fastapi import FastAPI, Request
from opentelemetry import trace
from opentelemetry.instrumentation.fastapi import FastAPIInstrumentor
from opentelemetry.instrumentation.sqlalchemy import SQLAlchemyInstrumentor
from opentelemetry.instrumentation.redis import RedisInstrumentor
from opentelemetry.exporter.otlp.proto.grpc.trace_exporter import OTLPSpanExporter
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from opentelemetry.sdk.resources import Resource
from opentelemetry.semconv.resource import ResourceAttributes

# 初始化追踪
resource = Resource(attributes={
    ResourceAttributes.SERVICE_NAME: "inventory-service",
    ResourceAttributes.SERVICE_VERSION: "1.0.0",
    ResourceAttributes.DEPLOYMENT_ENVIRONMENT: "production",
})

provider = TracerProvider(resource=resource)
processor = BatchSpanProcessor(OTLPSpanExporter(endpoint="otel-collector:4317"))
provider.add_span_processor(processor)
trace.set_tracer_provider(provider)

tracer = trace.get_tracer(__name__)

# 创建FastAPI应用
app = FastAPI()

# 自动instrumentation
FastAPIInstrumentor.instrument_app(app)
SQLAlchemyInstrumentor().instrument(engine=db_engine)
RedisInstrumentor().instrument()

@app.post("/api/inventory/check")
async def check_inventory(request: CheckInventoryRequest):
    """检查库存可用性"""
    with tracer.start_as_current_span("CheckInventory") as span:
        span.set_attributes({
            "inventory.item_count": len(request.items),
        })
        
        # 1. 检查Redis缓存
        with tracer.start_as_current_span("CheckCache",
            kind=trace.SpanKind.CLIENT) as cache_span:
            cache_span.set_attributes({
                "db.system": "redis",
                "db.operation": "MGET",
            })
            
            cached = redis_client.mget([f"inventory:{item.sku}" for item in request.items])
        
        # 2. 如果缓存未命中,查询数据库
        if None in cached:
            with tracer.start_as_current_span("QueryDatabase",
                kind=trace.SpanKind.CLIENT) as db_span:
                db_span.set_attributes({
                    "db.system": "postgresql",
                    "db.name": "inventory",
                    "db.operation": "SELECT",
                    "db.sql.table": "inventory",
                })
                
                inventory = db.query(Inventory).filter(
                    Inventory.sku.in_([item.sku for item in request.items])
                ).all()
                
                # 更新缓存
                for inv in inventory:
                    redis_client.setex(f"inventory:{inv.sku}", 300, inv.quantity)
        
        # 3. 检查数量
        available = all(inv.quantity >= item.quantity for inv in inventory)
        
        span.set_attribute("inventory.available", available)
        
        if available:
            span.set_status(trace.Status(trace.StatusCode.OK))
        else:
            span.set_status(trace.Status(
                trace.StatusCode.ERROR,
                "Insufficient inventory"
            ))
        
        return {"available": available}

@app.post("/api/inventory/deduct")
async def deduct_inventory(request: DeductInventoryRequest):
    """扣减库存"""
    with tracer.start_as_current_span("DeductInventory") as span:
        try:
            # 数据库事务
            with db.begin():
                for item in request.items:
                    db.execute(
                        "UPDATE inventory SET quantity = quantity - :qty WHERE sku = :sku",
                        {"qty": item.quantity, "sku": item.sku}
                    )
                    
                    # 清除缓存
                    redis_client.delete(f"inventory:{item.sku}")
            
            span.set_status(trace.Status(trace.StatusCode.OK))
            return {"success": True}
            
        except Exception as e:
            span.record_exception(e)
            span.set_status(trace.Status(
                trace.StatusCode.ERROR,
                str(e)
            ))
            raise
```

### 2.4 Payment Service (Java)

**Spring Boot实现**：

```java
package com.example.payment;

import io.opentelemetry.api.OpenTelemetry;
import io.opentelemetry.api.trace.Span;
import io.opentelemetry.api.trace.Tracer;
import io.opentelemetry.context.Scope;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.*;

@SpringBootApplication
@RestController
@RequestMapping("/api/payment")
public class PaymentService {
    
    private final Tracer tracer;
    
    public PaymentService(OpenTelemetry openTelemetry) {
        this.tracer = openTelemetry.getTracer("payment-service", "1.0.0");
    }
    
    @PostMapping("/process")
    public PaymentResponse processPayment(@RequestBody PaymentRequest request) {
        // 创建span
        Span span = tracer.spanBuilder("ProcessPayment")
            .setSpanKind(SpanKind.INTERNAL)
            .startSpan();
        
        try (Scope scope = span.makeCurrent()) {
            span.setAttribute("payment.order_id", request.getOrderId());
            span.setAttribute("payment.amount", request.getAmount());
            span.setAttribute("payment.method", request.getMethod());
            
            // 1. 验证支付信息
            Span validateSpan = tracer.spanBuilder("ValidatePayment")
                .startSpan();
            try (Scope validateScope = validateSpan.makeCurrent()) {
                validatePaymentInfo(request);
                validateSpan.setStatus(StatusCode.OK);
            } catch (Exception e) {
                validateSpan.recordException(e);
                validateSpan.setStatus(StatusCode.ERROR, "Validation failed");
                throw e;
            } finally {
                validateSpan.end();
            }
            
            // 2. 调用支付网关
            Span gatewaySpan = tracer.spanBuilder("CallPaymentGateway")
                .setSpanKind(SpanKind.CLIENT)
                .setAttribute("http.method", "POST")
                .setAttribute("http.url", "https://payment-gateway.com/charge")
                .startSpan();
            
            String transactionId;
            try (Scope gatewayScope = gatewaySpan.makeCurrent()) {
                transactionId = callPaymentGateway(request);
                gatewaySpan.setAttribute("payment.transaction_id", transactionId);
                gatewaySpan.setStatus(StatusCode.OK);
            } catch (Exception e) {
                gatewaySpan.recordException(e);
                gatewaySpan.setStatus(StatusCode.ERROR, "Gateway error");
                throw e;
            } finally {
                gatewaySpan.end();
            }
            
            // 3. 保存支付记录
            Span dbSpan = tracer.spanBuilder("SavePaymentRecord")
                .setSpanKind(SpanKind.CLIENT)
                .setAttribute("db.system", "postgresql")
                .setAttribute("db.name", "payments")
                .setAttribute("db.operation", "INSERT")
                .startSpan();
            
            try (Scope dbScope = dbSpan.makeCurrent()) {
                savePaymentRecord(request, transactionId);
                dbSpan.setStatus(StatusCode.OK);
            } finally {
                dbSpan.end();
            }
            
            span.setStatus(StatusCode.OK);
            
            return new PaymentResponse(transactionId, "SUCCESS");
            
        } catch (Exception e) {
            span.recordException(e);
            span.setStatus(StatusCode.ERROR, e.getMessage());
            throw new PaymentException("Payment processing failed", e);
        } finally {
            span.end();
        }
    }
    
    public static void main(String[] args) {
        SpringApplication.run(PaymentService.class, args);
    }
}
```

---

## 3. 数据库追踪

### 3.1 PostgreSQL追踪

**自动instrumentation (Go)**：

```go
import (
    "database/sql"
    "go.opentelemetry.io/contrib/instrumentation/database/sql/otelsql"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

// 使用otelsql包装database/sql
db, err := otelsql.Open("postgres", "postgres://user:pass@localhost/dbname",
    otelsql.WithAttributes(
        semconv.DBSystemPostgreSQL,
    ),
)

// 所有SQL操作自动创建span
rows, err := db.QueryContext(ctx, "SELECT * FROM orders WHERE user_id = $1", userID)
// 自动创建span:
//   name: "SELECT orders"
//   attributes:
//     db.system: "postgresql"
//     db.statement: "SELECT * FROM orders WHERE user_id = $1"
//     db.sql.table: "orders"
```

### 3.2 Redis追踪

**手动追踪Redis操作**：

```go
func GetFromCache(ctx context.Context, key string) (string, error) {
    ctx, span := tracer.Start(ctx, "Redis GET",
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            semconv.DBSystemRedis,
            semconv.DBOperation("GET"),
            semconv.DBStatement(fmt.Sprintf("GET %s", key)),
        ),
    )
    defer span.End()
    
    val, err := redisClient.Get(ctx, key).Result()
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "Redis error")
        return "", err
    }
    
    span.SetStatus(codes.Ok, "")
    return val, nil
}
```

---

## 4. 消息队列追踪

### 4.1 Kafka Producer

```go
func PublishOrderCreatedEvent(ctx context.Context, orderID string, order *Order) error {
    ctx, span := tracer.Start(ctx, "Publish order.created",
        trace.WithSpanKind(trace.SpanKindProducer),
        trace.WithAttributes(
            semconv.MessagingSystemKafka,
            semconv.MessagingDestinationKindTopic,
            semconv.MessagingDestination("order.events"),
            attribute.String("messaging.kafka.message.key", orderID),
        ),
    )
    defer span.End()
    
    // 序列化事件
    event := OrderCreatedEvent{
        OrderID:   orderID,
        UserID:    order.UserID,
        Timestamp: time.Now(),
    }
    
    data, _ := json.Marshal(event)
    
    // 创建Kafka消息
    msg := &kafka.Message{
        Topic: "order.events",
        Key:   []byte(orderID),
        Value: data,
        Headers: []kafka.Header{},
    }
    
    // 注入追踪上下文到消息头
    otel.GetTextMapPropagator().Inject(ctx, &kafkaHeaderCarrier{msg})
    
    // 发送消息
    err := producer.WriteMessages(ctx, msg)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "Kafka publish failed")
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// Kafka Header Carrier
type kafkaHeaderCarrier struct {
    msg *kafka.Message
}

func (c *kafkaHeaderCarrier) Get(key string) string {
    for _, h := range c.msg.Headers {
        if h.Key == key {
            return string(h.Value)
        }
    }
    return ""
}

func (c *kafkaHeaderCarrier) Set(key, value string) {
    c.msg.Headers = append(c.msg.Headers, kafka.Header{
        Key:   key,
        Value: []byte(value),
    })
}

func (c *kafkaHeaderCarrier) Keys() []string {
    keys := make([]string, len(c.msg.Headers))
    for i, h := range c.msg.Headers {
        keys[i] = h.Key
    }
    return keys
}
```

### 4.2 Kafka Consumer

```go
func ConsumeOrderEvents(ctx context.Context) {
    reader := kafka.NewReader(kafka.ReaderConfig{
        Brokers: []string{"localhost:9092"},
        Topic:   "order.events",
        GroupID: "notification-service",
    })
    
    for {
        msg, err := reader.FetchMessage(ctx)
        if err != nil {
            break
        }
        
        // 提取追踪上下文
        ctx := otel.GetTextMapPropagator().Extract(context.Background(),
            &kafkaHeaderCarrier{&msg})
        
        // 创建CONSUMER span
        ctx, span := tracer.Start(ctx, "Process order.created",
            trace.WithSpanKind(trace.SpanKindConsumer),
            trace.WithAttributes(
                semconv.MessagingSystemKafka,
                semconv.MessagingDestinationKindTopic,
                semconv.MessagingDestination("order.events"),
                semconv.MessagingOperationReceive,
                attribute.String("messaging.kafka.message.key", string(msg.Key)),
            ),
        )
        
        // 处理消息
        err = processOrderCreatedEvent(ctx, msg.Value)
        if err != nil {
            span.RecordError(err)
            span.SetStatus(codes.Error, "Processing failed")
        } else {
            span.SetStatus(codes.Ok, "")
        }
        
        span.End()
        
        // 提交offset
        reader.CommitMessages(ctx, msg)
    }
}
```

---

## 5. Collector配置

**完整Collector配置**：

```yaml
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317
      http:
        endpoint: 0.0.0.0:4318

processors:
  # 批处理
  batch:
    timeout: 10s
    send_batch_size: 1024
  
  # 采样 (生产环境10%)
  probabilistic_sampler:
    sampling_percentage: 10
  
  # 资源检测
  resourcedetection:
    detectors: [env, system, docker]
  
  # 属性处理
  attributes:
    actions:
      - key: environment
        value: production
        action: upsert

exporters:
  # Jaeger
  jaeger:
    endpoint: jaeger:14250
    tls:
      insecure: true
  
  # Prometheus (metrics)
  prometheus:
    endpoint: 0.0.0.0:8889
  
  # Logging (调试)
  logging:
    loglevel: info

service:
  pipelines:
    traces:
      receivers: [otlp]
      processors: [batch, resourcedetection, attributes, probabilistic_sampler]
      exporters: [jaeger, logging]
    
    metrics:
      receivers: [otlp]
      processors: [batch]
      exporters: [prometheus]
```

---

## 6. 可视化分析

### 6.1 正常请求链路

**Jaeger UI显示**：

```text
Trace: 5b8efff798038103d269b633813fc60c
Duration: 285ms
Spans: 15

Timeline:
┌─ API Gateway: POST /api/orders (285ms) ──────────────────┐
│  ├─ CreateOrder (280ms)                                  │
│  │  └─ Order Service: CreateOrder (275ms)                │
│  │     ├─ CheckInventory (50ms)                          │
│  │     │  └─ Inventory Service: Check (45ms)             │
│  │     │     ├─ Redis GET (5ms)                          │
│  │     │     └─ PostgreSQL SELECT (35ms)                 │
│  │     ├─ CreateOrderInDB (80ms)                         │
│  │     │  └─ PostgreSQL INSERT (75ms)                    │
│  │     ├─ DeductInventory (100ms)                        │
│  │     │  └─ Inventory Service: Deduct (95ms)            │
│  │     │     └─ PostgreSQL UPDATE (90ms)                 │
│  │     └─ PublishOrderCreated (25ms)                     │
│  │        └─ Kafka Producer (20ms)                       │
└──────────────────────────────────────────────────────────┘

分析:
- 总延迟: 285ms
- 最慢操作: DeductInventory (100ms)
- 数据库操作: 200ms (70%)
- 网络调用: 3次 gRPC + 1次 Kafka
```

### 6.2 错误诊断

**错误trace示例**：

```text
Trace: abc123... (错误)
Duration: 5050ms (超时!)
Spans: 8

Timeline:
┌─ API Gateway: POST /api/orders (5050ms) ❌───────────────┐
│  ├─ CreateOrder (5045ms) ❌                              │
│  │  └─ Order Service: CreateOrder (5040ms) ❌            │
│  │     ├─ CheckInventory (50ms) ✅                       │
│  │     ├─ CreateOrderInDB (80ms) ✅                      │
│  │     └─ DeductInventory (5000ms) ❌ TIMEOUT            │
│  │        └─ Inventory Service: Deduct (5000ms) ❌       │
│  │           └─ PostgreSQL UPDATE (5000ms) ❌ DEADLOCK   │
└──────────────────────────────────────────────────────────┘

错误详情:
Span: PostgreSQL UPDATE
Status: ERROR
Message: "pq: deadlock detected"
Stack Trace:
  at (*DB).ExecContext (db.go:1234)
  at deductInventory (inventory.go:56)

根因分析:
1. 数据库死锁
2. 导致UPDATE超时 (5s)
3. 影响整个请求链路

解决方案:
- 优化SQL查询顺序
- 减少锁持有时间
- 实现重试机制
```

### 6.3 性能瓶颈分析

**慢trace分析**：

```text
场景: 订单创建延迟高 (p95 > 2s)

查询Jaeger:
- duration > 2000ms
- service: order-service
- operation: CreateOrder

发现:
1. 50%的慢trace有相同特征:
   - CheckInventory: 1500ms (异常慢!)
   - 正常应该: 50ms

2. 深入CheckInventory span:
   - Redis GET: 5ms ✅
   - PostgreSQL SELECT: 1480ms ❌ 慢查询!

3. 查看SQL:
   db.statement: "SELECT * FROM inventory WHERE sku IN (...)"
   
   问题: 没有索引!

解决:
CREATE INDEX idx_inventory_sku ON inventory(sku);

结果:
- CheckInventory: 50ms → 10ms
- 整体p95延迟: 2000ms → 300ms
```

---

## 7. 生产环境最佳实践

```text
1. 采样
   ✅ 使用ParentBased(TraceIDRatioBased(0.1))
   ✅ 总是采样错误 (自定义采样器)
   ✅ 监控采样率

2. 资源管理
   ✅ 配置合理的batch size和timeout
   ✅ 限制并发span数
   ✅ 监控Collector性能

3. 属性控制
   ✅ 避免高基数属性
   ❌ 不要记录user_id, request_id
   ✅ 使用http.route而非url.path

4. 错误处理
   ✅ 总是记录exception
   ✅ 设置span status
   ✅ 添加有用的event

5. 性能
   ✅ 使用异步导出
   ✅ 复用tracer对象
   ✅ 避免过度instrumentation

6. 安全
   ✅ 不要记录敏感信息
   ✅ 脱敏SQL语句
   ✅ 使用TLS传输

7. 监控
   ✅ 监控追踪覆盖率
   ✅ 监控span丢失率
   ✅ 监控Collector健康状态
```

---

## 8. 故障排查案例

### 8.1 案例1: 订单创建慢

**问题描述**：

```text
现象:
- p95延迟从300ms突然上升到2000ms
- 错误率正常 (<1%)
- 影响: 用户体验差

排查步骤:
1. Jaeger查询慢trace
   - operation: CreateOrder
   - duration > 2000ms
   - time range: 最近1小时

2. 分析慢trace共同点
   - 50个trace样本
   - 共同特征: CheckInventory慢 (1500ms)

3. 深入CheckInventory
   - Redis GET: 5ms (正常)
   - PostgreSQL SELECT: 1480ms (异常!)

4. 查看数据库
   - 慢查询日志
   - 发现: "SELECT * FROM inventory WHERE sku IN (...)"
   - 执行计划: Seq Scan (全表扫描)

5. 根因
   - 索引被意外删除
   - 或数据量增长导致索引失效

解决:
CREATE INDEX idx_inventory_sku ON inventory(sku);
ANALYZE inventory;

验证:
- 重新采样
- CheckInventory: 10ms
- p95延迟: 300ms
- 问题解决!
```

### 8.2 案例2: 间歇性失败

**问题描述**：

```text
现象:
- 错误率周期性上升 (每5分钟)
- 错误: "Payment service unavailable"
- 影响: 10%请求失败

排查步骤:
1. Jaeger查询错误trace
   - status: error
   - service: order-service
   - error.message: "Payment service unavailable"

2. 分析错误trace
   - CallPaymentService span: ERROR
   - gRPC status: UNAVAILABLE (14)
   - pattern: 每5分钟一次

3. 检查Payment Service
   - 日志: "Connection reset by peer"
   - 指标: 连接池耗尽

4. 发现问题
   - Payment Service有定时任务
   - 每5分钟重启连接池
   - 导致正在处理的请求失败

解决:
- 优雅关闭连接池
- 等待现有请求完成
- 实现重试机制 (Order Service)

代码修改:
// Order Service添加重试
client := pb.NewPaymentServiceClient(conn)
for i := 0; i < 3; i++ {
    resp, err := client.ProcessPayment(ctx, req)
    if err == nil {
        return resp, nil
    }
    if isRetryable(err) {
        time.Sleep(time.Second * time.Duration(i+1))
        continue
    }
    return nil, err
}

验证:
- 错误率: 10% → 0.1%
- 重试成功率: 95%
- 用户影响: 最小化
```

---

## 9. 参考资源

- **OpenTelemetry Go**: <https://github.com/open-telemetry/opentelemetry-go>
- **OpenTelemetry Python**: <https://github.com/open-telemetry/opentelemetry-python>
- **OpenTelemetry Java**: <https://github.com/open-telemetry/opentelemetry-java>
- **Jaeger**: <https://www.jaegertracing.io/>

---

**文档状态**: ✅ 完成  
**审核状态**: 待审核  
**相关文档**: [采样策略](../05_采样与性能/01_采样策略.md), [SDK概述](../04_核心组件/01_SDK概述.md)
