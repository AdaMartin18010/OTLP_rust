# 分布式事务追踪实战

> **最后更新**: 2025年10月8日  
> **难度**: 高级  
> **目标读者**: 高级后端工程师、架构师

---

## 目录

- [分布式事务追踪实战](#分布式事务追踪实战)
  - [目录](#目录)
  - [1. 场景描述](#1-场景描述)
  - [2. 架构设计](#2-架构设计)
  - [3. Saga模式追踪](#3-saga模式追踪)
  - [4. TCC模式追踪](#4-tcc模式追踪)
  - [5. 补偿追踪](#5-补偿追踪)
  - [6. 完整实现](#6-完整实现)
  - [7. 可视化分析](#7-可视化分析)
  - [8. 最佳实践](#8-最佳实践)

---

## 1. 场景描述

**业务场景**：电商下单流程

```text
步骤:
1. 创建订单 (Order Service)
2. 扣减库存 (Inventory Service)
3. 扣款 (Payment Service)
4. 发货 (Shipping Service)

失败场景:
- 库存不足 → 取消订单
- 支付失败 → 回滚库存 + 取消订单
- 发货失败 → 退款 + 恢复库存 + 取消订单
```

---

## 2. 架构设计

```text
┌─────────────────────────────────────────────────────────┐
│                     API Gateway                          │
└────────────────┬────────────────────────────────────────┘
                 │ POST /orders
                 ▼
      ┌──────────────────────┐
      │   Order Service      │
      │  (Saga Orchestrator) │
      └──────────┬───────────┘
                 │
        ┌────────┴────────┐
        │                 │
        ▼                 ▼
┌──────────────┐  ┌──────────────┐
│  Inventory   │  │   Payment    │
│   Service    │  │   Service    │
└──────┬───────┘  └──────┬───────┘
       │                 │
       └────────┬────────┘
                ▼
        ┌──────────────┐
        │   Shipping   │
        │   Service    │
        └──────────────┘

每个步骤都生成Span，形成完整Trace
```

---

## 3. Saga模式追踪

**Orchestrator实现**:

```go
package main

import (
    "context"
    "fmt"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

type SagaOrchestrator struct {
    tracer trace.Tracer
}

func NewSagaOrchestrator() *SagaOrchestrator {
    return &SagaOrchestrator{
        tracer: otel.Tracer("saga-orchestrator"),
    }
}

// 创建订单 Saga
func (s *SagaOrchestrator) CreateOrder(ctx context.Context, req OrderRequest) (*Order, error) {
    ctx, span := s.tracer.Start(ctx, "Saga: Create Order",
        trace.WithSpanKind(trace.SpanKindInternal),
        trace.WithAttributes(
            attribute.String("saga.type", "choreography"),
            attribute.String("saga.id", generateSagaID()),
            attribute.String("order.id", req.OrderID),
        ),
    )
    defer span.End()
    
    // 步骤1: 创建订单
    order, err := s.createOrderStep(ctx, req)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "Failed to create order")
        return nil, err
    }
    span.AddEvent("Order created", trace.WithAttributes(
        attribute.String("order.id", order.ID),
    ))
    
    // 步骤2: 扣减库存
    err = s.reserveInventoryStep(ctx, order.ID, req.Items)
    if err != nil {
        span.RecordError(err)
        span.AddEvent("Inventory reservation failed, starting compensation")
        
        // 补偿: 取消订单
        s.cancelOrderStep(ctx, order.ID)
        
        span.SetStatus(codes.Error, "Saga failed at inventory step")
        return nil, err
    }
    span.AddEvent("Inventory reserved")
    
    // 步骤3: 扣款
    err = s.processPaymentStep(ctx, order.ID, req.Amount)
    if err != nil {
        span.RecordError(err)
        span.AddEvent("Payment failed, starting compensation")
        
        // 补偿: 恢复库存 + 取消订单
        s.releaseInventoryStep(ctx, order.ID)
        s.cancelOrderStep(ctx, order.ID)
        
        span.SetStatus(codes.Error, "Saga failed at payment step")
        return nil, err
    }
    span.AddEvent("Payment processed")
    
    // 步骤4: 发货
    err = s.createShipmentStep(ctx, order.ID)
    if err != nil {
        span.RecordError(err)
        span.AddEvent("Shipping failed, starting compensation")
        
        // 补偿: 退款 + 恢复库存 + 取消订单
        s.refundPaymentStep(ctx, order.ID)
        s.releaseInventoryStep(ctx, order.ID)
        s.cancelOrderStep(ctx, order.ID)
        
        span.SetStatus(codes.Error, "Saga failed at shipping step")
        return nil, err
    }
    span.AddEvent("Shipment created")
    
    span.SetStatus(codes.Ok, "Saga completed successfully")
    return order, nil
}

// 创建订单步骤
func (s *SagaOrchestrator) createOrderStep(ctx context.Context, req OrderRequest) (*Order, error) {
    ctx, span := s.tracer.Start(ctx, "Step: Create Order",
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            attribute.String("saga.step", "create_order"),
            attribute.Int("saga.step.number", 1),
        ),
    )
    defer span.End()
    
    // 调用Order Service
    order, err := callOrderService(ctx, req)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return nil, err
    }
    
    span.SetStatus(codes.Ok, "")
    return order, nil
}

// 扣减库存步骤
func (s *SagaOrchestrator) reserveInventoryStep(ctx context.Context, orderID string, items []Item) error {
    ctx, span := s.tracer.Start(ctx, "Step: Reserve Inventory",
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            attribute.String("saga.step", "reserve_inventory"),
            attribute.Int("saga.step.number", 2),
            attribute.String("order.id", orderID),
            attribute.Int("items.count", len(items)),
        ),
    )
    defer span.End()
    
    // 调用Inventory Service
    err := callInventoryService(ctx, orderID, items)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// 扣款步骤
func (s *SagaOrchestrator) processPaymentStep(ctx context.Context, orderID string, amount float64) error {
    ctx, span := s.tracer.Start(ctx, "Step: Process Payment",
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            attribute.String("saga.step", "process_payment"),
            attribute.Int("saga.step.number", 3),
            attribute.String("order.id", orderID),
            attribute.Float64("payment.amount", amount),
        ),
    )
    defer span.End()
    
    // 调用Payment Service
    err := callPaymentService(ctx, orderID, amount)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// 补偿: 取消订单
func (s *SagaOrchestrator) cancelOrderStep(ctx context.Context, orderID string) error {
    ctx, span := s.tracer.Start(ctx, "Compensation: Cancel Order",
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            attribute.String("saga.step", "cancel_order"),
            attribute.String("saga.step.type", "compensation"),
            attribute.String("order.id", orderID),
        ),
    )
    defer span.End()
    
    err := callOrderServiceCancel(ctx, orderID)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// 补偿: 恢复库存
func (s *SagaOrchestrator) releaseInventoryStep(ctx context.Context, orderID string) error {
    ctx, span := s.tracer.Start(ctx, "Compensation: Release Inventory",
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            attribute.String("saga.step", "release_inventory"),
            attribute.String("saga.step.type", "compensation"),
            attribute.String("order.id", orderID),
        ),
    )
    defer span.End()
    
    err := callInventoryServiceRelease(ctx, orderID)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}
```

---

## 4. TCC模式追踪

**Try-Confirm-Cancel追踪**:

```go
type TCCCoordinator struct {
    tracer trace.Tracer
}

// TCC事务
func (t *TCCCoordinator) ExecuteTransaction(ctx context.Context, req OrderRequest) error {
    ctx, span := t.tracer.Start(ctx, "TCC Transaction",
        trace.WithSpanKind(trace.SpanKindInternal),
        trace.WithAttributes(
            attribute.String("tcc.id", generateTCCID()),
            attribute.String("tcc.phase", "try"),
        ),
    )
    defer span.End()
    
    // Phase 1: Try
    tryResults, err := t.tryPhase(ctx, req)
    if err != nil {
        span.AddEvent("Try phase failed, executing cancel")
        t.cancelPhase(ctx, tryResults)
        span.SetStatus(codes.Error, "TCC failed at try phase")
        return err
    }
    span.AddEvent("Try phase succeeded")
    
    // Phase 2: Confirm
    err = t.confirmPhase(ctx, tryResults)
    if err != nil {
        span.AddEvent("Confirm phase failed, executing cancel")
        t.cancelPhase(ctx, tryResults)
        span.SetStatus(codes.Error, "TCC failed at confirm phase")
        return err
    }
    span.AddEvent("Confirm phase succeeded")
    
    span.SetStatus(codes.Ok, "TCC completed successfully")
    return nil
}

// Try阶段
func (t *TCCCoordinator) tryPhase(ctx context.Context, req OrderRequest) (map[string]interface{}, error) {
    ctx, span := t.tracer.Start(ctx, "TCC Phase: Try",
        trace.WithSpanKind(trace.SpanKindInternal),
        trace.WithAttributes(
            attribute.String("tcc.phase", "try"),
        ),
    )
    defer span.End()
    
    results := make(map[string]interface{})
    
    // Try: 冻结库存
    inventoryResult, err := t.tryInventory(ctx, req.Items)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "Failed to try inventory")
        return results, err
    }
    results["inventory"] = inventoryResult
    span.AddEvent("Inventory try succeeded")
    
    // Try: 冻结金额
    paymentResult, err := t.tryPayment(ctx, req.Amount)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "Failed to try payment")
        return results, err
    }
    results["payment"] = paymentResult
    span.AddEvent("Payment try succeeded")
    
    span.SetStatus(codes.Ok, "")
    return results, nil
}

// Confirm阶段
func (t *TCCCoordinator) confirmPhase(ctx context.Context, tryResults map[string]interface{}) error {
    ctx, span := t.tracer.Start(ctx, "TCC Phase: Confirm",
        trace.WithSpanKind(trace.SpanKindInternal),
        trace.WithAttributes(
            attribute.String("tcc.phase", "confirm"),
        ),
    )
    defer span.End()
    
    // Confirm: 确认扣减库存
    err := t.confirmInventory(ctx, tryResults["inventory"])
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "Failed to confirm inventory")
        return err
    }
    span.AddEvent("Inventory confirmed")
    
    // Confirm: 确认扣款
    err = t.confirmPayment(ctx, tryResults["payment"])
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "Failed to confirm payment")
        return err
    }
    span.AddEvent("Payment confirmed")
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// Cancel阶段
func (t *TCCCoordinator) cancelPhase(ctx context.Context, tryResults map[string]interface{}) error {
    ctx, span := t.tracer.Start(ctx, "TCC Phase: Cancel",
        trace.WithSpanKind(trace.SpanKindInternal),
        trace.WithAttributes(
            attribute.String("tcc.phase", "cancel"),
        ),
    )
    defer span.End()
    
    // Cancel: 释放库存
    if inv, ok := tryResults["inventory"]; ok {
        t.cancelInventory(ctx, inv)
        span.AddEvent("Inventory cancelled")
    }
    
    // Cancel: 释放金额
    if pay, ok := tryResults["payment"]; ok {
        t.cancelPayment(ctx, pay)
        span.AddEvent("Payment cancelled")
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}
```

---

## 5. 补偿追踪

**补偿流程可视化**:

```text
Trace结构:
Saga: Create Order (ROOT)
  ├─ Step: Create Order [OK]
  ├─ Step: Reserve Inventory [OK]
  ├─ Step: Process Payment [ERROR]
  ├─ Compensation: Release Inventory [OK]
  └─ Compensation: Cancel Order [OK]

每个补偿步骤都清晰标记:
- saga.step.type = "compensation"
- 关联原始步骤
```

---

## 6. 完整实现

**HTTP Handler**:

```go
func (h *Handler) CreateOrderHandler(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    
    // 提取TraceContext
    ctx = otel.GetTextMapPropagator().Extract(ctx, propagation.HeaderCarrier(r.Header))
    
    tracer := otel.Tracer("order-api")
    ctx, span := tracer.Start(ctx, "POST /orders",
        trace.WithSpanKind(trace.SpanKindServer),
        trace.WithAttributes(
            semconv.HTTPMethod(r.Method),
            semconv.HTTPURL(r.URL.String()),
        ),
    )
    defer span.End()
    
    // 解析请求
    var req OrderRequest
    json.NewDecoder(r.Body).Decode(&req)
    
    span.SetAttributes(
        attribute.String("order.id", req.OrderID),
        attribute.Float64("order.amount", req.Amount),
    )
    
    // 执行Saga
    orchestrator := NewSagaOrchestrator()
    order, err := orchestrator.CreateOrder(ctx, req)
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        
        w.WriteHeader(http.StatusInternalServerError)
        json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
        return
    }
    
    span.SetStatus(codes.Ok, "")
    span.SetAttributes(
        attribute.String("order.status", "completed"),
    )
    
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(order)
}
```

---

## 7. 可视化分析

**Jaeger Trace视图**:

```text
成功场景:
[===== POST /orders (200ms) =====]
  [= Create Order (20ms) =]
  [= Reserve Inventory (30ms) =]
  [= Process Payment (50ms) =]
  [= Create Shipment (100ms) =]

失败场景 (支付失败):
[===== POST /orders (120ms) =====]
  [= Create Order (20ms) =]
  [= Reserve Inventory (30ms) =]
  [= Process Payment (50ms) ERROR]
  [= Release Inventory (10ms) COMPENSATION]
  [= Cancel Order (10ms) COMPENSATION]

查询语句:
service="order-service" AND 
tags.saga.type="choreography" AND 
tags.error=true
```

---

## 8. 最佳实践

```text
✅ DO (推荐)
1. 每个Saga步骤创建独立Span
2. 补偿步骤明确标记
3. 记录完整上下文
4. 使用Event记录状态变化
5. 失败时记录详细错误
6. 关联业务ID (order.id, saga.id)
7. 监控补偿成功率
8. 设置合理超时

❌ DON'T (避免)
1. 不要跳过补偿追踪
2. 不要遗漏失败原因
3. 不要忽略补偿失败
4. 不要硬编码超时
5. 不要缺少业务上下文

监控指标:
- saga.duration (Saga总耗时)
- saga.success_rate (成功率)
- saga.compensation_rate (补偿率)
- saga.step.duration (步骤耗时)
- saga.compensation.success_rate (补偿成功率)

告警规则:
- Saga补偿率 > 10%
- 补偿失败率 > 1%
- Saga耗时 > 5s
```

---

**文档状态**: ✅ 完成  
**审核状态**: 待审核  
**相关文档**: [微服务追踪实战](01_微服务追踪实战.md), [SpanContext](../../03_数据模型/01_Traces数据模型/02_SpanContext.md)
