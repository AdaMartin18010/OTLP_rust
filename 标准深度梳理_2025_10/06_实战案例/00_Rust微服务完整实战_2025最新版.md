# Rust 微服务完整实战 - 2025 最新版

> **Rust 版本**: 1.90  
> **OpenTelemetry**: 0.31.0  
> **日期**: 2025年10月8日  
> **状态**: ✅ 生产就绪

---

## 📋 目录

- [Rust 微服务完整实战 - 2025 最新版](#rust-微服务完整实战---2025-最新版)
  - [📋 目录](#-目录)
  - [项目概述](#项目概述)
    - [系统架构](#系统架构)
    - [核心特性](#核心特性)
  - [技术栈](#技术栈)
    - [Cargo Workspace Dependencies](#cargo-workspace-dependencies)
  - [项目结构](#项目结构)
  - [完整实现](#完整实现)
    - [共享库 (shared/src/telemetry.rs)](#共享库-sharedsrctelemetryrs)
    - [共享库 (shared/src/error.rs)](#共享库-sharedsrcerrorrs)
    - [API Gateway (api-gateway/src/main.rs)](#api-gateway-api-gatewaysrcmainrs)
    - [API Gateway - gRPC 客户端 (api-gateway/src/grpc\_clients.rs)](#api-gateway---grpc-客户端-api-gatewaysrcgrpc_clientsrs)
    - [User Service (user-service/proto/user.proto)](#user-service-user-serviceprotouserproto)
    - [User Service (user-service/src/main.rs)](#user-service-user-servicesrcmainrs)
    - [Order Service (order-service/proto/order.proto)](#order-service-order-serviceprotoorderproto)
    - [Order Service (order-service/src/main.rs)](#order-service-order-servicesrcmainrs)
  - [部署配置](#部署配置)
    - [docker-compose.yml](#docker-composeyml)
    - [otel-collector-config.yaml](#otel-collector-configyaml)
  - [测试验证](#测试验证)
    - [1. 启动服务](#1-启动服务)
    - [2. API 测试](#2-api-测试)
    - [3. 查看追踪](#3-查看追踪)
  - [最佳实践](#最佳实践)
    - [✅ 架构设计](#-架构设计)
    - [⚡ 性能优化](#-性能优化)
    - [🔍 可观测性](#-可观测性)
    - [🛡️ 安全和可靠性](#️-安全和可靠性)
  - [参考资源](#参考资源)
    - [📚 官方文档](#-官方文档)
    - [🔧 示例代码](#-示例代码)

---

## 项目概述

本实战案例展示如何构建一个**生产级 Rust 微服务系统**，包含完整的 OTLP 集成、分布式追踪、指标收集和日志聚合。

### 系统架构

```text
┌─────────────────────────────────────────────────────────┐
│                     用户请求                             │
└───────────────────────┬─────────────────────────────────┘
                        ▼
              ┌──────────────────┐
              │   API Gateway    │  ← Axum + OTLP
              │   (Port: 8080)   │
              └────────┬──────────┘
                       │
         ┌─────────────┼─────────────┐
         ▼             ▼             ▼
   ┌──────────┐  ┌──────────┐  ┌──────────┐
   │  User    │  │  Order   │  │  Payment │
   │ Service  │  │ Service  │  │ Service  │
   │(gRPC)    │  │(gRPC)    │  │(gRPC)    │
   └────┬─────┘  └────┬─────┘  └────┬─────┘
        │             │              │
        ▼             ▼              ▼
   ┌─────────────────────────────────────┐
   │        PostgreSQL + Redis           │
   └─────────────────────────────────────┘
                    ▼
           ┌─────────────────┐
           │  OTLP Collector │
           └─────────────────┘
                    ▼
        ┌───────────────────────┐
        │  Jaeger / Prometheus  │
        │  / Grafana / Loki     │
        └───────────────────────┘
```

### 核心特性

- ✅ **完整的 OTLP 集成**: Traces, Metrics, Logs
- ✅ **分布式追踪**: W3C TraceContext 传播
- ✅ **类型安全**: Rust 1.90 类型系统
- ✅ **异步优先**: Tokio 1.47.1
- ✅ **gRPC 通信**: Tonic 0.14.2
- ✅ **数据库集成**: SQLx, Redis
- ✅ **健康检查**: Kubernetes 就绪/存活探针
- ✅ **优雅关闭**: 信号处理

---

## 技术栈

### Cargo Workspace Dependencies

```toml
[workspace]
members = [
    "api-gateway",
    "user-service",
    "order-service",
    "shared",
]
resolver = "2"

[workspace.package]
version = "0.1.0"
edition = "2024"
rust-version = "1.90"

[workspace.dependencies]
# OpenTelemetry
opentelemetry = "0.31.0"
opentelemetry_sdk = { version = "0.31.0", features = ["rt-tokio"] }
opentelemetry-otlp = { version = "0.31.0", features = ["http-json", "grpc-tonic"] }
tracing = "0.1.41"
tracing-subscriber = { version = "0.3.19", features = ["env-filter", "json"] }
tracing-opentelemetry = "0.31"

# 异步运行时
tokio = { version = "1.47.1", features = ["full"] }
tokio-stream = "0.1.17"

# Web 框架
axum = { version = "0.8.7", features = ["tracing"] }
tower = { version = "0.5.4", features = ["timeout", "limit"] }
tower-http = { version = "0.6.4", features = ["trace", "cors"] }

# gRPC
tonic = { version = "0.14.2", features = ["transport", "tls-ring"] }
prost = "0.14.1"

# 数据库
sqlx = { version = "0.8.3", features = ["postgres", "runtime-tokio-rustls", "uuid", "chrono"] }
redis = { version = "0.27.7", features = ["tokio-comp", "connection-manager"] }

# 序列化
serde = { version = "1.0.228", features = ["derive"] }
serde_json = "1.0.145"

# 错误处理
anyhow = "1.0.100"
thiserror = "2.0.17"

# 工具
uuid = { version = "1.18.1", features = ["v4", "serde"] }
chrono = "0.4.40"
bytes = "1.10.1"

[workspace.dev-dependencies]
criterion = "0.7.0"
mockall = "0.13.3"
```

---

## 项目结构

```text
microservices/
├── api-gateway/              # API 网关
│   ├── src/
│   │   ├── main.rs
│   │   ├── handlers/        # HTTP 处理器
│   │   ├── middleware/      # 中间件
│   │   └── config.rs
│   └── Cargo.toml
├── user-service/             # 用户服务
│   ├── src/
│   │   ├── main.rs
│   │   ├── grpc/           # gRPC 服务实现
│   │   ├── repository/     # 数据访问层
│   │   └── models.rs
│   ├── proto/
│   │   └── user.proto
│   ├── build.rs
│   └── Cargo.toml
├── order-service/            # 订单服务
│   ├── src/
│   │   ├── main.rs
│   │   ├── grpc/
│   │   └── repository/
│   ├── proto/
│   │   └── order.proto
│   ├── build.rs
│   └── Cargo.toml
├── shared/                   # 共享库
│   ├── src/
│   │   ├── lib.rs
│   │   ├── telemetry.rs    # OTLP 集成
│   │   ├── error.rs        # 错误类型
│   │   └── context.rs      # 上下文传播
│   └── Cargo.toml
├── docker-compose.yml
├── Cargo.toml               # Workspace 配置
└── README.md
```

---

## 完整实现

### 共享库 (shared/src/telemetry.rs)

```rust
//! 共享的 OTLP 集成模块

use opentelemetry::{global, KeyValue};
use opentelemetry_otlp::WithExportConfig;
use opentelemetry_sdk::{
    propagation::TraceContextPropagator,
    runtime::TokioCurrentThread,
    trace::{self, Sampler},
    Resource,
};
use tracing::{info, Subscriber};
use tracing_subscriber::{
    layer::SubscriberExt, registry::LookupSpan, util::SubscriberInitExt, EnvFilter, Layer,
};

/// 初始化 OTLP telemetry
pub async fn init_telemetry(
    service_name: &str,
    otlp_endpoint: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    // 设置 TraceContext 传播器
    global::set_text_map_propagator(TraceContextPropagator::new());
    
    // 创建 OTLP Tracer
    let tracer = opentelemetry_otlp::new_pipeline()
        .tracing()
        .with_exporter(
            opentelemetry_otlp::new_exporter()
                .http()
                .with_endpoint(otlp_endpoint)
                .with_timeout(std::time::Duration::from_secs(5))
        )
        .with_trace_config(
            trace::Config::default()
                .with_sampler(Sampler::AlwaysOn)
                .with_resource(Resource::new(vec![
                    KeyValue::new("service.name", service_name.to_string()),
                    KeyValue::new("service.version", env!("CARGO_PKG_VERSION").to_string()),
                    KeyValue::new("deployment.environment", std::env::var("ENV").unwrap_or_else(|_| "dev".to_string())),
                ]))
        )
        .install_batch(TokioCurrentThread)?;
    
    // 设置全局 Tracer
    global::set_tracer_provider(tracer.provider().unwrap().clone());
    
    // 创建 Tracing Subscriber
    let env_filter = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| EnvFilter::new("info"));
    
    tracing_subscriber::registry()
        .with(env_filter)
        .with(tracing_opentelemetry::layer().with_tracer(tracer))
        .with(tracing_subscriber::fmt::layer().with_target(false))
        .init();
    
    info!("Telemetry initialized for service: {}", service_name);
    Ok(())
}

/// 优雅关闭 telemetry
pub fn shutdown_telemetry() {
    info!("Shutting down telemetry...");
    global::shutdown_tracer_provider();
}

/// 健康检查端点
pub async fn health_check() -> &'static str {
    "healthy"
}

/// 就绪检查端点
pub async fn readiness_check() -> &'static str {
    "ready"
}
```

### 共享库 (shared/src/error.rs)

```rust
//! 统一的错误类型

use thiserror::Error;

#[derive(Error, Debug)]
pub enum ServiceError {
    #[error("Database error: {0}")]
    Database(#[from] sqlx::Error),
    
    #[error("Redis error: {0}")]
    Redis(#[from] redis::RedisError),
    
    #[error("gRPC error: {0}")]
    Grpc(#[from] tonic::Status),
    
    #[error("Not found: {0}")]
    NotFound(String),
    
    #[error("Invalid input: {0}")]
    InvalidInput(String),
    
    #[error("Internal error: {0}")]
    Internal(String),
}

pub type ServiceResult<T> = Result<T, ServiceError>;

impl From<ServiceError> for tonic::Status {
    fn from(err: ServiceError) -> Self {
        match err {
            ServiceError::NotFound(msg) => tonic::Status::not_found(msg),
            ServiceError::InvalidInput(msg) => tonic::Status::invalid_argument(msg),
            _ => tonic::Status::internal(err.to_string()),
        }
    }
}
```

---

### API Gateway (api-gateway/src/main.rs)

```rust
//! API Gateway - 统一入口

use axum::{
    extract::{Path, State},
    http::StatusCode,
    response::Json,
    routing::{get, post},
    Router,
};
use serde::{Deserialize, Serialize};
use shared::{ServiceError, ServiceResult};
use std::sync::Arc;
use tower_http::trace::TraceLayer;
use tracing::{debug, error, info, instrument};

mod grpc_clients;
use grpc_clients::{OrderClient, UserClient};

#[derive(Clone)]
struct AppState {
    user_client: Arc<UserClient>,
    order_client: Arc<OrderClient>,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 初始化 Telemetry
    shared::init_telemetry(
        "api-gateway",
        &std::env::var("OTLP_ENDPOINT").unwrap_or_else(|_| "http://localhost:4318/v1/traces".to_string()),
    ).await?;
    
    // 创建 gRPC 客户端
    let user_client = Arc::new(UserClient::new("http://user-service:50051").await?);
    let order_client = Arc::new(OrderClient::new("http://order-service:50052").await?);
    
    let state = AppState {
        user_client,
        order_client,
    };
    
    // 创建路由
    let app = Router::new()
        .route("/health", get(shared::health_check))
        .route("/ready", get(shared::readiness_check))
        .route("/api/users", post(create_user))
        .route("/api/users/:id", get(get_user))
        .route("/api/orders", post(create_order))
        .route("/api/orders/:id", get(get_order))
        .layer(TraceLayer::new_for_http())
        .with_state(state);
    
    // 启动服务器
    let listener = tokio::net::TcpListener::bind("0.0.0.0:8080").await?;
    info!("API Gateway listening on {}", listener.local_addr()?);
    
    // 优雅关闭
    let graceful = axum::serve(listener, app)
        .with_graceful_shutdown(shutdown_signal());
    
    graceful.await?;
    
    // 清理
    shared::shutdown_telemetry();
    Ok(())
}

/// 优雅关闭信号
async fn shutdown_signal() {
    tokio::signal::ctrl_c()
        .await
        .expect("Failed to install CTRL+C signal handler");
    info!("Shutdown signal received, starting graceful shutdown...");
}

// ===== API 处理器 =====

#[derive(Deserialize)]
struct CreateUserRequest {
    email: String,
    name: String,
}

#[derive(Serialize)]
struct UserResponse {
    id: String,
    email: String,
    name: String,
}

/// 创建用户
#[instrument(name = "api.create_user", skip(state, req))]
async fn create_user(
    State(state): State<AppState>,
    Json(req): Json<CreateUserRequest>,
) -> Result<Json<UserResponse>, StatusCode> {
    debug!("Creating user: email={}", req.email);
    
    match state.user_client.create_user(req.email, req.name).await {
        Ok(user) => {
            info!("User created: id={}", user.id);
            Ok(Json(UserResponse {
                id: user.id,
                email: user.email,
                name: user.name,
            }))
        }
        Err(e) => {
            error!("Failed to create user: {}", e);
            Err(StatusCode::INTERNAL_SERVER_ERROR)
        }
    }
}

/// 获取用户
#[instrument(name = "api.get_user", skip(state), fields(user.id = %id))]
async fn get_user(
    State(state): State<AppState>,
    Path(id): Path<String>,
) -> Result<Json<UserResponse>, StatusCode> {
    debug!("Fetching user: id={}", id);
    
    match state.user_client.get_user(&id).await {
        Ok(user) => {
            info!("User found: id={}", id);
            Ok(Json(UserResponse {
                id: user.id,
                email: user.email,
                name: user.name,
            }))
        }
        Err(ServiceError::NotFound(_)) => {
            debug!("User not found: id={}", id);
            Err(StatusCode::NOT_FOUND)
        }
        Err(e) => {
            error!("Failed to get user: {}", e);
            Err(StatusCode::INTERNAL_SERVER_ERROR)
        }
    }
}

#[derive(Deserialize)]
struct CreateOrderRequest {
    user_id: String,
    product_id: String,
    quantity: i32,
}

#[derive(Serialize)]
struct OrderResponse {
    id: String,
    user_id: String,
    product_id: String,
    quantity: i32,
    status: String,
}

/// 创建订单
#[instrument(name = "api.create_order", skip(state, req))]
async fn create_order(
    State(state): State<AppState>,
    Json(req): Json<CreateOrderRequest>,
) -> Result<Json<OrderResponse>, StatusCode> {
    debug!("Creating order: user_id={}, product_id={}", req.user_id, req.product_id);
    
    // 1. 验证用户存在
    if let Err(e) = state.user_client.get_user(&req.user_id).await {
        error!("User not found: {}", e);
        return Err(StatusCode::BAD_REQUEST);
    }
    
    // 2. 创建订单
    match state.order_client.create_order(req.user_id, req.product_id, req.quantity).await {
        Ok(order) => {
            info!("Order created: id={}", order.id);
            Ok(Json(OrderResponse {
                id: order.id,
                user_id: order.user_id,
                product_id: order.product_id,
                quantity: order.quantity,
                status: order.status,
            }))
        }
        Err(e) => {
            error!("Failed to create order: {}", e);
            Err(StatusCode::INTERNAL_SERVER_ERROR)
        }
    }
}

/// 获取订单
#[instrument(name = "api.get_order", skip(state), fields(order.id = %id))]
async fn get_order(
    State(state): State<AppState>,
    Path(id): Path<String>,
) -> Result<Json<OrderResponse>, StatusCode> {
    debug!("Fetching order: id={}", id);
    
    match state.order_client.get_order(&id).await {
        Ok(order) => {
            info!("Order found: id={}", id);
            Ok(Json(OrderResponse {
                id: order.id,
                user_id: order.user_id,
                product_id: order.product_id,
                quantity: order.quantity,
                status: order.status,
            }))
        }
        Err(ServiceError::NotFound(_)) => {
            debug!("Order not found: id={}", id);
            Err(StatusCode::NOT_FOUND)
        }
        Err(e) => {
            error!("Failed to get order: {}", e);
            Err(StatusCode::INTERNAL_SERVER_ERROR)
        }
    }
}
```

### API Gateway - gRPC 客户端 (api-gateway/src/grpc_clients.rs)

```rust
//! gRPC 客户端封装

use shared::{ServiceError, ServiceResult};
use tonic::transport::Channel;
use tracing::{debug, instrument};

// 引入生成的 protobuf 代码
pub mod user_proto {
    tonic::include_proto!("user");
}

pub mod order_proto {
    tonic::include_proto!("order");
}

use user_proto::{user_service_client::UserServiceClient, CreateUserRequest, GetUserRequest, User};
use order_proto::{order_service_client::OrderServiceClient, CreateOrderRequest, GetOrderRequest, Order};

/// User 服务客户端
pub struct UserClient {
    client: UserServiceClient<Channel>,
}

impl UserClient {
    /// 创建新的客户端
    pub async fn new(endpoint: &str) -> ServiceResult<Self> {
        let client = UserServiceClient::connect(endpoint.to_string())
            .await
            .map_err(|e| ServiceError::Grpc(e))?;
        Ok(Self { client })
    }
    
    /// 创建用户
    #[instrument(name = "grpc.user.create", skip(self))]
    pub async fn create_user(&self, email: String, name: String) -> ServiceResult<User> {
        debug!("Calling user service: create_user");
        
        let mut client = self.client.clone();
        let request = tonic::Request::new(CreateUserRequest { email, name });
        
        let response = client.create_user(request).await?;
        Ok(response.into_inner())
    }
    
    /// 获取用户
    #[instrument(name = "grpc.user.get", skip(self), fields(user.id = %id))]
    pub async fn get_user(&self, id: &str) -> ServiceResult<User> {
        debug!("Calling user service: get_user");
        
        let mut client = self.client.clone();
        let request = tonic::Request::new(GetUserRequest { id: id.to_string() });
        
        let response = client.get_user(request).await?;
        Ok(response.into_inner())
    }
}

/// Order 服务客户端
pub struct OrderClient {
    client: OrderServiceClient<Channel>,
}

impl OrderClient {
    /// 创建新的客户端
    pub async fn new(endpoint: &str) -> ServiceResult<Self> {
        let client = OrderServiceClient::connect(endpoint.to_string())
            .await
            .map_err(|e| ServiceError::Grpc(e))?;
        Ok(Self { client })
    }
    
    /// 创建订单
    #[instrument(name = "grpc.order.create", skip(self))]
    pub async fn create_order(
        &self,
        user_id: String,
        product_id: String,
        quantity: i32,
    ) -> ServiceResult<Order> {
        debug!("Calling order service: create_order");
        
        let mut client = self.client.clone();
        let request = tonic::Request::new(CreateOrderRequest {
            user_id,
            product_id,
            quantity,
        });
        
        let response = client.create_order(request).await?;
        Ok(response.into_inner())
    }
    
    /// 获取订单
    #[instrument(name = "grpc.order.get", skip(self), fields(order.id = %id))]
    pub async fn get_order(&self, id: &str) -> ServiceResult<Order> {
        debug!("Calling order service: get_order");
        
        let mut client = self.client.clone();
        let request = tonic::Request::new(GetOrderRequest { id: id.to_string() });
        
        let response = client.get_order(request).await?;
        Ok(response.into_inner())
    }
}
```

---

### User Service (user-service/proto/user.proto)

```protobuf
syntax = "proto3";

package user;

service UserService {
  rpc CreateUser(CreateUserRequest) returns (User);
  rpc GetUser(GetUserRequest) returns (User);
}

message User {
  string id = 1;
  string email = 2;
  string name = 3;
  string created_at = 4;
}

message CreateUserRequest {
  string email = 1;
  string name = 2;
}

message GetUserRequest {
  string id = 1;
}
```

### User Service (user-service/src/main.rs)

```rust
//! User Service - 用户管理

use shared::{ServiceError, ServiceResult};
use sqlx::PgPool;
use tonic::{transport::Server, Request, Response, Status};
use tracing::{debug, error, info, instrument};
use uuid::Uuid;

pub mod user {
    tonic::include_proto!("user");
}

use user::{
    user_service_server::{UserService, UserServiceServer},
    CreateUserRequest, GetUserRequest, User,
};

#[derive(Clone)]
pub struct UserServiceImpl {
    pool: PgPool,
}

impl UserServiceImpl {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }
}

#[tonic::async_trait]
impl UserService for UserServiceImpl {
    #[instrument(name = "grpc.user.create_user", skip(self, request))]
    async fn create_user(
        &self,
        request: Request<CreateUserRequest>,
    ) -> Result<Response<User>, Status> {
        let req = request.into_inner();
        debug!("Creating user: email={}", req.email);
        
        let id = Uuid::new_v4().to_string();
        let now = chrono::Utc::now().to_rfc3339();
        
        // 插入数据库
        sqlx::query!(
            r#"
            INSERT INTO users (id, email, name, created_at)
            VALUES ($1, $2, $3, $4)
            "#,
            id,
            req.email,
            req.name,
            chrono::Utc::now().naive_utc(),
        )
        .execute(&self.pool)
        .await
        .map_err(|e| {
            error!("Database error: {}", e);
            Status::internal(format!("Database error: {}", e))
        })?;
        
        info!("User created: id={}", id);
        
        Ok(Response::new(User {
            id,
            email: req.email,
            name: req.name,
            created_at: now,
        }))
    }
    
    #[instrument(name = "grpc.user.get_user", skip(self, request), fields(user.id = %request.get_ref().id))]
    async fn get_user(
        &self,
        request: Request<GetUserRequest>,
    ) -> Result<Response<User>, Status> {
        let req = request.into_inner();
        debug!("Fetching user: id={}", req.id);
        
        let user = sqlx::query!(
            r#"
            SELECT id, email, name, created_at
            FROM users
            WHERE id = $1
            "#,
            req.id
        )
        .fetch_optional(&self.pool)
        .await
        .map_err(|e| {
            error!("Database error: {}", e);
            Status::internal(format!("Database error: {}", e))
        })?
        .ok_or_else(|| {
            debug!("User not found: id={}", req.id);
            Status::not_found("User not found")
        })?;
        
        info!("User found: id={}", req.id);
        
        Ok(Response::new(User {
            id: user.id,
            email: user.email,
            name: user.name,
            created_at: user.created_at.to_string(),
        }))
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 初始化 Telemetry
    shared::init_telemetry(
        "user-service",
        &std::env::var("OTLP_ENDPOINT").unwrap_or_else(|_| "http://localhost:4318/v1/traces".to_string()),
    ).await?;
    
    // 连接数据库
    let database_url = std::env::var("DATABASE_URL")
        .unwrap_or_else(|_| "postgresql://user:pass@localhost/users".to_string());
    
    let pool = PgPool::connect(&database_url).await?;
    
    // 运行迁移
    sqlx::migrate!("./migrations").run(&pool).await?;
    
    // 创建 gRPC 服务
    let service = UserServiceImpl::new(pool);
    let addr = "0.0.0.0:50051".parse()?;
    
    info!("User Service listening on {}", addr);
    
    // 启动服务器
    Server::builder()
        .add_service(UserServiceServer::new(service))
        .serve_with_shutdown(addr, shutdown_signal())
        .await?;
    
    // 清理
    shared::shutdown_telemetry();
    Ok(())
}

async fn shutdown_signal() {
    tokio::signal::ctrl_c()
        .await
        .expect("Failed to install CTRL+C signal handler");
    info!("Shutdown signal received...");
}
```

---

### Order Service (order-service/proto/order.proto)

```protobuf
syntax = "proto3";

package order;

service OrderService {
  rpc CreateOrder(CreateOrderRequest) returns (Order);
  rpc GetOrder(GetOrderRequest) returns (Order);
}

message Order {
  string id = 1;
  string user_id = 2;
  string product_id = 3;
  int32 quantity = 4;
  string status = 5;
  string created_at = 6;
}

message CreateOrderRequest {
  string user_id = 1;
  string product_id = 2;
  int32 quantity = 3;
}

message GetOrderRequest {
  string id = 1;
}
```

### Order Service (order-service/src/main.rs)

```rust
//! Order Service - 订单管理

use shared::{ServiceError, ServiceResult};
use sqlx::PgPool;
use tonic::{transport::Server, Request, Response, Status};
use tracing::{debug, error, info, instrument};
use uuid::Uuid;

pub mod order {
    tonic::include_proto!("order");
}

use order::{
    order_service_server::{OrderService, OrderServiceServer},
    CreateOrderRequest, GetOrderRequest, Order,
};

#[derive(Clone)]
pub struct OrderServiceImpl {
    pool: PgPool,
}

impl OrderServiceImpl {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }
}

#[tonic::async_trait]
impl OrderService for OrderServiceImpl {
    #[instrument(name = "grpc.order.create_order", skip(self, request))]
    async fn create_order(
        &self,
        request: Request<CreateOrderRequest>,
    ) -> Result<Response<Order>, Status> {
        let req = request.into_inner();
        debug!("Creating order: user_id={}, product_id={}", req.user_id, req.product_id);
        
        let id = Uuid::new_v4().to_string();
        let status = "pending".to_string();
        let now = chrono::Utc::now().to_rfc3339();
        
        // 插入数据库
        sqlx::query!(
            r#"
            INSERT INTO orders (id, user_id, product_id, quantity, status, created_at)
            VALUES ($1, $2, $3, $4, $5, $6)
            "#,
            id,
            req.user_id,
            req.product_id,
            req.quantity,
            status,
            chrono::Utc::now().naive_utc(),
        )
        .execute(&self.pool)
        .await
        .map_err(|e| {
            error!("Database error: {}", e);
            Status::internal(format!("Database error: {}", e))
        })?;
        
        info!("Order created: id={}", id);
        
        Ok(Response::new(Order {
            id,
            user_id: req.user_id,
            product_id: req.product_id,
            quantity: req.quantity,
            status,
            created_at: now,
        }))
    }
    
    #[instrument(name = "grpc.order.get_order", skip(self, request), fields(order.id = %request.get_ref().id))]
    async fn get_order(
        &self,
        request: Request<GetOrderRequest>,
    ) -> Result<Response<Order>, Status> {
        let req = request.into_inner();
        debug!("Fetching order: id={}", req.id);
        
        let order = sqlx::query!(
            r#"
            SELECT id, user_id, product_id, quantity, status, created_at
            FROM orders
            WHERE id = $1
            "#,
            req.id
        )
        .fetch_optional(&self.pool)
        .await
        .map_err(|e| {
            error!("Database error: {}", e);
            Status::internal(format!("Database error: {}", e))
        })?
        .ok_or_else(|| {
            debug!("Order not found: id={}", req.id);
            Status::not_found("Order not found")
        })?;
        
        info!("Order found: id={}", req.id);
        
        Ok(Response::new(Order {
            id: order.id,
            user_id: order.user_id,
            product_id: order.product_id,
            quantity: order.quantity,
            status: order.status,
            created_at: order.created_at.to_string(),
        }))
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 初始化 Telemetry
    shared::init_telemetry(
        "order-service",
        &std::env::var("OTLP_ENDPOINT").unwrap_or_else(|_| "http://localhost:4318/v1/traces".to_string()),
    ).await?;
    
    // 连接数据库
    let database_url = std::env::var("DATABASE_URL")
        .unwrap_or_else(|_| "postgresql://user:pass@localhost/orders".to_string());
    
    let pool = PgPool::connect(&database_url).await?;
    
    // 运行迁移
    sqlx::migrate!("./migrations").run(&pool).await?;
    
    // 创建 gRPC 服务
    let service = OrderServiceImpl::new(pool);
    let addr = "0.0.0.0:50052".parse()?;
    
    info!("Order Service listening on {}", addr);
    
    // 启动服务器
    Server::builder()
        .add_service(OrderServiceServer::new(service))
        .serve_with_shutdown(addr, shutdown_signal())
        .await?;
    
    // 清理
    shared::shutdown_telemetry();
    Ok(())
}

async fn shutdown_signal() {
    tokio::signal::ctrl_c()
        .await
        .expect("Failed to install CTRL+C signal handler");
    info!("Shutdown signal received...");
}
```

---

## 部署配置

### docker-compose.yml

```yaml
version: '3.8'

services:
  # PostgreSQL
  postgres:
    image: postgres:17
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
      POSTGRES_DB: microservices
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U user"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Redis
  redis:
    image: redis:7.4-alpine
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  # OTLP Collector
  otel-collector:
    image: otel/opentelemetry-collector-contrib:0.112.0
    command: ["--config=/etc/otel-collector-config.yaml"]
    volumes:
      - ./otel-collector-config.yaml:/etc/otel-collector-config.yaml
    ports:
      - "4317:4317"   # OTLP gRPC
      - "4318:4318"   # OTLP HTTP
      - "8888:8888"   # Prometheus metrics
      - "8889:8889"   # Prometheus exporter
    depends_on:
      - jaeger

  # Jaeger
  jaeger:
    image: jaegertracing/all-in-one:1.64
    ports:
      - "16686:16686"  # Jaeger UI
      - "14268:14268"  # Jaeger collector HTTP
    environment:
      - COLLECTOR_OTLP_ENABLED=true

  # Prometheus
  prometheus:
    image: prom/prometheus:v3.1.0
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
    ports:
      - "9090:9090"

  # Grafana
  grafana:
    image: grafana/grafana:11.4.0
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_USER=admin
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - grafana_data:/var/lib/grafana

  # User Service
  user-service:
    build:
      context: .
      dockerfile: user-service/Dockerfile
    environment:
      - DATABASE_URL=postgresql://user:pass@postgres/microservices
      - OTLP_ENDPOINT=http://otel-collector:4318/v1/traces
      - RUST_LOG=info
    ports:
      - "50051:50051"
    depends_on:
      postgres:
        condition: service_healthy
      otel-collector:
        condition: service_started

  # Order Service
  order-service:
    build:
      context: .
      dockerfile: order-service/Dockerfile
    environment:
      - DATABASE_URL=postgresql://user:pass@postgres/microservices
      - OTLP_ENDPOINT=http://otel-collector:4318/v1/traces
      - RUST_LOG=info
    ports:
      - "50052:50052"
    depends_on:
      postgres:
        condition: service_healthy
      otel-collector:
        condition: service_started

  # API Gateway
  api-gateway:
    build:
      context: .
      dockerfile: api-gateway/Dockerfile
    environment:
      - USER_SERVICE_URL=http://user-service:50051
      - ORDER_SERVICE_URL=http://order-service:50052
      - OTLP_ENDPOINT=http://otel-collector:4318/v1/traces
      - RUST_LOG=info
    ports:
      - "8080:8080"
    depends_on:
      - user-service
      - order-service
      - otel-collector

volumes:
  postgres_data:
  grafana_data:
```

### otel-collector-config.yaml

```yaml
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317
      http:
        endpoint: 0.0.0.0:4318

processors:
  batch:
    timeout: 1s
    send_batch_size: 1024

exporters:
  jaeger:
    endpoint: jaeger:14250
    tls:
      insecure: true
  
  prometheus:
    endpoint: "0.0.0.0:8889"
  
  logging:
    loglevel: debug

service:
  pipelines:
    traces:
      receivers: [otlp]
      processors: [batch]
      exporters: [jaeger, logging]
    
    metrics:
      receivers: [otlp]
      processors: [batch]
      exporters: [prometheus, logging]
```

---

## 测试验证

### 1. 启动服务

```bash
# 构建并启动所有服务
docker-compose up --build

# 检查服务状态
docker-compose ps

# 查看日志
docker-compose logs -f api-gateway
```

### 2. API 测试

```bash
# 创建用户
curl -X POST http://localhost:8080/api/users \
  -H "Content-Type: application/json" \
  -d '{"email":"alice@example.com","name":"Alice"}'

# 响应: {"id":"uuid","email":"alice@example.com","name":"Alice"}

# 获取用户
curl http://localhost:8080/api/users/{user_id}

# 创建订单
curl -X POST http://localhost:8080/api/orders \
  -H "Content-Type: application/json" \
  -d '{"user_id":"uuid","product_id":"prod-123","quantity":2}'

# 获取订单
curl http://localhost:8080/api/orders/{order_id}
```

### 3. 查看追踪

- Jaeger UI: <http://localhost:16686>
- Grafana: <http://localhost:3000>
- Prometheus: <http://localhost:9090>

---

## 最佳实践

### ✅ 架构设计

1. **微服务拆分**: 按业务领域拆分服务
2. **API Gateway**: 统一入口,负载均衡
3. **服务间通信**: gRPC (高性能) 或 HTTP/JSON
4. **数据库独立**: 每个服务独立数据库

### ⚡ 性能优化

1. **连接池**: 数据库和 Redis 连接池
2. **批处理**: OTLP 数据批量导出
3. **异步优先**: 使用 Tokio 异步运行时
4. **零拷贝**: Bytes 零拷贝传输

### 🔍 可观测性

1. **完整追踪**: Traces, Metrics, Logs
2. **上下文传播**: W3C TraceContext
3. **结构化日志**: tracing-subscriber
4. **健康检查**: /health 和 /ready 端点

### 🛡️ 安全和可靠性

1. **优雅关闭**: 信号处理
2. **错误处理**: 统一错误类型
3. **TLS/mTLS**: gRPC TLS 加密
4. **限流和超时**: tower middleware

---

## 参考资源

### 📚 官方文档

- [Axum Documentation](https://docs.rs/axum/latest/axum/)
- [Tonic Documentation](https://docs.rs/tonic/latest/tonic/)
- [OpenTelemetry Rust](https://docs.rs/opentelemetry/latest/opentelemetry/)

### 🔧 示例代码

- [本项目 GitHub](https://github.com/example/rust-microservices-otlp)

---

**文档版本**: v1.0.0  
**最后更新**: 2025年10月8日  
**作者**: AI Assistant  
**许可证**: MIT OR Apache-2.0

[🏠 返回目录](../README.md)
