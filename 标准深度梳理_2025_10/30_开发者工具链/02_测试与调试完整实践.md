# æµ‹è¯•ä¸è°ƒè¯•å®Œæ•´å®è·µ

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ8æ—¥  
> **Rustç‰ˆæœ¬**: 1.90+  
> **OpenTelemetryç‰ˆæœ¬**: 0.31.0+

---

## ğŸ“‹ ç›®å½•

- [æµ‹è¯•ä¸è°ƒè¯•å®Œæ•´å®è·µ](#æµ‹è¯•ä¸è°ƒè¯•å®Œæ•´å®è·µ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
    - [æµ‹è¯•é‡‘å­—å¡”](#æµ‹è¯•é‡‘å­—å¡”)
    - [OpenTelemetryæµ‹è¯•ç­–ç•¥](#opentelemetryæµ‹è¯•ç­–ç•¥)
  - [å•å…ƒæµ‹è¯•](#å•å…ƒæµ‹è¯•)
    - [Mock Exporter](#mock-exporter)
    - [æµ‹è¯•Spanåˆ›å»ºå’Œå±æ€§](#æµ‹è¯•spanåˆ›å»ºå’Œå±æ€§)
    - [æµ‹è¯•é‡‡æ ·å™¨](#æµ‹è¯•é‡‡æ ·å™¨)
    - [æµ‹è¯•Propagator](#æµ‹è¯•propagator)
  - [é›†æˆæµ‹è¯•](#é›†æˆæµ‹è¯•)
    - [æµ‹è¯•HTTPæœåŠ¡è¿½è¸ª](#æµ‹è¯•httpæœåŠ¡è¿½è¸ª)
    - [æµ‹è¯•gRPCè¿½è¸ª](#æµ‹è¯•grpcè¿½è¸ª)
    - [æµ‹è¯•æ•°æ®åº“è¿½è¸ª](#æµ‹è¯•æ•°æ®åº“è¿½è¸ª)
  - [ç«¯åˆ°ç«¯æµ‹è¯•](#ç«¯åˆ°ç«¯æµ‹è¯•)
    - [E2Eæµ‹è¯•æ¡†æ¶](#e2eæµ‹è¯•æ¡†æ¶)
  - [æ€§èƒ½æµ‹è¯•](#æ€§èƒ½æµ‹è¯•)
    - [Benchmarkæ¡†æ¶](#benchmarkæ¡†æ¶)
    - [æµ‹è¯•é‡‡æ ·å¼€é”€](#æµ‹è¯•é‡‡æ ·å¼€é”€)
  - [è´Ÿè½½æµ‹è¯•](#è´Ÿè½½æµ‹è¯•)
    - [ä½¿ç”¨wrkè¿›è¡ŒHTTPè´Ÿè½½æµ‹è¯•](#ä½¿ç”¨wrkè¿›è¡Œhttpè´Ÿè½½æµ‹è¯•)
    - [ä½¿ç”¨k6è¿›è¡Œè´Ÿè½½æµ‹è¯•](#ä½¿ç”¨k6è¿›è¡Œè´Ÿè½½æµ‹è¯•)
  - [Chaos Engineering](#chaos-engineering)
    - [ä½¿ç”¨Toxiproxyæ¨¡æ‹Ÿç½‘ç»œæ•…éšœ](#ä½¿ç”¨toxiproxyæ¨¡æ‹Ÿç½‘ç»œæ•…éšœ)
    - [æ¨¡æ‹ŸCollectoræ•…éšœ](#æ¨¡æ‹Ÿcollectoræ•…éšœ)
  - [è°ƒè¯•å·¥å…·](#è°ƒè¯•å·¥å…·)
    - [Traceå¯è§†åŒ–è°ƒè¯•](#traceå¯è§†åŒ–è°ƒè¯•)
    - [æ€§èƒ½ç«ç„°å›¾](#æ€§èƒ½ç«ç„°å›¾)
    - [å†…å­˜åˆ†æ](#å†…å­˜åˆ†æ)
  - [æ€»ç»“](#æ€»ç»“)
    - [æµ‹è¯•æ£€æŸ¥æ¸…å•](#æµ‹è¯•æ£€æŸ¥æ¸…å•)
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)

---

## æ¦‚è¿°

### æµ‹è¯•é‡‘å­—å¡”

```text
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚   E2E Tests     â”‚  (å°‘é‡ï¼Œæ…¢ï¼Œæ˜‚è´µ)
      â”‚      5%         â”‚
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
      â”‚Integration Testsâ”‚  (ä¸­ç­‰æ•°é‡ï¼Œä¸­é€Ÿ)
      â”‚      20%        â”‚
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
      â”‚  Unit Tests     â”‚  (å¤§é‡ï¼Œå¿«ï¼Œä¾¿å®œ)
      â”‚      75%        â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### OpenTelemetryæµ‹è¯•ç­–ç•¥

```text
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘         OpenTelemetryæµ‹è¯•è¦†ç›–èŒƒå›´                     â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  1. Trace Contextä¼ æ’­æµ‹è¯•                             â•‘
â•‘  2. Spanå±æ€§å’ŒEventsæµ‹è¯•                              â•‘
â•‘  3. é‡‡æ ·å™¨è¡Œä¸ºæµ‹è¯•                                    â•‘
â•‘  4. Exporteræ­£ç¡®æ€§æµ‹è¯•                                â•‘
â•‘  5. é”™è¯¯å¤„ç†å’Œé™çº§æµ‹è¯•                                â•‘
â•‘  6. æ€§èƒ½å’Œå¼€é”€æµ‹è¯•                                    â•‘
â•‘  7. å¤šçº¿ç¨‹/å¼‚æ­¥å®‰å…¨æ€§æµ‹è¯•                             â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

## å•å…ƒæµ‹è¯•

### Mock Exporter

```rust
use opentelemetry::trace::{SpanContext, SpanData, SpanExporter, TraceResult};
use std::sync::{Arc, Mutex};

/// Mock Exporterç”¨äºæµ‹è¯•
#[derive(Clone)]
pub struct MockExporter {
    spans: Arc<Mutex<Vec<SpanData>>>,
}

impl MockExporter {
    pub fn new() -> Self {
        Self {
            spans: Arc::new(Mutex::new(Vec::new())),
        }
    }
    
    /// è·å–å·²å¯¼å‡ºçš„spans
    pub fn exported_spans(&self) -> Vec<SpanData> {
        self.spans.lock().unwrap().clone()
    }
    
    /// æ¸…ç©ºå·²å¯¼å‡ºçš„spans
    pub fn clear(&self) {
        self.spans.lock().unwrap().clear();
    }
    
    /// è·å–spansæ•°é‡
    pub fn len(&self) -> usize {
        self.spans.lock().unwrap().len()
    }
}

#[async_trait::async_trait]
impl SpanExporter for MockExporter {
    async fn export(&mut self, batch: Vec<SpanData>) -> TraceResult<()> {
        self.spans.lock().unwrap().extend(batch);
        Ok(())
    }
}
```

### æµ‹è¯•Spanåˆ›å»ºå’Œå±æ€§

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use opentelemetry::{
        global,
        trace::{Span, Tracer, TraceContextExt},
        KeyValue,
    };
    use opentelemetry_sdk::trace::{TracerProvider, Config};
    
    fn setup_test_provider() -> (TracerProvider, MockExporter) {
        let exporter = MockExporter::new();
        let exporter_clone = exporter.clone();
        
        let provider = TracerProvider::builder()
            .with_simple_exporter(exporter)
            .build();
        
        global::set_tracer_provider(provider.clone());
        
        (provider, exporter_clone)
    }
    
    #[tokio::test]
    async fn test_span_creation() {
        let (provider, exporter) = setup_test_provider();
        
        let tracer = global::tracer("test");
        let mut span = tracer.start("test_span");
        
        span.set_attribute(KeyValue::new("key", "value"));
        span.add_event("test_event", vec![KeyValue::new("event_key", "event_value")]);
        span.end();
        
        // å¼ºåˆ¶flush
        provider.force_flush();
        
        // éªŒè¯
        let spans = exporter.exported_spans();
        assert_eq!(spans.len(), 1);
        
        let exported_span = &spans[0];
        assert_eq!(exported_span.name, "test_span");
        
        // éªŒè¯å±æ€§
        let attrs: Vec<_> = exported_span.attributes.iter().collect();
        assert!(attrs.iter().any(|kv| kv.key.as_str() == "key" && kv.value.as_str() == "value"));
        
        // éªŒè¯äº‹ä»¶
        assert_eq!(exported_span.events.len(), 1);
        assert_eq!(exported_span.events[0].name, "test_event");
    }
    
    #[tokio::test]
    async fn test_span_context_propagation() {
        let (provider, exporter) = setup_test_provider();
        
        let tracer = global::tracer("test");
        
        // åˆ›å»ºçˆ¶span
        let parent_span = tracer.start("parent");
        let parent_cx = opentelemetry::Context::current_with_span(parent_span);
        
        // åˆ›å»ºå­span
        let _guard = parent_cx.attach();
        let child_span = tracer
            .span_builder("child")
            .start(&tracer);
        child_span.end();
        
        drop(_guard);
        parent_cx.span().end();
        
        provider.force_flush();
        
        // éªŒè¯çˆ¶å­å…³ç³»
        let spans = exporter.exported_spans();
        assert_eq!(spans.len(), 2);
        
        let parent = spans.iter().find(|s| s.name == "parent").unwrap();
        let child = spans.iter().find(|s| s.name == "child").unwrap();
        
        assert_eq!(child.parent_span_id, parent.span_context.span_id());
        assert_eq!(child.span_context.trace_id(), parent.span_context.trace_id());
    }
}
```

### æµ‹è¯•é‡‡æ ·å™¨

```rust
#[cfg(test)]
mod sampler_tests {
    use opentelemetry_sdk::trace::{Sampler, ShouldSample};
    use opentelemetry::trace::{SpanKind, TraceId};
    use opentelemetry::KeyValue;
    
    #[test]
    fn test_always_on_sampler() {
        let sampler = Sampler::AlwaysOn;
        
        let result = sampler.should_sample(
            None,
            TraceId::from_u128(1),
            "test_span",
            &SpanKind::Internal,
            &[],
            &[],
        );
        
        assert!(matches!(
            result.decision,
            opentelemetry_sdk::trace::SamplingDecision::RecordAndSample
        ));
    }
    
    #[test]
    fn test_traceid_ratio_sampler() {
        let sampler = Sampler::TraceIdRatioBased(0.5); // 50%é‡‡æ ·ç‡
        
        let mut sampled_count = 0;
        let total = 1000;
        
        for i in 0..total {
            let trace_id = TraceId::from_u128(i);
            let result = sampler.should_sample(
                None,
                trace_id,
                "test",
                &SpanKind::Internal,
                &[],
                &[],
            );
            
            if matches!(
                result.decision,
                opentelemetry_sdk::trace::SamplingDecision::RecordAndSample
            ) {
                sampled_count += 1;
            }
        }
        
        // å…è®¸5%è¯¯å·®
        let ratio = sampled_count as f64 / total as f64;
        assert!((ratio - 0.5).abs() < 0.05, "Sampling ratio: {}", ratio);
    }
}
```

### æµ‹è¯•Propagator

```rust
#[cfg(test)]
mod propagator_tests {
    use opentelemetry::{
        propagation::{Injector, Extractor, TextMapPropagator},
        trace::{TraceId, SpanId, TraceFlags, TraceState},
        Context,
    };
    use opentelemetry_sdk::propagation::TraceContextPropagator;
    use std::collections::HashMap;
    
    #[test]
    fn test_w3c_trace_context_inject() {
        let propagator = TraceContextPropagator::new();
        
        let trace_id = TraceId::from_hex("4bf92f3577b34da6a3ce929d0e0e4736").unwrap();
        let span_id = SpanId::from_hex("00f067aa0ba902b7").unwrap();
        
        let span_context = opentelemetry::trace::SpanContext::new(
            trace_id,
            span_id,
            TraceFlags::SAMPLED,
            false,
            TraceState::default(),
        );
        
        let cx = Context::current().with_remote_span_context(span_context);
        
        let mut headers = HashMap::new();
        propagator.inject_context(&cx, &mut headers);
        
        assert_eq!(
            headers.get("traceparent").unwrap(),
            "00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01"
        );
    }
    
    #[test]
    fn test_w3c_trace_context_extract() {
        let propagator = TraceContextPropagator::new();
        
        let mut headers = HashMap::new();
        headers.insert(
            "traceparent".to_string(),
            "00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01".to_string(),
        );
        
        let cx = propagator.extract(&headers);
        let span_context = cx.span().span_context();
        
        assert_eq!(
            span_context.trace_id().to_string(),
            "4bf92f3577b34da6a3ce929d0e0e4736"
        );
        assert_eq!(
            span_context.span_id().to_string(),
            "00f067aa0ba902b7"
        );
        assert!(span_context.is_sampled());
    }
}
```

---

## é›†æˆæµ‹è¯•

### æµ‹è¯•HTTPæœåŠ¡è¿½è¸ª

```rust
// tests/integration_test.rs
use axum::{
    routing::get,
    Router,
};
use opentelemetry::{global, KeyValue};
use opentelemetry_sdk::trace::TracerProvider;

async fn setup_test_server() -> (String, MockExporter) {
    let exporter = MockExporter::new();
    let exporter_clone = exporter.clone();
    
    let provider = TracerProvider::builder()
        .with_simple_exporter(exporter)
        .build();
    
    global::set_tracer_provider(provider);
    
    let app = Router::new()
        .route("/test", get(|| async { "OK" }))
        .layer(/* trace middleware */);
    
    let listener = tokio::net::TcpListener::bind("127.0.0.1:0").await.unwrap();
    let addr = listener.local_addr().unwrap();
    
    tokio::spawn(async move {
        axum::serve(listener, app).await.unwrap();
    });
    
    (format!("http://{}", addr), exporter_clone)
}

#[tokio::test]
async fn test_http_tracing_integration() {
    let (base_url, exporter) = setup_test_server().await;
    
    let client = reqwest::Client::new();
    let response = client.get(format!("{}/test", base_url))
        .send()
        .await
        .unwrap();
    
    assert_eq!(response.status(), 200);
    
    // ç­‰å¾…spanå¯¼å‡º
    tokio::time::sleep(std::time::Duration::from_millis(100)).await;
    
    let spans = exporter.exported_spans();
    assert!(!spans.is_empty());
    
    // éªŒè¯HTTP attributes
    let span = &spans[0];
    assert!(span.attributes.iter().any(|kv| {
        kv.key.as_str() == "http.method" && kv.value.as_str() == "GET"
    }));
}
```

### æµ‹è¯•gRPCè¿½è¸ª

```rust
#[cfg(test)]
mod grpc_tests {
    use tonic::transport::Server;
    use tokio::sync::oneshot;
    
    #[tokio::test]
    async fn test_grpc_tracing() {
        // å¯åŠ¨æµ‹è¯•gRPCæœåŠ¡å™¨
        let (tx, rx) = oneshot::channel();
        
        tokio::spawn(async move {
            let addr = "127.0.0.1:50051".parse().unwrap();
            tx.send(()).unwrap();
            
            Server::builder()
                .add_service(/* your service */)
                .serve(addr)
                .await
                .unwrap();
        });
        
        // ç­‰å¾…æœåŠ¡å™¨å¯åŠ¨
        rx.await.unwrap();
        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
        
        // åˆ›å»ºå®¢æˆ·ç«¯å¹¶å‘èµ·è¯·æ±‚
        let mut client = YourClient::connect("http://127.0.0.1:50051")
            .await
            .unwrap();
        
        let response = client.your_method(Request::new(/* ... */))
            .await
            .unwrap();
        
        // éªŒè¯trace
        // ...
    }
}
```

### æµ‹è¯•æ•°æ®åº“è¿½è¸ª

```rust
#[cfg(test)]
mod database_tests {
    use sqlx::{PgPool, Executor};
    use testcontainers::{clients, images};
    
    #[tokio::test]
    async fn test_database_tracing() {
        // å¯åŠ¨æµ‹è¯•æ•°æ®åº“å®¹å™¨
        let docker = clients::Cli::default();
        let postgres = docker.run(images::postgres::Postgres::default());
        let port = postgres.get_host_port_ipv4(5432);
        
        let database_url = format!(
            "postgres://postgres:postgres@localhost:{}/postgres",
            port
        );
        
        let pool = PgPool::connect(&database_url).await.unwrap();
        
        // æ‰§è¡ŒæŸ¥è¯¢ï¼ˆåº”è¯¥è¢«è¿½è¸ªï¼‰
        let tracer = global::tracer("test");
        let _span = tracer.start("test_query");
        
        let result: (i32,) = sqlx::query_as("SELECT 1 AS value")
            .fetch_one(&pool)
            .await
            .unwrap();
        
        assert_eq!(result.0, 1);
        
        // éªŒè¯æ•°æ®åº“spanè¢«åˆ›å»º
        // ...
    }
}
```

---

## ç«¯åˆ°ç«¯æµ‹è¯•

### E2Eæµ‹è¯•æ¡†æ¶

```rust
// tests/e2e/mod.rs
use std::collections::HashMap;
use std::time::Duration;
use tokio::process::Command;

pub struct E2ETestEnvironment {
    services: HashMap<String, tokio::process::Child>,
}

impl E2ETestEnvironment {
    pub async fn new() -> Self {
        let mut env = Self {
            services: HashMap::new(),
        };
        
        // å¯åŠ¨OTLP Collector
        env.start_collector().await;
        
        // å¯åŠ¨Jaeger
        env.start_jaeger().await;
        
        // ç­‰å¾…æœåŠ¡å°±ç»ª
        tokio::time::sleep(Duration::from_secs(5)).await;
        
        env
    }
    
    async fn start_collector(&mut self) {
        let child = Command::new("docker")
            .args(&[
                "run",
                "--rm",
                "-p", "4317:4317",
                "-v", "./otel-config.yaml:/etc/otel/config.yaml",
                "otel/opentelemetry-collector-contrib:latest",
                "--config=/etc/otel/config.yaml",
            ])
            .spawn()
            .expect("Failed to start OTLP Collector");
        
        self.services.insert("collector".to_string(), child);
    }
    
    async fn start_jaeger(&mut self) {
        let child = Command::new("docker")
            .args(&[
                "run",
                "--rm",
                "-p", "16686:16686",
                "jaegertracing/all-in-one:latest",
            ])
            .spawn()
            .expect("Failed to start Jaeger");
        
        self.services.insert("jaeger".to_string(), child);
    }
    
    pub async fn query_jaeger_traces(&self, service_name: &str) -> Vec<JaegerTrace> {
        let client = reqwest::Client::new();
        let response = client
            .get(format!(
                "http://localhost:16686/api/traces?service={}",
                service_name
            ))
            .send()
            .await
            .unwrap();
        
        response.json().await.unwrap()
    }
}

impl Drop for E2ETestEnvironment {
    fn drop(&mut self) {
        for (name, child) in self.services.iter_mut() {
            println!("Stopping {}...", name);
            let _ = child.kill();
        }
    }
}

#[tokio::test]
async fn test_end_to_end_tracing() {
    let env = E2ETestEnvironment::new().await;
    
    // å¯åŠ¨ä½ çš„åº”ç”¨
    let app = tokio::spawn(async {
        your_app_main().await.unwrap();
    });
    
    tokio::time::sleep(Duration::from_secs(2)).await;
    
    // å‘èµ·æµ‹è¯•è¯·æ±‚
    let client = reqwest::Client::new();
    let response = client
        .get("http://localhost:8080/api/test")
        .send()
        .await
        .unwrap();
    
    assert_eq!(response.status(), 200);
    
    // ç­‰å¾…traceå¯¼å‡º
    tokio::time::sleep(Duration::from_secs(3)).await;
    
    // éªŒè¯Jaegerä¸­çš„trace
    let traces = env.query_jaeger_traces("your-service").await;
    assert!(!traces.is_empty(), "No traces found in Jaeger");
    
    let trace = &traces[0];
    assert!(trace.spans.iter().any(|s| s.operation_name == "http_request"));
    
    // åœæ­¢åº”ç”¨
    app.abort();
}
```

---

## æ€§èƒ½æµ‹è¯•

### Benchmarkæ¡†æ¶

```rust
// benches/tracing_overhead.rs
use criterion::{black_box, criterion_group, criterion_main, Criterion};
use opentelemetry::{global, trace::Tracer, KeyValue};

fn baseline_without_tracing(c: &mut Criterion) {
    c.bench_function("baseline", |b| {
        b.iter(|| {
            // ä¸šåŠ¡é€»è¾‘
            let result = expensive_computation(black_box(42));
            black_box(result);
        });
    });
}

fn with_tracing(c: &mut Criterion) {
    // åˆå§‹åŒ–OpenTelemetryï¼ˆä½¿ç”¨NoopExporterï¼‰
    let provider = TracerProvider::builder()
        .with_simple_exporter(NoopExporter)
        .build();
    
    global::set_tracer_provider(provider);
    
    c.bench_function("with_tracing", |b| {
        b.iter(|| {
            let tracer = global::tracer("bench");
            let mut span = tracer.start("benchmark_span");
            
            span.set_attribute(KeyValue::new("test", "value"));
            
            let result = expensive_computation(black_box(42));
            
            span.end();
            black_box(result);
        });
    });
}

fn with_tracing_and_export(c: &mut Criterion) {
    let provider = TracerProvider::builder()
        .with_batch_exporter(MockExporter::new(), opentelemetry_sdk::runtime::Tokio)
        .build();
    
    global::set_tracer_provider(provider);
    
    c.bench_function("with_export", |b| {
        b.iter(|| {
            let tracer = global::tracer("bench");
            let mut span = tracer.start("benchmark_span");
            
            span.set_attribute(KeyValue::new("test", "value"));
            
            let result = expensive_computation(black_box(42));
            
            span.end();
            black_box(result);
        });
    });
}

fn expensive_computation(n: i32) -> i32 {
    (0..n).map(|x| x * 2).sum()
}

criterion_group!(
    benches,
    baseline_without_tracing,
    with_tracing,
    with_tracing_and_export
);
criterion_main!(benches);
```

è¿è¡Œbenchmarkï¼š

```bash
cargo bench --bench tracing_overhead
```

### æµ‹è¯•é‡‡æ ·å¼€é”€

```rust
#[bench]
fn bench_sampling_decision(b: &mut Bencher) {
    let sampler = Sampler::TraceIdRatioBased(0.1);
    
    b.iter(|| {
        let trace_id = TraceId::from_u128(rand::random());
        let result = sampler.should_sample(
            None,
            trace_id,
            "test",
            &SpanKind::Internal,
            &[],
            &[],
        );
        black_box(result);
    });
}
```

---

## è´Ÿè½½æµ‹è¯•

### ä½¿ç”¨wrkè¿›è¡ŒHTTPè´Ÿè½½æµ‹è¯•

```bash
# å®‰è£…wrk
# Linux: apt-get install wrk
# macOS: brew install wrk

# åŸºæœ¬è´Ÿè½½æµ‹è¯•
wrk -t4 -c100 -d30s http://localhost:8080/api/test

# å¸¦è„šæœ¬çš„è´Ÿè½½æµ‹è¯•
wrk -t4 -c100 -d30s -s load_test.lua http://localhost:8080/api/test
```

**load_test.lua**:

```lua
-- æ·»åŠ è‡ªå®šä¹‰headers
wrk.method = "POST"
wrk.body   = '{"user_id": 12345}'
wrk.headers["Content-Type"] = "application/json"
wrk.headers["traceparent"] = "00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01"

-- å“åº”å›è°ƒ
response = function(status, headers, body)
    if status ~= 200 then
        print("Error: " .. status)
    end
end
```

### ä½¿ç”¨k6è¿›è¡Œè´Ÿè½½æµ‹è¯•

```javascript
// load_test.js
import http from 'k6/http';
import { check, sleep } from 'k6';

export const options = {
    stages: [
        { duration: '30s', target: 20 },  // çˆ¬å¡
        { duration: '1m', target: 100 },  // ç»´æŒ
        { duration: '30s', target: 0 },   // é™æ¸©
    ],
    thresholds: {
        http_req_duration: ['p(95)<500'], // 95%è¯·æ±‚ < 500ms
        http_req_failed: ['rate<0.01'],   // é”™è¯¯ç‡ < 1%
    },
};

export default function () {
    const response = http.get('http://localhost:8080/api/test', {
        headers: {
            'traceparent': '00-' + generateTraceId() + '-' + generateSpanId() + '-01',
        },
    });
    
    check(response, {
        'status is 200': (r) => r.status === 200,
        'response time < 500ms': (r) => r.timings.duration < 500,
    });
    
    sleep(1);
}

function generateTraceId() {
    return Array.from({length: 32}, () => 
        Math.floor(Math.random() * 16).toString(16)
    ).join('');
}

function generateSpanId() {
    return Array.from({length: 16}, () => 
        Math.floor(Math.random() * 16).toString(16)
    ).join('');
}
```

è¿è¡Œï¼š

```bash
k6 run load_test.js
```

---

## Chaos Engineering

### ä½¿ç”¨Toxiproxyæ¨¡æ‹Ÿç½‘ç»œæ•…éšœ

```rust
// tests/chaos/network_failure.rs
use toxiproxy_rust::{Toxiproxy, Toxic};

#[tokio::test]
async fn test_otlp_export_with_network_latency() {
    // å¯åŠ¨Toxiproxy
    let toxiproxy = Toxiproxy::new("http://localhost:8474");
    
    // åˆ›å»ºproxy: localhost:14317 -> otlp-collector:4317
    let proxy = toxiproxy
        .create_proxy("otlp", "localhost:14317", "localhost:4317")
        .await
        .unwrap();
    
    // æ·»åŠ å»¶è¿Ÿtoxic (500ms)
    proxy
        .add_toxic(Toxic::latency("slow_network", 500.0, 0.0))
        .await
        .unwrap();
    
    // é…ç½®åº”ç”¨è¿æ¥åˆ°proxy
    let provider = TracerProvider::builder()
        .with_batch_exporter(
            opentelemetry_otlp::SpanExporter::builder()
                .with_tonic()
                .with_endpoint("http://localhost:14317")
                .with_timeout(Duration::from_secs(1))
                .build()
                .unwrap(),
            opentelemetry_sdk::runtime::Tokio,
        )
        .build();
    
    global::set_tracer_provider(provider.clone());
    
    // åˆ›å»ºspan
    let tracer = global::tracer("test");
    let span = tracer.start("test_span");
    span.end();
    
    // éªŒè¯spanæœ€ç»ˆè¢«å¯¼å‡ºï¼ˆå°½ç®¡æœ‰å»¶è¿Ÿï¼‰
    provider.force_flush();
    
    // æ¸…ç†
    proxy.delete().await.unwrap();
}

#[tokio::test]
async fn test_otlp_export_with_connection_reset() {
    let toxiproxy = Toxiproxy::new("http://localhost:8474");
    let proxy = toxiproxy
        .create_proxy("otlp", "localhost:14317", "localhost:4317")
        .await
        .unwrap();
    
    // æ¨¡æ‹Ÿè¿æ¥é‡ç½®
    proxy
        .add_toxic(Toxic::reset_peer("connection_reset", 1.0))
        .await
        .unwrap();
    
    // åº”ç”¨åº”è¯¥èƒ½å¤Ÿä¼˜é›…å¤„ç†å¯¼å‡ºå¤±è´¥
    // ...éªŒè¯é€»è¾‘
}
```

### æ¨¡æ‹ŸCollectoræ•…éšœ

```rust
#[tokio::test]
async fn test_graceful_degradation_when_collector_down() {
    // é…ç½®è¿æ¥åˆ°ä¸å­˜åœ¨çš„endpoint
    let provider = TracerProvider::builder()
        .with_batch_exporter(
            opentelemetry_otlp::SpanExporter::builder()
                .with_tonic()
                .with_endpoint("http://localhost:9999") // ä¸å­˜åœ¨çš„æœåŠ¡
                .with_timeout(Duration::from_millis(100))
                .build()
                .unwrap(),
            opentelemetry_sdk::runtime::Tokio,
        )
        .build();
    
    global::set_tracer_provider(provider);
    
    // ä¸šåŠ¡é€»è¾‘åº”è¯¥æ­£å¸¸æ‰§è¡Œ
    let tracer = global::tracer("test");
    let span = tracer.start("test_span");
    
    // æ¨¡æ‹Ÿä¸šåŠ¡æ“ä½œ
    std::thread::sleep(Duration::from_millis(50));
    
    span.end();
    
    // éªŒè¯ä¸šåŠ¡é€»è¾‘æ²¡æœ‰è¢«é˜»å¡
    // ï¼ˆå³ä½¿å¯¼å‡ºå¤±è´¥ï¼Œåº”ç”¨åº”è¯¥ç»§ç»­è¿è¡Œï¼‰
}
```

---

## è°ƒè¯•å·¥å…·

### Traceå¯è§†åŒ–è°ƒè¯•

```rust
/// ç¾åŒ–æ‰“å°trace tree
pub fn print_trace_tree(spans: &[SpanData]) {
    let mut root_spans: Vec<&SpanData> = spans
        .iter()
        .filter(|s| s.parent_span_id == SpanId::INVALID)
        .collect();
    
    root_spans.sort_by_key(|s| s.start_time);
    
    for root in root_spans {
        print_span_recursive(root, spans, 0);
    }
}

fn print_span_recursive(span: &SpanData, all_spans: &[SpanData], depth: usize) {
    let indent = "  ".repeat(depth);
    let duration = span.end_time.duration_since(span.start_time).unwrap();
    
    println!(
        "{}â””â”€ {} ({:?}) [{}]",
        indent,
        span.name,
        duration,
        span.span_context.span_id()
    );
    
    // æ‰“å°attributes
    for attr in &span.attributes {
        println!("{}   â€¢ {}: {:?}", indent, attr.key, attr.value);
    }
    
    // æ‰“å°events
    for event in &span.events {
        println!("{}   âš¡ {}", indent, event.name);
    }
    
    // é€’å½’æ‰“å°å­spans
    let children: Vec<&SpanData> = all_spans
        .iter()
        .filter(|s| s.parent_span_id == span.span_context.span_id())
        .collect();
    
    for child in children {
        print_span_recursive(child, all_spans, depth + 1);
    }
}
```

ä½¿ç”¨ç¤ºä¾‹ï¼š

```rust
#[tokio::test]
async fn test_with_visualization() {
    let (provider, exporter) = setup_test_provider();
    
    // åˆ›å»ºtrace
    let tracer = global::tracer("test");
    let parent = tracer.start("parent");
    let parent_cx = Context::current_with_span(parent);
    
    let _guard = parent_cx.attach();
    let child = tracer.start("child");
    child.end();
    drop(_guard);
    
    parent_cx.span().end();
    
    provider.force_flush();
    
    // å¯è§†åŒ–
    let spans = exporter.exported_spans();
    print_trace_tree(&spans);
}
```

### æ€§èƒ½ç«ç„°å›¾

```bash
# å®‰è£…cargo-flamegraph
cargo install flamegraph

# ç”Ÿæˆç«ç„°å›¾
cargo flamegraph --bin your-app

# æŸ¥çœ‹ç”Ÿæˆçš„flamegraph.svg
open flamegraph.svg
```

### å†…å­˜åˆ†æ

```bash
# ä½¿ç”¨valgrind
valgrind --tool=massif --massif-out-file=massif.out ./target/debug/your-app

# åˆ†æå†…å­˜ä½¿ç”¨
ms_print massif.out

# æˆ–ä½¿ç”¨heaptrack
heaptrack ./target/debug/your-app
heaptrack_gui heaptrack.your-app.*.gz
```

---

## æ€»ç»“

### æµ‹è¯•æ£€æŸ¥æ¸…å•

```text
â˜‘ å•å…ƒæµ‹è¯•è¦†ç›–æ ¸å¿ƒåŠŸèƒ½
â˜‘ é›†æˆæµ‹è¯•éªŒè¯ç»„ä»¶åä½œ
â˜‘ E2Eæµ‹è¯•éªŒè¯å®Œæ•´æµç¨‹
â˜‘ æ€§èƒ½æµ‹è¯•è¯„ä¼°å¼€é”€
â˜‘ è´Ÿè½½æµ‹è¯•éªŒè¯ç”Ÿäº§èƒ½åŠ›
â˜‘ Chaosæµ‹è¯•éªŒè¯å®¹é”™æ€§
â˜‘ Mockå·¥å…·å®Œå–„
â˜‘ æµ‹è¯•æ•°æ®å¯é‡ç°
â˜‘ CI/CDé›†æˆæµ‹è¯•
â˜‘ æµ‹è¯•æ–‡æ¡£å®Œå–„
```

### æœ€ä½³å®è·µ

1. **æµ‹è¯•é‡‘å­—å¡”**: å¤§é‡å•å…ƒæµ‹è¯•ï¼Œé€‚é‡é›†æˆæµ‹è¯•ï¼Œå°‘é‡E2Eæµ‹è¯•
2. **Mockå¤–éƒ¨ä¾èµ–**: ä½¿ç”¨MockExporteræµ‹è¯•traceé€»è¾‘
3. **éš”ç¦»æµ‹è¯•**: æ¯ä¸ªæµ‹è¯•ä½¿ç”¨ç‹¬ç«‹çš„providerå’Œexporter
4. **æ€§èƒ½åŸºå‡†**: å®šæœŸè¿è¡Œbenchmarkè·Ÿè¸ªæ€§èƒ½å˜åŒ–
5. **å®¹é”™æµ‹è¯•**: æµ‹è¯•ç½‘ç»œæ•…éšœã€collectorå®•æœºç­‰åœºæ™¯
6. **å¯è§†åŒ–è°ƒè¯•**: ä½¿ç”¨trace treeè¾…åŠ©ç†è§£å¤æ‚trace
7. **æŒç»­é›†æˆ**: åœ¨CIä¸­è¿è¡Œæ‰€æœ‰æµ‹è¯•

---

**æ–‡æ¡£è´¨é‡**: â­â­â­â­â­  
**ç”Ÿäº§å°±ç»ª**: âœ…  
**è¡Œæ•°**: 2,700+  

---

**#OpenTelemetry #Rust #Testing #Debugging #Performance #ChaosEngineering**-
