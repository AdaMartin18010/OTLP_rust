# OpenTelemetry 数据隐私与合规

> **最后更新**: 2025年10月8日

---

## 目录

- [OpenTelemetry 数据隐私与合规](#opentelemetry-数据隐私与合规)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 为什么需要关注隐私合规](#11-为什么需要关注隐私合规)
    - [1.2 主要合规框架](#12-主要合规框架)
  - [2. GDPR合规](#2-gdpr合规)
    - [2.1 核心要求](#21-核心要求)
    - [2.2 遥测数据中的个人数据](#22-遥测数据中的个人数据)
    - [2.3 GDPR合规实践](#23-gdpr合规实践)
  - [3. PCI-DSS合规](#3-pci-dss合规)
    - [3.1 核心要求](#31-核心要求)
    - [3.2 遥测数据保护](#32-遥测数据保护)
  - [4. HIPAA合规](#4-hipaa合规)
    - [4.1 核心要求](#41-核心要求)
    - [4.2 PHI保护实践](#42-phi保护实践)
  - [5. SOC2合规](#5-soc2合规)
    - [5.1 信任服务标准](#51-信任服务标准)
    - [5.2 OpenTelemetry实践](#52-opentelemetry实践)
  - [6. 数据最小化](#6-数据最小化)
    - [6.1 原则](#61-原则)
    - [6.2 实现技术](#62-实现技术)
  - [7. 数据匿名化与假名化](#7-数据匿名化与假名化)
    - [7.1 技术方法](#71-技术方法)
    - [7.2 实现示例](#72-实现示例)
  - [8. 数据保留与删除](#8-数据保留与删除)
    - [8.1 保留策略](#81-保留策略)
    - [8.2 自动删除](#82-自动删除)
  - [9. 数据访问控制](#9-数据访问控制)
  - [10. 审计日志](#10-审计日志)
  - [11. 跨境数据传输](#11-跨境数据传输)
  - [12. 事件响应](#12-事件响应)
  - [13. 合规检查清单](#13-合规检查清单)
  - [14. 参考资源](#14-参考资源)

---

## 1. 概述

### 1.1 为什么需要关注隐私合规

```text
遥测数据可能包含:
1. 个人可识别信息 (PII)
   - 邮箱地址
   - IP地址
   - 用户ID
   - 电话号码

2. 敏感业务数据
   - 交易金额
   - 账户余额
   - 信用卡信息

3. 健康信息 (PHI)
   - 医疗记录ID
   - 诊断代码

风险:
- 法律责任 (罚款高达€20M或4%营收)
- 声誉损失
- 客户信任流失
- 数据泄露

OpenTelemetry挑战:
- 自动采集可能无意中收集敏感数据
- 分布式系统中数据流动难追踪
- 多后端存储增加风险
```

### 1.2 主要合规框架

```text
1. GDPR (General Data Protection Regulation)
   适用: 欧盟居民数据
   要求: 数据最小化、同意、删除权

2. PCI-DSS (Payment Card Industry Data Security Standard)
   适用: 信用卡数据
   要求: 加密、访问控制、审计

3. HIPAA (Health Insurance Portability and Accountability Act)
   适用: 美国医疗数据
   要求: PHI保护、加密、审计

4. SOC2 (Service Organization Control 2)
   适用: 服务提供商
   要求: 安全性、可用性、机密性

5. CCPA (California Consumer Privacy Act)
   适用: 加州居民数据
   要求: 透明度、删除权、退出权
```

---

## 2. GDPR合规

### 2.1 核心要求

```text
1. 合法性基础 (Article 6)
   - 同意
   - 合同履行
   - 法律义务
   - 合法利益

2. 数据最小化 (Article 5.1.c)
   "仅收集必要数据"

3. 存储限制 (Article 5.1.e)
   "仅保留必要时间"

4. 数据主体权利 (Articles 15-22)
   - 访问权
   - 更正权
   - 删除权 (被遗忘权)
   - 数据可携权
   - 反对权

5. 数据保护影响评估 (Article 35)
   高风险处理需DPIA

6. 数据泄露通知 (Article 33)
   72小时内通知监管机构
```

### 2.2 遥测数据中的个人数据

```text
可能的个人数据:
1. 直接标识符
   ✅ 明确PII:
   - user.email
   - user.phone
   - user.ssn
   
   ⚠️ 可能PII:
   - user.id (如果可关联到个人)
   - session.id
   - device.id

2. 间接标识符
   - IP地址 (http.client.ip)
   - User-Agent (http.user_agent)
   - Cookie

3. 特殊类别数据 (Article 9)
   ❌ 禁止收集:
   - 健康数据
   - 种族/民族
   - 政治观点
   - 性取向

判断标准:
能否单独或结合其他信息识别个人?
- 是 → 个人数据 → 需GDPR合规
- 否 → 匿名数据 → 无GDPR约束
```

### 2.3 GDPR合规实践

**数据最小化**：

```yaml
# Collector配置: 删除PII
processors:
  attributes:
    actions:
      # 删除邮箱
      - key: user.email
        action: delete
      
      # 删除电话
      - key: user.phone
        action: delete
      
      # 哈希user.id
      - key: user.id
        action: hash
      
      # 掩码IP地址
      - key: http.client.ip
        action: extract
        pattern: ^(\d+\.\d+\.\d+)\.
        # 192.168.1.100 → 192.168.1.0
```

**Go SDK实现**：

```go
import (
    "crypto/sha256"
    "encoding/hex"
    "go.opentelemetry.io/otel/attribute"
)

// PII过滤Span Processor
type PIIFilterProcessor struct {
    next trace.SpanProcessor
}

func (p *PIIFilterProcessor) OnStart(ctx context.Context, span trace.ReadWriteSpan) {
    // 哈希user.id
    attrs := span.Attributes()
    for _, attr := range attrs {
        if attr.Key == "user.id" {
            hashedID := hashUserID(attr.Value.AsString())
            span.SetAttributes(attribute.String("user.id.hash", hashedID))
            // 删除原始user.id
            // (注意: OpenTelemetry SDK不支持删除属性，需在Collector中删除)
        }
        
        // 删除PII属性
        if attr.Key == "user.email" || attr.Key == "user.phone" {
            // 标记为不导出
            // (实际需在Collector中删除)
        }
    }
}

func hashUserID(userID string) string {
    hash := sha256.Sum256([]byte(userID))
    return hex.EncodeToString(hash[:])
}

// 使用
tp := trace.NewTracerProvider(
    trace.WithSpanProcessor(&PIIFilterProcessor{
        next: trace.NewBatchSpanProcessor(exporter),
    }),
)
```

**数据主体访问请求 (DSAR)**：

```go
// 实现GDPR数据访问API
func handleDSAR(w http.ResponseWriter, r *http.Request) {
    userID := r.URL.Query().Get("user_id")
    
    // 验证身份
    if !verifyIdentity(r) {
        http.Error(w, "Unauthorized", 401)
        return
    }
    
    // 查询所有包含该user.id的遥测数据
    traces := queryTraces(userID)
    metrics := queryMetrics(userID)
    logs := queryLogs(userID)
    
    // 返回JSON
    json.NewEncoder(w).Encode(map[string]interface{}{
        "traces": traces,
        "metrics": metrics,
        "logs": logs,
    })
}

// 实现GDPR删除请求
func handleDeletionRequest(w http.ResponseWriter, r *http.Request) {
    userID := r.URL.Query().Get("user_id")
    
    // 验证身份
    if !verifyIdentity(r) {
        http.Error(w, "Unauthorized", 401)
        return
    }
    
    // 删除所有数据
    deleteTraces(userID)
    deleteMetrics(userID)
    deleteLogs(userID)
    
    // 记录删除审计日志
    auditLog("GDPR_DELETION", userID)
    
    w.WriteHeader(200)
}
```

---

## 3. PCI-DSS合规

### 3.1 核心要求

```text
PCI-DSS v4.0 关键要求:

Requirement 3: 保护存储的持卡人数据
- 3.3: 掩码PAN (显示最多前6后4位)
- 3.4: 加密存储

Requirement 4: 传输加密
- 4.1: 使用强加密 (TLS 1.2+)

Requirement 8: 身份认证
- 8.2: 强密码策略
- 8.3: MFA

Requirement 10: 日志与监控
- 10.2: 审计所有访问
- 10.3: 记录所有事件
```

### 3.2 遥测数据保护

```yaml
# ❌ 不要记录完整信用卡号
attributes:
  - key: payment.card.number
    value: "4532123456789012"  # 违规!

# ✅ 正确做法: 掩码或删除
attributes:
  - key: payment.card.last4
    value: "9012"
  - key: payment.card.type
    value: "visa"
```

**Go实现**：

```go
// PCI-DSS合规Processor
type PCIComplianceProcessor struct {
    next trace.SpanProcessor
}

func (p *PCIComplianceProcessor) OnStart(ctx context.Context, span trace.ReadWriteSpan) {
    attrs := span.Attributes()
    for _, attr := range attrs {
        // 检测信用卡号模式
        if isLikelyCreditCard(attr.Value.AsString()) {
            // 掩码
            masked := maskCreditCard(attr.Value.AsString())
            span.SetAttributes(attribute.String(string(attr.Key), masked))
            
            // 告警
            logger.Warn("Potential credit card number detected in span",
                "span.id", span.SpanContext().SpanID(),
                "attribute", attr.Key)
        }
    }
}

func isLikelyCreditCard(value string) bool {
    // 简单检测: 13-19位数字
    matched, _ := regexp.MatchString(`^\d{13,19}$`, value)
    return matched
}

func maskCreditCard(cardNumber string) string {
    if len(cardNumber) < 10 {
        return "****"
    }
    // 保留前6后4位
    first6 := cardNumber[:6]
    last4 := cardNumber[len(cardNumber)-4:]
    return first6 + "******" + last4
}
```

**Collector配置**：

```yaml
processors:
  redaction:
    # 自动检测并删除信用卡号
    allow_all_keys: false
    blocked_values:
      # 检测Visa/MC/Amex/Discover模式
      - "^4[0-9]{12}(?:[0-9]{3})?$"  # Visa
      - "^5[1-5][0-9]{14}$"  # Mastercard
      - "^3[47][0-9]{13}$"  # Amex
      - "^6(?:011|5[0-9]{2})[0-9]{12}$"  # Discover

service:
  pipelines:
    traces:
      processors: [redaction, batch]
```

---

## 4. HIPAA合规

### 4.1 核心要求

```text
HIPAA Privacy Rule:
保护PHI (Protected Health Information)

PHI包括:
- 姓名
- 地理位置 (小于州级)
- 日期 (出生、入院、出院等)
- 电话号码
- 邮箱
- SSN
- 医疗记录号
- 健康计划号
- 生物识别信息

HIPAA Security Rule:
- 访问控制
- 审计日志
- 完整性控制
- 传输安全
```

### 4.2 PHI保护实践

```yaml
# Collector配置
processors:
  attributes:
    actions:
      # 删除可能的PHI
      - key: patient.name
        action: delete
      - key: patient.ssn
        action: delete
      - key: patient.dob
        action: delete
      - key: patient.mrn
        action: hash  # 医疗记录号哈希

  # IP地址掩码 (可能推断地理位置)
  transform:
    trace_statements:
      - context: span
        statements:
          - replace_pattern(attributes["http.client.ip"], "^(\\d+\\.\\d+\\.\\d+)\\.", "$$1.0")
```

**Go实现**：

```go
// HIPAA合规检查
var phiPatterns = map[string]*regexp.Regexp{
    "ssn": regexp.MustCompile(`\d{3}-\d{2}-\d{4}`),
    "mrn": regexp.MustCompile(`MRN-\d+`),
    "dob": regexp.MustCompile(`\d{4}-\d{2}-\d{2}`),
}

func detectPHI(value string) bool {
    for _, pattern := range phiPatterns {
        if pattern.MatchString(value) {
            return true
        }
    }
    return false
}

// 自动PHI检测和删除
type HIPAAProcessor struct {
    next trace.SpanProcessor
}

func (p *HIPAAProcessor) OnStart(ctx context.Context, span trace.ReadWriteSpan) {
    attrs := span.Attributes()
    for _, attr := range attrs {
        if detectPHI(attr.Value.AsString()) {
            // 告警并删除
            logger.Error("PHI detected in telemetry",
                "span.id", span.SpanContext().SpanID(),
                "attribute", attr.Key)
            
            // 标记为合规违规
            span.SetAttributes(attribute.Bool("hipaa.violation", true))
        }
    }
}
```

---

## 5. SOC2合规

### 5.1 信任服务标准

```text
SOC2 Trust Service Criteria:

CC1: 控制环境
- 组织诚信和道德价值观

CC2: 通信和信息
- 内部外部通信

CC3: 风险评估
- 识别和分析风险

CC4: 监控活动
- 持续监控

CC5: 控制活动
- 选择和开发控制活动

CC6: 逻辑和物理访问控制
- 访问控制
- 数据保护

CC7: 系统操作
- 系统监控
- 变更管理

CC8: 变更管理
- 跟踪和授权变更

CC9: 风险缓解
- 识别和管理风险
```

### 5.2 OpenTelemetry实践

**访问控制审计**：

```go
// 记录所有遥测数据访问
func auditAccess(ctx context.Context, userID, resource string) {
    tracer := otel.Tracer("audit")
    _, span := tracer.Start(ctx, "audit.access")
    defer span.End()
    
    span.SetAttributes(
        attribute.String("audit.user.id", userID),
        attribute.String("audit.resource", resource),
        attribute.String("audit.action", "read"),
        attribute.String("audit.timestamp", time.Now().Format(time.RFC3339)),
        attribute.String("audit.source.ip", getClientIP(ctx)),
    )
}

// Jaeger查询API包装
func queryTracesWithAudit(ctx context.Context, userID, query string) ([]Trace, error) {
    // 审计记录
    auditAccess(ctx, userID, "traces")
    
    // 执行查询
    traces, err := jaegerClient.Query(query)
    
    return traces, err
}
```

**变更管理**：

```go
// 记录配置变更
func updateCollectorConfig(ctx context.Context, userID, newConfig string) error {
    tracer := otel.Tracer("change-management")
    _, span := tracer.Start(ctx, "config.update")
    defer span.End()
    
    span.SetAttributes(
        attribute.String("change.user.id", userID),
        attribute.String("change.type", "collector_config"),
        attribute.String("change.timestamp", time.Now().Format(time.RFC3339)),
    )
    
    // 应用新配置
    err := applyConfig(newConfig)
    if err != nil {
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.SetStatus(codes.Ok, "Config updated successfully")
    return nil
}
```

---

## 6. 数据最小化

### 6.1 原则

```text
只收集必要数据:
1. 明确目的
   - 为什么需要这个属性?
   - 用于什么分析?

2. 评估必要性
   - 是否有其他方式实现目的?
   - 能否使用更少数据?

3. 定期审查
   - 季度审查属性列表
   - 删除不再使用的属性
```

### 6.2 实现技术

```yaml
# Collector: 白名单模式
processors:
  attributes:
    # 只保留白名单属性
    include:
      match_type: strict
      attributes:
        - http.method
        - http.status_code
        - http.route
        - service.name
    
    # 删除所有其他属性
    actions:
      - action: delete
        pattern: ".*"
        match_type: regexp
```

**SDK配置**：

```go
// 只采集必要属性
func minimalInstrumentation() {
    // HTTP客户端: 只采集method和status
    httpInstrumentation := otelhttp.NewHandler(
        handler,
        "api",
        otelhttp.WithSpanOptions(
            trace.WithAttributes(
                semconv.HTTPMethodKey.String(r.Method),
            ),
        ),
    )
}
```

---

## 7. 数据匿名化与假名化

### 7.1 技术方法

```text
1. 假名化 (Pseudonymization)
   可逆: 保留令牌可反向
   方法: 哈希、加密、令牌化
   
   示例:
   user.id: "user-123" → "a3f7b2c..."
   
2. 匿名化 (Anonymization)
   不可逆: 无法恢复原始值
   方法: 聚合、泛化、删除
   
   示例:
   user.age: 27 → "25-30"
   ip: 192.168.1.100 → "192.168.1.0/24"

3. 差分隐私
   添加噪音保护个体隐私
   
   示例:
   real_count: 100 → reported: 98~102
```

### 7.2 实现示例

**哈希假名化**：

```go
import (
    "crypto/sha256"
    "encoding/hex"
)

// 确定性哈希
func pseudonymize(value string, salt string) string {
    hash := sha256.Sum256([]byte(value + salt))
    return hex.EncodeToString(hash[:])
}

// Span Processor
type PseudonymizationProcessor struct {
    next trace.SpanProcessor
    salt string
}

func (p *PseudonymizationProcessor) OnStart(ctx context.Context, span trace.ReadWriteSpan) {
    attrs := span.Attributes()
    for _, attr := range attrs {
        if attr.Key == "user.id" {
            pseudo := pseudonymize(attr.Value.AsString(), p.salt)
            span.SetAttributes(attribute.String("user.id.pseudo", pseudo))
        }
    }
}
```

**IP地址匿名化**：

```go
func anonymizeIP(ip string) string {
    parts := strings.Split(ip, ".")
    if len(parts) == 4 {
        // IPv4: 保留前3段
        return strings.Join(parts[:3], ".") + ".0"
    }
    
    // IPv6: 保留前48位
    if strings.Contains(ip, ":") {
        parts := strings.Split(ip, ":")
        if len(parts) >= 3 {
            return strings.Join(parts[:3], ":") + "::"
        }
    }
    
    return "unknown"
}
```

**泛化**：

```go
func generalizeAge(age int) string {
    switch {
    case age < 18:
        return "<18"
    case age < 25:
        return "18-24"
    case age < 35:
        return "25-34"
    case age < 45:
        return "35-44"
    case age < 55:
        return "45-54"
    default:
        return "55+"
    }
}
```

---

## 8. 数据保留与删除

### 8.1 保留策略

```text
确定合适的保留期:
1. 业务需求
   - 故障排查: 7-30天
   - 趋势分析: 90天
   - 合规审计: 7年 (如SOX)

2. 法律要求
   - GDPR: "不超过必要时间"
   - HIPAA: 6年
   - PCI-DSS: 1年 (日志)

3. 成本考虑
   - 存储成本
   - 查询性能

推荐策略:
- Traces: 7-30天
- Metrics (raw): 15天
- Metrics (aggregated): 13月
- Logs: 30-90天
```

### 8.2 自动删除

**Jaeger配置**：

```yaml
# Jaeger存储配置
storage:
  type: elasticsearch
  options:
    index-prefix: jaeger
    # 自动删除30天前数据
    index-date-separator: "-"
    index-rollover-frequency-spans: "day"

# Elasticsearch ILM策略
PUT _ilm/policy/jaeger_policy
{
  "policy": {
    "phases": {
      "hot": {
        "min_age": "0ms",
        "actions": {
          "rollover": {
            "max_age": "1d"
          }
        }
      },
      "delete": {
        "min_age": "30d",
        "actions": {
          "delete": {}
        }
      }
    }
  }
}
```

**Prometheus配置**：

```yaml
# prometheus.yml
storage:
  tsdb:
    retention.time: 15d  # 保留15天
    retention.size: 100GB  # 或100GB
```

**自定义删除脚本**：

```go
// 定期删除旧数据
func cleanupOldData() {
    ticker := time.NewTicker(24 * time.Hour)
    defer ticker.Stop()
    
    for range ticker.C {
        cutoffTime := time.Now().Add(-30 * 24 * time.Hour)
        
        // 删除旧Traces
        err := deleteTracesOlderThan(cutoffTime)
        if err != nil {
            logger.Error("Failed to delete old traces", "error", err)
        }
        
        logger.Info("Cleaned up old data", "cutoff", cutoffTime)
    }
}
```

---

## 9. 数据访问控制

```yaml
# Grafana: 基于团队的访问控制
teams:
  - name: "Engineering"
    data_sources:
      - "Jaeger-Production"
      - "Prometheus-Production"
    dashboards:
      - "Service Overview"
      - "Error Rates"
  
  - name: "Support"
    data_sources:
      - "Jaeger-Production"  # 只读
    dashboards:
      - "Service Status"
    permissions:
      - read

# Jaeger: Query Service认证
query:
  bearer-token-propagation: true
  http-server:
    host-port: ":16686"
    tls:
      enabled: true
      cert: /path/to/cert.pem
      key: /path/to/key.pem
      client-ca: /path/to/ca.pem
```

**Go实现**：

```go
// RBAC中间件
func rbacMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        userID := getUserIDFromToken(r)
        resource := r.URL.Path
        
        if !hasPermission(userID, resource, "read") {
            http.Error(w, "Forbidden", 403)
            return
        }
        
        next.ServeHTTP(w, r)
    })
}

// 数据级别权限
func queryTracesWithPermissions(ctx context.Context, userID, serviceFilter string) ([]Trace, error) {
    // 检查用户可访问的服务
    allowedServices := getUserAllowedServices(userID)
    
    if !contains(allowedServices, serviceFilter) {
        return nil, fmt.Errorf("permission denied for service: %s", serviceFilter)
    }
    
    return jaegerClient.Query(serviceFilter)
}
```

---

## 10. 审计日志

```go
// 审计所有遥测数据访问
type AuditLogger struct {
    tracer trace.Tracer
}

func (a *AuditLogger) LogAccess(ctx context.Context, event AuditEvent) {
    _, span := a.tracer.Start(ctx, "audit.event")
    defer span.End()
    
    span.SetAttributes(
        attribute.String("audit.event.type", event.Type),
        attribute.String("audit.user.id", event.UserID),
        attribute.String("audit.resource", event.Resource),
        attribute.String("audit.action", event.Action),
        attribute.String("audit.result", event.Result),
        attribute.String("audit.timestamp", event.Timestamp.Format(time.RFC3339)),
        attribute.String("audit.source.ip", event.SourceIP),
    )
    
    // 同时写入独立的审计日志存储
    writeToAuditStorage(event)
}

// 使用示例
auditLogger.LogAccess(ctx, AuditEvent{
    Type: "TELEMETRY_ACCESS",
    UserID: "user-123",
    Resource: "/api/traces?service=checkout",
    Action: "READ",
    Result: "SUCCESS",
    Timestamp: time.Now(),
    SourceIP: "192.168.1.100",
})
```

---

## 11. 跨境数据传输

```text
GDPR Article 45-46: 国际数据传输

机制:
1. 充分性决定 (Adequacy Decision)
   欧盟认可的国家/地区

2. 标准合同条款 (SCCs)
   使用欧盟批准的SCC模板

3. 约束性公司规则 (BCRs)
   跨国公司内部数据传输

OpenTelemetry考虑:
- Collector部署位置
- Backend存储位置
- 数据流路径

推荐架构:
EU用户 → EU Collector → EU Storage
US用户 → US Collector → US Storage
```

**区域隔离配置**：

```yaml
# EU Collector配置
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: eu-collector.example.com:4317

exporters:
  jaeger:
    endpoint: eu-jaeger.example.com:14250  # EU存储

service:
  pipelines:
    traces:
      receivers: [otlp]
      exporters: [jaeger]
```

---

## 12. 事件响应

```text
数据泄露响应计划:

1. 检测 (Detection)
   - 监控异常访问
   - 告警大量数据导出

2. 遏制 (Containment)
   - 立即撤销受损凭证
   - 隔离受影响系统

3. 评估 (Assessment)
   - 确定泄露范围
   - 识别受影响个人
   - 评估数据敏感性

4. 通知 (Notification)
   - GDPR: 72小时内通知监管机构
   - 通知受影响个人

5. 修复 (Remediation)
   - 修复漏洞
   - 更新访问控制
   - 加强监控

6. 文档化 (Documentation)
   - 记录事件时间线
   - 保留证据
   - 编写事后报告
```

**泄露检测**：

```go
// 监控异常查询
func detectAnomalousQueries() {
    meter := otel.Meter("security")
    queryCounter, _ := meter.Int64Counter("queries.total")
    
    // 记录查询
    queryCounter.Add(ctx, 1, metric.WithAttributes(
        attribute.String("user.id", userID),
        attribute.String("query.type", "trace_search"),
        attribute.Int64("results.count", len(results)),
    ))
    
    // 告警规则 (Prometheus)
    // rate(queries_total{user_id="user-123"}[5m]) > 100
    // 用户在5分钟内查询超过100次
}
```

---

## 13. 合规检查清单

```text
✅ GDPR合规
- [ ] 数据处理活动记录 (ROPA)
- [ ] 隐私政策更新
- [ ] 数据保护影响评估 (DPIA)
- [ ] 删除PII属性
- [ ] 实现DSAR (访问/删除请求)
- [ ] DPO指派 (如适用)
- [ ] 数据泄露响应计划

✅ PCI-DSS合规
- [ ] 不记录完整PAN
- [ ] TLS 1.2+ 传输
- [ ] 强访问控制
- [ ] 审计所有访问
- [ ] 定期安全扫描
- [ ] ASV扫描 (季度)

✅ HIPAA合规
- [ ] 不记录PHI
- [ ] BAA (Business Associate Agreement)
- [ ] 加密传输和存储
- [ ] 访问日志
- [ ] 风险评估

✅ SOC2合规
- [ ] 访问控制策略
- [ ] 变更管理流程
- [ ] 监控和告警
- [ ] 事件响应计划
- [ ] 审计日志
- [ ] 定期审查

✅ 通用最佳实践
- [ ] 数据最小化
- [ ] 数据保留策略
- [ ] 自动删除旧数据
- [ ] 假名化/匿名化
- [ ] HTTPS/TLS everywhere
- [ ] 强认证 (MFA)
- [ ] 定期安全审计
```

---

## 14. 参考资源

- **GDPR**: <https://gdpr.eu/>
- **PCI-DSS**: <https://www.pcisecuritystandards.org/>
- **HIPAA**: <https://www.hhs.gov/hipaa/>
- **SOC2**: <https://www.aicpa.org/soc>
- **NIST隐私框架**: <https://www.nist.gov/privacy-framework>

---

**文档状态**: ✅ 完成  
**审核状态**: 待审核  
**免责声明**: 本文档仅供参考，不构成法律建议。请咨询专业律师确保合规。
