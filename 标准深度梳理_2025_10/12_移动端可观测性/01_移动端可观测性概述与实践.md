# 移动端可观测性概述与实践

> **标准版本**: v1.27.0  
> **状态**: Stable  
> **最后更新**: 2025年10月8日

---

## 目录

- [移动端可观测性概述与实践](#移动端可观测性概述与实践)
  - [目录](#目录)
  - [1. 概述](#1-概述)
  - [2. 移动端可观测性特点](#2-移动端可观测性特点)
    - [2.1 挑战](#21-挑战)
    - [2.2 关键指标](#22-关键指标)
  - [3. iOS集成](#3-ios集成)
    - [3.1 SDK安装](#31-sdk安装)
    - [3.2 基础配置](#32-基础配置)
    - [3.3 自动Instrumentation](#33-自动instrumentation)
    - [3.4 手动Instrumentation](#34-手动instrumentation)
    - [3.5 iOS特定指标](#35-ios特定指标)
  - [4. Android集成](#4-android集成)
    - [4.1 SDK安装](#41-sdk安装)
    - [4.2 基础配置](#42-基础配置)
    - [4.3 自动Instrumentation](#43-自动instrumentation)
    - [4.4 手动Instrumentation](#44-手动instrumentation)
    - [4.5 Android特定指标](#45-android特定指标)
  - [5. 移动端语义约定](#5-移动端语义约定)
    - [5.1 设备属性](#51-设备属性)
    - [5.2 应用属性](#52-应用属性)
    - [5.3 网络属性](#53-网络属性)
  - [6. 性能监控](#6-性能监控)
    - [6.1 应用启动时间](#61-应用启动时间)
    - [6.2 屏幕渲染性能](#62-屏幕渲染性能)
    - [6.3 网络性能](#63-网络性能)
    - [6.4 内存与电池](#64-内存与电池)
  - [7. 崩溃与错误追踪](#7-崩溃与错误追踪)
    - [7.1 iOS崩溃追踪](#71-ios崩溃追踪)
    - [7.2 Android崩溃追踪](#72-android崩溃追踪)
  - [8. 用户体验监控](#8-用户体验监控)
    - [8.1 用户会话追踪](#81-用户会话追踪)
    - [8.2 用户交互追踪](#82-用户交互追踪)
  - [9. 数据采样与优化](#9-数据采样与优化)
    - [9.1 采样策略](#91-采样策略)
    - [9.2 离线缓存](#92-离线缓存)
    - [9.3 电池优化](#93-电池优化)
  - [10. 最佳实践](#10-最佳实践)
    - [10.1 隐私保护](#101-隐私保护)
    - [10.2 性能影响最小化](#102-性能影响最小化)
    - [10.3 数据传输优化](#103-数据传输优化)
  - [11. 完整示例](#11-完整示例)
    - [11.1 iOS完整示例](#111-ios完整示例)
    - [11.2 Android完整示例](#112-android完整示例)
  - [12. 参考资源](#12-参考资源)
    - [官方文档](#官方文档)
    - [SDK文档](#sdk文档)

---

## 1. 概述

移动端可观测性面临独特的挑战和需求，包括有限的资源、不稳定的网络连接、用户隐私保护等。OpenTelemetry为iOS和Android提供了专门的SDK支持。

**核心目标**：

```text
✅ 监控应用性能（启动时间、响应速度）
✅ 追踪用户体验（屏幕导航、交互延迟）
✅ 检测崩溃与错误
✅ 优化网络请求
✅ 最小化对电池和性能的影响
```

---

## 2. 移动端可观测性特点

### 2.1 挑战

```text
❗ 资源受限:      有限的CPU/内存/电池
❗ 网络不稳定:    移动网络波动、离线场景
❗ 设备碎片化:    多种设备型号和OS版本
❗ 隐私保护:      GDPR/CCPA等隐私法规
❗ 应用生命周期:  频繁的前后台切换
```

### 2.2 关键指标

**性能指标**：

```text
- 应用启动时间（冷启动/热启动）
- 屏幕加载时间
- 帧率（FPS）
- 网络请求延迟
- 内存使用量
- 电池消耗
```

**用户体验指标**：

```text
- 用户会话时长
- 屏幕导航路径
- 交互响应时间
- 崩溃率
- ANR率（Android）
- 错误率
```

---

## 3. iOS集成

### 3.1 SDK安装

**CocoaPods**：

```ruby
# Podfile
platform :ios, '13.0'

target 'YourApp' do
  use_frameworks!
  
  # OpenTelemetry核心
  pod 'OpenTelemetryApi', '~> 1.6.0'
  pod 'OpenTelemetrySdk', '~> 1.6.0'
  
  # OTLP Exporter
  pod 'OpenTelemetryProtocolExporterGrpc', '~> 1.6.0'
  
  # 自动Instrumentation
  pod 'OpenTelemetryInstrumentationURLSession', '~> 1.6.0'
end
```

**Swift Package Manager**：

```swift
dependencies: [
    .package(
        url: "https://github.com/open-telemetry/opentelemetry-swift",
        from: "1.6.0"
    )
]
```

### 3.2 基础配置

**Swift初始化**：

```swift
import OpenTelemetryApi
import OpenTelemetrySdk
import OpenTelemetryProtocolExporterGrpc

class TelemetryManager {
    static let shared = TelemetryManager()
    
    private var tracerProvider: TracerProviderSdk!
    private var meterProvider: MeterProviderSdk!
    
    private init() {
        setupTelemetry()
    }
    
    private func setupTelemetry() {
        // Resource配置
        let resource = Resource(attributes: [
            ResourceAttributes.serviceName: AttributeValue.string("ios-app"),
            ResourceAttributes.serviceVersion: AttributeValue.string("1.0.0"),
            "device.model": AttributeValue.string(UIDevice.current.model),
            "os.type": AttributeValue.string("ios"),
            "os.version": AttributeValue.string(UIDevice.current.systemVersion)
        ])
        
        // OTLP Exporter配置
        let otlpConfiguration = OtlpConfiguration(
            timeout: TimeInterval(10),
            headers: [("Authorization", "Bearer your-token")]
        )
        
        let otlpExporter = OtlpTraceExporter(
            endpoint: "https://your-collector.example.com:4317",
            config: otlpConfiguration
        )
        
        // TracerProvider配置
        tracerProvider = TracerProviderBuilder()
            .with(resource: resource)
            .add(spanProcessor: BatchSpanProcessor(
                spanExporter: otlpExporter,
                scheduleDelay: 5.0  // 5秒批次延迟
            ))
            .build()
        
        OpenTelemetry.registerTracerProvider(tracerProvider: tracerProvider)
    }
    
    func getTracer() -> Tracer {
        return OpenTelemetry.instance.tracerProvider.get(
            instrumentationName: "ios-app",
            instrumentationVersion: "1.0.0"
        )
    }
}
```

### 3.3 自动Instrumentation

**URLSession自动追踪**：

```swift
import OpenTelemetryInstrumentationURLSession

// 启用URLSession自动instrumentation
let urlSessionInstrumentation = URLSessionInstrumentation(configuration: 
    URLSessionInstrumentationConfiguration(
        shouldRecordPayload: { request in
            // 决定是否记录请求体
            return true
        },
        shouldInstrument: { request in
            // 决定是否追踪该请求
            return !request.url?.absoluteString.contains("sensitive") ?? true
        },
        createdRequest: { request, span in
            // 自定义Span
            span.setAttribute(key: "custom.attribute", value: "value")
        }
    )
)
```

**生命周期自动追踪**：

```swift
import UIKit

class AppDelegate: UIResponder, UIApplicationDelegate {
    func application(
        _ application: UIApplication,
        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
    ) -> Bool {
        // 初始化遥测
        TelemetryManager.shared
        
        // 追踪应用启动
        let tracer = TelemetryManager.shared.getTracer()
        let span = tracer.spanBuilder(spanName: "app.launch")
            .setSpanKind(spanKind: .client)
            .startSpan()
        
        // 应用启动逻辑...
        
        span.end()
        return true
    }
    
    func applicationDidEnterBackground(_ application: UIApplication) {
        let tracer = TelemetryManager.shared.getTracer()
        let span = tracer.spanBuilder(spanName: "app.enter_background")
            .startSpan()
        span.end()
    }
}
```

### 3.4 手动Instrumentation

**屏幕导航追踪**：

```swift
import UIKit
import OpenTelemetryApi

class BaseViewController: UIViewController {
    private var screenSpan: Span?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        let tracer = TelemetryManager.shared.getTracer()
        screenSpan = tracer.spanBuilder(spanName: "screen.\(screenName)")
            .setSpanKind(spanKind: .client)
            .setAttribute(key: "screen.name", value: screenName)
            .setAttribute(key: "screen.class", value: String(describing: type(of: self)))
            .startSpan()
    }
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        screenSpan?.addEvent(name: "screen.appeared")
    }
    
    override func viewDidDisappear(_ animated: Bool) {
        super.viewDidDisappear(animated)
        screenSpan?.end()
    }
    
    var screenName: String {
        return String(describing: type(of: self))
    }
}
```

**用户操作追踪**：

```swift
@IBAction func buttonTapped(_ sender: UIButton) {
    let tracer = TelemetryManager.shared.getTracer()
    let span = tracer.spanBuilder(spanName: "user.action.button_tap")
        .setSpanKind(spanKind: .client)
        .setAttribute(key: "button.id", value: sender.accessibilityIdentifier ?? "unknown")
        .setAttribute(key: "button.title", value: sender.title(for: .normal) ?? "")
        .startSpan()
    
    defer {
        span.end()
    }
    
    // 执行按钮操作
    performButtonAction()
}
```

### 3.5 iOS特定指标

**内存监控**：

```swift
import Foundation

func collectMemoryMetrics() {
    var info = mach_task_basic_info()
    var count = mach_msg_type_number_t(MemoryLayout<mach_task_basic_info>.size)/4
    
    let kerr: kern_return_t = withUnsafeMutablePointer(to: &info) {
        $0.withMemoryRebound(to: integer_t.self, capacity: 1) {
            task_info(mach_task_self_,
                     task_flavor_t(MACH_TASK_BASIC_INFO),
                     $0,
                     &count)
        }
    }
    
    if kerr == KERN_SUCCESS {
        let usedMemory = Double(info.resident_size) / 1024.0 / 1024.0
        
        // 记录内存指标
        let meter = OpenTelemetry.instance.meterProvider.get(instrumentationName: "ios-app")
        let memoryGauge = meter.createDoubleObservableGauge(name: "app.memory.used_mb")
        memoryGauge.observe(value: usedMemory, attributes: [:])
    }
}
```

---

## 4. Android集成

### 4.1 SDK安装

**Gradle配置**：

```gradle
// build.gradle (Project level)
buildscript {
    ext {
        opentelemetry_version = '1.32.0'
        opentelemetry_alpha_version = '1.32.0-alpha'
    }
}

// build.gradle (App level)
dependencies {
    // OpenTelemetry核心
    implementation "io.opentelemetry:opentelemetry-api:${opentelemetry_version}"
    implementation "io.opentelemetry:opentelemetry-sdk:${opentelemetry_version}"
    
    // OTLP Exporter
    implementation "io.opentelemetry:opentelemetry-exporter-otlp:${opentelemetry_version}"
    
    // Android Instrumentation
    implementation "io.opentelemetry.android:instrumentation:${opentelemetry_alpha_version}"
    implementation "io.opentelemetry.android:instrumentation-okhttp:${opentelemetry_alpha_version}"
}
```

### 4.2 基础配置

**Kotlin初始化**：

```kotlin
package com.example.app

import android.app.Application
import io.opentelemetry.api.OpenTelemetry
import io.opentelemetry.api.common.Attributes
import io.opentelemetry.api.trace.Tracer
import io.opentelemetry.exporter.otlp.trace.OtlpGrpcSpanExporter
import io.opentelemetry.sdk.OpenTelemetrySdk
import io.opentelemetry.sdk.resources.Resource
import io.opentelemetry.sdk.trace.SdkTracerProvider
import io.opentelemetry.sdk.trace.export.BatchSpanProcessor
import io.opentelemetry.semconv.resource.attributes.ResourceAttributes

class MyApplication : Application() {
    companion object {
        private lateinit var openTelemetry: OpenTelemetry
        
        fun getTracer(): Tracer {
            return openTelemetry.getTracer("android-app", "1.0.0")
        }
    }
    
    override fun onCreate() {
        super.onCreate()
        setupOpenTelemetry()
    }
    
    private fun setupOpenTelemetry() {
        // Resource配置
        val resource = Resource.getDefault().toBuilder()
            .put(ResourceAttributes.SERVICE_NAME, "android-app")
            .put(ResourceAttributes.SERVICE_VERSION, "1.0.0")
            .put("device.model", android.os.Build.MODEL)
            .put("os.type", "android")
            .put("os.version", android.os.Build.VERSION.RELEASE)
            .build()
        
        // OTLP Exporter配置
        val otlpExporter = OtlpGrpcSpanExporter.builder()
            .setEndpoint("https://your-collector.example.com:4317")
            .addHeader("Authorization", "Bearer your-token")
            .setTimeout(10, java.util.concurrent.TimeUnit.SECONDS)
            .build()
        
        // TracerProvider配置
        val tracerProvider = SdkTracerProvider.builder()
            .setResource(resource)
            .addSpanProcessor(
                BatchSpanProcessor.builder(otlpExporter)
                    .setScheduleDelay(5, java.util.concurrent.TimeUnit.SECONDS)
                    .build()
            )
            .build()
        
        // OpenTelemetry SDK初始化
        openTelemetry = OpenTelemetrySdk.builder()
            .setTracerProvider(tracerProvider)
            .buildAndRegisterGlobal()
    }
}
```

### 4.3 自动Instrumentation

**OkHttp自动追踪**：

```kotlin
import io.opentelemetry.instrumentation.okhttp.v3_0.OkHttpTelemetry
import okhttp3.OkHttpClient

// 创建带instrumentation的OkHttpClient
val okHttpTelemetry = OkHttpTelemetry.builder(openTelemetry)
    .setCapturedRequestHeaders(listOf("User-Agent", "Content-Type"))
    .setCapturedResponseHeaders(listOf("Content-Type"))
    .build()

val client = OkHttpClient.Builder()
    .addInterceptor(okHttpTelemetry.newInterceptor())
    .build()
```

**Activity生命周期追踪**：

```kotlin
import android.app.Activity
import android.app.Application
import android.os.Bundle
import io.opentelemetry.api.trace.Span
import io.opentelemetry.api.trace.SpanKind

class ActivityLifecycleTracker : Application.ActivityLifecycleCallbacks {
    private val spanMap = mutableMapOf<Activity, Span>()
    
    override fun onActivityCreated(activity: Activity, savedInstanceState: Bundle?) {
        val tracer = MyApplication.getTracer()
        val span = tracer.spanBuilder("screen.${activity.localClassName}")
            .setSpanKind(SpanKind.CLIENT)
            .setAttribute("screen.name", activity.localClassName)
            .setAttribute("screen.class", activity::class.java.name)
            .startSpan()
        
        spanMap[activity] = span
    }
    
    override fun onActivityStarted(activity: Activity) {
        spanMap[activity]?.addEvent("screen.started")
    }
    
    override fun onActivityResumed(activity: Activity) {
        spanMap[activity]?.addEvent("screen.resumed")
    }
    
    override fun onActivityPaused(activity: Activity) {
        spanMap[activity]?.addEvent("screen.paused")
    }
    
    override fun onActivityDestroyed(activity: Activity) {
        spanMap[activity]?.end()
        spanMap.remove(activity)
    }
    
    // 其他生命周期回调...
    override fun onActivityStopped(activity: Activity) {}
    override fun onActivitySaveInstanceState(activity: Activity, outState: Bundle) {}
}

// 在Application中注册
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        registerActivityLifecycleCallbacks(ActivityLifecycleTracker())
    }
}
```

### 4.4 手动Instrumentation

**网络请求追踪**：

```kotlin
import io.opentelemetry.api.trace.SpanKind
import io.opentelemetry.api.trace.StatusCode
import io.opentelemetry.semconv.trace.attributes.SemanticAttributes

suspend fun fetchData(url: String): Result<String> {
    val tracer = MyApplication.getTracer()
    val span = tracer.spanBuilder("http.request")
        .setSpanKind(SpanKind.CLIENT)
        .setAttribute(SemanticAttributes.HTTP_METHOD, "GET")
        .setAttribute(SemanticAttributes.HTTP_URL, url)
        .startSpan()
    
    return try {
        val result = performHttpRequest(url)
        
        span.setAttribute(SemanticAttributes.HTTP_STATUS_CODE, 200)
        span.setStatus(StatusCode.OK)
        
        Result.success(result)
    } catch (e: Exception) {
        span.recordException(e)
        span.setStatus(StatusCode.ERROR, e.message ?: "Unknown error")
        
        Result.failure(e)
    } finally {
        span.end()
    }
}
```

### 4.5 Android特定指标

**内存与CPU监控**：

```kotlin
import android.app.ActivityManager
import android.content.Context
import android.os.Debug

class SystemMetricsCollector(private val context: Context) {
    private val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
    
    fun collectMemoryMetrics() {
        val memoryInfo = ActivityManager.MemoryInfo()
        activityManager.getMemoryInfo(memoryInfo)
        
        val runtime = Runtime.getRuntime()
        val usedMemory = (runtime.totalMemory() - runtime.freeMemory()) / 1024.0 / 1024.0
        
        // 记录指标
        val meter = OpenTelemetry.getGlobalMeterProvider().get("android-app")
        val memoryGauge = meter.gaugeBuilder("app.memory.used_mb")
            .build()
        
        memoryGauge.record(usedMemory)
    }
    
    fun collectCpuMetrics() {
        val cpuUsage = Debug.threadCpuTimeNanos() / 1000000.0
        
        val meter = OpenTelemetry.getGlobalMeterProvider().get("android-app")
        val cpuGauge = meter.gaugeBuilder("app.cpu.usage_ms")
            .build()
        
        cpuGauge.record(cpuUsage)
    }
}
```

---

## 5. 移动端语义约定

### 5.1 设备属性

```text
device.manufacturer:    设备制造商 (Apple/Samsung/Google)
device.model:           设备型号 (iPhone 14/Pixel 7)
device.id:              设备唯一标识 (匿名化)
```

### 5.2 应用属性

```text
app.version:            应用版本 (1.0.0)
app.build:              构建号 (100)
app.session.id:         会话ID (UUID)
app.state:              应用状态 (foreground/background)
```

### 5.3 网络属性

```text
network.type:           网络类型 (wifi/cellular/unknown)
network.generation:     网络世代 (4G/5G)
network.carrier:        运营商
```

---

## 6. 性能监控

### 6.1 应用启动时间

**iOS启动时间追踪**：

```swift
// AppDelegate.swift
func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
) -> Bool {
    let startTime = ProcessInfo.processInfo.systemUptime
    
    let tracer = TelemetryManager.shared.getTracer()
    let span = tracer.spanBuilder(spanName: "app.cold_start")
        .setStartTime(time: Date(timeIntervalSinceNow: -startTime))
        .setAttribute(key: "start.type", value: "cold")
        .startSpan()
    
    // 初始化逻辑...
    
    span.end()
    return true
}
```

### 6.2 屏幕渲染性能

**iOS帧率监控**：

```swift
import QuartzCore

class FrameRateMonitor {
    private var displayLink: CADisplayLink?
    private var lastTimestamp: CFTimeInterval = 0
    private var fps: Double = 0
    
    func startMonitoring() {
        displayLink = CADisplayLink(target: self, selector: #selector(update))
        displayLink?.add(to: .main, forMode: .common)
    }
    
    @objc private func update(displayLink: CADisplayLink) {
        if lastTimestamp == 0 {
            lastTimestamp = displayLink.timestamp
            return
        }
        
        let delta = displayLink.timestamp - lastTimestamp
        fps = 1.0 / delta
        lastTimestamp = displayLink.timestamp
        
        // 记录FPS指标
        let meter = OpenTelemetry.instance.meterProvider.get(instrumentationName: "ios-app")
        let fpsGauge = meter.createDoubleObservableGauge(name: "app.fps")
        fpsGauge.observe(value: fps, attributes: [:])
    }
}
```

### 6.3 网络性能

**网络延迟追踪**（已在上文OkHttp/URLSession自动instrumentation中实现）

### 6.4 内存与电池

**电池状态监控**（iOS）：

```swift
import UIKit

func monitorBatteryStatus() {
    UIDevice.current.isBatteryMonitoringEnabled = true
    
    NotificationCenter.default.addObserver(
        forName: UIDevice.batteryLevelDidChangeNotification,
        object: nil,
        queue: .main
    ) { _ in
        let level = UIDevice.current.batteryLevel
        let state = UIDevice.current.batteryState
        
        // 记录电池指标
        let meter = OpenTelemetry.instance.meterProvider.get(instrumentationName: "ios-app")
        let batteryGauge = meter.createDoubleObservableGauge(name: "device.battery.level")
        batteryGauge.observe(value: Double(level), attributes: [
            "battery.state": AttributeValue.string(state.description)
        ])
    }
}
```

---

## 7. 崩溃与错误追踪

### 7.1 iOS崩溃追踪

```swift
import Foundation

class CrashHandler {
    static func setup() {
        NSSetUncaughtExceptionHandler { exception in
            let tracer = TelemetryManager.shared.getTracer()
            let span = tracer.spanBuilder(spanName: "app.crash")
                .setSpanKind(spanKind: .internal)
                .setAttribute(key: "exception.type", value: exception.name.rawValue)
                .setAttribute(key: "exception.message", value: exception.reason ?? "")
                .setAttribute(key: "exception.stacktrace", 
                            value: exception.callStackSymbols.joined(separator: "\n"))
                .startSpan()
            
            span.setStatus(status: .error(description: "Application crashed"))
            span.end()
            
            // 强制刷新遥测数据
            TelemetryManager.shared.flush()
        }
    }
}
```

### 7.2 Android崩溃追踪

```kotlin
class CrashHandler : Thread.UncaughtExceptionHandler {
    private val defaultHandler = Thread.getDefaultUncaughtExceptionHandler()
    
    override fun uncaughtException(thread: Thread, throwable: Throwable) {
        val tracer = MyApplication.getTracer()
        val span = tracer.spanBuilder("app.crash")
            .setSpanKind(SpanKind.INTERNAL)
            .setAttribute("exception.type", throwable::class.java.name)
            .setAttribute("exception.message", throwable.message ?: "")
            .setAttribute("exception.stacktrace", throwable.stackTraceToString())
            .setAttribute("thread.name", thread.name)
            .startSpan()
        
        span.setStatus(StatusCode.ERROR, "Application crashed")
        span.end()
        
        // 默认处理
        defaultHandler?.uncaughtException(thread, throwable)
    }
}

// 在Application中设置
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        Thread.setDefaultUncaughtExceptionHandler(CrashHandler())
    }
}
```

---

## 8. 用户体验监控

### 8.1 用户会话追踪

**iOS会话管理**：

```swift
class SessionManager {
    static let shared = SessionManager()
    private var sessionId: String?
    private var sessionStartTime: Date?
    
    func startSession() {
        sessionId = UUID().uuidString
        sessionStartTime = Date()
        
        let tracer = TelemetryManager.shared.getTracer()
        let span = tracer.spanBuilder(spanName: "user.session")
            .setAttribute(key: "session.id", value: sessionId!)
            .startSpan()
        
        // Session span保持活跃直到应用关闭
    }
    
    func getCurrentSessionId() -> String? {
        return sessionId
    }
}
```

### 8.2 用户交互追踪

**Android点击事件追踪**：

```kotlin
import android.view.View

fun trackButtonClick(view: View, actionName: String) {
    val tracer = MyApplication.getTracer()
    val span = tracer.spanBuilder("user.interaction.$actionName")
        .setSpanKind(SpanKind.CLIENT)
        .setAttribute("ui.element.id", view.id.toString())
        .setAttribute("ui.element.type", "button")
        .setAttribute("session.id", SessionManager.getSessionId())
        .startSpan()
    
    span.end()
}
```

---

## 9. 数据采样与优化

### 9.1 采样策略

**基于电池与网络的动态采样**：

```kotlin
class AdaptiveSampler : Sampler {
    override fun shouldSample(
        parentContext: Context,
        traceId: String,
        name: String,
        spanKind: SpanKind,
        attributes: Attributes,
        parentLinks: List<LinkData>
    ): SamplingResult {
        val batteryLevel = getBatteryLevel()
        val networkType = getNetworkType()
        
        // 低电量时降低采样率
        val samplingProbability = when {
            batteryLevel < 20 -> 0.1  // 10%
            batteryLevel < 50 -> 0.5  // 50%
            networkType == "wifi" -> 1.0  // 100%
            networkType == "cellular" -> 0.7  // 70%
            else -> 0.5
        }
        
        return if (Math.random() < samplingProbability) {
            SamplingResult.recordAndSample()
        } else {
            SamplingResult.drop()
        }
    }
}
```

### 9.2 离线缓存

**离线数据持久化**：

```swift
class OfflineCache {
    private let fileManager = FileManager.default
    private let cacheDirectory: URL
    
    init() {
        cacheDirectory = fileManager.urls(for: .cachesDirectory, in: .userDomainMask)[0]
            .appendingPathComponent("telemetry")
        
        try? fileManager.createDirectory(at: cacheDirectory, withIntermediateDirectories: true)
    }
    
    func saveSpan(_ span: SpanData) {
        // 将span数据序列化并保存到本地
        let encoder = JSONEncoder()
        if let data = try? encoder.encode(span) {
            let filename = UUID().uuidString + ".span"
            let fileURL = cacheDirectory.appendingPathComponent(filename)
            try? data.write(to: fileURL)
        }
    }
    
    func flushWhenOnline() {
        guard isNetworkAvailable() else { return }
        
        // 读取并发送所有缓存的span
        let files = try? fileManager.contentsOfDirectory(at: cacheDirectory, includingPropertiesForKeys: nil)
        files?.forEach { fileURL in
            if let data = try? Data(contentsOf: fileURL),
               let span = try? JSONDecoder().decode(SpanData.self, from: data) {
                // 发送span
                sendSpan(span)
                // 删除文件
                try? fileManager.removeItem(at: fileURL)
            }
        }
    }
}
```

### 9.3 电池优化

**最佳实践**：

```text
✅ 使用批处理减少网络请求
✅ 在WiFi下优先发送数据
✅ 低电量时降低采样率
✅ 合并多个小请求为一个大请求
✅ 使用后台任务发送数据
✅ 避免频繁唤醒设备
```

---

## 10. 最佳实践

### 10.1 隐私保护

**数据脱敏**：

```swift
// 脱敏用户信息
func sanitizeUserData(_ userId: String) -> String {
    // 使用SHA256哈希
    let data = userId.data(using: .utf8)!
    let hash = SHA256.hash(data: data)
    return hash.compactMap { String(format: "%02x", $0) }.joined()
}

// 设置span属性时使用脱敏
span.setAttribute(key: "user.id", value: sanitizeUserData(actualUserId))
```

### 10.2 性能影响最小化

**异步处理**：

```kotlin
// 异步发送遥测数据
CoroutineScope(Dispatchers.IO).launch {
    try {
        sendTelemetryData(span)
    } catch (e: Exception) {
        // 静默失败，不影响主流程
        Log.e("Telemetry", "Failed to send data", e)
    }
}
```

### 10.3 数据传输优化

**压缩配置**：

```yaml
# Collector配置
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317
        # 启用压缩
        max_recv_msg_size_mib: 4

exporters:
  otlp:
    endpoint: backend:4317
    compression: gzip  # 使用gzip压缩
```

---

## 11. 完整示例

### 11.1 iOS完整示例

```swift
// AppDelegate.swift
import UIKit
import OpenTelemetryApi
import OpenTelemetrySdk

@main
class AppDelegate: UIResponder, UIApplicationDelegate {
    func application(
        _ application: UIApplication,
        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
    ) -> Bool {
        // 初始化OpenTelemetry
        TelemetryManager.shared
        
        // 设置崩溃处理
        CrashHandler.setup()
        
        // 开始会话
        SessionManager.shared.startSession()
        
        // 监控帧率
        FrameRateMonitor().startMonitoring()
        
        // 追踪启动时间
        let tracer = TelemetryManager.shared.getTracer()
        let span = tracer.spanBuilder(spanName: "app.launch")
            .setAttribute(key: "launch.type", value: "cold")
            .startSpan()
        
        // 应用初始化逻辑...
        
        span.end()
        return true
    }
}

// ViewController.swift
class ProductListViewController: BaseViewController {
    override var screenName: String {
        return "product_list"
    }
    
    @IBAction func productTapped(_ sender: UIButton) {
        let tracer = TelemetryManager.shared.getTracer()
        let span = tracer.spanBuilder(spanName: "user.action.product_tap")
            .setAttribute(key: "product.id", value: sender.tag)
            .setAttribute(key: "session.id", value: SessionManager.shared.getCurrentSessionId() ?? "")
            .startSpan()
        
        // 加载产品详情
        loadProductDetail(productId: sender.tag)
        
        span.end()
    }
    
    private func loadProductDetail(productId: Int) {
        let tracer = TelemetryManager.shared.getTracer()
        let span = tracer.spanBuilder(spanName: "api.product.detail")
            .setSpanKind(spanKind: .client)
            .setAttribute(key: "product.id", value: productId)
            .startSpan()
        
        let url = URL(string: "https://api.example.com/products/\(productId)")!
        
        URLSession.shared.dataTask(with: url) { data, response, error in
            if let error = error {
                span.recordException(exception: error)
                span.setStatus(status: .error(description: error.localizedDescription))
            } else if let httpResponse = response as? HTTPURLResponse {
                span.setAttribute(key: "http.status_code", value: httpResponse.statusCode)
                span.setStatus(status: .ok)
            }
            
            span.end()
        }.resume()
    }
}
```

### 11.2 Android完整示例

```kotlin
// MyApplication.kt
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        
        // 初始化OpenTelemetry
        setupOpenTelemetry()
        
        // 设置崩溃处理
        Thread.setDefaultUncaughtExceptionHandler(CrashHandler())
        
        // 注册Activity生命周期回调
        registerActivityLifecycleCallbacks(ActivityLifecycleTracker())
        
        // 开始会话
        SessionManager.startSession()
        
        // 定期收集系统指标
        scheduleMetricsCollection()
    }
    
    private fun scheduleMetricsCollection() {
        val executor = Executors.newScheduledThreadPool(1)
        val metricsCollector = SystemMetricsCollector(this)
        
        executor.scheduleAtFixedRate({
            metricsCollector.collectMemoryMetrics()
            metricsCollector.collectCpuMetrics()
        }, 0, 30, TimeUnit.SECONDS)
    }
}

// ProductListActivity.kt
class ProductListActivity : AppCompatActivity() {
    private lateinit var tracer: Tracer
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_product_list)
        
        tracer = MyApplication.getTracer()
        
        // 设置点击监听
        productButton.setOnClickListener { view ->
            trackButtonClick(view, "product_tap")
            loadProductDetail(productId = 123)
        }
    }
    
    private fun loadProductDetail(productId: Int) {
        val span = tracer.spanBuilder("api.product.detail")
            .setSpanKind(SpanKind.CLIENT)
            .setAttribute("product.id", productId.toLong())
            .setAttribute("session.id", SessionManager.getSessionId())
            .startSpan()
        
        lifecycleScope.launch {
            try {
                val response = apiService.getProductDetail(productId)
                
                span.setAttribute(SemanticAttributes.HTTP_STATUS_CODE, 200)
                span.setStatus(StatusCode.OK)
                
                // 更新UI
                updateUI(response)
            } catch (e: Exception) {
                span.recordException(e)
                span.setStatus(StatusCode.ERROR, e.message ?: "Unknown error")
                
                // 显示错误
                showError(e.message)
            } finally {
                span.end()
            }
        }
    }
}
```

---

## 12. 参考资源

### 官方文档

- **OpenTelemetry Swift**: <https://github.com/open-telemetry/opentelemetry-swift>
- **OpenTelemetry Android**: <https://github.com/open-telemetry/opentelemetry-android>
- **Mobile Semantic Conventions**: <https://opentelemetry.io/docs/specs/semconv/mobile/>

### SDK文档

- **Swift API**: <https://opentelemetry.io/docs/instrumentation/swift/>
- **Android API**: <https://opentelemetry.io/docs/instrumentation/android/>
- **Mobile Best Practices**: <https://opentelemetry.io/docs/instrumentation/mobile/best-practices/>

---

**文档维护**: OTLP深度梳理项目组  
**最后更新**: 2025年10月8日  
**文档版本**: v1.0  
**质量等级**: ⭐⭐⭐⭐⭐
