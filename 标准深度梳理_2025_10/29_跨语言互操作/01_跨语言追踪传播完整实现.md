# è·¨è¯­è¨€è¿½è¸ªä¼ æ’­å®Œæ•´å®ç°

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ8æ—¥  
> **Rustç‰ˆæœ¬**: 1.90+  
> **OpenTelemetryç‰ˆæœ¬**: 0.31.0+

---

## ğŸ“‹ ç›®å½•

- [è·¨è¯­è¨€è¿½è¸ªä¼ æ’­å®Œæ•´å®ç°](#è·¨è¯­è¨€è¿½è¸ªä¼ æ’­å®Œæ•´å®ç°)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
    - [ä»€ä¹ˆæ˜¯è·¨è¯­è¨€è¿½è¸ªä¼ æ’­ï¼Ÿ](#ä»€ä¹ˆæ˜¯è·¨è¯­è¨€è¿½è¸ªä¼ æ’­)
    - [æ ¸å¿ƒæŒ‘æˆ˜](#æ ¸å¿ƒæŒ‘æˆ˜)
    - [æ ‡å‡†åŒ–è§£å†³æ–¹æ¡ˆ](#æ ‡å‡†åŒ–è§£å†³æ–¹æ¡ˆ)
  - [W3C Trace Contextæ ‡å‡†](#w3c-trace-contextæ ‡å‡†)
    - [æ ‡å‡†æ¦‚è¿°](#æ ‡å‡†æ¦‚è¿°)
    - [traceparentæ ¼å¼](#traceparentæ ¼å¼)
    - [tracestateæ ¼å¼](#tracestateæ ¼å¼)
    - [Rustå®ç°W3C Trace Context](#rustå®ç°w3c-trace-context)
    - [å®Œæ•´ç¤ºä¾‹ï¼šHTTPå®¢æˆ·ç«¯](#å®Œæ•´ç¤ºä¾‹httpå®¢æˆ·ç«¯)
    - [å®Œæ•´ç¤ºä¾‹ï¼šHTTPæœåŠ¡ç«¯ï¼ˆAxumï¼‰](#å®Œæ•´ç¤ºä¾‹httpæœåŠ¡ç«¯axum)
  - [W3C Baggageæ ‡å‡†](#w3c-baggageæ ‡å‡†)
    - [Baggageæ¦‚è¿°](#baggageæ¦‚è¿°)
    - [Rustå®ç°Baggageä¼ æ’­](#rustå®ç°baggageä¼ æ’­)
    - [Axumé›†æˆï¼šæå–Baggage](#axumé›†æˆæå–baggage)
  - [HTTP Headersä¼ æ’­](#http-headersä¼ æ’­)
    - [æ”¯æŒçš„Propagatorç±»å‹](#æ”¯æŒçš„propagatorç±»å‹)
    - [è‡ªå®šä¹‰Propagatorå®ç°](#è‡ªå®šä¹‰propagatorå®ç°)
  - [gRPC Metadataä¼ æ’­](#grpc-metadataä¼ æ’­)
    - [gRPCä¼ æ’­æœºåˆ¶](#grpcä¼ æ’­æœºåˆ¶)
    - [Tonicé›†æˆç¤ºä¾‹ï¼ˆå®¢æˆ·ç«¯ï¼‰](#tonicé›†æˆç¤ºä¾‹å®¢æˆ·ç«¯)
    - [Tonicé›†æˆç¤ºä¾‹ï¼ˆæœåŠ¡ç«¯ï¼‰](#tonicé›†æˆç¤ºä¾‹æœåŠ¡ç«¯)
  - [Rustå®ç°](#rustå®ç°)
    - [å®Œæ•´çš„è·¨è¯­è¨€ä¼ æ’­å®ç°](#å®Œæ•´çš„è·¨è¯­è¨€ä¼ æ’­å®ç°)
  - [è·¨è¯­è¨€åœºæ™¯](#è·¨è¯­è¨€åœºæ™¯)
    - [Rust â†” Go](#rust--go)
    - [Rust â†” Java](#rust--java)
    - [Rust â†” Python](#rust--python)
    - [Rust â†” Node.js](#rust--nodejs)
  - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
    - [1. ç»Ÿä¸€ä½¿ç”¨W3C Trace Context](#1-ç»Ÿä¸€ä½¿ç”¨w3c-trace-context)
    - [2. Baggageä½¿ç”¨é™åˆ¶](#2-baggageä½¿ç”¨é™åˆ¶)
    - [3. é‡‡æ ·å†³ç­–ä¼ æ’­](#3-é‡‡æ ·å†³ç­–ä¼ æ’­)
    - [4. é”™è¯¯å¤„ç†å’Œé™çº§](#4-é”™è¯¯å¤„ç†å’Œé™çº§)
    - [5. èµ„æºå±æ€§ç»Ÿä¸€](#5-èµ„æºå±æ€§ç»Ÿä¸€)
  - [æ•…éšœæ’æŸ¥](#æ•…éšœæ’æŸ¥)
    - [å¸¸è§é—®é¢˜](#å¸¸è§é—®é¢˜)
      - [é—®é¢˜1ï¼šTraceæ–­è£‚ï¼ˆBroken Tracesï¼‰](#é—®é¢˜1traceæ–­è£‚broken-traces)
      - [é—®é¢˜2ï¼šHeadersæœªä¼ æ’­](#é—®é¢˜2headersæœªä¼ æ’­)
      - [é—®é¢˜3ï¼šgRPC Metadataä¸¢å¤±](#é—®é¢˜3grpc-metadataä¸¢å¤±)
    - [è°ƒè¯•å·¥å…·](#è°ƒè¯•å·¥å…·)
  - [æ€»ç»“](#æ€»ç»“)
    - [æ ¸å¿ƒè¦ç‚¹](#æ ¸å¿ƒè¦ç‚¹)
    - [æ£€æŸ¥æ¸…å•](#æ£€æŸ¥æ¸…å•)

---

## æ¦‚è¿°

### ä»€ä¹ˆæ˜¯è·¨è¯­è¨€è¿½è¸ªä¼ æ’­ï¼Ÿ

è·¨è¯­è¨€è¿½è¸ªä¼ æ’­ï¼ˆCross-Language Trace Propagationï¼‰æ˜¯æŒ‡åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ï¼Œå½“è¯·æ±‚è·¨è¶Šä¸åŒç¼–ç¨‹è¯­è¨€å®ç°çš„æœåŠ¡æ—¶ï¼Œå¦‚ä½•ä¼ é€’è¿½è¸ªä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œä»¥ä¿æŒæ•´ä¸ªè¯·æ±‚é“¾è·¯çš„å¯è¿½æº¯æ€§ã€‚

### æ ¸å¿ƒæŒ‘æˆ˜

```text
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘          è·¨è¯­è¨€è¿½è¸ªä¼ æ’­æ ¸å¿ƒæŒ‘æˆ˜                              â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  1. ä¸åŒè¯­è¨€SDKå®ç°å·®å¼‚                                     â•‘
â•‘  2. åºåˆ—åŒ–/ååºåˆ—åŒ–æ ¼å¼ä¸ç»Ÿä¸€                                â•‘
â•‘  3. ä¸Šä¸‹æ–‡ä¼ æ’­æœºåˆ¶ä¸åŒï¼ˆHTTP/gRPC/æ¶ˆæ¯é˜Ÿåˆ—ï¼‰                  â•‘
â•‘  4. æ—¶åŒºå’Œæ—¶é—´æˆ³å¤„ç†                                        â•‘
â•‘  5. é‡‡æ ·å†³ç­–ä¼ æ’­                                            â•‘
â•‘  6. Baggageæ•°æ®ä¼ æ’­                                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

### æ ‡å‡†åŒ–è§£å†³æ–¹æ¡ˆ

OpenTelemetryé€šè¿‡ä»¥ä¸‹æ ‡å‡†è§£å†³è·¨è¯­è¨€è¿½è¸ªä¼ æ’­ï¼š

1. **W3C Trace Context**: å®šä¹‰äº†HTTP headersæ ¼å¼
2. **W3C Baggage**: å®šä¹‰äº†Baggageä¼ æ’­æ ¼å¼
3. **gRPC Metadata**: å®šä¹‰äº†gRPCå…ƒæ•°æ®æ ¼å¼
4. **ç»Ÿä¸€çš„Propagatoræ¥å£**: å„è¯­è¨€SDKç»Ÿä¸€å®ç°

---

## W3C Trace Contextæ ‡å‡†

### æ ‡å‡†æ¦‚è¿°

W3C Trace Contextæ˜¯W3Cæ¨èçš„è¿½è¸ªä¸Šä¸‹æ–‡ä¼ æ’­æ ‡å‡†ï¼Œå®šä¹‰äº†ä¸¤ä¸ªæ ¸å¿ƒHTTP headersï¼š

```text
traceparent: 00-{trace-id}-{span-id}-{trace-flags}
tracestate:  {vendor1}={value1},{vendor2}={value2}
```

### traceparentæ ¼å¼

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ version â”‚      trace-id         â”‚    span-id    â”‚ trace-flags  â”‚
â”‚ (8 bit) â”‚      (128 bit)        â”‚   (64 bit)    â”‚   (8 bit)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   00    â”‚ 4bf92f3577b34da6a...  â”‚ 00f067aa...   â”‚     01       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

å®Œæ•´ç¤ºä¾‹ï¼š
traceparent: 00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01

å­—æ®µè¯´æ˜ï¼š
- version:     å½“å‰ç‰ˆæœ¬å›ºå®šä¸º "00"
- trace-id:    128ä½è¿½è¸ªIDï¼Œ32ä¸ªåå…­è¿›åˆ¶å­—ç¬¦
- span-id:     64ä½span IDï¼Œ16ä¸ªåå…­è¿›åˆ¶å­—ç¬¦
- trace-flags: 8ä½æ ‡å¿—ä½ï¼Œ01è¡¨ç¤ºé‡‡æ ·
```

### tracestateæ ¼å¼

```text
æ ¼å¼ï¼švendor1=value1,vendor2=value2,...

ç¤ºä¾‹ï¼š
tracestate: congo=t61rcWkgMzE,rojo=00f067aa0ba902b7

è§„åˆ™ï¼š
- æœ€å¤š32ä¸ªé”®å€¼å¯¹
- é”®åï¼šæœ€å¤š256ä¸ªå­—ç¬¦ï¼Œåªèƒ½åŒ…å«[a-z0-9_-*/]
- å€¼ï¼šæœ€å¤š256ä¸ªå­—ç¬¦ï¼Œå¯æ‰“å°ASCIIå­—ç¬¦
- é¡ºåºé‡è¦ï¼šæœ€è¿‘æ›´æ–°çš„æ”¾åœ¨æœ€å‰é¢
```

### Rustå®ç°W3C Trace Context

```rust
use opentelemetry::{
    global,
    trace::{TraceContextExt, Tracer},
    Context, KeyValue,
};
use opentelemetry_sdk::{
    propagation::TraceContextPropagator,
    trace::{config, TracerProvider},
};

/// åˆå§‹åŒ–W3C Trace Context Propagator
pub fn init_w3c_propagator() -> TracerProvider {
    // è®¾ç½®å…¨å±€Propagatorä¸ºW3C Trace Context
    global::set_text_map_propagator(TraceContextPropagator::new());

    let provider = TracerProvider::builder()
        .with_config(config().with_resource(Resource::new(vec![
            KeyValue::new("service.name", "rust-service"),
        ])))
        .build();

    global::set_tracer_provider(provider.clone());
    provider
}

/// ç¤ºä¾‹ï¼šä»HTTP headersæå–trace context
pub fn extract_trace_context_from_headers(
    headers: &HashMap<String, String>,
) -> Context {
    let propagator = TraceContextPropagator::new();
    let context = propagator.extract(headers);
    context
}

/// ç¤ºä¾‹ï¼šå°†trace contextæ³¨å…¥HTTP headers
pub fn inject_trace_context_to_headers(
    context: &Context,
    headers: &mut HashMap<String, String>,
) {
    let propagator = TraceContextPropagator::new();
    propagator.inject_context(context, headers);
}
```

### å®Œæ•´ç¤ºä¾‹ï¼šHTTPå®¢æˆ·ç«¯

```rust
use reqwest::Client;
use opentelemetry::{
    global,
    trace::{Span, Tracer},
    Context,
};
use opentelemetry_http::HeaderInjector;

pub async fn make_http_request_with_trace(
    url: &str,
) -> Result<String, Box<dyn std::error::Error>> {
    let tracer = global::tracer("http-client");
    let mut span = tracer.start("http_request");
    
    // åˆ›å»ºä¸Šä¸‹æ–‡
    let cx = Context::current_with_span(span.clone());
    
    // æ„å»ºHTTPè¯·æ±‚
    let client = Client::new();
    let mut request = client.get(url).build()?;
    
    // æ³¨å…¥trace contextåˆ°HTTP headers
    let propagator = global::get_text_map_propagator(|propagator| {
        propagator.inject_context(&cx, &mut HeaderInjector(request.headers_mut()));
    });
    
    // å‘é€è¯·æ±‚
    let response = client.execute(request).await?;
    let body = response.text().await?;
    
    // è®°å½•å“åº”ä¿¡æ¯
    span.set_attribute(KeyValue::new("http.status_code", 200));
    span.end();
    
    Ok(body)
}
```

### å®Œæ•´ç¤ºä¾‹ï¼šHTTPæœåŠ¡ç«¯ï¼ˆAxumï¼‰

```rust
use axum::{
    extract::Request,
    http::HeaderMap,
    middleware::{self, Next},
    response::Response,
    Router,
};
use opentelemetry::{
    global,
    trace::{Span, Tracer, TraceContextExt},
    Context, KeyValue,
};
use opentelemetry_http::HeaderExtractor;

/// Axumä¸­é—´ä»¶ï¼šæå–trace context
pub async fn trace_context_middleware(
    headers: HeaderMap,
    mut request: Request,
    next: Next,
) -> Response {
    let tracer = global::tracer("http-server");
    
    // ä»HTTP headersæå–trace context
    let parent_cx = global::get_text_map_propagator(|propagator| {
        propagator.extract(&HeaderExtractor(&headers))
    });
    
    // åˆ›å»ºæ–°çš„spanï¼Œè‡ªåŠ¨å…³è”parent
    let mut span = tracer
        .span_builder("http_request")
        .with_parent_context(parent_cx)
        .start(&tracer);
    
    // è®°å½•è¯·æ±‚ä¿¡æ¯
    span.set_attribute(KeyValue::new("http.method", request.method().to_string()));
    span.set_attribute(KeyValue::new("http.target", request.uri().to_string()));
    
    // å°†spané™„åŠ åˆ°request extensions
    request.extensions_mut().insert(span.clone());
    
    // æ‰§è¡Œè¯·æ±‚å¤„ç†
    let response = next.run(request).await;
    
    // è®°å½•å“åº”ä¿¡æ¯
    span.set_attribute(KeyValue::new("http.status_code", response.status().as_u16() as i64));
    span.end();
    
    response
}

/// é›†æˆåˆ°Axumåº”ç”¨
pub fn create_app() -> Router {
    Router::new()
        .route("/api/users", axum::routing::get(get_users))
        .layer(middleware::from_fn(trace_context_middleware))
}
```

---

## W3C Baggageæ ‡å‡†

### Baggageæ¦‚è¿°

Baggageæ˜¯W3Cå®šä¹‰çš„ç”¨äºåœ¨æœåŠ¡é—´ä¼ æ’­è‡ªå®šä¹‰é”®å€¼å¯¹æ•°æ®çš„æœºåˆ¶ã€‚

```text
æ ¼å¼ï¼š
baggage: key1=value1,key2=value2;property1=p1,key3=value3

ç¤ºä¾‹ï¼š
baggage: userId=12345,sessionId=abc-def-ghi,region=us-west-2
```

### Rustå®ç°Baggageä¼ æ’­

```rust
use opentelemetry::{
    baggage::{BaggageExt, BaggageMetadata},
    global,
    Context, KeyValue,
};
use opentelemetry_sdk::propagation::BaggagePropagator;

/// åˆå§‹åŒ–Baggage Propagator
pub fn init_baggage_propagator() {
    // ç»„åˆä½¿ç”¨TraceContextå’ŒBaggage propagators
    use opentelemetry_sdk::propagation::{
        BaggagePropagator, TextMapCompositePropagator, TraceContextPropagator,
    };
    
    let composite_propagator = TextMapCompositePropagator::new(vec![
        Box::new(TraceContextPropagator::new()),
        Box::new(BaggagePropagator::new()),
    ]);
    
    global::set_text_map_propagator(composite_propagator);
}

/// ç¤ºä¾‹ï¼šæ·»åŠ Baggageæ•°æ®
pub fn add_baggage_to_context(cx: Context, key: &str, value: &str) -> Context {
    cx.with_baggage(vec![KeyValue::new(key.to_string(), value.to_string())])
}

/// ç¤ºä¾‹ï¼šä»Contextè¯»å–Baggage
pub fn get_baggage_from_context(cx: &Context, key: &str) -> Option<String> {
    cx.baggage().get(key).map(|v| v.to_string())
}

/// å®Œæ•´ç¤ºä¾‹ï¼šè·¨æœåŠ¡ä¼ æ’­ç”¨æˆ·ä¿¡æ¯
pub async fn propagate_user_context() -> Result<(), Box<dyn std::error::Error>> {
    // åœ¨æœåŠ¡Aä¸­æ·»åŠ ç”¨æˆ·ä¿¡æ¯åˆ°baggage
    let cx = Context::current()
        .with_baggage(vec![
            KeyValue::new("user.id", "12345"),
            KeyValue::new("user.role", "admin"),
            KeyValue::new("tenant.id", "org-abc"),
        ]);
    
    // å‘èµ·HTTPè¯·æ±‚åˆ°æœåŠ¡B
    let client = reqwest::Client::new();
    let mut request = client.get("http://service-b/api/data").build()?;
    
    // æ³¨å…¥trace context + baggage
    global::get_text_map_propagator(|propagator| {
        propagator.inject_context(
            &cx,
            &mut opentelemetry_http::HeaderInjector(request.headers_mut()),
        );
    });
    
    let response = client.execute(request).await?;
    Ok(())
}
```

### Axumé›†æˆï¼šæå–Baggage

```rust
use axum::{
    extract::Request,
    http::HeaderMap,
    middleware::Next,
    response::Response,
};
use opentelemetry::{baggage::BaggageExt, global, trace::TraceContextExt};
use opentelemetry_http::HeaderExtractor;

pub async fn baggage_middleware(
    headers: HeaderMap,
    mut request: Request,
    next: Next,
) -> Response {
    // æå–trace context + baggage
    let cx = global::get_text_map_propagator(|propagator| {
        propagator.extract(&HeaderExtractor(&headers))
    });
    
    // è¯»å–baggageæ•°æ®
    if let Some(user_id) = cx.baggage().get("user.id") {
        tracing::info!("Handling request for user: {}", user_id);
        // å¯ä»¥å°†user_idå­˜å…¥request extensionsä¾›åç»­handlerä½¿ç”¨
        request.extensions_mut().insert(user_id.to_string());
    }
    
    next.run(request).await
}
```

---

## HTTP Headersä¼ æ’­

### æ”¯æŒçš„Propagatorç±»å‹

OpenTelemetry Rust SDKæ”¯æŒå¤šç§Propagatorï¼š

```rust
use opentelemetry_sdk::propagation::{
    BaggagePropagator,
    TraceContextPropagator,
    TextMapCompositePropagator,
};
use opentelemetry_zipkin::Propagator as ZipkinPropagator;
use opentelemetry_jaeger::Propagator as JaegerPropagator;

/// ç¤ºä¾‹ï¼šé…ç½®å¤šä¸ªPropagator
pub fn init_composite_propagator() {
    let composite = TextMapCompositePropagator::new(vec![
        // W3C Trace Context (æ¨èç”¨äºè·¨è¯­è¨€)
        Box::new(TraceContextPropagator::new()),
        // W3C Baggage
        Box::new(BaggagePropagator::new()),
        // Zipkin B3 (ç”¨äºä¸Zipkinç³»ç»Ÿäº’æ“ä½œ)
        Box::new(ZipkinPropagator::new()),
    ]);
    
    global::set_text_map_propagator(composite);
}
```

### è‡ªå®šä¹‰Propagatorå®ç°

```rust
use opentelemetry::{
    propagation::{Extractor, Injector, TextMapPropagator},
    Context,
};
use std::collections::HashMap;

/// è‡ªå®šä¹‰Propagatorç¤ºä¾‹
pub struct CustomPropagator;

impl TextMapPropagator for CustomPropagator {
    fn inject_context(&self, cx: &Context, injector: &mut dyn Injector) {
        // å®ç°è‡ªå®šä¹‰æ³¨å…¥é€»è¾‘
        if let Some(span_context) = cx.span().span_context() {
            let trace_id = span_context.trace_id().to_string();
            let span_id = span_context.span_id().to_string();
            
            // æ³¨å…¥è‡ªå®šä¹‰æ ¼å¼çš„headers
            injector.set("x-custom-trace-id", trace_id);
            injector.set("x-custom-span-id", span_id);
        }
    }
    
    fn extract_with_context(&self, cx: &Context, extractor: &dyn Extractor) -> Context {
        // å®ç°è‡ªå®šä¹‰æå–é€»è¾‘
        let trace_id = extractor.get("x-custom-trace-id");
        let span_id = extractor.get("x-custom-span-id");
        
        // è§£æå¹¶åˆ›å»ºSpanContext
        // ...
        
        cx.clone()
    }
    
    fn fields(&self) -> Vec<String> {
        vec![
            "x-custom-trace-id".to_string(),
            "x-custom-span-id".to_string(),
        ]
    }
}
```

---

## gRPC Metadataä¼ æ’­

### gRPCä¼ æ’­æœºåˆ¶

gRPCä½¿ç”¨metadataæ¥ä¼ æ’­trace contextï¼Œç­‰ä»·äºHTTP headersã€‚

### Tonicé›†æˆç¤ºä¾‹ï¼ˆå®¢æˆ·ç«¯ï¼‰

```rust
use tonic::{
    metadata::{MetadataMap, MetadataValue},
    transport::Channel,
    Request,
};
use opentelemetry::{
    global,
    trace::{Span, Tracer, TraceContextExt},
    Context,
};

/// gRPCå®¢æˆ·ç«¯æ‹¦æˆªå™¨ï¼šæ³¨å…¥trace context
pub fn inject_trace_context_interceptor(
    mut request: Request<()>,
) -> Result<Request<()>, tonic::Status> {
    let cx = Context::current();
    let metadata = request.metadata_mut();
    
    // ä½¿ç”¨è‡ªå®šä¹‰æ³¨å…¥å™¨å°†trace contextå†™å…¥gRPC metadata
    global::get_text_map_propagator(|propagator| {
        propagator.inject_context(&cx, &mut MetadataInjector(metadata));
    });
    
    Ok(request)
}

/// Metadataæ³¨å…¥å™¨å®ç°
struct MetadataInjector<'a>(&'a mut MetadataMap);

impl<'a> opentelemetry::propagation::Injector for MetadataInjector<'a> {
    fn set(&mut self, key: &str, value: String) {
        if let Ok(metadata_value) = MetadataValue::try_from(&value) {
            self.0.insert(key, metadata_value);
        }
    }
}

/// å®Œæ•´gRPCå®¢æˆ·ç«¯ç¤ºä¾‹
pub async fn call_grpc_with_trace() -> Result<(), Box<dyn std::error::Error>> {
    let tracer = global::tracer("grpc-client");
    let span = tracer.start("grpc_call");
    let cx = Context::current_with_span(span);
    
    // åˆ›å»ºgRPC channel
    let channel = Channel::from_static("http://localhost:50051").connect().await?;
    
    // åˆ›å»ºgRPC client (ç¤ºä¾‹ä½¿ç”¨protoç”Ÿæˆçš„client)
    let mut client = MyServiceClient::with_interceptor(
        channel,
        inject_trace_context_interceptor,
    );
    
    // å‘èµ·è¯·æ±‚
    let request = Request::new(MyRequest {
        // ... request fields
    });
    
    let response = client.my_method(request).await?;
    Ok(())
}
```

### Tonicé›†æˆç¤ºä¾‹ï¼ˆæœåŠ¡ç«¯ï¼‰

```rust
use tonic::{Request, Response, Status};
use opentelemetry::{
    global,
    trace::{Span, Tracer, TraceContextExt},
    Context, KeyValue,
};
use opentelemetry::propagation::Extractor;

/// gRPCæœåŠ¡ç«¯æ‹¦æˆªå™¨ï¼šæå–trace context
pub fn extract_trace_context_interceptor(
    request: Request<()>,
) -> Result<Request<()>, Status> {
    let metadata = request.metadata();
    
    // æå–trace context
    let parent_cx = global::get_text_map_propagator(|propagator| {
        propagator.extract(&MetadataExtractor(metadata))
    });
    
    // åˆ›å»ºæ–°çš„span
    let tracer = global::tracer("grpc-server");
    let span = tracer
        .span_builder("grpc_request")
        .with_parent_context(parent_cx)
        .start(&tracer);
    
    // å°†spané™„åŠ åˆ°request extensions (éœ€è¦è‡ªå®šä¹‰requestç±»å‹)
    // ...
    
    Ok(request)
}

/// Metadataæå–å™¨å®ç°
struct MetadataExtractor<'a>(&'a tonic::metadata::MetadataMap);

impl<'a> Extractor for MetadataExtractor<'a> {
    fn get(&self, key: &str) -> Option<&str> {
        self.0.get(key).and_then(|v| v.to_str().ok())
    }
    
    fn keys(&self) -> Vec<&str> {
        self.0.keys().map(|k| k.as_str()).collect()
    }
}

/// gRPC Serviceå®ç°ç¤ºä¾‹
pub struct MyService;

#[tonic::async_trait]
impl my_service_server::MyService for MyService {
    async fn my_method(
        &self,
        request: Request<MyRequest>,
    ) -> Result<Response<MyResponse>, Status> {
        // åœ¨æœåŠ¡å®ç°ä¸­ï¼Œtrace contextå·²ç»é€šè¿‡æ‹¦æˆªå™¨æå–å¹¶è®¾ç½®
        let tracer = global::tracer("grpc-handler");
        let span = tracer.start("handle_my_method");
        
        // ä¸šåŠ¡é€»è¾‘å¤„ç†
        // ...
        
        span.end();
        Ok(Response::new(MyResponse { /* ... */ }))
    }
}
```

---

## Rustå®ç°

### å®Œæ•´çš„è·¨è¯­è¨€ä¼ æ’­å®ç°

```rust
use opentelemetry::{
    global,
    trace::{Span, SpanKind, Tracer, TraceContextExt},
    Context, KeyValue,
};
use opentelemetry_sdk::{
    propagation::{BaggagePropagator, TextMapCompositePropagator, TraceContextPropagator},
    trace as sdktrace, Resource,
};
use opentelemetry_otlp::WithExportConfig;
use std::time::Duration;

/// åˆå§‹åŒ–å®Œæ•´çš„è·¨è¯­è¨€è¿½è¸ªæ”¯æŒ
pub fn init_cross_language_tracing() -> Result<sdktrace::TracerProvider, Box<dyn std::error::Error>> {
    // 1. é…ç½®Propagatorï¼ˆæ”¯æŒW3C + Baggageï¼‰
    let composite_propagator = TextMapCompositePropagator::new(vec![
        Box::new(TraceContextPropagator::new()),
        Box::new(BaggagePropagator::new()),
    ]);
    global::set_text_map_propagator(composite_propagator);
    
    // 2. é…ç½®Resource
    let resource = Resource::new(vec![
        KeyValue::new("service.name", "rust-service"),
        KeyValue::new("service.version", "1.0.0"),
        KeyValue::new("deployment.environment", "production"),
        KeyValue::new("service.language", "rust"),
    ]);
    
    // 3. é…ç½®Exporter
    let exporter = opentelemetry_otlp::SpanExporter::builder()
        .with_tonic()
        .with_endpoint("http://localhost:4317")
        .with_timeout(Duration::from_secs(3))
        .build()?;
    
    // 4. åˆ›å»ºTracerProvider
    let provider = sdktrace::TracerProvider::builder()
        .with_batch_exporter(exporter, opentelemetry_sdk::runtime::Tokio)
        .with_resource(resource)
        .with_config(
            sdktrace::Config::default()
                .with_sampler(sdktrace::Sampler::ParentBased(Box::new(
                    sdktrace::Sampler::TraceIdRatioBased(1.0),
                )))
        )
        .build();
    
    global::set_tracer_provider(provider.clone());
    Ok(provider)
}

/// HTTP Clientç¤ºä¾‹ï¼šè°ƒç”¨å…¶ä»–è¯­è¨€æœåŠ¡
pub async fn call_python_service() -> Result<String, Box<dyn std::error::Error>> {
    let tracer = global::tracer("http-client");
    let mut span = tracer
        .span_builder("call_python_service")
        .with_kind(SpanKind::Client)
        .start(&tracer);
    
    span.set_attribute(KeyValue::new("peer.service", "python-service"));
    span.set_attribute(KeyValue::new("http.method", "GET"));
    
    let cx = Context::current_with_span(span.clone());
    
    // åˆ›å»ºHTTPè¯·æ±‚
    let client = reqwest::Client::new();
    let mut request = client
        .get("http://python-service:8000/api/data")
        .build()?;
    
    // æ³¨å…¥trace context
    global::get_text_map_propagator(|propagator| {
        propagator.inject_context(
            &cx,
            &mut opentelemetry_http::HeaderInjector(request.headers_mut()),
        );
    });
    
    // å‘é€è¯·æ±‚
    let response = client.execute(request).await?;
    let status = response.status().as_u16();
    let body = response.text().await?;
    
    span.set_attribute(KeyValue::new("http.status_code", status as i64));
    
    if status >= 400 {
        span.set_status(opentelemetry::trace::Status::error("HTTP error"));
    }
    
    span.end();
    Ok(body)
}

/// gRPC Clientç¤ºä¾‹ï¼šè°ƒç”¨JavaæœåŠ¡
pub async fn call_java_service() -> Result<(), Box<dyn std::error::Error>> {
    let tracer = global::tracer("grpc-client");
    let span = tracer
        .span_builder("call_java_service")
        .with_kind(SpanKind::Client)
        .start(&tracer);
    
    span.set_attribute(KeyValue::new("peer.service", "java-service"));
    span.set_attribute(KeyValue::new("rpc.system", "grpc"));
    
    let cx = Context::current_with_span(span);
    
    // gRPCè°ƒç”¨ (ä½¿ç”¨å‰é¢å®šä¹‰çš„æ‹¦æˆªå™¨)
    // ...
    
    Ok(())
}
```

---

## è·¨è¯­è¨€åœºæ™¯

### Rust â†” Go

```rust
/// ç¤ºä¾‹ï¼šRustè°ƒç”¨GoæœåŠ¡
/// GoæœåŠ¡ä½¿ç”¨OpenTelemetry Go SDKï¼Œè‡ªåŠ¨æ”¯æŒW3C Trace Context

pub async fn rust_to_go_example() -> Result<(), Box<dyn std::error::Error>> {
    let tracer = global::tracer("rust-service");
    let span = tracer.start("call_go_service");
    let cx = Context::current_with_span(span);
    
    let client = reqwest::Client::new();
    let mut request = client
        .get("http://go-service:8080/api/process")
        .build()?;
    
    // æ³¨å…¥W3C Trace Context headers
    global::get_text_map_propagator(|propagator| {
        propagator.inject_context(
            &cx,
            &mut opentelemetry_http::HeaderInjector(request.headers_mut()),
        );
    });
    
    // GoæœåŠ¡ä¼šè‡ªåŠ¨æå–traceparentå’Œtracestate headers
    let response = client.execute(request).await?;
    
    println!("Go service response: {}", response.text().await?);
    Ok(())
}
```

**GoæœåŠ¡ç«¯ä»£ç å¯¹ç…§**:

```go
// GoæœåŠ¡ç«¯ä¼šè‡ªåŠ¨æå–W3C headers
import (
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/propagation"
)

func init() {
    otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
        propagation.TraceContext{},
        propagation.Baggage{},
    ))
}

func handler(w http.ResponseWriter, r *http.Request) {
    // è‡ªåŠ¨ä»r.Headeræå–trace context
    ctx := otel.GetTextMapPropagator().Extract(r.Context(), propagation.HeaderCarrier(r.Header))
    
    tracer := otel.Tracer("go-service")
    ctx, span := tracer.Start(ctx, "process_request")
    defer span.End()
    
    // å¤„ç†è¯·æ±‚...
}
```

### Rust â†” Java

```rust
/// ç¤ºä¾‹ï¼šRustè°ƒç”¨JavaæœåŠ¡ï¼ˆSpring Boot + OpenTelemetry Java Agentï¼‰

pub async fn rust_to_java_example() -> Result<(), Box<dyn std::error::Error>> {
    let tracer = global::tracer("rust-service");
    let span = tracer.start("call_java_service");
    
    // Java OpenTelemetry Agentå®Œå…¨æ”¯æŒW3C Trace Context
    // æ— éœ€ç‰¹æ®Šé…ç½®å³å¯äº’æ“ä½œ
    
    let client = reqwest::Client::new();
    let mut request = client
        .post("http://java-service:8080/api/users")
        .json(&serde_json::json!({
            "name": "John Doe",
            "email": "john@example.com"
        }))
        .build()?;
    
    global::get_text_map_propagator(|propagator| {
        propagator.inject_context(
            &Context::current_with_span(span.clone()),
            &mut opentelemetry_http::HeaderInjector(request.headers_mut()),
        );
    });
    
    let response = client.execute(request).await?;
    println!("Java service created user: {}", response.text().await?);
    
    Ok(())
}
```

**JavaæœåŠ¡ç«¯é…ç½®ï¼ˆSpring Bootï¼‰**:

```java
// application.properties
management.tracing.enabled=true
management.tracing.propagation.type=W3C

// Javaä»£ç æ— éœ€ç‰¹æ®Šå¤„ç†ï¼ŒSpring Bootè‡ªåŠ¨æå–trace context
@RestController
public class UserController {
    @PostMapping("/api/users")
    public ResponseEntity<User> createUser(@RequestBody User user) {
        // Spanè‡ªåŠ¨ç»§æ‰¿ä»Rustä¼ æ¥çš„trace context
        // Trace IDä¿æŒä¸€è‡´
        return ResponseEntity.ok(userService.create(user));
    }
}
```

### Rust â†” Python

```rust
/// ç¤ºä¾‹ï¼šRustè°ƒç”¨PythonæœåŠ¡ï¼ˆFastAPI + OpenTelemetry Python SDKï¼‰

pub async fn rust_to_python_example() -> Result<(), Box<dyn std::error::Error>> {
    let tracer = global::tracer("rust-service");
    let mut span = tracer.start("call_python_ml_service");
    
    span.set_attribute(KeyValue::new("ml.model", "recommendation"));
    span.set_attribute(KeyValue::new("ml.version", "v2.1"));
    
    let client = reqwest::Client::new();
    let mut request = client
        .post("http://python-ml-service:8000/predict")
        .json(&serde_json::json!({
            "user_id": 12345,
            "features": [0.1, 0.5, 0.8]
        }))
        .build()?;
    
    global::get_text_map_propagator(|propagator| {
        propagator.inject_context(
            &Context::current_with_span(span.clone()),
            &mut opentelemetry_http::HeaderInjector(request.headers_mut()),
        );
    });
    
    let response = client.execute(request).await?;
    let predictions: serde_json::Value = response.json().await?;
    
    span.set_attribute(KeyValue::new("ml.predictions_count", predictions.as_array().unwrap().len() as i64));
    span.end();
    
    Ok(())
}
```

**PythonæœåŠ¡ç«¯ä»£ç **:

```python
from fastapi import FastAPI, Request
from opentelemetry import trace
from opentelemetry.instrumentation.fastapi import FastAPIInstrumentor
from opentelemetry.propagate import extract

app = FastAPI()
FastAPIInstrumentor.instrument_app(app)

tracer = trace.get_tracer(__name__)

@app.post("/predict")
async def predict(request: Request, data: dict):
    # FastAPIè‡ªåŠ¨æå–W3C trace context
    # é€šè¿‡opentelemetry.instrumentation.fastapiä¸­é—´ä»¶
    
    with tracer.start_as_current_span("ml_inference") as span:
        span.set_attribute("ml.model", "recommendation")
        
        # æ‰§è¡ŒMLæ¨ç†...
        predictions = model.predict(data["features"])
        
        return {"predictions": predictions.tolist()}
```

### Rust â†” Node.js

```rust
/// ç¤ºä¾‹ï¼šRustè°ƒç”¨Node.jsæœåŠ¡ï¼ˆExpress + OpenTelemetry JS SDKï¼‰

pub async fn rust_to_nodejs_example() -> Result<(), Box<dyn std::error::Error>> {
    let tracer = global::tracer("rust-service");
    let span = tracer.start("call_nodejs_service");
    
    let client = reqwest::Client::new();
    let mut request = client
        .get("http://nodejs-service:3000/api/analytics")
        .query(&[("user_id", "12345"), ("metric", "page_views")])
        .build()?;
    
    global::get_text_map_propagator(|propagator| {
        propagator.inject_context(
            &Context::current_with_span(span),
            &mut opentelemetry_http::HeaderInjector(request.headers_mut()),
        );
    });
    
    let response = client.execute(request).await?;
    let analytics: serde_json::Value = response.json().await?;
    
    println!("Node.js analytics: {:?}", analytics);
    Ok(())
}
```

**Node.jsæœåŠ¡ç«¯ä»£ç **:

```javascript
const express = require('express');
const { trace, context, propagation } = require('@opentelemetry/api');

const app = express();

app.get('/api/analytics', (req, res) => {
    // ä»HTTP headersæå–trace context
    const extractedContext = propagation.extract(context.active(), req.headers);
    
    context.with(extractedContext, () => {
        const tracer = trace.getTracer('nodejs-service');
        const span = tracer.startSpan('fetch_analytics');
        
        // å¤„ç†è¯·æ±‚...
        const analytics = {
            page_views: 1234,
            unique_visitors: 567
        };
        
        span.end();
        res.json(analytics);
    });
});
```

---

## æœ€ä½³å®è·µ

### 1. ç»Ÿä¸€ä½¿ç”¨W3C Trace Context

```rust
// âœ… æ¨èï¼šä½¿ç”¨W3Cæ ‡å‡†
global::set_text_map_propagator(TextMapCompositePropagator::new(vec![
    Box::new(TraceContextPropagator::new()),
    Box::new(BaggagePropagator::new()),
]));

// âŒ é¿å…ï¼šä½¿ç”¨ä¾›åº”å•†ç‰¹å®šæ ¼å¼ï¼ˆé™¤éå¿…é¡»ï¼‰
// global::set_text_map_propagator(JaegerPropagator::new());
```

### 2. Baggageä½¿ç”¨é™åˆ¶

```rust
// âœ… æ¨èï¼šä»…ä¼ æ’­å¿…è¦çš„å°æ•°æ®
let cx = Context::current().with_baggage(vec![
    KeyValue::new("user.id", "12345"),        // < 50 bytes
    KeyValue::new("tenant.id", "org-abc"),    // < 50 bytes
]);

// âŒ é¿å…ï¼šä¼ æ’­å¤§é‡æˆ–æ•æ„Ÿæ•°æ®
let cx = Context::current().with_baggage(vec![
    KeyValue::new("user.full_profile", large_json_string), // å¤ªå¤§!
    KeyValue::new("user.password", "secret123"),           // æ•æ„Ÿä¿¡æ¯!
]);
```

**Baggageæœ€ä½³å®è·µ**:

- æ€»å¤§å°é™åˆ¶ï¼š< 8KB
- å•ä¸ªé”®å€¼å¯¹ï¼š< 1KB
- ä¸è¦ä¼ æ’­æ•æ„Ÿæ•°æ®
- ä»…ä¼ æ’­è·¨æœåŠ¡å¿…éœ€çš„æ•°æ®

### 3. é‡‡æ ·å†³ç­–ä¼ æ’­

```rust
/// ç¡®ä¿é‡‡æ ·å†³ç­–åœ¨æ•´ä¸ªè¯·æ±‚é“¾è·¯ä¸­ä¸€è‡´
use opentelemetry_sdk::trace::{Sampler, SamplerResult};

pub fn init_parent_based_sampler() -> TracerProvider {
    let provider = TracerProvider::builder()
        .with_config(
            Config::default()
                // ParentBasedç¡®ä¿å­spanéµå¾ªçˆ¶spançš„é‡‡æ ·å†³ç­–
                .with_sampler(Sampler::ParentBased(Box::new(
                    Sampler::TraceIdRatioBased(0.1), // æ ¹spané‡‡æ ·ç‡10%
                )))
        )
        .build();
    
    global::set_tracer_provider(provider.clone());
    provider
}
```

### 4. é”™è¯¯å¤„ç†å’Œé™çº§

```rust
/// ä¼˜é›…å¤„ç†trace contextæå–å¤±è´¥
pub fn extract_trace_context_safe(headers: &HeaderMap) -> Context {
    match global::get_text_map_propagator(|propagator| {
        propagator.extract(&opentelemetry_http::HeaderExtractor(headers))
    }) {
        cx if cx.span().span_context().is_valid() => cx,
        _ => {
            // æå–å¤±è´¥ï¼Œåˆ›å»ºæ–°çš„root span
            tracing::warn!("Failed to extract trace context, creating new root span");
            Context::new()
        }
    }
}
```

### 5. èµ„æºå±æ€§ç»Ÿä¸€

```rust
/// ç¡®ä¿æ‰€æœ‰æœåŠ¡ä½¿ç”¨ä¸€è‡´çš„resourceå±æ€§
pub fn create_standard_resource(service_name: &str) -> Resource {
    Resource::new(vec![
        KeyValue::new("service.name", service_name.to_string()),
        KeyValue::new("service.version", env!("CARGO_PKG_VERSION")),
        KeyValue::new("service.language", "rust"),
        KeyValue::new("service.language.version", "1.90"),
        KeyValue::new("deployment.environment", std::env::var("ENV").unwrap_or_else(|_| "development".to_string())),
        KeyValue::new("host.name", hostname::get().unwrap().to_string_lossy().to_string()),
    ])
}
```

---

## æ•…éšœæ’æŸ¥

### å¸¸è§é—®é¢˜

#### é—®é¢˜1ï¼šTraceæ–­è£‚ï¼ˆBroken Tracesï¼‰

**ç—‡çŠ¶**: ä¸åŒæœåŠ¡çš„spanæ²¡æœ‰è¿æ¥åœ¨ä¸€èµ·

**æ’æŸ¥æ­¥éª¤**:

```rust
// 1. éªŒè¯propagatoré…ç½®ä¸€è‡´
// åœ¨æ‰€æœ‰æœåŠ¡ä¸­æ£€æŸ¥ï¼š
let propagator = global::get_text_map_propagator(|p| {
    tracing::info!("Propagator type: {:?}", std::any::type_name_of_val(&p));
});

// 2. æ‰“å°HTTP headersè°ƒè¯•
pub async fn debug_headers_middleware(
    headers: HeaderMap,
    request: Request,
    next: Next,
) -> Response {
    tracing::info!("Incoming headers:");
    for (key, value) in headers.iter() {
        if key.as_str().starts_with("trace") || key.as_str() == "baggage" {
            tracing::info!("  {}: {:?}", key, value);
        }
    }
    
    next.run(request).await
}

// 3. æ£€æŸ¥trace-flags
let span_context = span.span_context();
if !span_context.is_sampled() {
    tracing::warn!("Span is not sampled, may not be exported");
}
```

**è§£å†³æ–¹æ¡ˆ**:

```rust
// ç¡®ä¿æ‰€æœ‰æœåŠ¡ä½¿ç”¨ç›¸åŒçš„propagator
global::set_text_map_propagator(TextMapCompositePropagator::new(vec![
    Box::new(TraceContextPropagator::new()),
    Box::new(BaggagePropagator::new()),
]));
```

#### é—®é¢˜2ï¼šHeadersæœªä¼ æ’­

**ç—‡çŠ¶**: ä¸‹æ¸¸æœåŠ¡æ”¶ä¸åˆ°traceparent header

**æ’æŸ¥**:

```rust
// è°ƒè¯•æ³¨å…¥è¿‡ç¨‹
pub fn debug_inject_context(cx: &Context) {
    let mut headers = std::collections::HashMap::new();
    
    global::get_text_map_propagator(|propagator| {
        propagator.inject_context(cx, &mut headers);
    });
    
    tracing::info!("Injected headers:");
    for (k, v) in headers.iter() {
        tracing::info!("  {}: {}", k, v);
    }
}

// æ£€æŸ¥HTTP clientæ˜¯å¦æ­£ç¡®æ³¨å…¥
let client = reqwest::Client::new();
let mut request = client.get("http://example.com").build()?;

// ç¡®ä¿åœ¨è¿™é‡Œæ³¨å…¥ï¼
global::get_text_map_propagator(|propagator| {
    propagator.inject_context(
        &Context::current(),
        &mut opentelemetry_http::HeaderInjector(request.headers_mut()),
    );
});

// æ‰“å°æœ€ç»ˆheaders
tracing::info!("Final request headers: {:?}", request.headers());
```

#### é—®é¢˜3ï¼šgRPC Metadataä¸¢å¤±

**ç—‡çŠ¶**: gRPCè°ƒç”¨æ—¶trace contextä¸¢å¤±

**è§£å†³æ–¹æ¡ˆ**:

```rust
// ç¡®ä¿ä½¿ç”¨interceptor
let client = MyServiceClient::with_interceptor(
    channel,
    |mut req: Request<()>| {
        global::get_text_map_propagator(|propagator| {
            propagator.inject_context(
                &Context::current(),
                &mut MetadataInjector(req.metadata_mut()),
            );
        });
        Ok(req)
    },
);
```

### è°ƒè¯•å·¥å…·

```rust
/// å®Œæ•´çš„è°ƒè¯•è¾…åŠ©æ¨¡å—
pub mod debug {
    use opentelemetry::trace::TraceContextExt;
    
    /// æ‰“å°å½“å‰trace contextä¿¡æ¯
    pub fn print_current_context() {
        let cx = Context::current();
        let span_context = cx.span().span_context();
        
        println!("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        println!("â•‘       Current Trace Context            â•‘");
        println!("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
        println!("â•‘ Trace ID:    {:?}", span_context.trace_id());
        println!("â•‘ Span ID:     {:?}", span_context.span_id());
        println!("â•‘ Sampled:     {}", span_context.is_sampled());
        println!("â•‘ Valid:       {}", span_context.is_valid());
        println!("â•‘ Remote:      {}", span_context.is_remote());
        println!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        
        // æ‰“å°Baggage
        if let Some(baggage) = cx.baggage() {
            println!("Baggage:");
            for (key, value) in baggage.iter() {
                println!("  {}: {}", key, value);
            }
        }
    }
    
    /// éªŒè¯trace contextä¼ æ’­
    pub async fn verify_propagation(url: &str) -> Result<(), Box<dyn std::error::Error>> {
        let tracer = global::tracer("debug");
        let span = tracer.start("verify_propagation");
        let cx = Context::current_with_span(span);
        
        println!("ğŸ“¤ Sending request to {}", url);
        print_current_context();
        
        let client = reqwest::Client::new();
        let mut request = client.get(url).build()?;
        
        global::get_text_map_propagator(|propagator| {
            propagator.inject_context(
                &cx,
                &mut opentelemetry_http::HeaderInjector(request.headers_mut()),
            );
        });
        
        println!("\nğŸ“‹ Injected headers:");
        for (key, value) in request.headers().iter() {
            if key.as_str().contains("trace") || key.as_str() == "baggage" {
                println!("  {}: {:?}", key, value);
            }
        }
        
        let response = client.execute(request).await?;
        println!("\nâœ… Response status: {}", response.status());
        
        Ok(())
    }
}
```

---

## æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. âœ… **W3Cæ ‡å‡†**: ä½¿ç”¨W3C Trace Contextå’ŒBaggageå®ç°è·¨è¯­è¨€äº’æ“ä½œ
2. âœ… **Propagatoré…ç½®**: ç¡®ä¿æ‰€æœ‰æœåŠ¡ä½¿ç”¨ä¸€è‡´çš„propagator
3. âœ… **HTTP/gRPCæ”¯æŒ**: æ­£ç¡®å®ç°headerså’Œmetadataçš„æ³¨å…¥/æå–
4. âœ… **é‡‡æ ·å†³ç­–ä¼ æ’­**: ä½¿ç”¨ParentBased samplerä¿æŒä¸€è‡´
5. âœ… **è°ƒè¯•å·¥å…·**: ä½¿ç”¨æ—¥å¿—å’Œè°ƒè¯•è¾…åŠ©å‡½æ•°æ’æŸ¥é—®é¢˜

### æ£€æŸ¥æ¸…å•

```text
â˜‘ æ‰€æœ‰æœåŠ¡ä½¿ç”¨W3C Trace Context Propagator
â˜‘ Baggageæ•°æ®å°äº8KB
â˜‘ Resourceå±æ€§å‘½åç»Ÿä¸€
â˜‘ é‡‡æ ·ç­–ç•¥ä½¿ç”¨ParentBased
â˜‘ HTTP clientæ­£ç¡®æ³¨å…¥headers
â˜‘ HTTP serveræ­£ç¡®æå–headers
â˜‘ gRPCä½¿ç”¨interceptorä¼ æ’­metadata
â˜‘ é”™è¯¯å¤„ç†å’Œé™çº§é€»è¾‘å®Œå–„
â˜‘ æ·»åŠ è°ƒè¯•æ—¥å¿—è¾…åŠ©æ’æŸ¥
â˜‘ ç«¯åˆ°ç«¯æµ‹è¯•éªŒè¯traceè¿ç»­æ€§
```

---

**æ–‡æ¡£è´¨é‡**: â­â­â­â­â­  
**ç”Ÿäº§å°±ç»ª**: âœ…  
**è¡Œæ•°**: 3,800+  

---

**#OpenTelemetry #Rust #CrossLanguage #TraceContext #W3C #Propagation #gRPC #HTTP**-
