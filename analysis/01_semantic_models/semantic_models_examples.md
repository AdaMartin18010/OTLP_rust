# ËØ≠‰πâÊ®°ÂûãÂ∫îÁî®Á§∫‰æã

## üìã ÁõÆÂΩï

- [ËØ≠‰πâÊ®°ÂûãÂ∫îÁî®Á§∫‰æã](#ËØ≠‰πâÊ®°ÂûãÂ∫îÁî®Á§∫‰æã)
  - [üìã ÁõÆÂΩï](#-ÁõÆÂΩï)
  - [Ê¶ÇËø∞](#Ê¶ÇËø∞)
  - [1. Âü∫Á°ÄËØ≠‰πâÊ®°ÂûãÁ§∫‰æã](#1-Âü∫Á°ÄËØ≠‰πâÊ®°ÂûãÁ§∫‰æã)
    - [1.1 ÁÆÄÂçïÁöÑHTTPËØ∑Ê±ÇË∑üË∏™](#11-ÁÆÄÂçïÁöÑhttpËØ∑Ê±ÇË∑üË∏™)
    - [1.2 Êï∞ÊçÆÂ∫ìÊìç‰ΩúË∑üË∏™](#12-Êï∞ÊçÆÂ∫ìÊìç‰ΩúË∑üË∏™)
  - [2. ÂæÆÊúçÂä°ËØ≠‰πâÊ®°ÂûãÁ§∫‰æã](#2-ÂæÆÊúçÂä°ËØ≠‰πâÊ®°ÂûãÁ§∫‰æã)
    - [2.1 Áî®Êà∑ÊúçÂä°](#21-Áî®Êà∑ÊúçÂä°)
    - [2.2 ËÆ¢ÂçïÊúçÂä°](#22-ËÆ¢ÂçïÊúçÂä°)
  - [3. ÊåáÊ†áÂíåÊó•ÂøóËØ≠‰πâÊ®°ÂûãÁ§∫‰æã](#3-ÊåáÊ†áÂíåÊó•ÂøóËØ≠‰πâÊ®°ÂûãÁ§∫‰æã)
    - [3.1 ÊÄßËÉΩÊåáÊ†á](#31-ÊÄßËÉΩÊåáÊ†á)
    - [3.2 ÁªìÊûÑÂåñÊó•Âøó](#32-ÁªìÊûÑÂåñÊó•Âøó)
  - [4. ÂÆåÊï¥Â∫îÁî®Á§∫‰æã](#4-ÂÆåÊï¥Â∫îÁî®Á§∫‰æã)
    - [4.1 ÁîµÂïÜÁ≥ªÁªüÂÆåÊï¥Á§∫‰æã](#41-ÁîµÂïÜÁ≥ªÁªüÂÆåÊï¥Á§∫‰æã)
  - [5. ÊÄªÁªì](#5-ÊÄªÁªì)

## Ê¶ÇËø∞

Êú¨ÊñáÊ°£ÈÄöËøáÂÖ∑‰ΩìÁöÑ‰ª£Á†ÅÁ§∫‰æãÂíåÂÆûÈôÖÂ∫îÁî®Âú∫ÊôØÔºåÂ±ïÁ§∫Â¶Ç‰ΩïÂú®OpenTelemetry Protocol (OTLP)‰∏≠Â∫îÁî®ËØ≠‰πâÊ®°Âûã„ÄÇÊØè‰∏™Á§∫‰æãÈÉΩÂåÖÂê´ÂÆåÊï¥ÁöÑ‰ª£Á†ÅÂÆûÁé∞ÂíåËØ¶ÁªÜËØ¥Êòé„ÄÇ

## 1. Âü∫Á°ÄËØ≠‰πâÊ®°ÂûãÁ§∫‰æã

### 1.1 ÁÆÄÂçïÁöÑHTTPËØ∑Ê±ÇË∑üË∏™

```rust
use opentelemetry::{trace::Tracer, KeyValue};
use opentelemetry_semantic_conventions as semconv;

// ÂàõÂª∫‰∏Ä‰∏™ÁÆÄÂçïÁöÑHTTPËØ∑Ê±ÇË∑üË∏™
pub fn trace_http_request() {
    let tracer = opentelemetry::global::tracer("http-service");
    
    let _span = tracer
        .span_builder("HTTP GET /api/users")
        .with_attributes(vec![
            KeyValue::new(semconv::trace::HTTP_METHOD, "GET"),
            KeyValue::new(semconv::trace::HTTP_URL, "https://api.example.com/api/users"),
            KeyValue::new(semconv::trace::HTTP_ROUTE, "/api/users"),
            KeyValue::new(semconv::trace::HTTP_STATUS_CODE, 200),
            KeyValue::new("user.id", "12345"),
        ])
        .start(&tracer);
    
    // ÊâßË°åHTTPËØ∑Ê±ÇÈÄªËæë
    println!("Â§ÑÁêÜHTTPËØ∑Ê±Ç...");
}
```

### 1.2 Êï∞ÊçÆÂ∫ìÊìç‰ΩúË∑üË∏™

```rust
use opentelemetry::{trace::Tracer, KeyValue};
use opentelemetry_semantic_conventions as semconv;

// ÂàõÂª∫‰∏Ä‰∏™Êï∞ÊçÆÂ∫ìÊü•ËØ¢Ë∑üË∏™
pub fn trace_database_query() {
    let tracer = opentelemetry::global::tracer("database-service");
    
    let _span = tracer
        .span_builder("SELECT users")
        .with_attributes(vec![
            KeyValue::new(semconv::trace::DB_SYSTEM, "postgresql"),
            KeyValue::new(semconv::trace::DB_NAME, "ecommerce"),
            KeyValue::new(semconv::trace::DB_OPERATION, "SELECT"),
            KeyValue::new(semconv::trace::DB_STATEMENT, "SELECT * FROM users WHERE active = true"),
            KeyValue::new(semconv::trace::DB_TABLE, "users"),
        ])
        .start(&tracer);
    
    // ÊâßË°åÊï∞ÊçÆÂ∫ìÊü•ËØ¢ÈÄªËæë
    println!("ÊâßË°åÊï∞ÊçÆÂ∫ìÊü•ËØ¢...");
}
```

## 2. ÂæÆÊúçÂä°ËØ≠‰πâÊ®°ÂûãÁ§∫‰æã

### 2.1 Áî®Êà∑ÊúçÂä°

```rust
use opentelemetry::{trace::Tracer, KeyValue, Context};
use opentelemetry_semantic_conventions as semconv;

pub struct UserService {
    tracer: Tracer,
}

impl UserService {
    pub fn new() -> Self {
        Self {
            tracer: opentelemetry::global::tracer("user-service"),
        }
    }
    
    // Áî®Êà∑Ê≥®ÂÜå
    pub fn register_user(&self, email: &str, password: &str) -> Result<String, String> {
        let span = self.tracer
            .span_builder("user.register")
            .with_attributes(vec![
                KeyValue::new("user.email", email.to_string()),
                KeyValue::new("operation.type", "user_registration"),
                KeyValue::new("service.name", "user-service"),
                KeyValue::new("service.version", "v1.0.0"),
            ])
            .start(&self.tracer);
        
        let _guard = Context::current_with_span(span);
        
        // È™åËØÅËæìÂÖ•
        self.validate_input(email, password)?;
        
        // Ê£ÄÊü•ÈáçÂ§ç
        self.check_duplicate(email)?;
        
        // ÂàõÂª∫Áî®Êà∑
        let user_id = self.create_user(email, password)?;
        
        // ÂèëÈÄÅÊ¨¢ËøéÈÇÆ‰ª∂
        self.send_welcome_email(email)?;
        
        Ok(user_id)
    }
    
    fn validate_input(&self, email: &str, password: &str) -> Result<(), String> {
        let span = self.tracer
            .span_builder("user.validate_input")
            .with_attributes(vec![
                KeyValue::new("validation.type", "input_validation"),
                KeyValue::new("user.email", email.to_string()),
            ])
            .start(&self.tracer);
        
        let _guard = Context::current_with_span(span);
        
        // È™åËØÅÈÄªËæë
        if email.is_empty() || password.is_empty() {
            return Err("ËæìÂÖ•‰∏çËÉΩ‰∏∫Á©∫".to_string());
        }
        
        if !email.contains('@') {
            return Err("ÈÇÆÁÆ±Ê†ºÂºè‰∏çÊ≠£Á°Æ".to_string());
        }
        
        Ok(())
    }
    
    fn check_duplicate(&self, email: &str) -> Result<(), String> {
        let span = self.tracer
            .span_builder("user.check_duplicate")
            .with_attributes(vec![
                KeyValue::new("db.operation", "SELECT"),
                KeyValue::new("db.table", "users"),
                KeyValue::new("user.email", email.to_string()),
            ])
            .start(&self.tracer);
        
        let _guard = Context::current_with_span(span);
        
        // Ê£ÄÊü•ÈáçÂ§çÈÄªËæë
        println!("Ê£ÄÊü•Áî®Êà∑ÊòØÂê¶Â∑≤Â≠òÂú®: {}", email);
        Ok(())
    }
    
    fn create_user(&self, email: &str, password: &str) -> Result<String, String> {
        let span = self.tracer
            .span_builder("user.create")
            .with_attributes(vec![
                KeyValue::new("db.operation", "INSERT"),
                KeyValue::new("db.table", "users"),
                KeyValue::new("user.email", email.to_string()),
            ])
            .start(&self.tracer);
        
        let _guard = Context::current_with_span(span);
        
        // ÂàõÂª∫Áî®Êà∑ÈÄªËæë
        let user_id = format!("user_{}", uuid::Uuid::new_v4());
        println!("ÂàõÂª∫Áî®Êà∑: {} -> {}", email, user_id);
        Ok(user_id)
    }
    
    fn send_welcome_email(&self, email: &str) -> Result<(), String> {
        let span = self.tracer
            .span_builder("email.send_welcome")
            .with_attributes(vec![
                KeyValue::new("email.type", "welcome"),
                KeyValue::new("email.recipient", email.to_string()),
                KeyValue::new("service.name", "email-service"),
            ])
            .start(&self.tracer);
        
        let _guard = Context::current_with_span(span);
        
        // ÂèëÈÄÅÈÇÆ‰ª∂ÈÄªËæë
        println!("ÂèëÈÄÅÊ¨¢ËøéÈÇÆ‰ª∂Âà∞: {}", email);
        Ok(())
    }
}
```

### 2.2 ËÆ¢ÂçïÊúçÂä°

```rust
use opentelemetry::{trace::Tracer, KeyValue, Context};
use opentelemetry_semantic_conventions as semconv;

pub struct OrderService {
    tracer: Tracer,
}

impl OrderService {
    pub fn new() -> Self {
        Self {
            tracer: opentelemetry::global::tracer("order-service"),
        }
    }
    
    // ÂàõÂª∫ËÆ¢Âçï
    pub fn create_order(&self, user_id: &str, items: &[OrderItem]) -> Result<String, String> {
        let span = self.tracer
            .span_builder("order.create")
            .with_attributes(vec![
                KeyValue::new("user.id", user_id.to_string()),
                KeyValue::new("order.item_count", items.len() as i64),
                KeyValue::new("operation.type", "order_creation"),
                KeyValue::new("service.name", "order-service"),
            ])
            .start(&self.tracer);
        
        let _guard = Context::current_with_span(span);
        
        // È™åËØÅËÆ¢Âçï
        self.validate_order(user_id, items)?;
        
        // Ê£ÄÊü•Â∫ìÂ≠ò
        self.check_inventory(items)?;
        
        // ËÆ°ÁÆó‰ª∑Ê†º
        let total_price = self.calculate_price(items)?;
        
        // ÂàõÂª∫ËÆ¢Âçï
        let order_id = self.create_order_record(user_id, items, total_price)?;
        
        // Êõ¥Êñ∞Â∫ìÂ≠ò
        self.update_inventory(items)?;
        
        Ok(order_id)
    }
    
    fn validate_order(&self, user_id: &str, items: &[OrderItem]) -> Result<(), String> {
        let span = self.tracer
            .span_builder("order.validate")
            .with_attributes(vec![
                KeyValue::new("validation.type", "order_validation"),
                KeyValue::new("user.id", user_id.to_string()),
                KeyValue::new("order.item_count", items.len() as i64),
            ])
            .start(&self.tracer);
        
        let _guard = Context::current_with_span(span);
        
        if items.is_empty() {
            return Err("ËÆ¢Âçï‰∏çËÉΩ‰∏∫Á©∫".to_string());
        }
        
        for item in items {
            if item.quantity <= 0 {
                return Err("ÂïÜÂìÅÊï∞ÈáèÂøÖÈ°ªÂ§ß‰∫é0".to_string());
            }
        }
        
        Ok(())
    }
    
    fn check_inventory(&self, items: &[OrderItem]) -> Result<(), String> {
        let span = self.tracer
            .span_builder("inventory.check")
            .with_attributes(vec![
                KeyValue::new("db.operation", "SELECT"),
                KeyValue::new("db.table", "inventory"),
                KeyValue::new("inventory.item_count", items.len() as i64),
            ])
            .start(&self.tracer);
        
        let _guard = Context::current_with_span(span);
        
        for item in items {
            println!("Ê£ÄÊü•Â∫ìÂ≠ò: ÂïÜÂìÅID {}, ÈúÄË¶ÅÊï∞Èáè {}", item.product_id, item.quantity);
        }
        
        Ok(())
    }
    
    fn calculate_price(&self, items: &[OrderItem]) -> Result<f64, String> {
        let span = self.tracer
            .span_builder("order.calculate_price")
            .with_attributes(vec![
                KeyValue::new("calculation.type", "price_calculation"),
                KeyValue::new("order.item_count", items.len() as i64),
            ])
            .start(&self.tracer);
        
        let _guard = Context::current_with_span(span);
        
        let mut total = 0.0;
        for item in items {
            total += item.price * item.quantity as f64;
        }
        
        span.set_attribute(KeyValue::new("order.total_price", total));
        
        Ok(total)
    }
    
    fn create_order_record(&self, user_id: &str, items: &[OrderItem], total_price: f64) -> Result<String, String> {
        let span = self.tracer
            .span_builder("order.create_record")
            .with_attributes(vec![
                KeyValue::new("db.operation", "INSERT"),
                KeyValue::new("db.table", "orders"),
                KeyValue::new("user.id", user_id.to_string()),
                KeyValue::new("order.total_price", total_price),
            ])
            .start(&self.tracer);
        
        let _guard = Context::current_with_span(span);
        
        let order_id = format!("order_{}", uuid::Uuid::new_v4());
        println!("ÂàõÂª∫ËÆ¢ÂçïËÆ∞ÂΩï: {} -> {}", user_id, order_id);
        Ok(order_id)
    }
    
    fn update_inventory(&self, items: &[OrderItem]) -> Result<(), String> {
        let span = self.tracer
            .span_builder("inventory.update")
            .with_attributes(vec![
                KeyValue::new("db.operation", "UPDATE"),
                KeyValue::new("db.table", "inventory"),
                KeyValue::new("inventory.item_count", items.len() as i64),
            ])
            .start(&self.tracer);
        
        let _guard = Context::current_with_span(span);
        
        for item in items {
            println!("Êõ¥Êñ∞Â∫ìÂ≠ò: ÂïÜÂìÅID {}, ÂáèÂ∞ëÊï∞Èáè {}", item.product_id, item.quantity);
        }
        
        Ok(())
    }
}

#[derive(Debug, Clone)]
pub struct OrderItem {
    pub product_id: String,
    pub quantity: u32,
    pub price: f64,
}
```

## 3. ÊåáÊ†áÂíåÊó•ÂøóËØ≠‰πâÊ®°ÂûãÁ§∫‰æã

### 3.1 ÊÄßËÉΩÊåáÊ†á

```rust
use opentelemetry::{metrics::Meter, KeyValue};
use opentelemetry_semantic_conventions as semconv;

pub struct PerformanceMetrics {
    meter: Meter,
    request_duration: opentelemetry::metrics::Histogram<f64>,
    request_count: opentelemetry::metrics::Counter<u64>,
    error_count: opentelemetry::metrics::Counter<u64>,
}

impl PerformanceMetrics {
    pub fn new() -> Self {
        let meter = opentelemetry::global::meter("performance-metrics");
        
        Self {
            request_duration: meter
                .f64_histogram("http_request_duration")
                .with_description("HTTPËØ∑Ê±ÇÊåÅÁª≠Êó∂Èó¥")
                .with_unit("ms")
                .init(),
            
            request_count: meter
                .u64_counter("http_requests_total")
                .with_description("HTTPËØ∑Ê±ÇÊÄªÊï∞")
                .init(),
            
            error_count: meter
                .u64_counter("http_errors_total")
                .with_description("HTTPÈîôËØØÊÄªÊï∞")
                .init(),
        }
    }
    
    // ËÆ∞ÂΩïHTTPËØ∑Ê±ÇÊåáÊ†á
    pub fn record_http_request(&self, method: &str, route: &str, status_code: u16, duration_ms: f64) {
        let attributes = vec![
            KeyValue::new(semconv::trace::HTTP_METHOD, method.to_string()),
            KeyValue::new(semconv::trace::HTTP_ROUTE, route.to_string()),
            KeyValue::new(semconv::trace::HTTP_STATUS_CODE, status_code as i64),
            KeyValue::new("service.name", "api-service".to_string()),
        ];
        
        // ËÆ∞ÂΩïËØ∑Ê±ÇÊåÅÁª≠Êó∂Èó¥
        self.request_duration.record(duration_ms, &attributes);
        
        // ËÆ∞ÂΩïËØ∑Ê±ÇËÆ°Êï∞
        self.request_count.add(1, &attributes);
        
        // Â¶ÇÊûúÊòØÈîôËØØÁä∂ÊÄÅÁ†ÅÔºåËÆ∞ÂΩïÈîôËØØËÆ°Êï∞
        if status_code >= 400 {
            self.error_count.add(1, &attributes);
        }
    }
    
    // ËÆ∞ÂΩïÊï∞ÊçÆÂ∫ìÊìç‰ΩúÊåáÊ†á
    pub fn record_db_operation(&self, operation: &str, table: &str, duration_ms: f64, success: bool) {
        let attributes = vec![
            KeyValue::new(semconv::trace::DB_OPERATION, operation.to_string()),
            KeyValue::new(semconv::trace::DB_TABLE, table.to_string()),
            KeyValue::new("db.success", success),
            KeyValue::new("service.name", "database-service".to_string()),
        ];
        
        // ËÆ∞ÂΩïÊï∞ÊçÆÂ∫ìÊìç‰ΩúÊåÅÁª≠Êó∂Èó¥
        self.request_duration.record(duration_ms, &attributes);
        
        // ËÆ∞ÂΩïÊìç‰ΩúËÆ°Êï∞
        self.request_count.add(1, &attributes);
        
        // Â¶ÇÊûúÊìç‰ΩúÂ§±Ë¥•ÔºåËÆ∞ÂΩïÈîôËØØËÆ°Êï∞
        if !success {
            self.error_count.add(1, &attributes);
        }
    }
}
```

### 3.2 ÁªìÊûÑÂåñÊó•Âøó

```rust
use opentelemetry::{trace::Tracer, KeyValue};
use serde_json::{json, Value};

pub struct StructuredLogger {
    tracer: Tracer,
}

impl StructuredLogger {
    pub fn new() -> Self {
        Self {
            tracer: opentelemetry::global::tracer("structured-logger"),
        }
    }
    
    // ËÆ∞ÂΩï‰ø°ÊÅØÊó•Âøó
    pub fn info(&self, message: &str, attributes: Vec<KeyValue>) {
        let span = self.tracer
            .span_builder("log.info")
            .with_attributes(attributes.clone())
            .start(&self.tracer);
        
        let _guard = opentelemetry::Context::current_with_span(span);
        
        let log_data = json!({
            "level": "INFO",
            "message": message,
            "timestamp": chrono::Utc::now().to_rfc3339(),
            "attributes": self.attributes_to_json(attributes),
        });
        
        println!("{}", serde_json::to_string_pretty(&log_data).unwrap());
    }
    
    // ËÆ∞ÂΩïÈîôËØØÊó•Âøó
    pub fn error(&self, message: &str, error: &str, attributes: Vec<KeyValue>) {
        let span = self.tracer
            .span_builder("log.error")
            .with_attributes(attributes.clone())
            .start(&self.tracer);
        
        let _guard = opentelemetry::Context::current_with_span(span);
        
        let log_data = json!({
            "level": "ERROR",
            "message": message,
            "error": error,
            "timestamp": chrono::Utc::now().to_rfc3339(),
            "attributes": self.attributes_to_json(attributes),
        });
        
        eprintln!("{}", serde_json::to_string_pretty(&log_data).unwrap());
    }
    
    // ËÆ∞ÂΩï‰∏öÂä°‰∫ã‰ª∂Êó•Âøó
    pub fn business_event(&self, event_type: &str, user_id: &str, details: Value) {
        let attributes = vec![
            KeyValue::new("event.type", event_type.to_string()),
            KeyValue::new("user.id", user_id.to_string()),
            KeyValue::new("service.name", "business-service".to_string()),
        ];
        
        let span = self.tracer
            .span_builder("business.event")
            .with_attributes(attributes.clone())
            .start(&self.tracer);
        
        let _guard = opentelemetry::Context::current_with_span(span);
        
        let log_data = json!({
            "level": "INFO",
            "event_type": event_type,
            "user_id": user_id,
            "details": details,
            "timestamp": chrono::Utc::now().to_rfc3339(),
            "attributes": self.attributes_to_json(attributes),
        });
        
        println!("{}", serde_json::to_string_pretty(&log_data).unwrap());
    }
    
    fn attributes_to_json(&self, attributes: Vec<KeyValue>) -> Value {
        let mut map = serde_json::Map::new();
        
        for attr in attributes {
            let value = match attr.value {
                opentelemetry::Value::String(s) => Value::String(s),
                opentelemetry::Value::Bool(b) => Value::Bool(b),
                opentelemetry::Value::I64(i) => Value::Number(i.into()),
                opentelemetry::Value::F64(f) => Value::Number(serde_json::Number::from_f64(f).unwrap_or(0.into())),
                opentelemetry::Value::Array(_) => Value::Null, // ÁÆÄÂåñÂ§ÑÁêÜ
            };
            map.insert(attr.key.to_string(), value);
        }
        
        Value::Object(map)
    }
}
```

## 4. ÂÆåÊï¥Â∫îÁî®Á§∫‰æã

### 4.1 ÁîµÂïÜÁ≥ªÁªüÂÆåÊï¥Á§∫‰æã

```rust
use opentelemetry::{trace::Tracer, KeyValue, Context};
use opentelemetry_semantic_conventions as semconv;

pub struct ECommerceSystem {
    user_service: UserService,
    order_service: OrderService,
    performance_metrics: PerformanceMetrics,
    logger: StructuredLogger,
}

impl ECommerceSystem {
    pub fn new() -> Self {
        Self {
            user_service: UserService::new(),
            order_service: OrderService::new(),
            performance_metrics: PerformanceMetrics::new(),
            logger: StructuredLogger::new(),
        }
    }
    
    // Â§ÑÁêÜÁî®Êà∑Ë¥≠‰π∞ÊµÅÁ®ã
    pub fn process_user_purchase(&self, user_id: &str, product_id: &str, quantity: u32) -> Result<String, String> {
        let tracer = opentelemetry::global::tracer("ecommerce-system");
        
        let span = tracer
            .span_builder("ecommerce.purchase")
            .with_attributes(vec![
                KeyValue::new("user.id", user_id.to_string()),
                KeyValue::new("product.id", product_id.to_string()),
                KeyValue::new("order.quantity", quantity as i64),
                KeyValue::new("business.operation", "user_purchase"),
            ])
            .start(&tracer);
        
        let _guard = Context::current_with_span(span);
        
        // ËÆ∞ÂΩï‰∏öÂä°‰∫ã‰ª∂
        self.logger.business_event(
            "purchase_started",
            user_id,
            json!({
                "product_id": product_id,
                "quantity": quantity
            })
        );
        
        // 1. È™åËØÅÁî®Êà∑
        self.validate_user(user_id)?;
        
        // 2. Ê£ÄÊü•ÂïÜÂìÅ
        let product_price = self.check_product(product_id, quantity)?;
        
        // 3. ÂàõÂª∫ËÆ¢Âçï
        let order_items = vec![OrderItem {
            product_id: product_id.to_string(),
            quantity,
            price: product_price,
        }];
        
        let order_id = self.order_service.create_order(user_id, &order_items)?;
        
        // 4. Â§ÑÁêÜÊîØ‰ªò
        self.process_payment(user_id, order_id, product_price * quantity as f64)?;
        
        // ËÆ∞ÂΩïÊàêÂäü‰∫ã‰ª∂
        self.logger.business_event(
            "purchase_completed",
            user_id,
            json!({
                "order_id": order_id,
                "product_id": product_id,
                "quantity": quantity,
                "total_price": product_price * quantity as f64
            })
        );
        
        Ok(order_id)
    }
    
    fn validate_user(&self, user_id: &str) -> Result<(), String> {
        let span = self.tracer
            .span_builder("user.validate")
            .with_attributes(vec![
                KeyValue::new("user.id", user_id.to_string()),
                KeyValue::new("validation.type", "user_validation"),
            ])
            .start(&self.tracer);
        
        let _guard = Context::current_with_span(span);
        
        // È™åËØÅÁî®Êà∑ÈÄªËæë
        println!("È™åËØÅÁî®Êà∑: {}", user_id);
        Ok(())
    }
    
    fn check_product(&self, product_id: &str, quantity: u32) -> Result<f64, String> {
        let span = self.tracer
            .span_builder("product.check")
            .with_attributes(vec![
                KeyValue::new("product.id", product_id.to_string()),
                KeyValue::new("product.quantity", quantity as i64),
                KeyValue::new("db.operation", "SELECT"),
                KeyValue::new("db.table", "products"),
            ])
            .start(&self.tracer);
        
        let _guard = Context::current_with_span(span);
        
        // Ê£ÄÊü•ÂïÜÂìÅÈÄªËæë
        let price = 99.99; // Ê®°Êãü‰ª∑Ê†º
        println!("Ê£ÄÊü•ÂïÜÂìÅ: {} Êï∞Èáè: {} ‰ª∑Ê†º: {}", product_id, quantity, price);
        Ok(price)
    }
    
    fn process_payment(&self, user_id: &str, order_id: &str, amount: f64) -> Result<(), String> {
        let span = self.tracer
            .span_builder("payment.process")
            .with_attributes(vec![
                KeyValue::new("user.id", user_id.to_string()),
                KeyValue::new("order.id", order_id.to_string()),
                KeyValue::new("payment.amount", amount),
                KeyValue::new("payment.method", "credit_card"),
            ])
            .start(&self.tracer);
        
        let _guard = Context::current_with_span(span);
        
        // Â§ÑÁêÜÊîØ‰ªòÈÄªËæë
        println!("Â§ÑÁêÜÊîØ‰ªò: Áî®Êà∑ {} ËÆ¢Âçï {} ÈáëÈ¢ù {}", user_id, order_id, amount);
        Ok(())
    }
}

// ‰∏ªÂáΩÊï∞Á§∫‰æã
fn main() -> Result<(), Box<dyn std::error::Error>> {
    // ÂàùÂßãÂåñOpenTelemetry
    let _tracer = opentelemetry::global::tracer("ecommerce-app");
    
    // ÂàõÂª∫ÁîµÂïÜÁ≥ªÁªü
    let ecommerce = ECommerceSystem::new();
    
    // Â§ÑÁêÜÁî®Êà∑Ë¥≠‰π∞
    let result = ecommerce.process_user_purchase("user123", "product456", 2);
    
    match result {
        Ok(order_id) => println!("ËÆ¢ÂçïÂàõÂª∫ÊàêÂäü: {}", order_id),
        Err(error) => println!("ËÆ¢ÂçïÂàõÂª∫Â§±Ë¥•: {}", error),
    }
    
    Ok(())
}
```

## 5. ÊÄªÁªì

ÈÄöËøáËøô‰∫õÂÖ∑‰ΩìÁöÑ‰ª£Á†ÅÁ§∫‰æãÔºåÊàë‰ª¨ÂèØ‰ª•ÁúãÂà∞ËØ≠‰πâÊ®°ÂûãÂú®ÂÆûÈôÖÂ∫îÁî®‰∏≠ÁöÑ‰ª∑ÂÄºÔºö

1. **Ê∏ÖÊô∞ÁöÑË∑üË∏™**: ÊØè‰∏™Êìç‰ΩúÈÉΩÊúâÊòéÁ°ÆÁöÑËØ≠‰πâÊ†áÁ≠æÔºå‰æø‰∫éÁêÜËß£ÂíåË∞ÉËØï
2. **Áªü‰∏ÄÁöÑÊ†ºÂºè**: ÊâÄÊúâÊúçÂä°‰ΩøÁî®Áõ∏ÂêåÁöÑËØ≠‰πâÁ∫¶ÂÆöÔºåÁ°Æ‰øùÊï∞ÊçÆ‰∏ÄËá¥ÊÄß
3. **‰∏∞ÂØåÁöÑ‰∏ä‰∏ãÊñá**: ÈÄöËøáÂ±ûÊÄßÊèê‰æõ‰∏∞ÂØåÁöÑ‰∏ä‰∏ãÊñá‰ø°ÊÅØ
4. **Ëá™Âä®ÂåñÂàÜÊûê**: Á≥ªÁªüÂèØ‰ª•Ëá™Âä®ËØÜÂà´ÂíåÂàÜÊûê‰∏çÂêåÁ±ªÂûãÁöÑÊìç‰Ωú

Âú®ÂÆûÈôÖÈ°πÁõÆ‰∏≠ÔºåÂª∫ËÆÆÔºö

1. ‰ªéÁÆÄÂçïÁöÑËØ≠‰πâÊ®°ÂûãÂºÄÂßã
2. ÈÄêÊ≠•Êâ©Â±ïÂà∞Êõ¥Â§çÊùÇÁöÑÂú∫ÊôØ
3. ÈÅµÂæ™OpenTelemetryÁöÑÊ†áÂáÜËØ≠‰πâÁ∫¶ÂÆö
4. Ê†πÊçÆ‰∏öÂä°ÈúÄÊ±ÇÂÆöÂà∂ËØ≠‰πâÊ†áÁ≠æ

---

*Êú¨ÊñáÊ°£ÈÄöËøáÂÖ∑‰ΩìÁöÑ‰ª£Á†ÅÁ§∫‰æãÂ±ïÁ§∫‰∫ÜËØ≠‰πâÊ®°ÂûãÁöÑÂÆûÈôÖÂ∫îÁî®ÔºåÂ∏ÆÂä©ÂºÄÂèëËÄÖÊõ¥Â•ΩÂú∞ÁêÜËß£ÂíåÂÆûÁé∞ËØ≠‰πâÊ®°Âûã„ÄÇ*
