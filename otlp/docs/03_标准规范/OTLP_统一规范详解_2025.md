# OpenTelemetry Protocol (OTLP) 统一规范详解

## 📊 OTLP规范概览

**创建时间**: 2025年1月27日  
**文档版本**: 2.0.0  
**维护者**: OpenTelemetry 2025 标准团队  
**状态**: 统一整合版本  
**整合来源**: 合并了多个重复的规范文档

> 权威来源与实现对齐
>
> - 权威定义入口：本文件（统一规范详解）
> - 代码映射（Spec ↔ Code）：参见 `docs/OTLP_2025_COMPREHENSIVE_DOCUMENTATION_INDEX.md` 的“规范-实现对齐矩阵”章节
> - 源码跳转：`otlp/src/data.rs`、`otlp/src/transport.rs`、`otlp/src/protobuf.rs`、`otlp/src/exporter.rs`、`otlp/src/processor.rs`、`otlp/src/config.rs`

## 🎯 OTLP规范目标

### 主要目标

1. **协议标准化**: 建立统一的遥测数据协议
2. **数据模型**: 定义标准的数据模型
3. **传输协议**: 支持多种传输协议
4. **互操作性**: 确保系统间互操作性
5. **版本兼容**: 保证向后兼容性

### 成功标准

- **协议完整性**: 100%完整
- **数据模型**: 标准化
- **传输支持**: 多协议支持
- **互操作性**: 完全互操作
- **兼容性**: 向后兼容保证

## 🏗️ OTLP协议架构

### 协议层次

```text
应用层
├── 遥测数据 (Traces, Metrics, Logs)
├── 资源信息 (Resource)
└── 属性信息 (Attributes)

协议层
├── OTLP协议定义
├── 数据序列化
└── 消息格式

传输层
├── gRPC传输
├── HTTP传输
└── 其他传输协议

网络层
├── TCP/IP
├── TLS/SSL
└── 其他网络协议
```

### 核心特性

```text
OTLP 协议特性
├── 标准化数据格式
│   ├── Protocol Buffers 定义
│   ├── 跨语言支持
│   ├── 版本化兼容
│   └── 向后兼容保证
├── 多传输协议支持
│   ├── gRPC 传输
│   ├── HTTP/1.1 传输
│   ├── HTTP/2 传输
│   └── 自定义传输协议
├── 数据类型支持
│   ├── 追踪数据 (Traces)
│   ├── 指标数据 (Metrics)
│   └── 日志数据 (Logs)
└── 高级特性
    ├── 压缩支持
    ├── 重试机制
    ├── 流控制
    └── 安全认证
```

## 📋 数据模型详解

### 1. 追踪数据 (Traces)

#### 基本结构

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TraceData {
    /// 追踪ID - 全局唯一标识
    pub trace_id: String,
    /// 跨度ID - 操作唯一标识
    pub span_id: String,
    /// 父跨度ID - 用于构建调用链
    pub parent_span_id: Option<String>,
    /// 操作名称
    pub name: String,
    /// 跨度类型
    pub span_kind: SpanKind,
    /// 开始时间
    pub start_time: u64,
    /// 结束时间
    pub end_time: u64,
    /// 状态信息
    pub status: SpanStatus,
    /// 属性集合
    pub attributes: HashMap<String, AttributeValue>,
    /// 事件列表
    pub events: Vec<SpanEvent>,
    /// 链接列表
    pub links: Vec<SpanLink>,
}
```

#### 跨度类型

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SpanKind {
    /// 内部跨度 - 服务内部操作
    Internal,
    /// 服务器跨度 - 接收请求
    Server,
    /// 客户端跨度 - 发送请求
    Client,
    /// 生产者跨度 - 消息生产
    Producer,
    /// 消费者跨度 - 消息消费
    Consumer,
}
```

### 2. 指标数据 (Metrics)

#### 基本结构2

```rust
#[derive(Debug, Clone)]
pub struct MetricData {
    /// 指标名称
    pub name: String,
    /// 指标描述
    pub description: String,
    /// 指标单位
    pub unit: String,
    /// 指标类型
    pub metric_type: MetricType,
    /// 数据点集合
    pub data_points: Vec<DataPoint>,
}
```

#### 指标类型2

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum MetricType {
    /// 计数器 - 单调递增的数值
    Counter,
    /// 仪表 - 可增可减的数值
    Gauge,
    /// 直方图 - 数值分布统计
    Histogram,
    /// 摘要 - 分位数统计
    Summary,
}
```

### 3. 日志数据 (Logs)

#### 基本结构3

```rust
#[derive(Debug, Clone)]
pub struct LogData {
    /// 时间戳
    pub timestamp: u64,
    /// 严重程度
    pub severity: LogSeverity,
    /// 严重程度文本
    pub severity_text: String,
    /// 日志消息
    pub message: String,
    /// 属性集合
    pub attributes: HashMap<String, AttributeValue>,
    /// 资源属性
    pub resource_attributes: HashMap<String, AttributeValue>,
    /// 关联的追踪ID
    pub trace_id: Option<String>,
    /// 关联的跨度ID
    pub span_id: Option<String>,
}
```

## 🌐 传输协议详解

### 1. gRPC传输

#### 配置示例

```rust
pub struct GrpcTransport {
    config: OtlpConfig,
    client: Option<tonic::transport::Channel>,
    compression_utils: CompressionUtils,
}

impl GrpcTransport {
    pub fn new(config: OtlpConfig) -> Self {
        Self {
            config,
            client: None,
            compression_utils: CompressionUtils::new(),
        }
    }
    
    pub async fn initialize(&mut self) -> Result<()> {
        let endpoint = self.config.endpoint.clone();
        let channel = tonic::transport::Channel::from_shared(endpoint)?
            .connect()
            .await?;
        
        self.client = Some(channel);
        Ok(())
    }
}
```

#### 性能特性

- **默认端口**: 4317
- **压缩支持**: gzip默认
- **流控制**: 内置back-pressure
- **性能基准**: 200k spans/s

### 2. HTTP传输

#### 配置示例2

```rust
pub struct HttpTransport {
    config: OtlpConfig,
    client: reqwest::Client,
    compression_utils: CompressionUtils,
}

impl HttpTransport {
    pub fn new(config: OtlpConfig) -> Self {
        let client = reqwest::Client::builder()
            .timeout(config.timeout)
            .build()
            .expect("Failed to create HTTP client");
        
        Self {
            config,
            client,
            compression_utils: CompressionUtils::new(),
        }
    }
}
```

#### 性能特性2

- **默认端口**: 4318
- **格式支持**: Protobuf over HTTP
- **防火墙友好**: 复用80/443端口
- **性能基准**: 60k spans/s

## ⚙️ 配置管理

### 基础配置

```rust
#[derive(Debug, Clone)]
pub struct OtlpConfig {
    /// 服务端点
    pub endpoint: String,
    /// 传输协议
    pub protocol: TransportProtocol,
    /// 连接超时
    pub timeout: Duration,
    /// 重试次数
    pub retry_count: usize,
    /// 批处理配置
    pub batch_config: BatchConfig,
    /// 压缩算法
    pub compression: CompressionAlgorithm,
    /// 认证配置
    pub auth: Option<AuthConfig>,
    /// TLS配置
    pub tls: TlsConfig,
    /// 采样配置
    pub sampling: SamplingConfig,
}
```

### 环境特定配置

```rust
impl OtlpConfig {
    /// 开发环境配置
    pub fn for_development() -> Self {
        Self {
            endpoint: "http://localhost:4317".to_string(),
            protocol: TransportProtocol::Grpc,
            timeout: Duration::from_secs(5),
            retry_count: 3,
            batch_config: BatchConfig::default(),
            compression: CompressionAlgorithm::Gzip,
            auth: None,
            tls: TlsConfig::disabled(),
            sampling: SamplingConfig::ratio(1.0),
        }
    }
    
    /// 生产环境配置
    pub fn for_production() -> Self {
        Self {
            endpoint: "https://otlp-collector.company.com".to_string(),
            protocol: TransportProtocol::Grpc,
            timeout: Duration::from_secs(30),
            retry_count: 5,
            batch_config: BatchConfig::high_throughput(),
            compression: CompressionAlgorithm::Zstd,
            auth: Some(AuthConfig::with_api_key("production-key")),
            tls: TlsConfig::enabled(),
            sampling: SamplingConfig::adaptive(0.01),
        }
    }
}
```

## 🔧 高级特性

### 1. 压缩支持

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CompressionAlgorithm {
    /// 无压缩
    None,
    /// Gzip压缩 - 通用压缩算法
    Gzip,
    /// Brotli压缩 - 高效压缩算法
    Brotli,
    /// Zstd压缩 - 快速压缩算法
    Zstd,
}
```

### 2. 重试机制

```rust
pub struct RetryConfig {
    /// 最大重试次数
    pub max_retries: usize,
    /// 初始退避时间
    pub initial_backoff: Duration,
    /// 最大退避时间
    pub max_backoff: Duration,
    /// 退避乘数
    pub backoff_multiplier: f64,
    /// 抖动因子
    pub jitter_factor: f64,
}
```

### 3. 采样控制

```rust
pub struct SamplingConfig {
    /// 采样比例
    pub ratio: f64,
    /// 采样策略
    pub strategy: SamplingStrategy,
    /// 动态调整
    pub adaptive: bool,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SamplingStrategy {
    /// 固定比例采样
    Fixed,
    /// 自适应采样
    Adaptive,
    /// 基于规则的采样
    RuleBased,
}
```

## 🚀 使用示例

### 基础使用

```rust
use otlp::{OtlpClient, OtlpConfig};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 创建配置
    let config = OtlpConfig::for_development()
        .with_endpoint("http://localhost:4317")
        .with_service("my-service", "1.0.0");
    
    // 创建客户端
    let client = OtlpClient::new(config).await?;
    client.initialize().await?;
    
    // 发送追踪数据
    let result = client.send_trace("example-operation").await?
        .with_attribute("service.name", "my-service")
        .with_attribute("operation.type", "database")
        .finish()
        .await?;
    
    println!("发送成功: {} 条", result.success_count);
    
    client.shutdown().await?;
    Ok(())
}
```

### 高级配置

```rust
// 高吞吐量配置
let config = OtlpConfig::for_production()
    .with_endpoint("https://api.honeycomb.io:443")
    .with_protocol(TransportProtocol::Grpc)
    .with_compression(CompressionAlgorithm::Zstd)
    .with_sampling_ratio(0.1)
    .with_batch_config(BatchConfig {
        max_export_batch_size: 1000,
        export_timeout: Duration::from_millis(5000),
        max_queue_size: 10000,
        scheduled_delay: Duration::from_millis(1000),
    })
    .with_auth(AuthConfig::with_api_key("your-api-key"))
    .with_tls(TlsConfig::enabled());
```

### 批量处理

```rust
// 批量发送数据
async fn send_batch_data(client: &OtlpClient) -> Result<()> {
    let mut batch = Vec::new();
    
    for i in 0..1000 {
        let data = TelemetryData::trace(format!("operation-{}", i))
            .with_attribute("batch_id", "batch-001")
            .with_attribute("index", i.to_string());
        batch.push(data);
    }
    
    let result = client.send_batch(batch).await?;
    println!("批量发送成功: {} 条", result.success_count);
    
    Ok(())
}
```

## 📊 性能优化

### 1. 批处理优化

```rust
pub struct BatchConfig {
    /// 最大批处理大小
    pub max_export_batch_size: usize,
    /// 导出超时时间
    pub export_timeout: Duration,
    /// 最大队列大小
    pub max_queue_size: usize,
    /// 调度延迟
    pub scheduled_delay: Duration,
}

impl BatchConfig {
    /// 低延迟配置
    pub fn low_latency() -> Self {
        Self {
            max_export_batch_size: 10,
            export_timeout: Duration::from_millis(10),
            max_queue_size: 100,
            scheduled_delay: Duration::from_millis(1),
        }
    }
    
    /// 高吞吐量配置
    pub fn high_throughput() -> Self {
        Self {
            max_export_batch_size: 10000,
            export_timeout: Duration::from_secs(10),
            max_queue_size: 100000,
            scheduled_delay: Duration::from_secs(1),
        }
    }
}
```

### 2. 连接池优化

```rust
pub struct ConnectionPool {
    /// 最大连接数
    pub max_connections: usize,
    /// 连接超时
    pub connection_timeout: Duration,
    /// 空闲超时
    pub idle_timeout: Duration,
    /// 健康检查间隔
    pub health_check_interval: Duration,
}
```

## 🔍 故障排查

### 常见问题

| 问题 | 原因 | 解决方案 |
|------|------|----------|
| 连接超时 | 网络问题或服务不可用 | 检查网络连接和服务状态 |
| 认证失败 | API密钥错误或过期 | 验证API密钥和权限 |
| 数据丢失 | 批处理配置不当 | 调整批处理参数 |
| 性能问题 | 采样率过高或批处理过小 | 优化采样和批处理配置 |

### 调试技巧

1. **启用调试日志**: 设置日志级别为DEBUG
2. **监控指标**: 使用内置指标监控性能
3. **健康检查**: 定期检查服务健康状态
4. **错误重试**: 配置适当的重试策略

## 📚 参考资料

- [OpenTelemetry官方文档](https://opentelemetry.io/docs/)
- [OTLP协议规范](https://github.com/open-telemetry/opentelemetry-proto)
- [CNCF项目](https://www.cncf.io/projects/)
- [Rust官方文档](https://doc.rust-lang.org/)

---

**文档版本**: v2.0.0  
**最后更新**: 2025年1月27日  
**维护者**: OpenTelemetry 2025 标准团队  
**整合状态**: 已完成重复内容合并
