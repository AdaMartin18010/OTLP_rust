# 集成测试指南

## EnhancedOtlpClient 与 OpenTelemetry Collector

---

## 📋 目录

1. [测试环境设置](#测试环境设置)
2. [Docker Compose 配置](#docker-compose-配置)
3. [集成测试示例](#集成测试示例)
4. [验证 OTLP 兼容性](#验证-otlp-兼容性)
5. [故障排查](#故障排查)

---

## 🚀 测试环境设置

### 1. 安装 Docker

确保已安装 Docker 和 Docker Compose。

```bash
docker --version
docker-compose --version
```

### 2. 创建测试目录

```bash
mkdir -p otlp/tests/integration
cd otlp/tests/integration
```

---

## 🐳 Docker Compose 配置

### 创建 `docker-compose.yml`

```yaml
version: '3.8'

services:
  # OpenTelemetry Collector
  otel-collector:
    image: otel/opentelemetry-collector:latest
    container_name: otlp-collector
    command: ["--config=/etc/otel-collector-config.yaml"]
    volumes:
      - ./otel-collector-config.yaml:/etc/otel-collector-config.yaml
    ports:
      - "4317:4317"  # OTLP gRPC
      - "4318:4318"  # OTLP HTTP
      - "8888:8888"  # Prometheus metrics
      - "13133:13133" # Health check
    networks:
      - otlp-network
    healthcheck:
      test: ["CMD", "wget", "--spider", "http://localhost:13133/"]
      interval: 5s
      timeout: 3s
      retries: 5

  # Jaeger (用于查看 traces)
  jaeger:
    image: jaegertracing/all-in-one:latest
    container_name: otlp-jaeger
    ports:
      - "16686:16686"  # Jaeger UI
      - "14250:14250"  # gRPC
    environment:
      - COLLECTOR_OTLP_ENABLED=true
    networks:
      - otlp-network

networks:
  otlp-network:
    driver: bridge
```

### 创建 `otel-collector-config.yaml`

```yaml
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317
      http:
        endpoint: 0.0.0.0:4318

processors:
  batch:
    timeout: 1s
    send_batch_size: 1024

exporters:
  logging:
    loglevel: debug
  
  jaeger:
    endpoint: jaeger:14250
    tls:
      insecure: true
  
  prometheus:
    endpoint: "0.0.0.0:8889"

service:
  pipelines:
    traces:
      receivers: [otlp]
      processors: [batch]
      exporters: [logging, jaeger]
    
    metrics:
      receivers: [otlp]
      processors: [batch]
      exporters: [logging, prometheus]

  telemetry:
    logs:
      level: debug
```

### 启动环境

```bash
# 启动所有服务
docker-compose up -d

# 查看日志
docker-compose logs -f otel-collector

# 检查健康状态
curl http://localhost:13133/
```

### 停止环境

```bash
docker-compose down
```

---

## 🧪 集成测试示例

### 测试文件: `otlp/tests/integration_test.rs`

```rust
//! 集成测试 - 验证与 OpenTelemetry Collector 的互操作性
//!
//! 运行前确保:
//! 1. Docker Compose 环境已启动
//! 2. OpenTelemetry Collector 运行在 localhost:4317

use otlp::core::EnhancedOtlpClient;
use opentelemetry::{
    trace::{Tracer, Status},
    KeyValue,
};
use std::time::Duration;

/// 测试基本的 span 导出
#[tokio::test]
#[ignore] // 默认跳过，需要手动运行
async fn test_basic_span_export() -> Result<(), Box<dyn std::error::Error>> {
    println!("🧪 测试基本 Span 导出...");
    
    // 创建客户端
    let client = EnhancedOtlpClient::builder()
        .with_endpoint("http://localhost:4317")
        .with_service_name("integration-test")
        .with_timeout(Duration::from_secs(10))
        .build()
        .await?;
    
    println!("✅ 客户端创建成功");
    
    // 获取 tracer
    let tracer = client.tracer("test-tracer");
    
    // 创建 span
    let span = tracer.start("test-operation");
    
    // 模拟工作
    tokio::time::sleep(Duration::from_millis(100)).await;
    
    drop(span);
    
    println!("✅ Span 已创建和结束");
    
    // 等待导出
    tokio::time::sleep(Duration::from_secs(2)).await;
    
    // 检查统计
    let stats = client.stats().await;
    println!("📊 统计:");
    println!("  - 导出的 spans: {}", stats.spans_exported);
    println!("  - 导出错误: {}", stats.export_errors);
    
    // 关闭客户端
    client.shutdown().await?;
    
    println!("✅ 测试完成");
    
    Ok(())
}

/// 测试嵌套 spans
#[tokio::test]
#[ignore]
async fn test_nested_spans() -> Result<(), Box<dyn std::error::Error>> {
    println!("🧪 测试嵌套 Spans...");
    
    let client = EnhancedOtlpClient::builder()
        .with_endpoint("http://localhost:4317")
        .with_service_name("nested-test")
        .build()
        .await?;
    
    let tracer = client.tracer("nested-tracer");
    
    // 父 span
    let parent = tracer.start("parent-operation");
    
    // 子 spans
    for i in 0..3 {
        let child = tracer.start(format!("child-operation-{}", i));
        tokio::time::sleep(Duration::from_millis(50)).await;
        drop(child);
    }
    
    drop(parent);
    
    println!("✅ 嵌套 Spans 创建完成");
    
    tokio::time::sleep(Duration::from_secs(2)).await;
    
    let stats = client.stats().await;
    println!("📊 导出的 spans: {}", stats.spans_exported);
    
    client.shutdown().await?;
    
    Ok(())
}

/// 测试 span 属性和事件
#[tokio::test]
#[ignore]
async fn test_span_attributes_and_events() -> Result<(), Box<dyn std::error::Error>> {
    println!("🧪 测试 Span 属性和事件...");
    
    let client = EnhancedOtlpClient::builder()
        .with_endpoint("http://localhost:4317")
        .with_service_name("attributes-test")
        .build()
        .await?;
    
    let tracer = client.tracer("attributes-tracer");
    let mut span = tracer.start("operation-with-attributes");
    
    // 添加属性
    span.set_attribute(KeyValue::new("user.id", "12345"));
    span.set_attribute(KeyValue::new("request.method", "GET"));
    span.set_attribute(KeyValue::new("response.status", 200));
    
    // 添加事件
    span.add_event("Processing started", vec![
        KeyValue::new("item.count", 10),
        KeyValue::new("batch.size", 100),
    ]);
    
    tokio::time::sleep(Duration::from_millis(50)).await;
    
    span.add_event("Processing completed", vec![
        KeyValue::new("items.processed", 10),
    ]);
    
    // 设置状态
    span.set_status(Status::Ok);
    
    drop(span);
    
    println!("✅ 属性和事件已添加");
    
    tokio::time::sleep(Duration::from_secs(2)).await;
    
    client.shutdown().await?;
    
    Ok(())
}

/// 测试并发 spans
#[tokio::test]
#[ignore]
async fn test_concurrent_spans() -> Result<(), Box<dyn std::error::Error>> {
    println!("🧪 测试并发 Spans...");
    
    use std::sync::Arc;
    
    let client = Arc::new(
        EnhancedOtlpClient::builder()
            .with_endpoint("http://localhost:4317")
            .with_service_name("concurrent-test")
            .build()
            .await?
    );
    
    let mut handles = vec![];
    
    // 创建 10 个并发任务
    for i in 0..10 {
        let client_clone = Arc::clone(&client);
        let handle = tokio::spawn(async move {
            let tracer = client_clone.tracer(format!("worker-{}", i));
            let span = tracer.start(format!("concurrent-task-{}", i));
            
            tokio::time::sleep(Duration::from_millis(100)).await;
            
            drop(span);
        });
        
        handles.push(handle);
    }
    
    // 等待所有任务完成
    for handle in handles {
        handle.await?;
    }
    
    println!("✅ 所有并发任务完成");
    
    tokio::time::sleep(Duration::from_secs(2)).await;
    
    let stats = client.stats().await;
    println!("📊 总共导出 {} 个 spans", stats.spans_exported);
    
    client.shutdown().await?;
    
    Ok(())
}

/// 测试错误处理
#[tokio::test]
#[ignore]
async fn test_error_handling() -> Result<(), Box<dyn std::error::Error>> {
    println!("🧪 测试错误处理...");
    
    let client = EnhancedOtlpClient::builder()
        .with_endpoint("http://localhost:4317")
        .with_service_name("error-test")
        .build()
        .await?;
    
    let tracer = client.tracer("error-tracer");
    let mut span = tracer.start("operation-with-error");
    
    // 模拟错误
    span.set_attribute(KeyValue::new("error.type", "DatabaseError"));
    span.set_attribute(KeyValue::new("error.message", "Connection timeout"));
    span.set_status(Status::error("Database connection failed"));
    
    drop(span);
    
    println!("✅ 错误 Span 已创建");
    
    tokio::time::sleep(Duration::from_secs(2)).await;
    
    client.shutdown().await?;
    
    Ok(())
}

/// 性能测试 - 大量 spans
#[tokio::test]
#[ignore]
async fn test_high_volume_spans() -> Result<(), Box<dyn std::error::Error>> {
    println!("🧪 测试高容量 Spans (1000个)...");
    
    let client = EnhancedOtlpClient::builder()
        .with_endpoint("http://localhost:4317")
        .with_service_name("high-volume-test")
        .with_performance_optimization(true)
        .build()
        .await?;
    
    let tracer = client.tracer("volume-tracer");
    
    let start = std::time::Instant::now();
    
    // 创建 1000 个 spans
    for i in 0..1000 {
        let span = tracer.start(format!("span-{}", i));
        drop(span);
    }
    
    let duration = start.elapsed();
    println!("✅ 创建 1000 个 spans 耗时: {:?}", duration);
    
    tokio::time::sleep(Duration::from_secs(3)).await;
    
    let stats = client.stats().await;
    println!("📊 导出的 spans: {}", stats.spans_exported);
    println!("📊 平均导出时间: {}ms", stats.avg_export_time_ms);
    
    client.shutdown().await?;
    
    Ok(())
}
```

### 运行集成测试

```bash
# 启动 Docker Compose 环境
docker-compose up -d

# 运行所有集成测试 (包括 ignored)
cargo test --test integration_test -- --ignored --nocapture

# 运行单个测试
cargo test --test integration_test test_basic_span_export -- --ignored --nocapture

# 查看 Jaeger UI 中的 traces
# 打开浏览器: http://localhost:16686
```

---

## ✅ 验证 OTLP 兼容性

### 1. 检查 Collector 健康状态

```bash
curl http://localhost:13133/
```

**预期输出**:

```json
{"status":"Server available","upSince":"..."}
```

### 2. 查看 Collector 日志

```bash
docker-compose logs -f otel-collector
```

**查找关键信息**:

```
Traces received: X
Spans exported: Y
```

### 3. 在 Jaeger UI 中验证

1. 打开 <http://localhost:16686>
2. 选择服务名称 (如 `integration-test`)
3. 点击 "Find Traces"
4. 查看导出的 traces 和 spans

### 4. 验证 span 数据完整性

检查以下字段:

- ✅ Trace ID
- ✅ Span ID
- ✅ Parent Span ID (嵌套 spans)
- ✅ Operation Name
- ✅ Start Time / End Time
- ✅ Duration
- ✅ Attributes
- ✅ Events
- ✅ Status

---

## 🔧 故障排查

### 问题 1: 无法连接到 Collector

**症状**:

```
Error: Failed to build exporter: Connection refused
```

**解决方案**:

1. 检查 Docker 容器状态:

   ```bash
   docker ps | grep otel-collector
   ```

2. 检查端口是否被占用:

   ```bash
   netstat -an | grep 4317
   ```

3. 重启容器:

   ```bash
   docker-compose restart otel-collector
   ```

### 问题 2: Spans 未在 Jaeger 中显示

**检查步骤**:

1. **查看 Collector 日志**:

   ```bash
   docker-compose logs otel-collector | grep "Traces received"
   ```

2. **验证配置**:
   确保 `otel-collector-config.yaml` 中的 pipeline 配置正确

3. **检查 Jaeger 连接**:

   ```bash
   docker-compose logs jaeger
   ```

### 问题 3: 测试超时

**调整**:

```rust
let client = EnhancedOtlpClient::builder()
    .with_endpoint("http://localhost:4317")
    .with_timeout(Duration::from_secs(30))  // 增加超时
    .build()
    .await?;
```

---

## 📊 性能基准

### 预期指标

```text
操作                        预期性能
────────────────────────────────────────
创建单个 span              < 1ms
导出 100 spans            < 100ms
导出 1000 spans           < 1s
并发创建 10 spans          < 500ms
```

### 监控指标

```bash
# Prometheus metrics
curl http://localhost:8888/metrics
```

---

## 📖 相关资源

- [OpenTelemetry Collector 文档](https://opentelemetry.io/docs/collector/)
- [OTLP 规范](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/protocol/otlp.md)
- [Jaeger 文档](https://www.jaegertracing.io/docs/)

---

**最后更新**: 2025-10-18  
**版本**: 0.1.0

---
