# 语义约定标准

## 📋 目录

## 🎯 标准概览

### 1. 语义约定定义

语义约定（Semantic Conventions）是 OpenTelemetry 中定义的一套标准化规范，用于确保遥测数据的一致性和互操作性。

```text
语义约定核心要素
├── 标准化属性名称
│   ├── 统一命名空间
│   ├── 层次化命名结构
│   ├── 语义化属性名
│   └── 版本化命名规范
├── 标准化属性值
│   ├── 数据类型规范
│   ├── 取值范围定义
│   ├── 单位标准化
│   └── 格式规范化
├── 标准化数据模型
│   ├── 追踪数据模型
│   ├── 指标数据模型
│   ├── 日志数据模型
│   └── 元数据模型
└── 标准化语义映射
    ├── 业务语义映射
    ├── 技术语义映射
    ├── 上下文语义映射
    └── 关系语义映射
```

### 2. 标准组织架构

```text
语义约定标准组织
├── OpenTelemetry 语义约定工作组
│   ├── 规范制定委员会
│   ├── 技术审查委员会
│   ├── 实现指导委员会
│   └── 社区反馈委员会
├── 行业标准对齐
│   ├── CNCF 标准对齐
│   ├── 云厂商标准对齐
│   ├── 开源项目标准对齐
│   └── 企业应用标准对齐
├── 国际标准对接
│   ├── ISO/IEC 标准对接
│   ├── IEEE 标准对接
│   ├── ITU-T 标准对接
│   └── IETF 标准对接
└── 学术研究支持
    ├── 大学研究合作
    ├── 学术论文支持
    ├── 研究项目资助
    └── 学术会议参与
```

## 🏗️ 语义约定体系

### 1. 命名空间体系

#### 1.1 核心命名空间

```text
语义约定命名空间
├── otel.* (OpenTelemetry 核心)
│   ├── otel.service.* (服务相关)
│   │   ├── otel.service.name
│   │   ├── otel.service.version
│   │   ├── otel.service.namespace
│   │   └── otel.service.instance.id
│   ├── otel.resource.* (资源相关)
│   │   ├── otel.resource.cloud.*
│   │   ├── otel.resource.container.*
│   │   ├── otel.resource.host.*
│   │   └── otel.resource.k8s.*
│   ├── otel.instrumentation.* (仪表化相关)
│   │   ├── otel.instrumentation.name
│   │   ├── otel.instrumentation.version
│   │   ├── otel.instrumentation.library
│   │   └── otel.instrumentation.scope
│   └── otel.status.* (状态相关)
        ├── otel.status.code
        ├── otel.status.message
        ├── otel.status.details
        └── otel.status.tags
├── http.* (HTTP 协议)
│   ├── http.method
│   ├── http.url
│   ├── http.status_code
│   ├── http.request.header.*
│   ├── http.response.header.*
│   └── http.route
├── db.* (数据库相关)
│   ├── db.system
│   ├── db.name
│   ├── db.operation
│   ├── db.statement
│   └── db.connection_string
├── rpc.* (RPC 相关)
│   ├── rpc.system
│   ├── rpc.service
│   ├── rpc.method
│   └── rpc.grpc.status_code
├── messaging.* (消息传递)
│   ├── messaging.system
│   ├── messaging.destination
│   ├── messaging.protocol
│   └── messaging.message_id
└── faas.* (函数即服务)
    ├── faas.name
    ├── faas.id
    ├── faas.version
    ├── faas.instance
    └── faas.execution
```

### 2. 数据类型体系

#### 2.1 基础数据类型

```text
语义约定数据类型
├── 字符串类型
│   ├── string (UTF-8 字符串)
│   ├── string[] (字符串数组)
│   └── map<string, string> (字符串映射)
├── 数值类型
│   ├── int (32位整数)
│   ├── long (64位整数)
│   ├── double (64位浮点数)
│   └── bool (布尔值)
├── 时间类型
│   ├── timestamp (时间戳)
│   ├── duration (持续时间)
│   └── interval (时间间隔)
├── 二进制类型
│   ├── bytes (字节数组)
│   └── blob (二进制大对象)
└── 复合类型
    ├── array (数组)
    ├── map (映射)
    ├── struct (结构体)
    └── union (联合体)
```

## 📊 数据模型标准

### 1. 追踪数据模型

#### 1.1 Span 数据模型

```rust
// Span 语义约定数据模型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SemanticSpan {
    // 基础属性
    pub trace_id: String,
    pub span_id: String,
    pub parent_span_id: Option<String>,
    pub operation_name: String,
    pub start_time: Timestamp,
    pub end_time: Option<Timestamp>,
    pub duration: Option<Duration>,
    
    // 状态属性
    pub status: SpanStatus,
    pub status_code: StatusCode,
    pub status_message: Option<String>,
    
    // 资源属性
    pub resource: ResourceAttributes,
    pub service_name: String,
    pub service_version: Option<String>,
    pub service_namespace: Option<String>,
    
    // 标签属性
    pub tags: HashMap<String, AttributeValue>,
    
    // 事件属性
    pub events: Vec<SpanEvent>,
    
    // 链接属性
    pub links: Vec<SpanLink>,
    
    // 语义约定属性
    pub semantic_attributes: SemanticAttributes,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SemanticAttributes {
    // HTTP 相关属性
    pub http: Option<HttpAttributes>,
    
    // 数据库相关属性
    pub db: Option<DatabaseAttributes>,
    
    // RPC 相关属性
    pub rpc: Option<RpcAttributes>,
    
    // 消息传递相关属性
    pub messaging: Option<MessagingAttributes>,
    
    // 云平台相关属性
    pub cloud: Option<CloudAttributes>,
    
    // Kubernetes 相关属性
    pub k8s: Option<KubernetesAttributes>,
    
    // 自定义属性
    pub custom: Option<CustomAttributes>,
}
```

#### 1.2 HTTP 语义约定

```rust
// HTTP 语义约定属性
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HttpAttributes {
    // 请求属性
    pub method: String,
    pub url: String,
    pub target: Option<String>,
    pub host: Option<String>,
    pub scheme: Option<String>,
    pub user_agent: Option<String>,
    pub request_content_length: Option<u64>,
    pub request_content_type: Option<String>,
    
    // 响应属性
    pub status_code: u16,
    pub response_content_length: Option<u64>,
    pub response_content_type: Option<String>,
    
    // 路由属性
    pub route: Option<String>,
    pub server_name: Option<String>,
    
    // 头部属性
    pub request_headers: HashMap<String, String>,
    pub response_headers: HashMap<String, String>,
    
    // 客户端属性
    pub client_ip: Option<String>,
    pub server_ip: Option<String>,
    
    // 其他属性
    pub flavor: Option<String>,
    pub server_port: Option<u16>,
    pub client_port: Option<u16>,
}
```

## 🏷️ 属性命名规范

### 1. 命名原则

#### 1.1 基础命名原则

```text
属性命名原则
├── 语义化原则
│   ├── 使用有意义的名称
│   ├── 避免缩写和简称
│   ├── 使用标准术语
│   └── 保持名称一致性
├── 层次化原则
│   ├── 使用点分隔的层次结构
│   ├── 从通用到具体
│   ├── 保持层次清晰
│   └── 避免过深层次
├── 命名空间原则
│   ├── 使用标准命名空间
│   ├── 避免命名空间冲突
│   ├── 保持命名空间一致
│   └── 支持命名空间扩展
└── 版本化原则
    ├── 支持向后兼容
    ├── 标记废弃属性
    ├── 提供迁移路径
    └── 维护版本历史
```

### 2. 标准属性集合

#### 2.1 通用属性

```text
通用语义约定属性
├── 标识符属性
│   ├── id (标识符)
│   ├── name (名称)
│   ├── type (类型)
│   └── version (版本)
├── 时间属性
│   ├── timestamp (时间戳)
│   ├── duration (持续时间)
│   ├── start_time (开始时间)
│   └── end_time (结束时间)
├── 状态属性
│   ├── status (状态)
│   ├── code (状态码)
│   ├── message (消息)
│   └── reason (原因)
├── 位置属性
│   ├── location (位置)
│   ├── region (区域)
│   ├── zone (可用区)
│   └── datacenter (数据中心)
├── 大小属性
│   ├── size (大小)
│   ├── count (数量)
│   ├── length (长度)
│   └── capacity (容量)
├── 质量属性
│   ├── quality (质量)
│   ├── accuracy (准确性)
│   ├── reliability (可靠性)
│   └── availability (可用性)
└── 性能属性
    ├── performance (性能)
    ├── latency (延迟)
    ├── throughput (吞吐量)
    └── efficiency (效率)
```

## 🛠️ 实现指南

### 1. Rust 实现示例

#### 1.1 语义约定属性构建器

```rust
use std::collections::HashMap;
use serde::{Serialize, Deserialize};

// 语义约定属性构建器
pub struct SemanticAttributeBuilder {
    attributes: HashMap<String, AttributeValue>,
}

impl SemanticAttributeBuilder {
    pub fn new() -> Self {
        Self {
            attributes: HashMap::new(),
        }
    }
    
    // HTTP 属性构建
    pub fn http_method(mut self, method: &str) -> Self {
        self.attributes.insert("http.method".to_string(), 
                              AttributeValue::String(method.to_string()));
        self
    }
    
    pub fn http_url(mut self, url: &str) -> Self {
        self.attributes.insert("http.url".to_string(), 
                              AttributeValue::String(url.to_string()));
        self
    }
    
    pub fn http_status_code(mut self, status_code: u16) -> Self {
        self.attributes.insert("http.status_code".to_string(), 
                              AttributeValue::Int(status_code as i64));
        self
    }
    
    // 数据库属性构建
    pub fn db_system(mut self, system: &str) -> Self {
        self.attributes.insert("db.system".to_string(), 
                              AttributeValue::String(system.to_string()));
        self
    }
    
    pub fn db_operation(mut self, operation: &str) -> Self {
        self.attributes.insert("db.operation".to_string(), 
                              AttributeValue::String(operation.to_string()));
        self
    }
    
    // 构建最终属性集合
    pub fn build(self) -> HashMap<String, AttributeValue> {
        self.attributes
    }
}

// 使用示例
fn create_http_span_attributes() -> HashMap<String, AttributeValue> {
    SemanticAttributeBuilder::new()
        .service_name("user-service")
        .service_version("1.2.3")
        .http_method("GET")
        .http_url("https://api.example.com/users/123")
        .http_status_code(200)
        .custom_attribute("user_id", AttributeValue::String("user_123".to_string()))
        .build()
}
```

## 💡 最佳实践

### 1. 设计原则

#### 1.1 语义化设计原则

```text
语义约定设计原则
├── 一致性原则
│   ├── 命名一致性
│   ├── 类型一致性
│   ├── 格式一致性
│   └── 行为一致性
├── 可扩展性原则
│   ├── 支持新属性添加
│   ├── 支持属性版本管理
│   ├── 支持向后兼容
│   └── 支持自定义扩展
├── 互操作性原则
│   ├── 跨平台兼容
│   ├── 跨语言兼容
│   ├── 跨版本兼容
│   └── 跨工具兼容
└── 性能原则
    ├── 最小化属性数量
    ├── 优化属性大小
    ├── 减少序列化开销
    └── 提高处理效率
```

### 2. 实施建议

#### 2.1 分阶段实施

```text
语义约定分阶段实施
├── 第一阶段：基础实施（1-2个月）
│   ├── 实施核心语义约定
│   ├── 建立属性命名规范
│   ├── 配置属性验证器
│   └── 培训开发团队
├── 第二阶段：扩展实施（2-4个月）
│   ├── 实施业务语义约定
│   ├── 集成第三方系统
│   ├── 建立监控告警
│   └── 优化性能表现
├── 第三阶段：完善实施（4-6个月）
│   ├── 完善所有语义约定
│   ├── 建立自动化测试
│   ├── 实施持续改进
│   └── 建立最佳实践库
└── 第四阶段：持续优化（6个月+）
    ├── 监控使用情况
    ├── 收集反馈意见
    ├── 持续改进优化
    └── 分享成功经验
```

---

## 📚 总结

语义约定标准为 OpenTelemetry 提供了：

1. **标准化框架** - 统一的属性命名和数据类型规范
2. **互操作性** - 跨平台、跨语言的语义一致性
3. **可扩展性** - 支持自定义属性和业务语义
4. **质量保证** - 完整的验证和标准化机制

通过遵循语义约定标准，可以确保遥测数据的一致性、可理解性和可操作性，为构建高质量的可观测性系统提供坚实基础。
