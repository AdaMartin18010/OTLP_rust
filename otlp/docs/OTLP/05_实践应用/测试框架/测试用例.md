# OTLP Rust 测试框架与用例

## 📚 概述

本文档详细介绍了OTLP Rust实现的测试框架，包括单元测试、集成测试、性能测试、压力测试等，以及完整的测试用例设计。

## 🧪 测试框架架构

### 1. 测试分层

```rust
// 测试分层结构
pub mod unit_tests {
    // 单元测试 - 测试单个函数和模块
}

pub mod integration_tests {
    // 集成测试 - 测试模块间交互
}

pub mod performance_tests {
    // 性能测试 - 测试性能指标
}

pub mod stress_tests {
    // 压力测试 - 测试系统极限
}

pub mod e2e_tests {
    // 端到端测试 - 测试完整流程
}
```

### 2. 测试工具链

```toml
# Cargo.toml 测试依赖
[dev-dependencies]
tokio-test = "0.4"
criterion = { version = "0.5", features = ["html_reports"] }
proptest = "1.0"
mockito = "1.0"
testcontainers = "0.15"
serial_test = "2.0"
tempfile = "3.0"
assert_cmd = "2.0"
predicates = "3.0"
```

## 🔬 单元测试

### 1. 客户端测试

```rust
#[cfg(test)]
mod client_tests {
    use super::*;
    use tokio_test;
    use mockito;

    #[tokio::test]
    async fn test_client_creation() {
        let config = OtlpConfig::default()
            .with_endpoint("http://localhost:4317")
            .with_service("test-service", "1.0.0");
        
        let client = OtlpClient::new(config).await;
        assert!(client.is_ok());
    }

    #[tokio::test]
    async fn test_client_initialization() {
        let config = OtlpConfig::default()
            .with_endpoint("http://localhost:4317");
        
        let client = OtlpClient::new(config).await.unwrap();
        let result = client.initialize().await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_invalid_endpoint() {
        let config = OtlpConfig::default()
            .with_endpoint("invalid-url");
        
        let client = OtlpClient::new(config).await;
        assert!(client.is_err());
    }
}
```

### 2. 配置测试

```rust
#[cfg(test)]
mod config_tests {
    use super::*;

    #[test]
    fn test_default_config() {
        let config = OtlpConfig::default();
        assert_eq!(config.endpoint, "http://localhost:4317");
        assert_eq!(config.protocol, TransportProtocol::Grpc);
        assert_eq!(config.sampling_ratio, 1.0);
    }

    #[test]
    fn test_config_builder() {
        let config = OtlpConfig::default()
            .with_endpoint("https://api.example.com")
            .with_protocol(TransportProtocol::Http)
            .with_sampling_ratio(0.1);
        
        assert_eq!(config.endpoint, "https://api.example.com");
        assert_eq!(config.protocol, TransportProtocol::Http);
        assert_eq!(config.sampling_ratio, 0.1);
    }

    #[test]
    fn test_config_validation() {
        // 测试无效的采样率
        let config = OtlpConfig::default()
            .with_sampling_ratio(1.5);
        
        assert!(config.validate().is_err());
        
        // 测试无效的端点
        let config = OtlpConfig::default()
            .with_endpoint("");
        
        assert!(config.validate().is_err());
    }
}
```

### 3. 数据模型测试

```rust
#[cfg(test)]
mod data_tests {
    use super::*;

    #[test]
    fn test_telemetry_data_creation() {
        let trace_data = TelemetryData::trace("test-operation")
            .with_attribute("service.name", "test-service");
        
        assert_eq!(trace_data.operation_name(), "test-operation");
        assert!(trace_data.has_attribute("service.name"));
    }

    #[test]
    fn test_key_value_creation() {
        let kv = KeyValue::new("key", "value");
        assert_eq!(kv.key(), "key");
        assert_eq!(kv.value().as_str(), Some("value"));
        
        let numeric_kv = KeyValue::new("duration", 150.0);
        assert_eq!(numeric_kv.value().as_f64(), Some(150.0));
    }

    #[test]
    fn test_attribute_value_types() {
        let string_val = AttributeValue::String("test".to_string());
        let number_val = AttributeValue::Number(123.45);
        let bool_val = AttributeValue::Boolean(true);
        
        assert!(matches!(string_val, AttributeValue::String(_)));
        assert!(matches!(number_val, AttributeValue::Number(_)));
        assert!(matches!(bool_val, AttributeValue::Boolean(_)));
    }
}
```

## 🔗 集成测试

### 1. 端到端测试

```rust
#[cfg(test)]
mod integration_tests {
    use super::*;
    use testcontainers::*;
    use testcontainers::images::generic::GenericImage;

    #[tokio::test]
    async fn test_full_otlp_flow() {
        // 启动测试容器
        let docker = clients::Cli::default();
        let collector_image = GenericImage::new("otel/opentelemetry-collector", "latest");
        let collector = docker.run(collector_image);
        
        let collector_port = collector.get_host_port_ipv4(4317);
        let endpoint = format!("http://localhost:{}", collector_port);
        
        // 创建客户端
        let config = OtlpConfig::default()
            .with_endpoint(&endpoint)
            .with_service("integration-test", "1.0.0");
        
        let client = OtlpClient::new(config).await.unwrap();
        client.initialize().await.unwrap();
        
        // 发送追踪数据
        let trace_result = client.send_trace("integration-test-operation").await.unwrap()
            .with_attribute("test.type", "integration")
            .finish()
            .await.unwrap();
        
        assert!(trace_result.success_count > 0);
        
        // 发送指标数据
        let metric_result = client.send_metric("test_metric", 1.0).await.unwrap()
            .with_label("test", "integration")
            .send()
            .await.unwrap();
        
        assert!(metric_result.success_count > 0);
        
        // 发送日志数据
        let log_result = client.send_log("Integration test log", LogSeverity::Info).await.unwrap()
            .with_attribute("test.type", "integration")
            .send()
            .await.unwrap();
        
        assert!(log_result.success_count > 0);
        
        client.shutdown().await.unwrap();
    }
}
```

### 2. 批量处理测试

```rust
#[tokio::test]
async fn test_batch_processing() {
    let config = OtlpConfig::default()
        .with_endpoint("http://localhost:4317")
        .with_batch_config(BatchConfig {
            max_export_batch_size: 10,
            export_timeout: Duration::from_millis(1000),
            max_queue_size: 100,
            scheduled_delay: Duration::from_millis(100),
            max_export_timeout: Duration::from_secs(5),
        });
    
    let client = OtlpClient::new(config).await.unwrap();
    client.initialize().await.unwrap();
    
    // 创建批量数据
    let mut batch_data = Vec::new();
    for i in 0..20 {
        batch_data.push(TelemetryData::trace(format!("batch-operation-{}", i))
            .with_attribute("batch.id", "test-batch"));
    }
    
    let result = client.send_batch(batch_data).await.unwrap();
    assert!(result.success_count > 0);
    
    client.shutdown().await.unwrap();
}
```

### 3. 错误处理测试

```rust
#[tokio::test]
async fn test_error_handling() {
    // 测试连接错误
    let config = OtlpConfig::default()
        .with_endpoint("http://invalid-endpoint:9999");
    
    let client = OtlpClient::new(config).await.unwrap();
    let result = client.initialize().await;
    assert!(result.is_err());
    
    // 测试超时错误
    let config = OtlpConfig::default()
        .with_endpoint("http://localhost:4317")
        .with_timeout(Duration::from_millis(1));
    
    let client = OtlpClient::new(config).await.unwrap();
    client.initialize().await.unwrap();
    
    let result = client.send_trace("timeout-test").await.unwrap()
        .finish()
        .await;
    
    assert!(result.is_err());
}
```

## 📊 性能测试

### 1. 基准测试

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn benchmark_trace_creation(c: &mut Criterion) {
    c.bench_function("trace_creation", |b| {
        b.iter(|| {
            let trace = TelemetryData::trace(black_box("benchmark-operation"))
                .with_attribute(black_box("service.name"), black_box("benchmark-service"))
                .with_numeric_attribute(black_box("duration"), black_box(150.0));
            black_box(trace)
        })
    });
}

fn benchmark_serialization(c: &mut Criterion) {
    let trace = TelemetryData::trace("serialization-test")
        .with_attribute("key1", "value1")
        .with_attribute("key2", "value2");
    
    c.bench_function("trace_serialization", |b| {
        b.iter(|| {
            let serialized = serde_json::to_vec(black_box(&trace)).unwrap();
            black_box(serialized)
        })
    });
}

fn benchmark_batch_processing(c: &mut Criterion) {
    let mut batch_data = Vec::new();
    for i in 0..100 {
        batch_data.push(TelemetryData::trace(format!("batch-{}", i)));
    }
    
    c.bench_function("batch_processing", |b| {
        b.iter(|| {
            let processed = process_batch(black_box(&batch_data));
            black_box(processed)
        })
    });
}

criterion_group!(benches, benchmark_trace_creation, benchmark_serialization, benchmark_batch_processing);
criterion_main!(benches);
```

### 2. 负载测试

```rust
#[tokio::test]
async fn test_load_performance() {
    let config = OtlpConfig::default()
        .with_endpoint("http://localhost:4317")
        .with_batch_config(BatchConfig {
            max_export_batch_size: 1000,
            export_timeout: Duration::from_millis(5000),
            max_queue_size: 10000,
            scheduled_delay: Duration::from_millis(1000),
            max_export_timeout: Duration::from_secs(30),
        });
    
    let client = OtlpClient::new(config).await.unwrap();
    client.initialize().await.unwrap();
    
    let start_time = std::time::Instant::now();
    let num_requests = 10000;
    
    // 并发发送请求
    let futures: Vec<_> = (0..num_requests)
        .map(|i| {
            let client = client.clone();
            tokio::spawn(async move {
                client.send_trace(format!("load-test-{}", i)).await.unwrap()
                    .with_attribute("load.test", "true")
                    .finish()
                    .await
            })
        })
        .collect();
    
    let results = futures::future::join_all(futures).await;
    let end_time = std::time::Instant::now();
    
    let successful_requests: usize = results.iter()
        .filter(|r| r.is_ok())
        .count();
    
    let duration = end_time.duration_since(start_time);
    let requests_per_second = num_requests as f64 / duration.as_secs_f64();
    
    println!("Load test results:");
    println!("  Total requests: {}", num_requests);
    println!("  Successful requests: {}", successful_requests);
    println!("  Duration: {:?}", duration);
    println!("  Requests per second: {:.2}", requests_per_second);
    
    assert!(successful_requests > num_requests * 95 / 100); // 95% 成功率
    assert!(requests_per_second > 1000.0); // 至少1000 RPS
    
    client.shutdown().await.unwrap();
}
```

## 🧪 压力测试

### 1. 内存压力测试

```rust
#[tokio::test]
async fn test_memory_pressure() {
    let config = OtlpConfig::default()
        .with_memory_limit(100 * 1024 * 1024) // 100MB限制
        .with_endpoint("http://localhost:4317");
    
    let client = OtlpClient::new(config).await.unwrap();
    client.initialize().await.unwrap();
    
    // 创建大量数据直到内存限制
    let mut batch_data = Vec::new();
    let mut total_size = 0;
    
    while total_size < 50 * 1024 * 1024 { // 50MB
        let data = TelemetryData::trace(format!("memory-test-{}", total_size))
            .with_attribute("data", "x".repeat(1024)); // 1KB数据
        
        batch_data.push(data);
        total_size += 1024;
    }
    
    // 发送数据
    let result = client.send_batch(batch_data).await.unwrap();
    assert!(result.success_count > 0);
    
    client.shutdown().await.unwrap();
}
```

### 2. 连接压力测试

```rust
#[tokio::test]
async fn test_connection_pressure() {
    let config = OtlpConfig::default()
        .with_endpoint("http://localhost:4317")
        .with_connection_pool_config(ConnectionPoolConfig {
            max_connections: 10,
            max_connections_per_route: 5,
            connection_timeout: Duration::from_millis(1000),
            keep_alive_timeout: Duration::from_secs(30),
            max_idle_timeout: Duration::from_secs(60),
        });
    
    let client = OtlpClient::new(config).await.unwrap();
    client.initialize().await.unwrap();
    
    // 创建大量并发连接
    let futures: Vec<_> = (0..100)
        .map(|i| {
            let client = client.clone();
            tokio::spawn(async move {
                client.send_trace(format!("connection-test-{}", i)).await.unwrap()
                    .finish()
                    .await
            })
        })
        .collect();
    
    let results = futures::future::join_all(futures).await;
    let successful = results.iter().filter(|r| r.is_ok()).count();
    
    assert!(successful > 90); // 90%成功率
    
    client.shutdown().await.unwrap();
}
```

## 🔍 属性测试

### 1. 使用Proptest进行属性测试

```rust
use proptest::prelude::*;

proptest! {
    #[test]
    fn test_trace_creation_properties(
        operation_name in "\\PC*",
        attribute_count in 0..10usize,
    ) {
        let mut trace = TelemetryData::trace(&operation_name);
        
        for i in 0..attribute_count {
            trace = trace.with_attribute(
                format!("key{}", i),
                format!("value{}", i)
            );
        }
        
        assert_eq!(trace.operation_name(), operation_name);
        assert_eq!(trace.attribute_count(), attribute_count);
    }

    #[test]
    fn test_config_validation_properties(
        endpoint in "https?://[a-zA-Z0-9.-]+:[0-9]+",
        sampling_ratio in 0.0f64..1.0f64,
    ) {
        let config = OtlpConfig::default()
            .with_endpoint(&endpoint)
            .with_sampling_ratio(sampling_ratio);
        
        assert!(config.validate().is_ok());
    }

    #[test]
    fn test_serialization_roundtrip(
        operation_name in "\\PC*",
        attributes in prop::collection::hash_map(
            "\\PC*", "\\PC*", 0..5
        ),
    ) {
        let mut trace = TelemetryData::trace(&operation_name);
        
        for (key, value) in &attributes {
            trace = trace.with_attribute(key, value);
        }
        
        let serialized = serde_json::to_vec(&trace).unwrap();
        let deserialized: TelemetryData = serde_json::from_slice(&serialized).unwrap();
        
        assert_eq!(deserialized.operation_name(), operation_name);
        assert_eq!(deserialized.attribute_count(), attributes.len());
    }
}
```

## 🎯 测试工具和辅助函数

### 1. 测试辅助工具

```rust
#[cfg(test)]
mod test_utils {
    use super::*;
    use std::sync::Arc;
    use tokio::sync::Mutex;

    pub struct MockCollector {
        pub received_traces: Arc<Mutex<Vec<Trace>>>,
        pub received_metrics: Arc<Mutex<Vec<Metric>>>,
        pub received_logs: Arc<Mutex<Vec<Log>>>,
    }

    impl MockCollector {
        pub fn new() -> Self {
            Self {
                received_traces: Arc::new(Mutex::new(Vec::new())),
                received_metrics: Arc::new(Mutex::new(Vec::new())),
                received_logs: Arc::new(Mutex::new(Vec::new())),
            }
        }

        pub async fn get_trace_count(&self) -> usize {
            self.received_traces.lock().await.len()
        }

        pub async fn get_metric_count(&self) -> usize {
            self.received_metrics.lock().await.len()
        }

        pub async fn get_log_count(&self) -> usize {
            self.received_logs.lock().await.len()
        }
    }

    pub fn create_test_config() -> OtlpConfig {
        OtlpConfig::default()
            .with_endpoint("http://localhost:4317")
            .with_service("test-service", "1.0.0")
            .with_debug(true)
    }

    pub async fn create_test_client() -> OtlpClient {
        let config = create_test_config();
        let client = OtlpClient::new(config).await.unwrap();
        client.initialize().await.unwrap();
        client
    }

    pub fn create_test_trace(operation: &str) -> TelemetryData {
        TelemetryData::trace(operation)
            .with_attribute("test.type", "unit_test")
            .with_attribute("test.timestamp", chrono::Utc::now().to_rfc3339())
    }

    pub fn create_test_metric(name: &str, value: f64) -> TelemetryData {
        TelemetryData::metric(name, value)
            .with_label("test", "true")
            .with_description("Test metric")
            .with_unit("count")
    }

    pub fn create_test_log(message: &str) -> TelemetryData {
        TelemetryData::log(message, LogSeverity::Info)
            .with_attribute("test.type", "unit_test")
    }
}
```

### 2. 测试数据生成器

```rust
#[cfg(test)]
mod test_data_generator {
    use super::*;
    use rand::Rng;

    pub struct TestDataGenerator {
        rng: rand::rngs::ThreadRng,
    }

    impl TestDataGenerator {
        pub fn new() -> Self {
            Self {
                rng: rand::thread_rng(),
            }
        }

        pub fn generate_trace(&mut self) -> TelemetryData {
            let operation = format!("operation_{}", self.rng.gen_range(0..1000));
            let duration = self.rng.gen_range(10.0..1000.0);
            
            TelemetryData::trace(operation)
                .with_attribute("duration", duration)
                .with_attribute("status", if self.rng.gen_bool(0.9) { "success" } else { "error" })
                .with_numeric_attribute("memory_usage", self.rng.gen_range(100.0..10000.0))
        }

        pub fn generate_metric(&mut self) -> TelemetryData {
            let metric_name = format!("metric_{}", self.rng.gen_range(0..100));
            let value = self.rng.gen_range(0.0..1000.0);
            
            TelemetryData::metric(metric_name, value)
                .with_label("service", format!("service_{}", self.rng.gen_range(0..10)))
                .with_label("instance", format!("instance_{}", self.rng.gen_range(0..100)))
        }

        pub fn generate_log(&mut self) -> TelemetryData {
            let messages = vec![
                "User login successful",
                "Database connection established",
                "Cache hit",
                "Request processed",
                "Error occurred",
            ];
            
            let message = messages[self.rng.gen_range(0..messages.len())];
            let severity = match self.rng.gen_range(0..4) {
                0 => LogSeverity::Error,
                1 => LogSeverity::Warn,
                2 => LogSeverity::Info,
                _ => LogSeverity::Debug,
            };
            
            TelemetryData::log(message, severity)
                .with_attribute("user_id", format!("user_{}", self.rng.gen_range(0..1000)))
                .with_attribute("session_id", format!("session_{}", self.rng.gen_range(0..10000)))
        }

        pub fn generate_batch(&mut self, size: usize) -> Vec<TelemetryData> {
            let mut batch = Vec::new();
            
            for _ in 0..size {
                match self.rng.gen_range(0..3) {
                    0 => batch.push(self.generate_trace()),
                    1 => batch.push(self.generate_metric()),
                    _ => batch.push(self.generate_log()),
                }
            }
            
            batch
        }
    }
}
```

## 📈 测试覆盖率

### 1. 覆盖率配置

```toml
# Cargo.toml
[dev-dependencies]
cargo-tarpaulin = "0.25"

# 运行覆盖率测试
# cargo tarpaulin --out Html --output-dir coverage
```

### 2. 覆盖率目标

- **单元测试覆盖率**: ≥ 90%
- **集成测试覆盖率**: ≥ 80%
- **关键路径覆盖率**: 100%

## 🚀 测试执行

### 1. 本地测试

```bash
# 运行所有测试
cargo test

# 运行特定测试
cargo test test_client_creation

# 运行集成测试
cargo test --test integration_tests

# 运行性能测试
cargo bench

# 生成覆盖率报告
cargo tarpaulin --out Html
```

### 2. CI/CD集成

```yaml
# GitHub Actions 测试步骤
- name: Run tests
  run: cargo test --verbose

- name: Run integration tests
  run: cargo test --test '*' --verbose

- name: Generate coverage
  run: cargo tarpaulin --out Xml

- name: Upload coverage
  uses: codecov/codecov-action@v3
  with:
    file: ./cobertura.xml
```

## 📚 最佳实践

### 1. 测试设计原则

- **单一职责**: 每个测试只验证一个功能点
- **独立性**: 测试之间不应该相互依赖
- **可重复性**: 测试结果应该是确定性的
- **快速执行**: 单元测试应该快速执行

### 2. 测试命名规范

- **单元测试**: `test_<function_name>`
- **集成测试**: `test_<module>_<functionality>`
- **性能测试**: `benchmark_<operation>`
- **压力测试**: `test_<component>_stress`

### 3. 测试数据管理

- **使用工厂模式**: 创建测试数据生成器
- **模拟外部依赖**: 使用mock对象
- **清理资源**: 确保测试后清理资源
- **并行执行**: 支持测试并行执行

---

**测试框架与用例版本**: v1.0  
**最后更新**: 2025年1月27日  
**维护者**: OTLP 2025 文档团队
