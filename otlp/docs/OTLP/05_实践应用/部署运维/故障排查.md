# æ•…éšœæ’æŸ¥ä¸è¯Šæ–­æŒ‡å—

## ğŸ“š æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›äº†OTLP Ruståº”ç”¨çš„å®Œæ•´æ•…éšœæ’æŸ¥æŒ‡å—ï¼ŒåŒ…æ‹¬å¸¸è§é—®é¢˜è¯Šæ–­ã€æ•…éšœæ’é™¤æµç¨‹ã€è¯Šæ–­å·¥å…·å’Œåº”æ€¥å“åº”ç¨‹åºã€‚

## ğŸ” æ•…éšœæ’æŸ¥æµç¨‹

### 1. æ•…éšœåˆ†ç±»

```mermaid
graph TD
    A[æ•…éšœæŠ¥å‘Š] --> B{æ•…éšœç±»å‹}
    B -->|åº”ç”¨æ•…éšœ| C[åº”ç”¨å±‚æ’æŸ¥]
    B -->|ç½‘ç»œæ•…éšœ| D[ç½‘ç»œå±‚æ’æŸ¥]
    B -->|å­˜å‚¨æ•…éšœ| E[å­˜å‚¨å±‚æ’æŸ¥]
    B -->|é…ç½®æ•…éšœ| F[é…ç½®å±‚æ’æŸ¥]
    
    C --> G[æ£€æŸ¥åº”ç”¨çŠ¶æ€]
    D --> H[æ£€æŸ¥ç½‘ç»œè¿æ¥]
    E --> I[æ£€æŸ¥å­˜å‚¨çŠ¶æ€]
    F --> J[æ£€æŸ¥é…ç½®æ–‡ä»¶]
    
    G --> K[æ”¶é›†è¯Šæ–­ä¿¡æ¯]
    H --> K
    I --> K
    J --> K
    
    K --> L[åˆ†ææ ¹æœ¬åŸå› ]
    L --> M[åˆ¶å®šè§£å†³æ–¹æ¡ˆ]
    M --> N[å®æ–½ä¿®å¤]
    N --> O[éªŒè¯ä¿®å¤æ•ˆæœ]
```

### 2. æ•…éšœä¸¥é‡ç¨‹åº¦åˆ†çº§

| çº§åˆ« | æè¿° | å“åº”æ—¶é—´ | å½±å“èŒƒå›´ |
|------|------|----------|----------|
| P0 | ç³»ç»Ÿå®Œå…¨ä¸å¯ç”¨ | 15åˆ†é’Ÿ | æ‰€æœ‰ç”¨æˆ· |
| P1 | æ ¸å¿ƒåŠŸèƒ½ä¸å¯ç”¨ | 1å°æ—¶ | å¤§éƒ¨åˆ†ç”¨æˆ· |
| P2 | éƒ¨åˆ†åŠŸèƒ½å¼‚å¸¸ | 4å°æ—¶ | éƒ¨åˆ†ç”¨æˆ· |
| P3 | æ€§èƒ½ä¸‹é™ | 24å°æ—¶ | å°‘æ•°ç”¨æˆ· |

## ğŸš¨ å¸¸è§æ•…éšœåœºæ™¯

### 1. åº”ç”¨å¯åŠ¨å¤±è´¥

#### ç—‡çŠ¶

- PodçŠ¶æ€ä¸ºCrashLoopBackOff
- åº”ç”¨æ— æ³•å“åº”å¥åº·æ£€æŸ¥
- æ—¥å¿—æ˜¾ç¤ºå¯åŠ¨é”™è¯¯

#### æ’æŸ¥æ­¥éª¤

```bash
# 1. æ£€æŸ¥PodçŠ¶æ€
kubectl get pods -n otlp-system -l app=otlp-app

# 2. æŸ¥çœ‹Podäº‹ä»¶
kubectl describe pod <pod-name> -n otlp-system

# 3. æŸ¥çœ‹åº”ç”¨æ—¥å¿—
kubectl logs <pod-name> -n otlp-system --previous

# 4. æ£€æŸ¥é…ç½®æ–‡ä»¶
kubectl get configmap otlp-app-config -n otlp-system -o yaml

# 5. æ£€æŸ¥Secret
kubectl get secret otlp-app-secrets -n otlp-system -o yaml
```

#### å¸¸è§åŸå› åŠè§£å†³æ–¹æ¡ˆ

| åŸå›  | è§£å†³æ–¹æ¡ˆ |
|------|----------|
| é…ç½®é”™è¯¯ | æ£€æŸ¥ConfigMapå’ŒSecreté…ç½® |
| ä¾èµ–æœåŠ¡ä¸å¯ç”¨ | æ£€æŸ¥ä¾èµ–æœåŠ¡çŠ¶æ€ |
| èµ„æºä¸è¶³ | æ£€æŸ¥èµ„æºé™åˆ¶å’Œè¯·æ±‚ |
| ç«¯å£å†²çª | æ£€æŸ¥ç«¯å£é…ç½® |
| æƒé™é—®é¢˜ | æ£€æŸ¥RBACé…ç½® |

### 2. ç½‘ç»œè¿æ¥é—®é¢˜

#### ç—‡çŠ¶2

- è¿æ¥è¶…æ—¶
- è¿æ¥è¢«æ‹’ç»
- ç½‘ç»œä¸å¯è¾¾

#### æ’æŸ¥æ­¥éª¤2

```bash
# 1. æ£€æŸ¥ServiceçŠ¶æ€
kubectl get svc -n otlp-system

# 2. æ£€æŸ¥Endpoint
kubectl get endpoints -n otlp-system

# 3. æµ‹è¯•ç½‘ç»œè¿æ¥
kubectl exec -it <pod-name> -n otlp-system -- curl -v http://otel-collector:4317

# 4. æ£€æŸ¥DNSè§£æ
kubectl exec -it <pod-name> -n otlp-system -- nslookup otel-collector

# 5. æ£€æŸ¥ç½‘ç»œç­–ç•¥
kubectl get networkpolicy -n otlp-system
```

#### è¯Šæ–­è„šæœ¬

```bash
#!/bin/bash
# network-diagnostics.sh

NAMESPACE=${1:-otlp-system}
POD_NAME=${2:-}

if [ -z "$POD_NAME" ]; then
    POD_NAME=$(kubectl get pods -n "$NAMESPACE" -l app=otlp-app -o jsonpath='{.items[0].metadata.name}')
fi

echo "=== Network Diagnostics for Pod: $POD_NAME ==="

# æ£€æŸ¥Podç½‘ç»œé…ç½®
echo "1. Pod Network Configuration:"
kubectl exec -it "$POD_NAME" -n "$NAMESPACE" -- ip addr show

# æ£€æŸ¥è·¯ç”±è¡¨
echo -e "\n2. Routing Table:"
kubectl exec -it "$POD_NAME" -n "$NAMESPACE" -- ip route show

# æµ‹è¯•DNSè§£æ
echo -e "\n3. DNS Resolution Test:"
kubectl exec -it "$POD_NAME" -n "$NAMESPACE" -- nslookup kubernetes.default.svc.cluster.local

# æµ‹è¯•å†…éƒ¨æœåŠ¡è¿æ¥
echo -e "\n4. Internal Service Connectivity:"
kubectl exec -it "$POD_NAME" -n "$NAMESPACE" -- curl -v --connect-timeout 5 http://otel-collector:4317/health || echo "Connection failed"

# æµ‹è¯•å¤–éƒ¨è¿æ¥
echo -e "\n5. External Connectivity:"
kubectl exec -it "$POD_NAME" -n "$NAMESPACE" -- curl -v --connect-timeout 5 http://www.google.com || echo "External connection failed"

# æ£€æŸ¥ç«¯å£ç›‘å¬
echo -e "\n6. Port Listening Status:"
kubectl exec -it "$POD_NAME" -n "$NAMESPACE" -- netstat -tlnp
```

### 3. æ€§èƒ½é—®é¢˜

#### ç—‡çŠ¶3

- å“åº”æ—¶é—´è¿‡é•¿
- ååé‡ä¸‹é™
- èµ„æºä½¿ç”¨ç‡é«˜

#### æ’æŸ¥æ­¥éª¤3

```bash
# 1. æ£€æŸ¥èµ„æºä½¿ç”¨
kubectl top pods -n otlp-system -l app=otlp-app

# 2. æ£€æŸ¥èŠ‚ç‚¹èµ„æº
kubectl top nodes

# 3. æŸ¥çœ‹åº”ç”¨æŒ‡æ ‡
kubectl port-forward -n otlp-system svc/otlp-app-service 8080:80
curl http://localhost:8080/metrics | grep -E "(duration|latency|queue)"

# 4. æ£€æŸ¥æ…¢æŸ¥è¯¢æ—¥å¿—
kubectl logs <pod-name> -n otlp-system | grep -i "slow\|timeout\|error"

# 5. åˆ†æå†…å­˜ä½¿ç”¨
kubectl exec -it <pod-name> -n otlp-system -- ps aux
```

#### æ€§èƒ½åˆ†æè„šæœ¬

```bash
#!/bin/bash
# performance-analysis.sh

NAMESPACE=${1:-otlp-system}
DURATION=${2:-300}

echo "=== Performance Analysis for OTLP App ==="

# è·å–Podåç§°
POD_NAME=$(kubectl get pods -n "$NAMESPACE" -l app=otlp-app -o jsonpath='{.items[0].metadata.name}')

if [ -z "$POD_NAME" ]; then
    echo "No OTLP app pods found"
    exit 1
fi

echo "Analyzing pod: $POD_NAME"
echo "Duration: $DURATION seconds"

# ç«¯å£è½¬å‘
kubectl port-forward -n "$NAMESPACE" svc/otlp-app-service 8080:80 &
PORT_FORWARD_PID=$!

sleep 5

# æ”¶é›†æ€§èƒ½æ•°æ®
echo "1. Collecting baseline metrics..."
curl -s http://localhost:8080/metrics > baseline_metrics.txt

echo "2. Running load test..."
for i in {1..100}; do
    curl -s -w "%{time_total}\n" -o /dev/null http://localhost:8080/health &
done
wait

echo "3. Collecting post-load metrics..."
curl -s http://localhost:8080/metrics > post_load_metrics.txt

# åˆ†æç»“æœ
echo "4. Performance Analysis Results:"

echo "Baseline metrics:"
grep -E "otlp_request_duration_seconds|otlp_queue_size|otlp_active_connections" baseline_metrics.txt

echo -e "\nPost-load metrics:"
grep -E "otlp_request_duration_seconds|otlp_queue_size|otlp_active_connections" post_load_metrics.txt

echo -e "\nResource usage:"
kubectl top pod "$POD_NAME" -n "$NAMESPACE"

# æ¸…ç†
kill $PORT_FORWARD_PID
rm -f baseline_metrics.txt post_load_metrics.txt
```

## ğŸ› ï¸ è¯Šæ–­å·¥å…·

### 1. ç³»ç»Ÿè¯Šæ–­å·¥å…·

```rust
// src/diagnostics.rs
use std::collections::HashMap;
use serde_json::json;
use tokio::time::{Duration, Instant};

pub struct DiagnosticTool {
    client: OtlpClient,
}

impl DiagnosticTool {
    pub fn new(client: OtlpClient) -> Self {
        Self { client }
    }
    
    pub async fn run_full_diagnostics(&self) -> DiagnosticReport {
        let mut report = DiagnosticReport::new();
        
        // åŸºç¡€è¿æ¥æµ‹è¯•
        report.add_test("connection_test", self.test_connection().await);
        
        // æ•°æ®ä¼ è¾“æµ‹è¯•
        report.add_test("data_transmission", self.test_data_transmission().await);
        
        // æ€§èƒ½æµ‹è¯•
        report.add_test("performance", self.test_performance().await);
        
        // é…ç½®éªŒè¯
        report.add_test("configuration", self.test_configuration().await);
        
        // èµ„æºä½¿ç”¨æ£€æŸ¥
        report.add_test("resources", self.test_resources().await);
        
        report
    }
    
    async fn test_connection(&self) -> TestResult {
        let start = Instant::now();
        
        match self.client.initialize().await {
            Ok(_) => {
                let duration = start.elapsed();
                TestResult::success(format!("Connection established in {:?}", duration))
            }
            Err(e) => {
                TestResult::failure(format!("Connection failed: {}", e))
            }
        }
    }
    
    async fn test_data_transmission(&self) -> TestResult {
        let start = Instant::now();
        
        // å‘é€æµ‹è¯•æ•°æ®
        let trace_result = self.client.send_trace("diagnostic-test").await
            .map_err(|e| format!("Failed to send trace: {}", e))?
            .with_attribute("test.type", "diagnostic")
            .finish()
            .await
            .map_err(|e| format!("Failed to finish trace: {}", e))?;
        
        let metric_result = self.client.send_metric("diagnostic_metric", 1.0).await
            .map_err(|e| format!("Failed to send metric: {}", e))?
            .with_label("test", "diagnostic")
            .send()
            .await
            .map_err(|e| format!("Failed to send metric: {}", e))?;
        
        let log_result = self.client.send_log("Diagnostic test log", LogSeverity::Info).await
            .map_err(|e| format!("Failed to send log: {}", e))?
            .with_attribute("test.type", "diagnostic")
            .send()
            .await
            .map_err(|e| format!("Failed to send log: {}", e))?;
        
        let duration = start.elapsed();
        let total_sent = trace_result.success_count + metric_result.success_count + log_result.success_count;
        
        if total_sent > 0 {
            TestResult::success(format!(
                "Data transmission successful: {} items sent in {:?}",
                total_sent, duration
            ))
        } else {
            TestResult::failure("No data was sent successfully".to_string())
        }
    }
    
    async fn test_performance(&self) -> TestResult {
        let num_requests = 100;
        let start = Instant::now();
        
        let mut futures = Vec::new();
        for i in 0..num_requests {
            let client = self.client.clone();
            let future = tokio::spawn(async move {
                client.send_trace(format!("perf-test-{}", i)).await
                    .map_err(|e| format!("Request {} failed: {}", i, e))?
                    .finish()
                    .await
                    .map_err(|e| format!("Request {} failed: {}", i, e))
            });
            futures.push(future);
        }
        
        let results = futures::future::join_all(futures).await;
        let successful: usize = results.iter()
            .filter(|r| r.is_ok())
            .count();
        
        let duration = start.elapsed();
        let rps = num_requests as f64 / duration.as_secs_f64();
        
        if successful >= num_requests * 95 / 100 {
            TestResult::success(format!(
                "Performance test passed: {}/{} requests successful, {:.2} RPS",
                successful, num_requests, rps
            ))
        } else {
            TestResult::failure(format!(
                "Performance test failed: {}/{} requests successful",
                successful, num_requests
            ))
        }
    }
    
    async fn test_configuration(&self) -> TestResult {
        let config = self.client.get_config().await;
        
        let mut issues = Vec::new();
        
        if config.endpoint.is_empty() {
            issues.push("Endpoint is empty".to_string());
        }
        
        if config.sampling_ratio < 0.0 || config.sampling_ratio > 1.0 {
            issues.push("Invalid sampling ratio".to_string());
        }
        
        if config.batch_config.max_export_batch_size == 0 {
            issues.push("Invalid batch size".to_string());
        }
        
        if issues.is_empty() {
            TestResult::success("Configuration is valid".to_string())
        } else {
            TestResult::failure(format!("Configuration issues: {}", issues.join(", ")))
        }
    }
    
    async fn test_resources(&self) -> TestResult {
        let metrics = self.client.get_metrics().await;
        
        let mut status = Vec::new();
        
        if metrics.memory_usage > 100 * 1024 * 1024 * 1024 { // 100GB
            status.push("High memory usage".to_string());
        }
        
        if metrics.queue_size > 1000 {
            status.push("Large queue size".to_string());
        }
        
        if metrics.exporter_metrics.success_rate < 0.95 {
            status.push("Low success rate".to_string());
        }
        
        if status.is_empty() {
            TestResult::success("Resources are within normal limits".to_string())
        } else {
            TestResult::warning(format!("Resource warnings: {}", status.join(", ")))
        }
    }
}

#[derive(Debug, Clone)]
pub struct DiagnosticReport {
    pub tests: HashMap<String, TestResult>,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

impl DiagnosticReport {
    pub fn new() -> Self {
        Self {
            tests: HashMap::new(),
            timestamp: chrono::Utc::now(),
        }
    }
    
    pub fn add_test(&mut self, name: String, result: TestResult) {
        self.tests.insert(name, result);
    }
    
    pub fn get_summary(&self) -> String {
        let total = self.tests.len();
        let successful = self.tests.values()
            .filter(|r| matches!(r, TestResult::Success(_)))
            .count();
        let warnings = self.tests.values()
            .filter(|r| matches!(r, TestResult::Warning(_)))
            .count();
        let failures = self.tests.values()
            .filter(|r| matches!(r, TestResult::Failure(_)))
            .count();
        
        format!(
            "Diagnostic Summary: {}/{} tests passed, {} warnings, {} failures",
            successful, total, warnings, failures
        )
    }
    
    pub fn to_json(&self) -> String {
        json!({
            "timestamp": self.timestamp.to_rfc3339(),
            "summary": self.get_summary(),
            "tests": self.tests
        }).to_string()
    }
}

#[derive(Debug, Clone)]
pub enum TestResult {
    Success(String),
    Warning(String),
    Failure(String),
}

impl TestResult {
    pub fn success(message: String) -> Self {
        Self::Success(message)
    }
    
    pub fn warning(message: String) -> Self {
        Self::Warning(message)
    }
    
    pub fn failure(message: String) -> Self {
        Self::Failure(message)
    }
}
```

### 2. æ—¥å¿—åˆ†æå·¥å…·

```bash
#!/bin/bash
# log-analyzer.sh

NAMESPACE=${1:-otlp-system}
POD_NAME=${2:-}
LOG_LINES=${3:-1000}

if [ -z "$POD_NAME" ]; then
    POD_NAME=$(kubectl get pods -n "$NAMESPACE" -l app=otlp-app -o jsonpath='{.items[0].metadata.name}')
fi

echo "=== Log Analysis for Pod: $POD_NAME ==="

# æ”¶é›†æ—¥å¿—
echo "1. Collecting logs..."
kubectl logs "$POD_NAME" -n "$NAMESPACE" --tail="$LOG_LINES" > logs.txt

# é”™è¯¯åˆ†æ
echo "2. Error Analysis:"
echo "Total errors:"
grep -i "error\|failed\|exception" logs.txt | wc -l

echo -e "\nError types:"
grep -i "error\|failed\|exception" logs.txt | sort | uniq -c | sort -nr | head -10

# æ€§èƒ½åˆ†æ
echo -e "\n3. Performance Analysis:"
echo "Slow operations:"
grep -E "duration|latency|timeout" logs.txt | sort | uniq -c | sort -nr | head -5

# è¿æ¥åˆ†æ
echo -e "\n4. Connection Analysis:"
echo "Connection issues:"
grep -i "connection\|connect" logs.txt | sort | uniq -c | sort -nr | head -5

# æ—¶é—´åˆ†æ
echo -e "\n5. Time-based Analysis:"
echo "Recent errors (last 10):"
grep -i "error\|failed\|exception" logs.txt | tail -10

# æ¸…ç†
rm -f logs.txt
```

### 3. é…ç½®éªŒè¯å·¥å…·

```bash
#!/bin/bash
# config-validator.sh

NAMESPACE=${1:-otlp-system}

echo "=== Configuration Validation ==="

# æ£€æŸ¥ConfigMap
echo "1. ConfigMap Validation:"
kubectl get configmap otlp-app-config -n "$NAMESPACE" -o yaml > configmap.yaml

if [ -f configmap.yaml ]; then
    echo "âœ“ ConfigMap exists"
    
    # éªŒè¯YAMLæ ¼å¼
    if kubectl apply --dry-run=client -f configmap.yaml > /dev/null 2>&1; then
        echo "âœ“ ConfigMap YAML is valid"
    else
        echo "âœ— ConfigMap YAML is invalid"
    fi
else
    echo "âœ— ConfigMap not found"
fi

# æ£€æŸ¥Secret
echo -e "\n2. Secret Validation:"
kubectl get secret otlp-app-secrets -n "$NAMESPACE" -o yaml > secret.yaml

if [ -f secret.yaml ]; then
    echo "âœ“ Secret exists"
    
    # æ£€æŸ¥å¿…éœ€çš„å¯†é’¥
    if kubectl get secret otlp-app-secrets -n "$NAMESPACE" -o jsonpath='{.data.api-key}' > /dev/null 2>&1; then
        echo "âœ“ API key exists"
    else
        echo "âœ— API key missing"
    fi
else
    echo "âœ— Secret not found"
fi

# æ£€æŸ¥éƒ¨ç½²é…ç½®
echo -e "\n3. Deployment Validation:"
kubectl get deployment otlp-app -n "$NAMESPACE" -o yaml > deployment.yaml

if [ -f deployment.yaml ]; then
    echo "âœ“ Deployment exists"
    
    # æ£€æŸ¥é•œåƒ
    local image=$(kubectl get deployment otlp-app -n "$NAMESPACE" -o jsonpath='{.spec.template.spec.containers[0].image}')
    echo "Image: $image"
    
    # æ£€æŸ¥èµ„æºé™åˆ¶
    local cpu_limit=$(kubectl get deployment otlp-app -n "$NAMESPACE" -o jsonpath='{.spec.template.spec.containers[0].resources.limits.cpu}')
    local memory_limit=$(kubectl get deployment otlp-app -n "$NAMESPACE" -o jsonpath='{.spec.template.spec.containers[0].resources.limits.memory}')
    
    echo "CPU Limit: $cpu_limit"
    echo "Memory Limit: $memory_limit"
else
    echo "âœ— Deployment not found"
fi

# æ£€æŸ¥Service
echo -e "\n4. Service Validation:"
kubectl get service otlp-app-service -n "$NAMESPACE" -o yaml > service.yaml

if [ -f service.yaml ]; then
    echo "âœ“ Service exists"
    
    # æ£€æŸ¥ç«¯å£
    local port=$(kubectl get service otlp-app-service -n "$NAMESPACE" -o jsonpath='{.spec.ports[0].port}')
    echo "Port: $port"
else
    echo "âœ— Service not found"
fi

# æ£€æŸ¥Ingress
echo -e "\n5. Ingress Validation:"
kubectl get ingress -n "$NAMESPACE" -o yaml > ingress.yaml

if [ -f ingress.yaml ] && [ -s ingress.yaml ]; then
    echo "âœ“ Ingress exists"
    
    local host=$(kubectl get ingress -n "$NAMESPACE" -o jsonpath='{.items[0].spec.rules[0].host}')
    echo "Host: $host"
else
    echo "âœ— Ingress not found"
fi

# æ¸…ç†ä¸´æ—¶æ–‡ä»¶
rm -f configmap.yaml secret.yaml deployment.yaml service.yaml ingress.yaml
```

## ğŸš¨ åº”æ€¥å“åº”ç¨‹åº

### 1. P0çº§æ•…éšœå“åº”

```bash
#!/bin/bash
# p0-incident-response.sh

set -euo pipefail

INCIDENT_ID=$(date +%Y%m%d-%H%M%S)
NAMESPACE=${1:-otlp-system}

echo "=== P0 Incident Response - ID: $INCIDENT_ID ==="

# 1. ç«‹å³é€šçŸ¥
echo "1. Sending immediate notifications..."
curl -X POST -H 'Content-type: application/json' \
    --data "{\"text\":\"ğŸš¨ P0 INCIDENT: OTLP Rust application is down - Incident ID: $INCIDENT_ID\"}" \
    "$SLACK_WEBHOOK_URL"

# 2. å¿«é€Ÿè¯Šæ–­
echo "2. Running quick diagnostics..."
./health-check.sh "$NAMESPACE" > "incident-$INCIDENT_ID-diagnostics.txt"

# 3. æ£€æŸ¥ç³»ç»ŸçŠ¶æ€
echo "3. Checking system status..."
kubectl get pods -n "$NAMESPACE" -l app=otlp-app > "incident-$INCIDENT_ID-pods.txt"
kubectl get events -n "$NAMESPACE" --sort-by='.lastTimestamp' | tail -20 > "incident-$INCIDENT_ID-events.txt"

# 4. å°è¯•è‡ªåŠ¨æ¢å¤
echo "4. Attempting automatic recovery..."
kubectl rollout restart deployment/otlp-app -n "$NAMESPACE"

# ç­‰å¾…æ¢å¤
echo "5. Waiting for recovery..."
sleep 60

# æ£€æŸ¥æ¢å¤çŠ¶æ€
if ./health-check.sh "$NAMESPACE" > /dev/null 2>&1; then
    echo "âœ“ Application recovered automatically"
    curl -X POST -H 'Content-type: application/json' \
        --data "{\"text\":\"âœ… RECOVERY: OTLP Rust application recovered - Incident ID: $INCIDENT_ID\"}" \
        "$SLACK_WEBHOOK_URL"
else
    echo "âœ— Automatic recovery failed"
    echo "6. Escalating to on-call engineer..."
    curl -X POST -H 'Content-type: application/json' \
        --data "{\"text\":\"âš ï¸ ESCALATION: Automatic recovery failed - Incident ID: $INCIDENT_ID\"}" \
        "$SLACK_WEBHOOK_URL"
fi

echo "Incident response completed. Files saved with prefix: incident-$INCIDENT_ID"
```

### 2. å›æ»šç¨‹åº

```bash
#!/bin/bash
# emergency-rollback.sh

NAMESPACE=${1:-otlp-system}
TARGET_REVISION=${2:-}

if [ -z "$TARGET_REVISION" ]; then
    echo "Available revisions:"
    kubectl rollout history deployment/otlp-app -n "$NAMESPACE"
    echo "Usage: $0 <namespace> <revision>"
    exit 1
fi

echo "=== Emergency Rollback ==="
echo "Namespace: $NAMESPACE"
echo "Target Revision: $TARGET_REVISION"

# ç¡®è®¤å›æ»š
read -p "Are you sure you want to rollback to revision $TARGET_REVISION? (y/N): " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "Rollback cancelled"
    exit 1
fi

# æ‰§è¡Œå›æ»š
echo "Executing rollback..."
kubectl rollout undo deployment/otlp-app --to-revision="$TARGET_REVISION" -n "$NAMESPACE"

# ç­‰å¾…å›æ»šå®Œæˆ
echo "Waiting for rollback to complete..."
kubectl rollout status deployment/otlp-app -n "$NAMESPACE" --timeout=300s

# éªŒè¯å›æ»š
echo "Verifying rollback..."
if ./health-check.sh "$NAMESPACE" > /dev/null 2>&1; then
    echo "âœ“ Rollback successful and application is healthy"
else
    echo "âœ— Rollback completed but application is not healthy"
    exit 1
fi

echo "Emergency rollback completed"
```

## ğŸ“‹ æ•…éšœæ’æŸ¥æ£€æŸ¥æ¸…å•

### 1. åŸºç¡€æ£€æŸ¥æ¸…å•

- [ ] æ£€æŸ¥PodçŠ¶æ€å’Œäº‹ä»¶
- [ ] æŸ¥çœ‹åº”ç”¨æ—¥å¿—
- [ ] éªŒè¯é…ç½®æ–‡ä»¶
- [ ] æ£€æŸ¥ç½‘ç»œè¿æ¥
- [ ] éªŒè¯èµ„æºä½¿ç”¨
- [ ] æ£€æŸ¥ä¾èµ–æœåŠ¡çŠ¶æ€

### 2. é«˜çº§æ£€æŸ¥æ¸…å•

- [ ] è¿è¡Œå®Œæ•´è¯Šæ–­å·¥å…·
- [ ] åˆ†ææ€§èƒ½æŒ‡æ ‡
- [ ] æ£€æŸ¥å®‰å…¨é…ç½®
- [ ] éªŒè¯å¤‡ä»½å’Œæ¢å¤
- [ ] æ£€æŸ¥ç›‘æ§å’Œå‘Šè­¦
- [ ] å®¡æŸ¥å˜æ›´å†å²

### 3. æ•…éšœåæ£€æŸ¥æ¸…å•

- [ ] éªŒè¯é—®é¢˜å·²è§£å†³
- [ ] æ›´æ–°ç›‘æ§é…ç½®
- [ ] è®°å½•æ•…éšœæŠ¥å‘Š
- [ ] æ›´æ–°è¿è¡Œæ‰‹å†Œ
- [ ] è¿›è¡Œæ•…éšœå¤ç›˜
- [ ] å®æ–½é¢„é˜²æªæ–½

## ğŸ“š æœ€ä½³å®è·µ

### 1. é¢„é˜²æªæ–½

- **å®šæœŸå¥åº·æ£€æŸ¥**: å®æ–½è‡ªåŠ¨åŒ–çš„å¥åº·æ£€æŸ¥
- **ç›‘æ§å‘Šè­¦**: è®¾ç½®å…¨é¢çš„ç›‘æ§å’Œå‘Šè­¦
- **å®¹é‡è§„åˆ’**: å®šæœŸè¿›è¡Œå®¹é‡è§„åˆ’
- **å¤‡ä»½ç­–ç•¥**: å®æ–½å®Œæ•´çš„å¤‡ä»½ç­–ç•¥
- **å˜æ›´ç®¡ç†**: ä¸¥æ ¼æ§åˆ¶å˜æ›´æµç¨‹

### 2. å“åº”åŸåˆ™

- **å¿«é€Ÿå“åº”**: æ ¹æ®æ•…éšœçº§åˆ«å¿«é€Ÿå“åº”
- **ä¿¡æ¯é€æ˜**: åŠæ—¶æ›´æ–°æ•…éšœçŠ¶æ€
- **å›¢é˜Ÿåä½œ**: æœ‰æ•ˆåè°ƒå›¢é˜Ÿèµ„æº
- **æ–‡æ¡£è®°å½•**: è¯¦ç»†è®°å½•æ•…éšœå¤„ç†è¿‡ç¨‹
- **æŒç»­æ”¹è¿›**: ä»æ•…éšœä¸­å­¦ä¹ å’Œæ”¹è¿›

### 3. å·¥å…·ä½¿ç”¨

- **è‡ªåŠ¨åŒ–å·¥å…·**: ä¼˜å…ˆä½¿ç”¨è‡ªåŠ¨åŒ–å·¥å…·
- **æ ‡å‡†åŒ–æµç¨‹**: éµå¾ªæ ‡å‡†åŒ–çš„æ•…éšœå¤„ç†æµç¨‹
- **çŸ¥è¯†åº“**: ç»´æŠ¤å®Œæ•´çš„æ•…éšœçŸ¥è¯†åº“
- **åŸ¹è®­**: å®šæœŸè¿›è¡Œæ•…éšœå¤„ç†åŸ¹è®­
- **æ¼”ç»ƒ**: å®šæœŸè¿›è¡Œæ•…éšœæ¼”ç»ƒ

---

**æ•…éšœæ’æŸ¥ä¸è¯Šæ–­æŒ‡å—ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ27æ—¥  
**ç»´æŠ¤è€…**: OTLP 2025 æ–‡æ¡£å›¢é˜Ÿ
