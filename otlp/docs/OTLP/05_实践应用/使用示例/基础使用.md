# OTLP 基础使用示例

## 目录

- [OTLP 基础使用示例](#otlp-基础使用示例)
  - [目录](#目录)
  - [📚 概述](#-概述)
  - [🚀 快速开始](#-快速开始)
    - [基础配置](#基础配置)
  - [📊 追踪数据发送](#-追踪数据发送)
    - [基础追踪示例](#基础追踪示例)
    - [嵌套追踪示例](#嵌套追踪示例)
    - [错误追踪示例](#错误追踪示例)
  - [📈 指标数据发送](#-指标数据发送)
    - [计数器指标](#计数器指标)
    - [仪表盘指标](#仪表盘指标)
    - [直方图指标](#直方图指标)
  - [📝 日志数据发送](#-日志数据发送)
    - [基础日志示例](#基础日志示例)
    - [结构化日志示例](#结构化日志示例)
  - [📦 批量数据发送](#-批量数据发送)
    - [批量追踪数据](#批量追踪数据)
    - [混合数据类型批量发送](#混合数据类型批量发送)
  - [⚙️ 高级配置示例](#️-高级配置示例)
    - [生产环境配置](#生产环境配置)
    - [开发环境配置](#开发环境配置)
  - [🔄 异步并发示例](#-异步并发示例)
    - [并发发送追踪数据](#并发发送追踪数据)
    - [异步批处理示例](#异步批处理示例)
  - [🛡️ 错误处理示例](#️-错误处理示例)
    - [基础错误处理](#基础错误处理)
    - [重试机制示例](#重试机制示例)
  - [📊 性能监控示例](#-性能监控示例)
    - [获取客户端指标](#获取客户端指标)
    - [自定义性能指标](#自定义性能指标)
  - [🎯 完整应用示例](#-完整应用示例)
    - [Web服务集成示例](#web服务集成示例)
  - [📚 最佳实践](#-最佳实践)
    - [1. 资源管理](#1-资源管理)
    - [2. 配置管理](#2-配置管理)
    - [3. 错误处理策略](#3-错误处理策略)
  - [🚀 下一步](#-下一步)
    - [深入学习](#深入学习)
    - [实际应用](#实际应用)
    - [性能优化](#性能优化)

## 📚 概述

本文档提供了OTLP Rust实现的基础使用示例，涵盖了追踪、指标、日志的发送，以及常见的配置和最佳实践。

## 🚀 快速开始

### 基础配置

```rust
use c21_otlp::{OtlpClient, OtlpConfig};
use c21_otlp::transport::TransportProtocol;
use std::time::Duration;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 创建基础配置
    let config = OtlpConfig::default()
        .with_endpoint("http://localhost:4317")
        .with_protocol(TransportProtocol::Grpc)
        .with_service("example-service", "1.0.0")
        .with_timeout(Duration::from_secs(10));
    
    // 创建客户端
    let client = OtlpClient::new(config).await?;
    client.initialize().await?;
    
    // 使用客户端...
    
    client.shutdown().await?;
    Ok(())
}
```

## 📊 追踪数据发送

### 基础追踪示例

```rust
use c21_otlp::data::StatusCode;

async fn send_basic_trace(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    let result = client.send_trace("user-login").await?
        .with_attribute("service.name", "auth-service")
        .with_attribute("user.id", "12345")
        .with_attribute("operation.type", "authentication")
        .with_numeric_attribute("duration", 150.0)
        .with_status(StatusCode::Ok, Some("登录成功".to_string()))
        .finish()
        .await?;
    
    println!("追踪数据发送成功: {} 条", result.success_count);
    Ok(())
}
```

### 嵌套追踪示例

```rust
async fn send_nested_traces(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    // 父级追踪
    let parent_result = client.send_trace("process-order").await?
        .with_attribute("order.id", "ORD-001")
        .with_attribute("customer.id", "CUST-123")
        .finish()
        .await?;
    
    // 子级追踪 - 验证支付
    let payment_result = client.send_trace("validate-payment").await?
        .with_attribute("order.id", "ORD-001")
        .with_attribute("payment.method", "credit-card")
        .with_attribute("payment.amount", 99.99)
        .finish()
        .await?;
    
    // 子级追踪 - 库存检查
    let inventory_result = client.send_trace("check-inventory").await?
        .with_attribute("order.id", "ORD-001")
        .with_attribute("product.id", "PROD-456")
        .with_attribute("quantity", 2)
        .finish()
        .await?;
    
    println!("父级追踪: {} 条", parent_result.success_count);
    println!("支付验证: {} 条", payment_result.success_count);
    println!("库存检查: {} 条", inventory_result.success_count);
    
    Ok(())
}
```

### 错误追踪示例

```rust
use c21_otlp::data::StatusCode;

async fn send_error_trace(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    let result = client.send_trace("database-query").await?
        .with_attribute("service.name", "user-service")
        .with_attribute("db.operation", "SELECT")
        .with_attribute("db.table", "users")
        .with_attribute("error.message", "Connection timeout")
        .with_attribute("error.type", "DatabaseError")
        .with_numeric_attribute("duration", 5000.0)
        .with_status(StatusCode::Error, Some("数据库连接超时".to_string()))
        .finish()
        .await?;
    
    println!("错误追踪发送成功: {} 条", result.success_count);
    Ok(())
}
```

## 📈 指标数据发送

### 计数器指标

```rust
async fn send_counter_metrics(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    // HTTP请求计数器
    let http_result = client.send_metric("http_requests_total", 1.0).await?
        .with_label("method", "GET")
        .with_label("endpoint", "/api/users")
        .with_label("status_code", "200")
        .with_description("HTTP请求总数")
        .with_unit("count")
        .send()
        .await?;
    
    // 业务操作计数器
    let business_result = client.send_metric("orders_created_total", 1.0).await?
        .with_label("product_category", "electronics")
        .with_label("payment_method", "credit_card")
        .with_description("创建的订单总数")
        .with_unit("count")
        .send()
        .await?;
    
    println!("HTTP指标: {} 条", http_result.success_count);
    println!("业务指标: {} 条", business_result.success_count);
    
    Ok(())
}
```

### 仪表盘指标

```rust
async fn send_gauge_metrics(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    // 内存使用量
    let memory_result = client.send_metric("memory_usage_bytes", 1024.0 * 1024.0 * 512.0).await?
        .with_label("type", "heap")
        .with_description("内存使用量")
        .with_unit("bytes")
        .send()
        .await?;
    
    // 活跃连接数
    let connection_result = client.send_metric("active_connections", 42.0).await?
        .with_label("connection_type", "websocket")
        .with_description("活跃连接数")
        .with_unit("count")
        .send()
        .await?;
    
    println!("内存指标: {} 条", memory_result.success_count);
    println!("连接指标: {} 条", connection_result.success_count);
    
    Ok(())
}
```

### 直方图指标

```rust
async fn send_histogram_metrics(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    // 请求延迟分布
    let latency_result = client.send_metric("request_duration_seconds", 0.15).await?
        .with_label("endpoint", "/api/users")
        .with_label("method", "GET")
        .with_description("请求处理延迟")
        .with_unit("seconds")
        .send()
        .await?;
    
    // 响应大小分布
    let size_result = client.send_metric("response_size_bytes", 2048.0).await?
        .with_label("content_type", "application/json")
        .with_description("响应大小")
        .with_unit("bytes")
        .send()
        .await?;
    
    println!("延迟指标: {} 条", latency_result.success_count);
    println!("大小指标: {} 条", size_result.success_count);
    
    Ok(())
}
```

## 📝 日志数据发送

### 基础日志示例

```rust
use c21_otlp::data::LogSeverity;

async fn send_basic_logs(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    // 信息日志
    let info_result = client.send_log("用户登录成功", LogSeverity::Info).await?
        .with_attribute("user.id", "12345")
        .with_attribute("user.email", "user@example.com")
        .with_attribute("login.method", "password")
        .with_attribute("ip.address", "192.168.1.100")
        .send()
        .await?;
    
    // 警告日志
    let warning_result = client.send_log("API响应时间过长", LogSeverity::Warn).await?
        .with_attribute("endpoint", "/api/slow-endpoint")
        .with_attribute("response_time", 5000.0)
        .with_attribute("threshold", 3000.0)
        .send()
        .await?;
    
    // 错误日志
    let error_result = client.send_log("数据库连接失败", LogSeverity::Error).await?
        .with_attribute("database.host", "db.example.com")
        .with_attribute("database.port", 5432)
        .with_attribute("error.code", "CONNECTION_TIMEOUT")
        .with_attribute("retry_count", 3)
        .send()
        .await?;
    
    println!("信息日志: {} 条", info_result.success_count);
    println!("警告日志: {} 条", warning_result.success_count);
    println!("错误日志: {} 条", error_result.success_count);
    
    Ok(())
}
```

### 结构化日志示例

```rust
async fn send_structured_logs(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    // 订单处理日志
    let order_result = client.send_log("订单处理完成", LogSeverity::Info).await?
        .with_attribute("order.id", "ORD-12345")
        .with_attribute("order.amount", 299.99)
        .with_attribute("customer.id", "CUST-67890")
        .with_attribute("payment.method", "credit_card")
        .with_attribute("processing.time", 2.5)
        .with_attribute("items.count", 3)
        .with_trace_context("trace-abc123", "span-def456")
        .send()
        .await?;
    
    // 系统性能日志
    let performance_result = client.send_log("系统性能报告", LogSeverity::Info).await?
        .with_attribute("cpu.usage", 45.2)
        .with_attribute("memory.usage", 68.5)
        .with_attribute("disk.usage", 32.1)
        .with_attribute("network.throughput", 1024.0)
        .with_attribute("active.users", 1250)
        .send()
        .await?;
    
    println!("订单日志: {} 条", order_result.success_count);
    println!("性能日志: {} 条", performance_result.success_count);
    
    Ok(())
}
```

## 📦 批量数据发送

### 批量追踪数据

```rust
use c21_otlp::TelemetryData;

async fn send_batch_traces(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    let mut batch_data = Vec::new();
    
    // 创建多个追踪数据
    for i in 0..10 {
        let trace_data = TelemetryData::trace(format!("batch-operation-{}", i))
            .with_attribute("batch.id", "BATCH-001")
            .with_attribute("operation.index", i.to_string())
            .with_attribute("operation.type", "batch_process")
            .with_attribute("batch.size", "10");
        
        batch_data.push(trace_data);
    }
    
    let result = client.send_batch(batch_data).await?;
    println!("批量追踪发送成功: {} 条", result.success_count);
    
    Ok(())
}
```

### 混合数据类型批量发送

```rust
async fn send_mixed_batch(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    let mut batch_data = Vec::new();
    
    // 添加追踪数据
    for i in 0..5 {
        let trace_data = TelemetryData::trace(format!("api-call-{}", i))
            .with_attribute("endpoint", "/api/data")
            .with_attribute("method", "GET")
            .with_attribute("request.id", format!("REQ-{}", i));
        
        batch_data.push(trace_data);
    }
    
    // 添加指标数据
    for i in 0..3 {
        let metric_data = TelemetryData::metric("api_requests_total", 1.0)
            .with_label("endpoint", "/api/data")
            .with_label("status", "200");
        
        batch_data.push(metric_data);
    }
    
    // 添加日志数据
    for i in 0..2 {
        let log_data = TelemetryData::log("API请求处理", LogSeverity::Info)
            .with_attribute("request.id", format!("REQ-{}", i))
            .with_attribute("processing.time", 0.1 + i as f64 * 0.05);
        
        batch_data.push(log_data);
    }
    
    let result = client.send_batch(batch_data).await?;
    println!("混合批量数据发送成功: {} 条", result.success_count);
    
    Ok(())
}
```

## ⚙️ 高级配置示例

### 生产环境配置

```rust
async fn create_production_config() -> OtlpConfig {
    OtlpConfig::default()
        .with_endpoint("https://api.honeycomb.io:443")
        .with_protocol(TransportProtocol::Grpc)
        .with_compression(Compression::Gzip)
        .with_api_key("your-api-key")
        .with_bearer_token("your-bearer-token")
        .with_tls(true)
        .with_sampling_ratio(0.1) // 10%采样率
        .with_resource_attribute("service.name", "production-service")
        .with_resource_attribute("service.version", "2.1.0")
        .with_resource_attribute("deployment.environment", "production")
        .with_resource_attribute("deployment.region", "us-west-2")
        .with_batch_config(BatchConfig {
            max_export_batch_size: 512,
            export_timeout: Duration::from_millis(5000),
            max_queue_size: 2048,
            scheduled_delay: Duration::from_millis(5000),
        })
        .with_retry_config(RetryConfig {
            max_retries: 5,
            initial_retry_delay: Duration::from_millis(1000),
            max_retry_delay: Duration::from_secs(30),
            retry_delay_multiplier: 2.0,
            randomize_retry_delay: true,
        })
}
```

### 开发环境配置

```rust
async fn create_development_config() -> OtlpConfig {
    OtlpConfig::default()
        .with_endpoint("http://localhost:4317")
        .with_protocol(TransportProtocol::Grpc)
        .with_debug(true)
        .with_sampling_ratio(1.0) // 100%采样率用于调试
        .with_resource_attribute("service.name", "dev-service")
        .with_resource_attribute("service.version", "dev")
        .with_resource_attribute("deployment.environment", "development")
        .with_batch_config(BatchConfig {
            max_export_batch_size: 10, // 小批量用于快速调试
            export_timeout: Duration::from_millis(1000),
            max_queue_size: 100,
            scheduled_delay: Duration::from_millis(1000),
        })
}
```

## 🔄 异步并发示例

### 并发发送追踪数据

```rust
async fn send_concurrent_traces(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    let mut futures = Vec::new();
    
    // 创建多个并发任务
    for i in 0..10 {
        let client_clone = client.clone();
        let future = tokio::spawn(async move {
            client_clone.send_trace(format!("concurrent-operation-{}", i)).await?
                .with_attribute("task.id", i.to_string())
                .with_attribute("concurrent", "true")
                .finish()
                .await
        });
        futures.push(future);
    }
    
    // 等待所有任务完成
    let mut total_success = 0;
    for future in futures {
        let result = future.await??;
        total_success += result.success_count;
    }
    
    println!("并发发送完成，总计成功: {} 条", total_success);
    Ok(())
}
```

### 异步批处理示例

```rust
async fn async_batch_processing(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    let (tx, mut rx) = tokio::sync::mpsc::channel(100);
    
    // 生产者任务
    let producer = tokio::spawn(async move {
        for i in 0..100 {
            let data = TelemetryData::trace(format!("async-operation-{}", i))
                .with_attribute("batch.id", "ASYNC-BATCH")
                .with_attribute("operation.id", i.to_string());
            
            if tx.send(data).await.is_err() {
                break;
            }
            
            // 模拟异步数据生成
            tokio::time::sleep(Duration::from_millis(10)).await;
        }
    });
    
    // 消费者任务
    let consumer = tokio::spawn(async move {
        let mut batch = Vec::new();
        let batch_size = 20;
        
        while let Some(data) = rx.recv().await {
            batch.push(data);
            
            if batch.len() >= batch_size {
                let result = client.send_batch(batch).await?;
                println!("异步批处理发送: {} 条", result.success_count);
                batch = Vec::new();
            }
        }
        
        // 发送剩余数据
        if !batch.is_empty() {
            let result = client.send_batch(batch).await?;
            println!("最后批次发送: {} 条", result.success_count);
        }
        
        Ok::<(), Box<dyn std::error::Error>>(())
    });
    
    // 等待任务完成
    tokio::try_join!(producer, consumer)?;
    
    Ok(())
}
```

## 🛡️ 错误处理示例

### 基础错误处理

```rust
async fn handle_basic_errors(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    match client.send_trace("error-prone-operation").await {
        Ok(mut builder) => {
            match builder
                .with_attribute("operation.type", "risky")
                .finish()
                .await
            {
                Ok(result) => println!("操作成功: {} 条", result.success_count),
                Err(e) => eprintln!("发送失败: {}", e),
            }
        }
        Err(e) => eprintln!("创建追踪失败: {}", e),
    }
    
    Ok(())
}
```

### 重试机制示例

```rust
async fn send_with_retry(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    let max_retries = 3;
    let mut retry_count = 0;
    
    loop {
        match client.send_trace("retry-operation").await?
            .with_attribute("retry.count", retry_count.to_string())
            .finish()
            .await
        {
            Ok(result) => {
                println!("发送成功: {} 条", result.success_count);
                break;
            }
            Err(e) => {
                retry_count += 1;
                if retry_count >= max_retries {
                    eprintln!("达到最大重试次数，放弃发送: {}", e);
                    break;
                }
                
                eprintln!("发送失败，第{}次重试: {}", retry_count, e);
                tokio::time::sleep(Duration::from_millis(1000 * retry_count)).await;
            }
        }
    }
    
    Ok(())
}
```

## 📊 性能监控示例

### 获取客户端指标

```rust
async fn monitor_client_metrics(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    let metrics = client.get_metrics().await;
    
    println!("=== 客户端性能指标 ===");
    println!("总发送数据量: {}", metrics.total_data_sent);
    println!("总接收数据量: {}", metrics.total_data_received);
    println!("运行时间: {:?}", metrics.uptime);
    println!("平均导出延迟: {:?}", metrics.exporter_metrics.average_export_latency);
    println!("导出成功率: {:.2}%", metrics.exporter_metrics.success_rate * 100.0);
    println!("当前队列大小: {}", metrics.processor_metrics.current_queue_size);
    println!("处理的批次数量: {}", metrics.processor_metrics.processed_batches);
    
    Ok(())
}
```

### 自定义性能指标

```rust
async fn send_custom_performance_metrics(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    let start_time = std::time::Instant::now();
    
    // 执行一些操作
    let result = client.send_trace("performance-test").await?
        .with_attribute("test.type", "performance")
        .finish()
        .await?;
    
    let duration = start_time.elapsed();
    
    // 发送性能指标
    let perf_result = client.send_metric("operation_duration_ms", duration.as_millis() as f64).await?
        .with_label("operation", "performance-test")
        .with_label("result", "success")
        .with_description("操作执行时间")
        .with_unit("milliseconds")
        .send()
        .await?;
    
    println!("操作耗时: {:?}", duration);
    println!("追踪发送: {} 条", result.success_count);
    println!("性能指标: {} 条", perf_result.success_count);
    
    Ok(())
}
```

## 🎯 完整应用示例

### Web服务集成示例

```rust
use warp::Filter;

async fn create_web_service() -> Result<(), Box<dyn std::error::Error>> {
    let config = OtlpConfig::default()
        .with_endpoint("http://localhost:4317")
        .with_service("web-service", "1.0.0");
    
    let client = OtlpClient::new(config).await?;
    client.initialize().await?;
    
    // 创建路由
    let routes = warp::path("api")
        .and(warp::path("users"))
        .and(warp::get())
        .and_then(move || {
            let client = client.clone();
            async move {
                // 发送追踪数据
                let _ = client.send_trace("get-users").await?
                    .with_attribute("http.method", "GET")
                    .with_attribute("http.path", "/api/users")
                    .finish()
                    .await;
                
                // 发送指标数据
                let _ = client.send_metric("api_requests_total", 1.0).await?
                    .with_label("endpoint", "/api/users")
                    .with_label("method", "GET")
                    .send()
                    .await;
                
                Ok::<_, warp::Rejection>(warp::reply::json(&vec![
                    serde_json::json!({"id": 1, "name": "Alice"}),
                    serde_json::json!({"id": 2, "name": "Bob"}),
                ]))
            }
        });
    
    warp::serve(routes)
        .run(([127, 0, 0, 1], 3030))
        .await;
    
    client.shutdown().await?;
    Ok(())
}
```

## 📚 最佳实践

### 1. 资源管理

```rust
// 使用RAII模式管理客户端生命周期
struct OtlpService {
    client: OtlpClient,
}

impl OtlpService {
    async fn new() -> Result<Self, Box<dyn std::error::Error>> {
        let config = OtlpConfig::default()
            .with_endpoint("http://localhost:4317")
            .with_service("managed-service", "1.0.0");
        
        let client = OtlpClient::new(config).await?;
        client.initialize().await?;
        
        Ok(Self { client })
    }
}

impl Drop for OtlpService {
    fn drop(&mut self) {
        // 注意：这里需要异步清理，实际应用中可能需要使用不同的模式
        println!("OTLP服务正在关闭...");
    }
}
```

### 2. 配置管理

```rust
// 使用环境变量进行配置
fn load_config_from_env() -> OtlpConfig {
    let endpoint = std::env::var("OTLP_ENDPOINT")
        .unwrap_or_else(|_| "http://localhost:4317".to_string());
    
    let service_name = std::env::var("SERVICE_NAME")
        .unwrap_or_else(|_| "default-service".to_string());
    
    let service_version = std::env::var("SERVICE_VERSION")
        .unwrap_or_else(|_| "1.0.0".to_string());
    
    OtlpConfig::default()
        .with_endpoint(&endpoint)
        .with_service(&service_name, &service_version)
        .with_debug(std::env::var("DEBUG").is_ok())
}
```

### 3. 错误处理策略

```rust
// 统一的错误处理
async fn safe_send_trace(client: &OtlpClient, operation: &str) -> Result<u64, String> {
    match client.send_trace(operation).await {
        Ok(builder) => {
            match builder
                .with_attribute("operation", operation)
                .finish()
                .await
            {
                Ok(result) => Ok(result.success_count),
                Err(e) => Err(format!("发送失败: {}", e)),
            }
        }
        Err(e) => Err(format!("创建追踪失败: {}", e)),
    }
}
```

## 🚀 下一步

### 深入学习

1. **[高级配置示例](高级配置.md)** - 学习更复杂的配置选项
2. **[批量处理示例](批量处理.md)** - 了解高效的批量处理
3. **[错误处理示例](错误处理.md)** - 掌握错误处理最佳实践

### 实际应用

1. **[Web应用集成](../集成指南/Web应用集成.md)** - 集成到Web应用
2. **[微服务集成](../集成指南/微服务集成.md)** - 微服务环境部署
3. **[数据库集成](../集成指南/数据库集成.md)** - 数据库操作监控

### 性能优化

1. **[性能优化指南](../性能调优/优化策略.md)** - 提升应用性能
2. **[监控告警设置](../部署运维/监控告警.md)** - 建立监控体系
3. **[故障排查指南](../部署运维/故障排查.md)** - 快速定位问题

---

**基础使用示例版本**: v1.0  
**最后更新**: 2025年1月27日  
**维护者**: OTLP 2025 文档团队
