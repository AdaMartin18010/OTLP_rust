# 性能问题识别

## 目录

- [性能问题识别](#性能问题识别)
  - [目录](#目录)
  - [概述](#概述)
  - [性能指标监控](#性能指标监控)
    - [关键指标](#关键指标)
    - [Rust 实现：性能监控器](#rust-实现性能监控器)
  - [性能剖析方法](#性能剖析方法)
    - [CPU Profiling](#cpu-profiling)
    - [内存 Profiling](#内存-profiling)
  - [热点识别](#热点识别)
    - [Rust 实现：热点追踪器](#rust-实现热点追踪器)
  - [瓶颈定位](#瓶颈定位)
    - [系统瓶颈分类](#系统瓶颈分类)
    - [诊断脚本](#诊断脚本)
  - [性能基准测试](#性能基准测试)
    - [Rust 实现：基准测试框架](#rust-实现基准测试框架)

## 概述

性能问题识别是性能优化的第一步，需要系统化的方法和工具来发现系统瓶颈。

## 性能指标监控

### 关键指标

- **延迟指标**：P50, P95, P99, P999
- **吞吐量**：QPS, TPS
- **资源使用**：CPU, 内存, 网络, 磁盘I/O
- **错误率**：4xx, 5xx错误比例

### Rust 实现：性能监控器

```rust
use prometheus::{Histogram, Counter, Gauge, Registry};
use std::time::Instant;

pub struct PerformanceMonitor {
    latency_histogram: Histogram,
    throughput_counter: Counter,
    cpu_gauge: Gauge,
    memory_gauge: Gauge,
}

impl PerformanceMonitor {
    pub fn new(registry: &Registry) -> Result<Self, prometheus::Error> {
        let latency_histogram = Histogram::with_opts(
            prometheus::HistogramOpts::new("request_latency_seconds", "Request latency")
                .buckets(vec![0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1.0, 5.0])
        )?;

        let throughput_counter = Counter::new("requests_total", "Total requests")?;
        let cpu_gauge = Gauge::new("cpu_usage_percent", "CPU usage")?;
        let memory_gauge = Gauge::new("memory_usage_bytes", "Memory usage")?;

        registry.register(Box::new(latency_histogram.clone()))?;
        registry.register(Box::new(throughput_counter.clone()))?;
        registry.register(Box::new(cpu_gauge.clone()))?;
        registry.register(Box::new(memory_gauge.clone()))?;

        Ok(Self {
            latency_histogram,
            throughput_counter,
            cpu_gauge,
            memory_gauge,
        })
    }

    pub fn record_request(&self, start: Instant) {
        let duration = start.elapsed();
        self.latency_histogram.observe(duration.as_secs_f64());
        self.throughput_counter.inc();
    }
}
```

## 性能剖析方法

### CPU Profiling

```bash
# 使用 perf 进行 CPU 剖析
perf record -F 99 -p <PID> -g -- sleep 30
perf script | stackcollapse-perf.pl | flamegraph.pl > flamegraph.svg

# 使用 Rust 的 pprof
cargo build --release
CARGO_PROFILE_RELEASE_DEBUG=true cargo flamegraph
```

### 内存 Profiling

```bash
# 使用 valgrind
valgrind --tool=massif --massif-out-file=massif.out ./target/release/otlp

# 使用 heaptrack
heaptrack ./target/release/otlp
heaptrack_gui heaptrack.otlp.*.gz
```

## 热点识别

### Rust 实现：热点追踪器

```rust
use std::collections::HashMap;
use std::sync::Arc;
use parking_lot::RwLock;

pub struct HotspotTracker {
    function_calls: Arc<RwLock<HashMap<String, u64>>>,
    function_times: Arc<RwLock<HashMap<String, u128>>>,
}

impl HotspotTracker {
    pub fn new() -> Self {
        Self {
            function_calls: Arc::new(RwLock::new(HashMap::new())),
            function_times: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    pub fn track<F, R>(&self, function_name: &str, f: F) -> R
    where
        F: FnOnce() -> R,
    {
        let start = std::time::Instant::now();
        let result = f();
        let elapsed = start.elapsed().as_micros();

        {
            let mut calls = self.function_calls.write();
            *calls.entry(function_name.to_string()).or_insert(0) += 1;
        }

        {
            let mut times = self.function_times.write();
            *times.entry(function_name.to_string()).or_insert(0) += elapsed;
        }

        result
    }

    pub fn get_hotspots(&self, top_n: usize) -> Vec<(String, u64, u128)> {
        let calls = self.function_calls.read();
        let times = self.function_times.read();

        let mut hotspots: Vec<_> = calls
            .iter()
            .map(|(name, &count)| {
                let time = times.get(name).copied().unwrap_or(0);
                (name.clone(), count, time)
            })
            .collect();

        hotspots.sort_by(|a, b| b.2.cmp(&a.2));
        hotspots.truncate(top_n);
        hotspots
    }
}
```

## 瓶颈定位

### 系统瓶颈分类

1. **CPU 瓶颈**：CPU 使用率 > 80%
2. **内存瓶颈**：频繁 GC 或 OOM
3. **I/O 瓶颈**：磁盘/网络等待时间长
4. **锁竞争**：高并发下性能下降

### 诊断脚本

```bash
#!/bin/bash
# 性能瓶颈快速诊断

echo "=== CPU Usage ==="
top -bn1 | grep "Cpu(s)" | sed "s/.*, *\([0-9.]*\)%* id.*/\1/" | awk '{print 100 - $1"%"}'

echo "=== Memory Usage ==="
free -h

echo "=== Disk I/O ==="
iostat -x 1 3

echo "=== Network ==="
netstat -s | grep -i "segments retransmitted"

echo "=== Top Processes ==="
ps aux --sort=-%cpu | head -10
```

## 性能基准测试

### Rust 实现：基准测试框架

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};
use std::time::Duration;

pub fn otlp_export_benchmark(c: &mut Criterion) {
    let mut group = c.benchmark_group("otlp_export");
    
    for batch_size in [10, 100, 1000, 10000].iter() {
        group.bench_with_input(
            BenchmarkId::from_parameter(batch_size),
            batch_size,
            |b, &size| {
                b.iter(|| {
                    // 模拟导出操作
                    export_spans(black_box(size))
                });
            },
        );
    }
    
    group.finish();
}

fn export_spans(count: usize) {
    // 实际导出逻辑
}

criterion_group!(benches, otlp_export_benchmark);
criterion_main!(benches);
```

---

**相关文档**：

- [系统瓶颈分析](./系统瓶颈分析.md)
- [优化方案库](./优化方案库.md)
