# 系统瓶颈分析

## 目录

- [系统瓶颈分析](#系统瓶颈分析)
  - [目录](#目录)
  - [概述](#概述)
  - [CPU 瓶颈分析](#cpu-瓶颈分析)
    - [识别方法](#识别方法)
    - [优化策略](#优化策略)
  - [内存瓶颈分析](#内存瓶颈分析)
    - [识别方法1](#识别方法1)
    - [Rust 实现：内存监控](#rust-实现内存监控)
  - [I/O 瓶颈分析](#io-瓶颈分析)
    - [磁盘 I/O](#磁盘-io)
    - [优化策略1](#优化策略1)
  - [网络瓶颈分析](#网络瓶颈分析)
    - [识别方法2](#识别方法2)
    - [Rust 实现：网络监控](#rust-实现网络监控)
  - [并发瓶颈分析](#并发瓶颈分析)
    - [锁竞争分析](#锁竞争分析)

## 概述

系统瓶颈分析帮助定位限制系统性能的关键因素，为优化提供方向。

## CPU 瓶颈分析

### 识别方法

```bash
# CPU 使用率
mpstat -P ALL 1

# CPU 火焰图
perf record -F 99 -a -g -- sleep 30
perf script | flamegraph.pl > cpu-flamegraph.svg

# 查看 CPU 密集型进程
ps aux --sort=-%cpu | head -20
```

### 优化策略

1. **算法优化**：降低时间复杂度
2. **并行化**：利用多核
3. **缓存**：减少重复计算
4. **异步处理**：避免阻塞

## 内存瓶颈分析

### 识别方法1

```bash
# 内存使用情况
free -h
vmstat 1

# 内存泄漏检测
valgrind --leak-check=full ./program

# Rust 内存分析
cargo build --release
heaptrack ./target/release/program
```

### Rust 实现：内存监控

```rust
use std::alloc::{GlobalAlloc, Layout, System};
use std::sync::atomic::{AtomicUsize, Ordering};

pub struct TrackingAllocator;

static ALLOCATED: AtomicUsize = AtomicUsize::new(0);

unsafe impl GlobalAlloc for TrackingAllocator {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        let ret = System.alloc(layout);
        if !ret.is_null() {
            ALLOCATED.fetch_add(layout.size(), Ordering::SeqCst);
        }
        ret
    }

    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
        System.dealloc(ptr, layout);
        ALLOCATED.fetch_sub(layout.size(), Ordering::SeqCst);
    }
}

pub fn current_memory_usage() -> usize {
    ALLOCATED.load(Ordering::SeqCst)
}
```

## I/O 瓶颈分析

### 磁盘 I/O

```bash
# I/O 统计
iostat -x 1

# I/O 延迟分析
ioping /path/to/disk

# 查看 I/O 密集型进程
iotop -o
```

### 优化策略1

1. **批量写入**：减少 I/O 次数
2. **异步 I/O**：非阻塞操作
3. **缓冲**：减少小块写入
4. **SSD**：使用更快的存储介质

## 网络瓶颈分析

### 识别方法2

```bash
# 网络带宽使用
iftop -i eth0

# TCP 连接状态
netstat -ant | awk '{print $6}' | sort | uniq -c

# 丢包和重传
netstat -s | grep -i "segments retransmitted"
```

### Rust 实现：网络监控

```rust
use std::time::Instant;
use std::sync::atomic::{AtomicU64, Ordering};

pub struct NetworkMonitor {
    bytes_sent: AtomicU64,
    bytes_received: AtomicU64,
    start_time: Instant,
}

impl NetworkMonitor {
    pub fn new() -> Self {
        Self {
            bytes_sent: AtomicU64::new(0),
            bytes_received: AtomicU64::new(0),
            start_time: Instant::now(),
        }
    }

    pub fn record_send(&self, bytes: u64) {
        self.bytes_sent.fetch_add(bytes, Ordering::Relaxed);
    }

    pub fn record_receive(&self, bytes: u64) {
        self.bytes_received.fetch_add(bytes, Ordering::Relaxed);
    }

    pub fn bandwidth_mbps(&self) -> (f64, f64) {
        let elapsed = self.start_time.elapsed().as_secs_f64();
        let sent = self.bytes_sent.load(Ordering::Relaxed) as f64;
        let received = self.bytes_received.load(Ordering::Relaxed) as f64;

        let send_mbps = (sent * 8.0) / (elapsed * 1_000_000.0);
        let recv_mbps = (received * 8.0) / (elapsed * 1_000_000.0);

        (send_mbps, recv_mbps)
    }
}
```

## 并发瓶颈分析

### 锁竞争分析

```rust
use std::sync::Arc;
use parking_lot::Mutex;
use std::time::Instant;

pub struct LockMonitor<T> {
    data: Arc<Mutex<T>>,
    lock_wait_time: Arc<AtomicU64>,
    lock_count: Arc<AtomicU64>,
}

impl<T> LockMonitor<T> {
    pub fn new(data: T) -> Self {
        Self {
            data: Arc::new(Mutex::new(data)),
            lock_wait_time: Arc::new(AtomicU64::new(0)),
            lock_count: Arc::new(AtomicU64::new(0)),
        }
    }

    pub fn lock(&self) -> parking_lot::MutexGuard<'_, T> {
        let start = Instant::now();
        let guard = self.data.lock();
        let wait_time = start.elapsed().as_micros() as u64;

        self.lock_wait_time.fetch_add(wait_time, Ordering::Relaxed);
        self.lock_count.fetch_add(1, Ordering::Relaxed);

        guard
    }

    pub fn average_wait_time_us(&self) -> f64 {
        let total_wait = self.lock_wait_time.load(Ordering::Relaxed);
        let count = self.lock_count.load(Ordering::Relaxed);

        if count == 0 {
            0.0
        } else {
            total_wait as f64 / count as f64
        }
    }
}
```

---

**相关文档**：

- [性能问题识别](./性能问题识别.md)
- [优化方案库](./优化方案库.md)
