# 降级预案

## 目录

- [降级预案](#降级预案)
  - [目录](#目录)
  - [概述](#概述)
  - [降级策略](#降级策略)
    - [功能降级](#功能降级)
    - [采样降级](#采样降级)
  - [降级实施](#降级实施)
    - [自动降级触发](#自动降级触发)
    - [降级配置](#降级配置)
  - [降级恢复](#降级恢复)
    - [恢复策略](#恢复策略)

## 概述

降级预案在系统过载或故障时保护核心功能，牺牲非核心功能换取系统稳定。

## 降级策略

### 功能降级

```rust
pub enum DegradationLevel {
    Normal,          // 正常
    Partial,         // 部分降级
    Minimal,         // 最小功能
    Emergency,       // 紧急模式
}

pub struct FeatureDegradation {
    current_level: DegradationLevel,
}

impl FeatureDegradation {
    pub fn apply_degradation(&mut self, level: DegradationLevel) {
        match level {
            DegradationLevel::Normal => {
                // 所有功能可用
            }
            DegradationLevel::Partial => {
                // 禁用非核心功能
                self.disable_analytics();
                self.disable_detailed_logging();
            }
            DegradationLevel::Minimal => {
                // 仅保留核心导出功能
                self.disable_all_non_essential();
            }
            DegradationLevel::Emergency => {
                // 仅接受请求，暂存到队列
                self.enable_queue_only_mode();
            }
        }
        self.current_level = level;
    }

    fn disable_analytics(&self) {}
    fn disable_detailed_logging(&self) {}
    fn disable_all_non_essential(&self) {}
    fn enable_queue_only_mode(&self) {}
}
```

### 采样降级

```rust
pub struct AdaptiveDegradation {
    normal_sampling_rate: f64,
    degraded_sampling_rate: f64,
}

impl AdaptiveDegradation {
    pub fn get_sampling_rate(&self, system_load: f64) -> f64 {
        if system_load < 0.7 {
            self.normal_sampling_rate
        } else if system_load < 0.9 {
            // 线性降级
            let factor = (0.9 - system_load) / 0.2;
            self.normal_sampling_rate * factor + self.degraded_sampling_rate * (1.0 - factor)
        } else {
            self.degraded_sampling_rate
        }
    }
}
```

## 降级实施

### 自动降级触发

```rust
pub struct AutoDegradationTrigger {
    cpu_threshold: f64,
    memory_threshold: f64,
    latency_threshold_ms: f64,
    error_rate_threshold: f64,
}

impl AutoDegradationTrigger {
    pub fn should_degrade(&self, metrics: &SystemMetrics) -> Option<DegradationLevel> {
        let violations = self.count_violations(metrics);

        match violations {
            0 => None,
            1 => Some(DegradationLevel::Partial),
            2 => Some(DegradationLevel::Minimal),
            _ => Some(DegradationLevel::Emergency),
        }
    }

    fn count_violations(&self, metrics: &SystemMetrics) -> usize {
        let mut count = 0;

        if metrics.cpu_usage > self.cpu_threshold {
            count += 1;
        }
        if metrics.memory_usage > self.memory_threshold {
            count += 1;
        }
        if metrics.p99_latency_ms > self.latency_threshold_ms {
            count += 1;
        }
        if metrics.error_rate > self.error_rate_threshold {
            count += 1;
        }

        count
    }
}

pub struct SystemMetrics {
    pub cpu_usage: f64,
    pub memory_usage: f64,
    pub p99_latency_ms: f64,
    pub error_rate: f64,
}
```

### 降级配置

```yaml
# 降级配置示例
degradation:
  triggers:
    - name: high_cpu
      metric: cpu_usage
      threshold: 80
      action: partial_degradation
      
    - name: high_latency
      metric: p99_latency_ms
      threshold: 500
      action: minimal_degradation
      
  levels:
    partial:
      sampling_rate: 0.5
      disable_features:
        - analytics
        - detailed_logs
        
    minimal:
      sampling_rate: 0.1
      disable_features:
        - analytics
        - detailed_logs
        - metrics_export
        
    emergency:
      sampling_rate: 0.01
      queue_only: true
```

## 降级恢复

### 恢复策略

```rust
pub struct DegradationRecovery {
    degradation: FeatureDegradation,
    recovery_threshold: f64,
    stability_window: Duration,
}

impl DegradationRecovery {
    pub async fn monitor_and_recover(&mut self) {
        let mut stable_since = None;

        loop {
            tokio::time::sleep(Duration::from_secs(30)).await;

            let metrics = self.collect_metrics().await;
            let is_healthy = self.is_system_healthy(&metrics);

            if is_healthy {
                if stable_since.is_none() {
                    stable_since = Some(Instant::now());
                } else if stable_since.unwrap().elapsed() >= self.stability_window {
                    // 系统稳定，逐步恢复
                    self.gradual_recovery();
                    stable_since = None;
                }
            } else {
                stable_since = None;
            }
        }
    }

    fn is_system_healthy(&self, metrics: &SystemMetrics) -> bool {
        metrics.cpu_usage < 70.0 &&
        metrics.memory_usage < 75.0 &&
        metrics.p99_latency_ms < 200.0 &&
        metrics.error_rate < 0.01
    }

    fn gradual_recovery(&mut self) {
        match self.degradation.current_level {
            DegradationLevel::Emergency => {
                self.degradation.apply_degradation(DegradationLevel::Minimal);
            }
            DegradationLevel::Minimal => {
                self.degradation.apply_degradation(DegradationLevel::Partial);
            }
            DegradationLevel::Partial => {
                self.degradation.apply_degradation(DegradationLevel::Normal);
            }
            DegradationLevel::Normal => {}
        }
    }

    async fn collect_metrics(&self) -> SystemMetrics {
        // 收集系统指标
        SystemMetrics {
            cpu_usage: 0.0,
            memory_usage: 0.0,
            p99_latency_ms: 0.0,
            error_rate: 0.0,
        }
    }
}

use std::time::Instant;
use tokio::time::Duration;
```

---

**相关文档**：

- [故障响应流程](./故障响应流程.md)
- [数据恢复](./数据恢复.md)
