# 事后复盘

## 目录

- [事后复盘](#事后复盘)
  - [目录](#目录)
  - [概述](#概述)
  - [复盘流程](#复盘流程)
    - [复盘时间线](#复盘时间线)
    - [复盘原则](#复盘原则)
  - [复盘模板](#复盘模板)
    - [故障复盘报告模板](#故障复盘报告模板)
  - [改进措施跟踪](#改进措施跟踪)
    - [跟踪系统](#跟踪系统)

## 概述

事后复盘（Post-Mortem）是从故障中学习、持续改进的关键环节。

## 复盘流程

### 复盘时间线

```text
故障发生 -> 24小时内 -> 初步复盘会议
         -> 3天内    -> 完整复盘报告
         -> 1周内    -> 改进措施制定
         -> 持续跟踪  -> 改进措施落实
```

### 复盘原则

1. **无责文化**：关注问题，不追究个人责任
2. **事实导向**：基于数据和日志，不做主观臆断
3. **系统思维**：分析系统性问题，而非个别事件
4. **持续改进**：制定可执行的改进措施

## 复盘模板

### 故障复盘报告模板

```markdown
    # 故障复盘报告

    ## 基本信息

    - **故障ID**: INC-2025-10-05-001
    - **故障时间**: 2025-10-05 18:00 - 19:30 (UTC+8)
    - **影响范围**: OTLP Collector 全部实例
    - **故障等级**: P1 (严重)
    - **负责人**: @张三
    - **参与人**: @李四, @王五

    ## 执行摘要

    简明扼要地描述故障的影响、根本原因和关键改进措施。

    **影响**：所有 OTLP Collector 实例无法接收 Span 数据，持续 1.5 小时。

    **根本原因**：配置更新导致内存泄漏，触发 OOM Killer。

    **关键改进**：
    1. 增加配置变更的灰度发布流程
    2. 完善内存监控告警
    3. 实施自动重启机制

    ## 故障时间线

    | 时间 | 事件 | 操作人 |
    |------|------|--------|
    | 18:00 | 配置更新推送到生产环境 | @张三 |
    | 18:15 | 内存使用率告警触发 | 系统 |
    | 18:20 | 第一个实例 OOM | 系统 |
    | 18:25 | 所有实例陆续 OOM | 系统 |
    | 18:30 | 值班工程师收到告警 | @李四 |
    | 18:35 | 确认故障范围 | @李四 |
    | 18:40 | 回滚配置变更 | @李四 |
    | 19:00 | 服务开始恢复 | 系统 |
    | 19:30 | 服务完全恢复 | 系统 |

    ## 影响分析

    ### 用户影响

    - **受影响用户数**: 约 10,000
    - **数据丢失**: 无（启用了本地缓存）
    - **业务影响**: Span 数据延迟上报 1.5 小时

    ### 系统影响

    - **可用性**: 0% (1.5小时)
    - **SLO 影响**: 月度可用性从 99.95% 降至 99.79%
    - **错误预算消耗**: 消耗 50% 月度预算

    ## 根本原因分析

    ### 直接原因

    配置参数 `batch_size` 从 1000 增加到 10000，导致内存使用量激增。

    ### 根本原因（5 Whys）

    1. **为什么服务 OOM？**
    - 因为内存使用量超过限制

    2. **为什么内存使用量超过限制？**
    - 因为批次大小增加了 10 倍

    3. **为什么批次大小增加了 10 倍？**
    - 因为配置变更时计算错误

    4. **为什么配置变更时计算错误？**
    - 因为缺少配置变更的影响评估流程

    5. **为什么缺少影响评估流程？**
    - 因为团队规模扩大后，流程未及时更新

    ### 贡献因素

    1. 内存监控告警阈值设置过高（90%）
    2. 缺少自动重启机制
    3. 配置变更未经过灰度发布

    ## 改进措施

    ### 立即措施（已完成）

    - [x] 回滚配置到正常值
    - [x] 重启所有实例
    - [x] 验证服务恢复

    ### 短期措施（1周内）

    - [ ] 降低内存告警阈值到 80%
    - [ ] 实施配置变更的影响评估流程
    - [ ] 添加自动重启机制（K8s liveness probe）

    ### 长期措施（1个月内）

    - [ ] 建立配置变更的灰度发布流程
    - [ ] 完善容量规划模型
    - [ ] 实施混沌工程测试

    ## 经验教训

    ### 做得好的地方

    1. 本地缓存机制避免了数据丢失
    2. 值班工程师响应及时
    3. 回滚操作执行迅速

    ### 需要改进的地方

    1. 配置变更缺少充分测试
    2. 监控告警不够敏感
    3. 缺少自动恢复机制

    ## 相关数据

    ### 监控截图

    ![CPU使用率](./images/cpu_usage.png)
    ![内存使用率](./images/memory_usage.png)

    ### 日志片段

    ```text

    2025-10-05 18:20:15 ERROR Out of memory: Kill process 12345
    2025-10-05 18:20:15 INFO Process terminated by OOM Killer

    ```

    ## 参考资料

    - [配置变更记录](./config_change_log.md)
    - [监控数据](./monitoring_data.csv)
    - [相关Issue](https://github.com/org/repo/issues/123)

    ---

    **复盘会议记录**: [会议纪要链接]
    **改进措施跟踪**: [Jira Epic链接]
```

## 改进措施跟踪

### 跟踪系统

```rust
use std::collections::HashMap;

pub struct ActionItemTracker {
    items: HashMap<String, ActionItem>,
}

#[derive(Debug, Clone)]
pub struct ActionItem {
    pub id: String,
    pub description: String,
    pub priority: Priority,
    pub owner: String,
    pub due_date: chrono::NaiveDate,
    pub status: ActionStatus,
    pub completion_date: Option<chrono::NaiveDate>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum Priority {
    Critical,
    High,
    Medium,
    Low,
}

#[derive(Debug, Clone, PartialEq)]
pub enum ActionStatus {
    NotStarted,
    InProgress,
    Completed,
    Blocked,
    Cancelled,
}

impl ActionItemTracker {
    pub fn new() -> Self {
        Self {
            items: HashMap::new(),
        }
    }

    pub fn add_item(&mut self, item: ActionItem) {
        self.items.insert(item.id.clone(), item);
    }

    pub fn update_status(&mut self, id: &str, status: ActionStatus) {
        if let Some(item) = self.items.get_mut(id) {
            item.status = status.clone();
            if status == ActionStatus::Completed {
                item.completion_date = Some(chrono::Local::now().date_naive());
            }
        }
    }

    pub fn get_overdue_items(&self) -> Vec<&ActionItem> {
        let today = chrono::Local::now().date_naive();
        self.items
            .values()
            .filter(|item| {
                item.status != ActionStatus::Completed &&
                item.status != ActionStatus::Cancelled &&
                item.due_date < today
            })
            .collect()
    }

    pub fn get_completion_rate(&self) -> f64 {
        if self.items.is_empty() {
            return 0.0;
        }

        let completed = self.items.values()
            .filter(|item| item.status == ActionStatus::Completed)
            .count();

        (completed as f64 / self.items.len() as f64) * 100.0
    }

    pub fn generate_report(&self) -> String {
        let mut report = String::from("=== 改进措施跟踪报告 ===\n\n");

        let total = self.items.len();
        let completed = self.items.values()
            .filter(|item| item.status == ActionStatus::Completed)
            .count();
        let in_progress = self.items.values()
            .filter(|item| item.status == ActionStatus::InProgress)
            .count();
        let overdue = self.get_overdue_items().len();

        report.push_str(&format!("总计: {}\n", total));
        report.push_str(&format!("已完成: {}\n", completed));
        report.push_str(&format!("进行中: {}\n", in_progress));
        report.push_str(&format!("逾期: {}\n", overdue));
        report.push_str(&format!("完成率: {:.1}%\n\n", self.get_completion_rate()));

        report.push_str("逾期项目:\n");
        for item in self.get_overdue_items() {
            report.push_str(&format!("  - [{}] {} (负责人: {}, 截止: {})\n",
                item.id, item.description, item.owner, item.due_date));
        }

        report
    }
}
```

---

**相关文档**：

- [故障响应流程](./故障响应流程.md)
- [根因分析方法论](../故障诊断/根因分析方法论.md)
