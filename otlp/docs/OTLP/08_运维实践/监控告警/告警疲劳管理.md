# 告警疲劳管理

## 目录

- [告警疲劳管理](#告警疲劳管理)
  - [目录](#目录)
  - [概述](#概述)
  - [告警疲劳识别](#告警疲劳识别)
    - [告警统计分析](#告警统计分析)
  - [缓解策略](#缓解策略)
    - [1. 告警聚合](#1-告警聚合)
    - [2. 告警抑制](#2-告警抑制)
    - [3. 智能静默](#3-智能静默)
  - [告警质量评估](#告警质量评估)
    - [告警有效性指标](#告警有效性指标)
    - [告警审查流程](#告警审查流程)

## 概述

告警疲劳是指过多的告警导致运维人员麻木，忽视真正重要的告警。

## 告警疲劳识别

### 告警统计分析

```rust
use std::collections::HashMap;

pub struct AlertAnalyzer {
    alert_history: Vec<Alert>,
}

impl AlertAnalyzer {
    pub fn analyze_fatigue(&self) -> FatigueReport {
        let total_alerts = self.alert_history.len();
        let unique_alerts = self.count_unique_alerts();
        let flapping_alerts = self.detect_flapping_alerts();
        let noisy_alerts = self.find_noisy_alerts();

        FatigueReport {
            total_alerts,
            unique_alerts,
            flapping_count: flapping_alerts.len(),
            noisy_count: noisy_alerts.len(),
            fatigue_score: self.calculate_fatigue_score(),
        }
    }

    fn count_unique_alerts(&self) -> usize {
        let mut unique = std::collections::HashSet::new();
        for alert in &self.alert_history {
            unique.insert(&alert.name);
        }
        unique.len()
    }

    fn detect_flapping_alerts(&self) -> Vec<String> {
        let mut flapping = Vec::new();
        let mut state_changes: HashMap<String, usize> = HashMap::new();

        for alert in &self.alert_history {
            *state_changes.entry(alert.name.clone()).or_insert(0) += 1;
        }

        for (name, count) in state_changes {
            if count > 10 {
                flapping.push(name);
            }
        }

        flapping
    }

    fn find_noisy_alerts(&self) -> Vec<String> {
        let mut counts: HashMap<String, usize> = HashMap::new();

        for alert in &self.alert_history {
            *counts.entry(alert.name.clone()).or_insert(0) += 1;
        }

        counts.into_iter()
            .filter(|(_, count)| *count > 100)
            .map(|(name, _)| name)
            .collect()
    }

    fn calculate_fatigue_score(&self) -> f64 {
        // 0-100 分数，越高表示疲劳越严重
        let alerts_per_hour = self.alert_history.len() as f64 / 24.0;
        (alerts_per_hour / 10.0 * 100.0).min(100.0)
    }
}

pub struct Alert {
    pub name: String,
    pub severity: String,
    pub timestamp: u64,
}

pub struct FatigueReport {
    pub total_alerts: usize,
    pub unique_alerts: usize,
    pub flapping_count: usize,
    pub noisy_count: usize,
    pub fatigue_score: f64,
}
```

## 缓解策略

### 1. 告警聚合

```yaml
# Alertmanager 配置
route:
  group_by: ['alertname', 'cluster', 'service']
  group_wait: 30s
  group_interval: 5m
  repeat_interval: 4h
  
  routes:
  - match:
      severity: critical
    group_wait: 10s
    repeat_interval: 1h
    
  - match:
      severity: warning
    group_wait: 1m
    repeat_interval: 12h
```

### 2. 告警抑制

```yaml
# 抑制规则
inhibit_rules:
  # 如果集群宕机，抑制该集群的所有其他告警
  - source_match:
      alertname: 'ClusterDown'
      severity: 'critical'
    target_match:
      severity: 'warning'
    equal: ['cluster']
    
  # 如果节点宕机，抑制该节点的所有服务告警
  - source_match:
      alertname: 'NodeDown'
    target_match_re:
      alertname: '.*'
    equal: ['instance']
```

### 3. 智能静默

```rust
pub struct IntelligentSilencer {
    silence_rules: Vec<SilenceRule>,
}

pub struct SilenceRule {
    pub pattern: String,
    pub duration_hours: u64,
    pub conditions: Vec<Condition>,
}

pub enum Condition {
    TimeWindow { start_hour: u8, end_hour: u8 },
    DayOfWeek { days: Vec<u8> },
    AlertFrequency { max_per_hour: usize },
}

impl IntelligentSilencer {
    pub fn should_silence(&self, alert: &Alert) -> bool {
        for rule in &self.silence_rules {
            if self.matches_rule(alert, rule) {
                return true;
            }
        }
        false
    }

    fn matches_rule(&self, alert: &Alert, rule: &SilenceRule) -> bool {
        if !alert.name.contains(&rule.pattern) {
            return false;
        }

        rule.conditions.iter().all(|condition| {
            self.check_condition(alert, condition)
        })
    }

    fn check_condition(&self, alert: &Alert, condition: &Condition) -> bool {
        match condition {
            Condition::TimeWindow { start_hour, end_hour } => {
                // 检查时间窗口
                true
            }
            Condition::DayOfWeek { days } => {
                // 检查星期几
                true
            }
            Condition::AlertFrequency { max_per_hour } => {
                // 检查频率
                true
            }
        }
    }
}
```

## 告警质量评估

### 告警有效性指标

```rust
pub struct AlertQualityMetrics {
    pub true_positives: usize,   // 真实问题
    pub false_positives: usize,  // 误报
    pub actionable: usize,       // 可操作的
    pub auto_resolved: usize,    // 自动恢复的
}

impl AlertQualityMetrics {
    pub fn precision(&self) -> f64 {
        let total = self.true_positives + self.false_positives;
        if total == 0 {
            return 0.0;
        }
        self.true_positives as f64 / total as f64
    }

    pub fn actionable_rate(&self) -> f64 {
        let total = self.true_positives + self.false_positives;
        if total == 0 {
            return 0.0;
        }
        self.actionable as f64 / total as f64
    }

    pub fn quality_score(&self) -> f64 {
        // 综合评分：精确度 * 可操作率
        self.precision() * self.actionable_rate() * 100.0
    }
}
```

### 告警审查流程

```markdown
## 告警审查清单

每周审查以下内容：

1. **高频告警**
   - [ ] 识别触发次数 > 50 的告警
   - [ ] 分析根本原因
   - [ ] 调整阈值或修复问题

2. **低价值告警**
   - [ ] 识别从未被处理的告警
   - [ ] 评估是否需要保留
   - [ ] 删除或降级

3. **误报告警**
   - [ ] 收集误报反馈
   - [ ] 优化告警条件
   - [ ] 更新文档

4. **告警覆盖**
   - [ ] 检查是否有遗漏的监控点
   - [ ] 补充必要的告警规则
```

---

**相关文档**：

- [告警规则设计](./告警规则设计.md)
- [SLO_SLA管理](./SLO_SLA管理.md)
