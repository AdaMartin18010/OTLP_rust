# å¯è§‚æµ‹æ€§æœ€ä½³å®è·µ

## ç›®å½•

- [å¯è§‚æµ‹æ€§æœ€ä½³å®è·µ](#å¯è§‚æµ‹æ€§æœ€ä½³å®è·µ)
  - [ç›®å½•](#ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
    - [ğŸ“Š å¯è§‚æµ‹æ€§æ¶æ„å…¨æ™¯å›¾](#-å¯è§‚æµ‹æ€§æ¶æ„å…¨æ™¯å›¾)
    - [ğŸ”„ æ•°æ®æµè½¬æµç¨‹å›¾](#-æ•°æ®æµè½¬æµç¨‹å›¾)
  - [ä¸‰å¤§æ”¯æŸ±](#ä¸‰å¤§æ”¯æŸ±)
    - [1. Metrics (æŒ‡æ ‡)](#1-metrics-æŒ‡æ ‡)
    - [2. Logs (æ—¥å¿—)](#2-logs-æ—¥å¿—)
    - [3. Traces (è¿½è¸ª)](#3-traces-è¿½è¸ª)
  - [å¯è§‚æµ‹æ€§è®¾è®¡åŸåˆ™](#å¯è§‚æµ‹æ€§è®¾è®¡åŸåˆ™)
    - [1. é«˜åŸºæ•°ç»´åº¦](#1-é«˜åŸºæ•°ç»´åº¦)
    - [2. ä¸€è‡´çš„å‘½åè§„èŒƒ](#2-ä¸€è‡´çš„å‘½åè§„èŒƒ)
    - [3. å…³è”æ€§](#3-å…³è”æ€§)
  - [OTLP å¯è§‚æµ‹æ€§å®è·µ](#otlp-å¯è§‚æµ‹æ€§å®è·µ)
    - [å®Œæ•´çš„å¯è§‚æµ‹æ€§æ ˆ](#å®Œæ•´çš„å¯è§‚æµ‹æ€§æ ˆ)
    - [é»„é‡‘ä¿¡å·ç›‘æ§](#é»„é‡‘ä¿¡å·ç›‘æ§)
    - [ä»ªè¡¨æ¿è®¾è®¡](#ä»ªè¡¨æ¿è®¾è®¡)
  - [ä¸‰å¤§æ”¯æŸ±æ·±åº¦è§£æ](#ä¸‰å¤§æ”¯æŸ±æ·±åº¦è§£æ)
    - [Metricsï¼ˆæŒ‡æ ‡ï¼‰æ·±åº¦å®è·µ](#metricsæŒ‡æ ‡æ·±åº¦å®è·µ)
      - [æŒ‡æ ‡ç±»å‹é€‰æ‹©æŒ‡å—](#æŒ‡æ ‡ç±»å‹é€‰æ‹©æŒ‡å—)
      - [é«˜çº§æŒ‡æ ‡æ¨¡å¼](#é«˜çº§æŒ‡æ ‡æ¨¡å¼)
    - [Logsï¼ˆæ—¥å¿—ï¼‰æ·±åº¦å®è·µ](#logsæ—¥å¿—æ·±åº¦å®è·µ)
      - [ç»“æ„åŒ–æ—¥å¿—æœ€ä½³å®è·µ](#ç»“æ„åŒ–æ—¥å¿—æœ€ä½³å®è·µ)
      - [æ—¥å¿—é‡‡æ ·ç­–ç•¥](#æ—¥å¿—é‡‡æ ·ç­–ç•¥)
    - [Tracesï¼ˆè¿½è¸ªï¼‰æ·±åº¦å®è·µ](#tracesè¿½è¸ªæ·±åº¦å®è·µ)
      - [åˆ†å¸ƒå¼è¿½è¸ªæœ€ä½³å®è·µ](#åˆ†å¸ƒå¼è¿½è¸ªæœ€ä½³å®è·µ)
  - [å…³è”åˆ†æ](#å…³è”åˆ†æ)
    - [ä¸‰å¤§æ”¯æŸ±å…³è”](#ä¸‰å¤§æ”¯æŸ±å…³è”)
    - [ç«¯åˆ°ç«¯è¿½è¸ªç¤ºä¾‹](#ç«¯åˆ°ç«¯è¿½è¸ªç¤ºä¾‹)
  - [å®æˆ˜æ¡ˆä¾‹](#å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹1ï¼šæ€§èƒ½é—®é¢˜æ’æŸ¥](#æ¡ˆä¾‹1æ€§èƒ½é—®é¢˜æ’æŸ¥)
    - [æ¡ˆä¾‹2ï¼šé”™è¯¯ç‡æ¿€å¢æ’æŸ¥](#æ¡ˆä¾‹2é”™è¯¯ç‡æ¿€å¢æ’æŸ¥)
  - [å¯è§‚æµ‹æ€§æˆç†Ÿåº¦æ¨¡å‹](#å¯è§‚æµ‹æ€§æˆç†Ÿåº¦æ¨¡å‹)
    - [æˆç†Ÿåº¦ç­‰çº§](#æˆç†Ÿåº¦ç­‰çº§)
  - [å·¥å…·é“¾æ¨è](#å·¥å…·é“¾æ¨è)
    - [å®Œæ•´çš„å¯è§‚æµ‹æ€§å·¥å…·æ ˆ](#å®Œæ•´çš„å¯è§‚æµ‹æ€§å·¥å…·æ ˆ)
    - [å·¥å…·é…ç½®ç¤ºä¾‹](#å·¥å…·é…ç½®ç¤ºä¾‹)

## æ¦‚è¿°

å¯è§‚æµ‹æ€§ä½¿ç³»ç»Ÿå†…éƒ¨çŠ¶æ€å¯ä»¥é€šè¿‡å¤–éƒ¨è¾“å‡ºæ¨æ–­ï¼Œæ˜¯ç°ä»£è¿ç»´çš„åŸºç¡€ã€‚

### ğŸ“Š å¯è§‚æµ‹æ€§æ¶æ„å…¨æ™¯å›¾

```mermaid
graph TB
    subgraph "æ•°æ®æºå±‚"
        A1[åº”ç”¨æœåŠ¡]
        A2[åŸºç¡€è®¾æ–½]
        A3[æ•°æ®åº“]
        A4[æ¶ˆæ¯é˜Ÿåˆ—]
    end
    
    subgraph "é‡‡é›†å±‚"
        B1[OpenTelemetry SDK]
        B2[Prometheus Exporter]
        B3[Fluent Bit]
    end
    
    subgraph "ä¼ è¾“å±‚"
        C1[OTLP Collector]
        C2[é‡‡æ ·å™¨]
        C3[æ‰¹å¤„ç†å™¨]
    end
    
    subgraph "å­˜å‚¨å±‚"
        D1[Prometheus<br/>æŒ‡æ ‡å­˜å‚¨]
        D2[Loki<br/>æ—¥å¿—å­˜å‚¨]
        D3[Tempo<br/>è¿½è¸ªå­˜å‚¨]
    end
    
    subgraph "åˆ†æå±‚"
        E1[Grafana<br/>å¯è§†åŒ–]
        E2[Alertmanager<br/>å‘Šè­¦]
        E3[åˆ†æå·¥å…·]
    end
    
    A1 --> B1
    A2 --> B2
    A3 --> B1
    A4 --> B3
    
    B1 --> C1
    B2 --> C1
    B3 --> C1
    
    C1 --> C2
    C2 --> C3
    
    C3 --> D1
    C3 --> D2
    C3 --> D3
    
    D1 --> E1
    D2 --> E1
    D3 --> E1
    
    E1 --> E2
    E1 --> E3
    
    style C1 fill:#ff9999
    style E1 fill:#99ccff
    style D1 fill:#99ff99
    style D2 fill:#99ff99
    style D3 fill:#99ff99
```

### ğŸ”„ æ•°æ®æµè½¬æµç¨‹å›¾

```mermaid
sequenceDiagram
    participant App as åº”ç”¨æœåŠ¡
    participant SDK as OTEL SDK
    participant Collector as OTLP Collector
    participant Prom as Prometheus
    participant Loki as Loki
    participant Tempo as Tempo
    participant Grafana as Grafana
    
    App->>SDK: ç”Ÿæˆ Metrics/Logs/Traces
    SDK->>SDK: æœ¬åœ°é‡‡æ ·
    SDK->>Collector: OTLP/gRPC å‘é€
    
    Collector->>Collector: æ‰¹å¤„ç†
    Collector->>Collector: æ•°æ®å¢å¼º
    
    par å¹¶è¡Œå­˜å‚¨
        Collector->>Prom: Remote Write (Metrics)
        Collector->>Loki: Push (Logs)
        Collector->>Tempo: Push (Traces)
    end
    
    Grafana->>Prom: PromQL æŸ¥è¯¢
    Grafana->>Loki: LogQL æŸ¥è¯¢
    Grafana->>Tempo: TraceQL æŸ¥è¯¢
    
    Grafana->>Grafana: å…³è”åˆ†æ
    Grafana-->>App: å±•ç¤ºç»“æœ
```

## ä¸‰å¤§æ”¯æŸ±

### 1. Metrics (æŒ‡æ ‡)

```rust
use prometheus::{Counter, Histogram, Gauge, Registry};

pub struct OtlpMetrics {
    // Counter: å•è°ƒé€’å¢
    pub requests_total: Counter,
    pub errors_total: Counter,
    
    // Histogram: åˆ†å¸ƒç»Ÿè®¡
    pub request_duration: Histogram,
    pub batch_size: Histogram,
    
    // Gauge: å¯å¢å¯å‡
    pub active_connections: Gauge,
    pub queue_size: Gauge,
}

impl OtlpMetrics {
    pub fn new(registry: &Registry) -> Result<Self, prometheus::Error> {
        let requests_total = Counter::new("otlp_requests_total", "Total requests")?;
        let errors_total = Counter::new("otlp_errors_total", "Total errors")?;
        
        let request_duration = Histogram::with_opts(
            prometheus::HistogramOpts::new("otlp_request_duration_seconds", "Request duration")
                .buckets(vec![0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1.0])
        )?;
        
        let batch_size = Histogram::with_opts(
            prometheus::HistogramOpts::new("otlp_batch_size", "Batch size")
                .buckets(vec![10.0, 50.0, 100.0, 500.0, 1000.0, 5000.0])
        )?;
        
        let active_connections = Gauge::new("otlp_active_connections", "Active connections")?;
        let queue_size = Gauge::new("otlp_queue_size", "Queue size")?;

        registry.register(Box::new(requests_total.clone()))?;
        registry.register(Box::new(errors_total.clone()))?;
        registry.register(Box::new(request_duration.clone()))?;
        registry.register(Box::new(batch_size.clone()))?;
        registry.register(Box::new(active_connections.clone()))?;
        registry.register(Box::new(queue_size.clone()))?;

        Ok(Self {
            requests_total,
            errors_total,
            request_duration,
            batch_size,
            active_connections,
            queue_size,
        })
    }
}
```

### 2. Logs (æ—¥å¿—)

```rust
use tracing::{info, warn, error, debug, instrument};

#[instrument(skip(spans))]
pub async fn export_spans(spans: Vec<Span>) -> Result<(), ExportError> {
    info!(span_count = spans.len(), "Starting span export");
    
    match send_to_collector(&spans).await {
        Ok(_) => {
            info!("Export successful");
            Ok(())
        }
        Err(e) => {
            error!(error = ?e, "Export failed");
            Err(e)
        }
    }
}

// ç»“æ„åŒ–æ—¥å¿—
#[derive(Debug, serde::Serialize)]
struct ExportEvent {
    span_count: usize,
    batch_id: String,
    duration_ms: u64,
    success: bool,
}
```

### 3. Traces (è¿½è¸ª)

```rust
use opentelemetry::trace::{Tracer, SpanKind};

pub async fn process_request(tracer: &dyn Tracer) -> Result<()> {
    let span = tracer
        .span_builder("process_request")
        .with_kind(SpanKind::Server)
        .start(tracer);

    let _guard = span.enter();

    // ä¸šåŠ¡é€»è¾‘
    validate_request().await?;
    process_data().await?;
    send_response().await?;

    Ok(())
}
```

## å¯è§‚æµ‹æ€§è®¾è®¡åŸåˆ™

### 1. é«˜åŸºæ•°ç»´åº¦

```rust
// å¥½çš„å®è·µï¼šä½¿ç”¨æ ‡ç­¾
metrics.requests_total
    .with_label_values(&[
        &endpoint,
        &method,
        &status_code,
    ])
    .inc();

// é¿å…ï¼šå°†é«˜åŸºæ•°å€¼æ”¾å…¥æŒ‡æ ‡å
// âŒ metrics.requests_user_12345.inc();
```

### 2. ä¸€è‡´çš„å‘½åè§„èŒƒ

```yaml
# æŒ‡æ ‡å‘½åè§„èŒƒ
<namespace>_<subsystem>_<metric>_<unit>

ç¤ºä¾‹:
- otlp_export_requests_total
- otlp_export_duration_seconds
- otlp_batch_size_bytes
```

### 3. å…³è”æ€§

```rust
// ä½¿ç”¨ TraceID å…³è”æ—¥å¿—å’Œè¿½è¸ª
#[instrument(fields(trace_id = %trace_id))]
pub async fn handle_request(trace_id: String) {
    info!("Processing request");
    // ...
}
```

## OTLP å¯è§‚æµ‹æ€§å®è·µ

### å®Œæ•´çš„å¯è§‚æµ‹æ€§æ ˆ

```rust
use opentelemetry::sdk::trace::TracerProvider;
use opentelemetry_otlp::WithExportConfig;

pub struct ObservabilityStack {
    metrics: OtlpMetrics,
    tracer: Box<dyn Tracer>,
}

impl ObservabilityStack {
    pub fn init() -> Result<Self> {
        // åˆå§‹åŒ– Metrics
        let registry = Registry::new();
        let metrics = OtlpMetrics::new(&registry)?;

        // åˆå§‹åŒ– Tracing
        let tracer = opentelemetry_otlp::new_pipeline()
            .tracing()
            .with_exporter(
                opentelemetry_otlp::new_exporter()
                    .tonic()
                    .with_endpoint("http://localhost:4317")
            )
            .install_batch(opentelemetry::runtime::Tokio)?;

        // åˆå§‹åŒ– Logging
        tracing_subscriber::fmt()
            .with_max_level(tracing::Level::INFO)
            .json()
            .init();

        Ok(Self {
            metrics,
            tracer: Box::new(tracer),
        })
    }
}
```

### é»„é‡‘ä¿¡å·ç›‘æ§

```yaml
# å››å¤§é»„é‡‘ä¿¡å·
1. Latency (å»¶è¿Ÿ)
   - otlp_request_duration_seconds

2. Traffic (æµé‡)
   - rate(otlp_requests_total[5m])

3. Errors (é”™è¯¯)
   - rate(otlp_errors_total[5m]) / rate(otlp_requests_total[5m])

4. Saturation (é¥±å’Œåº¦)
   - otlp_queue_size / otlp_queue_capacity
   - otlp_cpu_usage_percent
```

### ä»ªè¡¨æ¿è®¾è®¡

```markdown
## OTLP è¿ç»´ä»ªè¡¨æ¿

### æ¦‚è§ˆé¢æ¿
- è¯·æ±‚é€Ÿç‡ (QPS)
- é”™è¯¯ç‡
- P50/P95/P99 å»¶è¿Ÿ
- å¯ç”¨æ€§

### è¯¦ç»†é¢æ¿
- æŒ‰ç«¯ç‚¹åˆ†ç»„çš„å»¶è¿Ÿ
- é”™è¯¯ç±»å‹åˆ†å¸ƒ
- èµ„æºä½¿ç”¨ç‡
- é˜Ÿåˆ—æ·±åº¦

### SLO é¢æ¿
- SLO è¾¾æˆç‡
- é”™è¯¯é¢„ç®—å‰©ä½™
- SLI è¶‹åŠ¿å›¾
```

## ä¸‰å¤§æ”¯æŸ±æ·±åº¦è§£æ

### Metricsï¼ˆæŒ‡æ ‡ï¼‰æ·±åº¦å®è·µ

#### æŒ‡æ ‡ç±»å‹é€‰æ‹©æŒ‡å—

```rust
/// æŒ‡æ ‡ç±»å‹å†³ç­–æ ‘
pub enum MetricTypeDecision {
    /// åªå¢ä¸å‡çš„è®¡æ•° â†’ Counter
    Counter {
        example: &'static str,
        use_case: &'static str,
    },
    /// å¯å¢å¯å‡çš„å½“å‰å€¼ â†’ Gauge
    Gauge {
        example: &'static str,
        use_case: &'static str,
    },
    /// å€¼çš„åˆ†å¸ƒç»Ÿè®¡ â†’ Histogram
    Histogram {
        example: &'static str,
        use_case: &'static str,
    },
    /// åˆ†ä½æ•°ä¼°ç®— â†’ Summary
    Summary {
        example: &'static str,
        use_case: &'static str,
    },
}

impl MetricTypeDecision {
    pub fn guide() -> Vec<Self> {
        vec![
            Self::Counter {
                example: "è¯·æ±‚æ€»æ•°ã€é”™è¯¯æ€»æ•°",
                use_case: "éœ€è¦è®¡ç®—é€Ÿç‡ï¼ˆrateï¼‰çš„åœºæ™¯",
            },
            Self::Gauge {
                example: "é˜Ÿåˆ—é•¿åº¦ã€æ´»è·ƒè¿æ¥æ•°ã€CPUä½¿ç”¨ç‡",
                use_case: "éœ€è¦çŸ¥é“å½“å‰çŠ¶æ€çš„åœºæ™¯",
            },
            Self::Histogram {
                example: "è¯·æ±‚å»¶è¿Ÿã€å“åº”å¤§å°",
                use_case: "éœ€è¦è®¡ç®—åˆ†ä½æ•°ï¼ˆP99ï¼‰å’Œå¹³å‡å€¼",
            },
            Self::Summary {
                example: "å®¢æˆ·ç«¯è®¡ç®—çš„åˆ†ä½æ•°",
                use_case: "æ— æ³•ä½¿ç”¨ Histogram æ—¶çš„æ›¿ä»£æ–¹æ¡ˆ",
            },
        ]
    }
}
```

#### é«˜çº§æŒ‡æ ‡æ¨¡å¼

**1. RED æ–¹æ³•ï¼ˆRate, Errors, Durationï¼‰**:

```rust
/// RED æŒ‡æ ‡æ”¶é›†å™¨
pub struct RedMetrics {
    // Rate: è¯·æ±‚é€Ÿç‡
    requests_total: Counter,
    
    // Errors: é”™è¯¯æ•°
    errors_total: Counter,
    
    // Duration: æŒç»­æ—¶é—´
    request_duration: Histogram,
}

impl RedMetrics {
    /// è®°å½•è¯·æ±‚
    pub fn record_request(&self, duration: f64, is_error: bool) {
        self.requests_total.inc();
        self.request_duration.observe(duration);
        
        if is_error {
            self.errors_total.inc();
        }
    }

    /// è®¡ç®—é”™è¯¯ç‡ï¼ˆéœ€è¦ Prometheus æŸ¥è¯¢ï¼‰
    pub fn error_rate_query() -> &'static str {
        "rate(otlp_errors_total[5m]) / rate(otlp_requests_total[5m])"
    }

    /// è®¡ç®— P99 å»¶è¿Ÿï¼ˆéœ€è¦ Prometheus æŸ¥è¯¢ï¼‰
    pub fn p99_latency_query() -> &'static str {
        "histogram_quantile(0.99, rate(otlp_request_duration_seconds_bucket[5m]))"
    }
}
```

**2. USE æ–¹æ³•ï¼ˆUtilization, Saturation, Errorsï¼‰**:

```rust
/// USE èµ„æºç›‘æ§
pub struct UseMetrics {
    // Utilization: èµ„æºåˆ©ç”¨ç‡
    cpu_usage: Gauge,
    memory_usage: Gauge,
    
    // Saturation: é¥±å’Œåº¦ï¼ˆæ’é˜Ÿç­‰å¾…ï¼‰
    queue_depth: Gauge,
    thread_pool_saturation: Gauge,
    
    // Errors: èµ„æºé”™è¯¯
    oom_kills: Counter,
    throttled_requests: Counter,
}

impl UseMetrics {
    pub fn update_resource_metrics(&self) {
        // CPU åˆ©ç”¨ç‡
        let cpu = self.get_cpu_usage();
        self.cpu_usage.set(cpu);
        
        // å†…å­˜åˆ©ç”¨ç‡
        let mem = self.get_memory_usage();
        self.memory_usage.set(mem);
        
        // é˜Ÿåˆ—é¥±å’Œåº¦
        let queue = self.get_queue_depth();
        self.queue_depth.set(queue as f64);
    }

    fn get_cpu_usage(&self) -> f64 {
        // å®ç° CPU ä½¿ç”¨ç‡è·å–
        0.0
    }

    fn get_memory_usage(&self) -> f64 {
        // å®ç°å†…å­˜ä½¿ç”¨ç‡è·å–
        0.0
    }

    fn get_queue_depth(&self) -> usize {
        // å®ç°é˜Ÿåˆ—æ·±åº¦è·å–
        0
    }
}
```

**3. ä¸šåŠ¡æŒ‡æ ‡**:

```rust
/// OTLP ä¸šåŠ¡æŒ‡æ ‡
pub struct OtlpBusinessMetrics {
    // æ•°æ®é‡æŒ‡æ ‡
    spans_exported: Counter,
    bytes_exported: Counter,
    
    // æ•°æ®è´¨é‡æŒ‡æ ‡
    invalid_spans: Counter,
    dropped_spans: Counter,
    
    // æˆæœ¬æŒ‡æ ‡
    export_cost_dollars: Counter,
}

impl OtlpBusinessMetrics {
    pub fn record_export(&self, span_count: u64, bytes: u64, cost: f64) {
        self.spans_exported.inc_by(span_count);
        self.bytes_exported.inc_by(bytes);
        self.export_cost_dollars.inc_by(cost);
    }
}
```

### Logsï¼ˆæ—¥å¿—ï¼‰æ·±åº¦å®è·µ

#### ç»“æ„åŒ–æ—¥å¿—æœ€ä½³å®è·µ

```rust
use tracing::{info, warn, error, debug, instrument, Span};
use serde::{Serialize, Deserialize};

/// æ—¥å¿—çº§åˆ«é€‰æ‹©æŒ‡å—
#[derive(Debug)]
pub enum LogLevelGuide {
    Error,   // éœ€è¦ç«‹å³å¤„ç†çš„é”™è¯¯
    Warn,    // æ½œåœ¨é—®é¢˜ï¼Œä½†æœåŠ¡ä»å¯ç”¨
    Info,    // é‡è¦çš„ä¸šåŠ¡äº‹ä»¶
    Debug,   // è°ƒè¯•ä¿¡æ¯
    Trace,   // è¯¦ç»†çš„æ‰§è¡Œè·¯å¾„
}

/// ç»“æ„åŒ–æ—¥å¿—äº‹ä»¶
#[derive(Debug, Serialize)]
pub struct ExportEvent {
    // åŸºæœ¬ä¿¡æ¯
    event_type: String,
    timestamp: u64,
    
    // ä¸šåŠ¡ä¿¡æ¯
    span_count: usize,
    batch_id: String,
    
    // æ€§èƒ½ä¿¡æ¯
    duration_ms: u64,
    
    // ç»“æœä¿¡æ¯
    success: bool,
    error_message: Option<String>,
    
    // è¿½è¸ªå…³è”
    trace_id: String,
    span_id: String,
}

/// æ—¥å¿—è®°å½•å™¨
pub struct StructuredLogger;

impl StructuredLogger {
    /// è®°å½•å¯¼å‡ºäº‹ä»¶
    #[instrument(skip(spans))]
    pub async fn log_export(
        spans: &[Span],
        batch_id: String,
        trace_id: String,
    ) -> Result<(), ExportError> {
        let start = std::time::Instant::now();
        
        info!(
            batch_id = %batch_id,
            span_count = spans.len(),
            "Starting export"
        );
        
        match self.perform_export(spans).await {
            Ok(_) => {
                let duration = start.elapsed();
                info!(
                    batch_id = %batch_id,
                    span_count = spans.len(),
                    duration_ms = duration.as_millis(),
                    "Export successful"
                );
                Ok(())
            }
            Err(e) => {
                error!(
                    batch_id = %batch_id,
                    error = ?e,
                    "Export failed"
                );
                Err(e)
            }
        }
    }

    async fn perform_export(&self, _spans: &[Span]) -> Result<(), ExportError> {
        Ok(())
    }
}

#[derive(Debug)]
pub struct ExportError;
```

#### æ—¥å¿—é‡‡æ ·ç­–ç•¥

```rust
/// æ—¥å¿—é‡‡æ ·å™¨ï¼ˆé¿å…æ—¥å¿—æ´ªæ°´ï¼‰
pub struct LogSampler {
    sample_rate: f64,
    always_log_errors: bool,
}

impl LogSampler {
    pub fn new(sample_rate: f64) -> Self {
        Self {
            sample_rate,
            always_log_errors: true,
        }
    }

    /// å†³å®šæ˜¯å¦è®°å½•æ—¥å¿—
    pub fn should_log(&self, level: tracing::Level) -> bool {
        // é”™è¯¯æ€»æ˜¯è®°å½•
        if self.always_log_errors && level == tracing::Level::ERROR {
            return true;
        }
        
        // å…¶ä»–çº§åˆ«æŒ‰é‡‡æ ·ç‡
        use rand::Rng;
        let mut rng = rand::thread_rng();
        rng.gen::<f64>() < self.sample_rate
    }
}
```

### Tracesï¼ˆè¿½è¸ªï¼‰æ·±åº¦å®è·µ

#### åˆ†å¸ƒå¼è¿½è¸ªæœ€ä½³å®è·µ

```rust
use opentelemetry::trace::{Tracer, Span, SpanKind, Status};
use opentelemetry::Context;

/// è¿½è¸ªè£…é¥°å™¨
pub struct TracingDecorator {
    tracer: Box<dyn Tracer>,
}

impl TracingDecorator {
    /// åˆ›å»ºå­ Span
    pub fn create_child_span(&self, parent_ctx: &Context, name: &str) -> Span {
        self.tracer
            .span_builder(name)
            .with_kind(SpanKind::Internal)
            .start_with_context(&self.tracer, parent_ctx)
    }

    /// è®°å½• Span äº‹ä»¶
    pub fn record_event(span: &Span, name: &str, attributes: Vec<(&str, String)>) {
        span.add_event(
            name.to_string(),
            attributes.into_iter().map(|(k, v)| {
                opentelemetry::KeyValue::new(k.to_string(), v)
            }).collect(),
        );
    }

    /// è®°å½•é”™è¯¯
    pub fn record_error(span: &Span, error: &dyn std::error::Error) {
        span.set_status(Status::error(error.to_string()));
        span.set_attribute(opentelemetry::KeyValue::new(
            "error.type",
            format!("{:?}", error),
        ));
    }
}

/// å®Œæ•´çš„è¿½è¸ªç¤ºä¾‹
pub struct OtlpExporter {
    tracer: Box<dyn Tracer>,
}

impl OtlpExporter {
    #[instrument(skip(self, spans))]
    pub async fn export_with_tracing(&self, spans: Vec<Span>) -> Result<(), ExportError> {
        // åˆ›å»ºæ ¹ Span
        let mut span = self.tracer
            .span_builder("export_spans")
            .with_kind(SpanKind::Client)
            .start(&self.tracer);
        
        span.set_attribute(opentelemetry::KeyValue::new("span.count", spans.len() as i64));
        
        // éªŒè¯é˜¶æ®µ
        let validation_result = {
            let mut validation_span = self.tracer
                .span_builder("validate_spans")
                .with_kind(SpanKind::Internal)
                .start(&self.tracer);
            
            let result = self.validate_spans(&spans);
            
            if let Err(e) = &result {
                validation_span.set_status(Status::error(e.to_string()));
            }
            
            result
        };
        
        validation_result?;
        
        // åºåˆ—åŒ–é˜¶æ®µ
        let serialized = {
            let mut serialize_span = self.tracer
                .span_builder("serialize_spans")
                .with_kind(SpanKind::Internal)
                .start(&self.tracer);
            
            let result = self.serialize_spans(&spans);
            
            if let Ok(data) = &result {
                serialize_span.set_attribute(
                    opentelemetry::KeyValue::new("serialized.bytes", data.len() as i64)
                );
            }
            
            result
        }?;
        
        // å‘é€é˜¶æ®µ
        {
            let mut send_span = self.tracer
                .span_builder("send_to_collector")
                .with_kind(SpanKind::Client)
                .start(&self.tracer);
            
            send_span.set_attribute(
                opentelemetry::KeyValue::new("collector.endpoint", "http://localhost:4317")
            );
            
            self.send_data(&serialized).await?;
        }
        
        span.set_status(Status::Ok);
        Ok(())
    }

    fn validate_spans(&self, _spans: &[Span]) -> Result<(), ExportError> {
        Ok(())
    }

    fn serialize_spans(&self, _spans: &[Span]) -> Result<Vec<u8>, ExportError> {
        Ok(vec![])
    }

    async fn send_data(&self, _data: &[u8]) -> Result<(), ExportError> {
        Ok(())
    }
}
```

## å…³è”åˆ†æ

### ä¸‰å¤§æ”¯æŸ±å…³è”

```rust
/// å¯è§‚æµ‹æ€§å…³è”å™¨
pub struct ObservabilityCorrelator {
    trace_id: String,
    span_id: String,
}

impl ObservabilityCorrelator {
    /// åˆ›å»ºå…³è”ä¸Šä¸‹æ–‡
    pub fn create_context(trace_id: String, span_id: String) -> Self {
        Self { trace_id, span_id }
    }

    /// åœ¨æ—¥å¿—ä¸­æ·»åŠ è¿½è¸ªä¿¡æ¯
    pub fn log_with_trace(&self, message: &str) {
        info!(
            trace_id = %self.trace_id,
            span_id = %self.span_id,
            message = message
        );
    }

    /// åœ¨æŒ‡æ ‡ä¸­æ·»åŠ è¿½è¸ªæ ‡ç­¾
    pub fn record_metric_with_trace(&self, metric: &Counter) {
        // æ³¨æ„ï¼šé«˜åŸºæ•°æ ‡ç­¾ä¼šå½±å“æ€§èƒ½
        // ä»…åœ¨å¿…è¦æ—¶ä½¿ç”¨
        metric.inc();
    }

    /// ä»è¿½è¸ªåˆ°æ—¥å¿—çš„æŸ¥è¯¢
    pub fn trace_to_logs_query(&self) -> String {
        format!(
            r#"{{trace_id="{}"}} | json | line_format "{{{{.message}}}}""#,
            self.trace_id
        )
    }

    /// ä»æ—¥å¿—åˆ°è¿½è¸ªçš„æŸ¥è¯¢
    pub fn logs_to_trace_query(log_trace_id: &str) -> String {
        format!("trace_id:{}", log_trace_id)
    }
}
```

### ç«¯åˆ°ç«¯è¿½è¸ªç¤ºä¾‹

```rust
/// ç«¯åˆ°ç«¯å¯è§‚æµ‹æ€§ç¤ºä¾‹
pub struct EndToEndObservability {
    metrics: OtlpMetrics,
    tracer: Box<dyn Tracer>,
}

impl EndToEndObservability {
    #[instrument(skip(self, request))]
    pub async fn handle_request(&self, request: Request) -> Result<Response, Error> {
        // 1. åˆ›å»ºè¿½è¸ª Span
        let span = self.tracer
            .span_builder("handle_request")
            .with_kind(SpanKind::Server)
            .start(&self.tracer);
        
        let trace_id = format!("{:?}", span.span_context().trace_id());
        let span_id = format!("{:?}", span.span_context().span_id());
        
        // 2. è®°å½•æŒ‡æ ‡
        self.metrics.requests_total.inc();
        let start = std::time::Instant::now();
        
        // 3. è®°å½•æ—¥å¿—ï¼ˆå¸¦è¿½è¸ªIDï¼‰
        info!(
            trace_id = %trace_id,
            span_id = %span_id,
            method = %request.method,
            path = %request.path,
            "Processing request"
        );
        
        // 4. å¤„ç†è¯·æ±‚
        let result = self.process_request(request).await;
        
        // 5. è®°å½•ç»“æœ
        let duration = start.elapsed();
        self.metrics.request_duration.observe(duration.as_secs_f64());
        
        match &result {
            Ok(_) => {
                info!(
                    trace_id = %trace_id,
                    duration_ms = duration.as_millis(),
                    "Request successful"
                );
                span.set_status(Status::Ok);
            }
            Err(e) => {
                error!(
                    trace_id = %trace_id,
                    error = ?e,
                    "Request failed"
                );
                self.metrics.errors_total.inc();
                span.set_status(Status::error(e.to_string()));
            }
        }
        
        result
    }

    async fn process_request(&self, _request: Request) -> Result<Response, Error> {
        Ok(Response { status: 200 })
    }
}

#[derive(Debug)]
pub struct Request {
    method: String,
    path: String,
}

#[derive(Debug)]
pub struct Response {
    status: u16,
}

#[derive(Debug)]
pub struct Error;

impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Error")
    }
}

impl std::error::Error for Error {}
```

## å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹1ï¼šæ€§èƒ½é—®é¢˜æ’æŸ¥

**é—®é¢˜æè¿°**ï¼š

- P99 å»¶è¿Ÿçªç„¶ä» 50ms ä¸Šå‡åˆ° 500ms
- é”™è¯¯ç‡æ­£å¸¸
- ç”¨æˆ·æŠ•è¯‰å“åº”æ…¢

**æ’æŸ¥æµç¨‹**ï¼š

```text
1. æŸ¥çœ‹æŒ‡æ ‡ï¼ˆMetricsï¼‰
   â†’ å‘ç° P99 å»¶è¿Ÿå¼‚å¸¸
   â†’ å®šä½æ—¶é—´èŒƒå›´ï¼š14:30-15:00

2. æŸ¥çœ‹è¿½è¸ªï¼ˆTracesï¼‰
   â†’ ç­›é€‰è¯¥æ—¶é—´æ®µçš„æ…¢è¯·æ±‚
   â†’ å‘ç°æ•°æ®åº“æŸ¥è¯¢è€—æ—¶é•¿

3. æŸ¥çœ‹æ—¥å¿—ï¼ˆLogsï¼‰
   â†’ ä½¿ç”¨ trace_id å…³è”æ—¥å¿—
   â†’ å‘ç°æ…¢æŸ¥è¯¢ SQL

4. æ ¹å› åˆ†æ
   â†’ æ•°æ®åº“ç´¢å¼•å¤±æ•ˆ
   â†’ æŸä¸ªè¡¨æ•°æ®é‡æ¿€å¢
```

**Grafana æŸ¥è¯¢ç¤ºä¾‹**ï¼š

```promql
# 1. è¯†åˆ«å»¶è¿Ÿå¼‚å¸¸
histogram_quantile(0.99, 
  rate(otlp_request_duration_seconds_bucket[5m])
) > 0.1

# 2. æŒ‰ç«¯ç‚¹åˆ†ç»„æŸ¥çœ‹
histogram_quantile(0.99, 
  sum by (endpoint) (
    rate(otlp_request_duration_seconds_bucket[5m])
  )
)
```

**Loki æ—¥å¿—æŸ¥è¯¢**ï¼š

```logql
# æŸ¥æ‰¾æ…¢è¯·æ±‚çš„æ—¥å¿—
{job="otlp-collector"} 
  | json 
  | duration_ms > 100
  | line_format "{{.trace_id}} - {{.message}}"
```

### æ¡ˆä¾‹2ï¼šé”™è¯¯ç‡æ¿€å¢æ’æŸ¥

**é—®é¢˜æè¿°**ï¼š

- é”™è¯¯ç‡ä» 0.1% ä¸Šå‡åˆ° 5%
- å‘Šè­¦è§¦å‘

**æ’æŸ¥æµç¨‹**ï¼š

```rust
/// é”™è¯¯åˆ†æå·¥å…·
pub struct ErrorAnalyzer;

impl ErrorAnalyzer {
    /// åˆ†æé”™è¯¯æ¨¡å¼
    pub fn analyze_error_pattern() -> Vec<ErrorPattern> {
        vec![
            ErrorPattern {
                error_type: "ConnectionTimeout".to_string(),
                count: 1250,
                percentage: 62.5,
                first_seen: "14:35:00".to_string(),
                sample_trace_id: "abc123".to_string(),
            },
            ErrorPattern {
                error_type: "ServiceUnavailable".to_string(),
                count: 500,
                percentage: 25.0,
                first_seen: "14:36:00".to_string(),
                sample_trace_id: "def456".to_string(),
            },
        ]
    }

    /// ç”Ÿæˆé”™è¯¯æŠ¥å‘Š
    pub fn generate_report(patterns: Vec<ErrorPattern>) -> String {
        let mut report = String::from("=== é”™è¯¯åˆ†ææŠ¥å‘Š ===\n\n");
        
        for pattern in patterns {
            report.push_str(&format!(
                "é”™è¯¯ç±»å‹: {}\n\
                 å‘ç”Ÿæ¬¡æ•°: {}\n\
                 å æ¯”: {:.1}%\n\
                 é¦–æ¬¡å‡ºç°: {}\n\
                 ç¤ºä¾‹ Trace: {}\n\n",
                pattern.error_type,
                pattern.count,
                pattern.percentage,
                pattern.first_seen,
                pattern.sample_trace_id
            ));
        }
        
        report
    }
}

#[derive(Debug)]
pub struct ErrorPattern {
    error_type: String,
    count: usize,
    percentage: f64,
    first_seen: String,
    sample_trace_id: String,
}
```

## å¯è§‚æµ‹æ€§æˆç†Ÿåº¦æ¨¡å‹

### æˆç†Ÿåº¦ç­‰çº§

```rust
/// å¯è§‚æµ‹æ€§æˆç†Ÿåº¦è¯„ä¼°
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum ObservabilityMaturity {
    Level1_Reactive,    // è¢«åŠ¨å“åº”
    Level2_Proactive,   // ä¸»åŠ¨ç›‘æ§
    Level3_Predictive,  // é¢„æµ‹æ€§
    Level4_Autonomous,  // è‡ªä¸»åŒ–
}

impl ObservabilityMaturity {
    pub fn describe(&self) -> MaturityDescription {
        match self {
            Self::Level1_Reactive => MaturityDescription {
                level: "Level 1: è¢«åŠ¨å“åº”",
                characteristics: vec![
                    "ä¾èµ–ç”¨æˆ·æŠ¥å‘Šé—®é¢˜",
                    "åŸºç¡€æ—¥å¿—å’ŒæŒ‡æ ‡",
                    "æ‰‹åŠ¨æ’æŸ¥",
                ],
                improvements: vec![
                    "å»ºç«‹åŸºç¡€ç›‘æ§",
                    "é…ç½®å‘Šè­¦è§„åˆ™",
                    "æ ‡å‡†åŒ–æ—¥å¿—æ ¼å¼",
                ],
            },
            Self::Level2_Proactive => MaturityDescription {
                level: "Level 2: ä¸»åŠ¨ç›‘æ§",
                characteristics: vec![
                    "å®Œæ•´çš„æŒ‡æ ‡ã€æ—¥å¿—ã€è¿½è¸ª",
                    "è‡ªåŠ¨å‘Šè­¦",
                    "ä»ªè¡¨æ¿å¯è§†åŒ–",
                ],
                improvements: vec![
                    "å®æ–½ SLO/SLA",
                    "å»ºç«‹ Runbook",
                    "å…³è”åˆ†æ",
                ],
            },
            Self::Level3_Predictive => MaturityDescription {
                level: "Level 3: é¢„æµ‹æ€§",
                characteristics: vec![
                    "å¼‚å¸¸æ£€æµ‹",
                    "å®¹é‡é¢„æµ‹",
                    "æ ¹å› åˆ†æè‡ªåŠ¨åŒ–",
                ],
                improvements: vec![
                    "æœºå™¨å­¦ä¹ é›†æˆ",
                    "è‡ªåŠ¨åŒ–ä¿®å¤",
                    "æ··æ²Œå·¥ç¨‹",
                ],
            },
            Self::Level4_Autonomous => MaturityDescription {
                level: "Level 4: è‡ªä¸»åŒ–",
                characteristics: vec![
                    "è‡ªæ„ˆç³»ç»Ÿ",
                    "è‡ªåŠ¨æ‰©ç¼©å®¹",
                    "æ™ºèƒ½è·¯ç”±",
                ],
                improvements: vec![
                    "æŒç»­ä¼˜åŒ–",
                    "AI é©±åŠ¨å†³ç­–",
                ],
            },
        }
    }
}

pub struct MaturityDescription {
    level: &'static str,
    characteristics: Vec<&'static str>,
    improvements: Vec<&'static str>,
}
```

## å·¥å…·é“¾æ¨è

### å®Œæ•´çš„å¯è§‚æµ‹æ€§å·¥å…·æ ˆ

```yaml
# OTLP å¯è§‚æµ‹æ€§å·¥å…·æ ˆ

## æŒ‡æ ‡ï¼ˆMetricsï¼‰
- é‡‡é›†: Prometheus
- å­˜å‚¨: Prometheus / VictoriaMetrics / Thanos
- å¯è§†åŒ–: Grafana
- å‘Šè­¦: Alertmanager

## æ—¥å¿—ï¼ˆLogsï¼‰
- é‡‡é›†: Fluent Bit / Vector
- å­˜å‚¨: Loki / Elasticsearch
- æŸ¥è¯¢: LogQL / Kibana
- åˆ†æ: Grafana

## è¿½è¸ªï¼ˆTracesï¼‰
- é‡‡é›†: OpenTelemetry Collector
- å­˜å‚¨: Jaeger / Tempo / Zipkin
- å¯è§†åŒ–: Jaeger UI / Grafana
- åˆ†æ: Grafana Tempo

## ç»Ÿä¸€å¹³å°
- Grafana (ç»Ÿä¸€å¯è§†åŒ–)
- OpenTelemetry (ç»Ÿä¸€é‡‡é›†)
- Grafana Cloud (æ‰˜ç®¡æœåŠ¡)
```

### å·¥å…·é…ç½®ç¤ºä¾‹

```yaml
# docker-compose.yml
version: '3.8'

services:
  # Prometheus
  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml

  # Loki
  loki:
    image: grafana/loki:latest
    ports:
      - "3100:3100"

  # Tempo
  tempo:
    image: grafana/tempo:latest
    ports:
      - "3200:3200"
      - "4317:4317"  # OTLP gRPC
      - "4318:4318"  # OTLP HTTP

  # Grafana
  grafana:
    image: grafana/grafana:latest
    ports:
      - "3000:3000"
    environment:
      - GF_AUTH_ANONYMOUS_ENABLED=true
    volumes:
      - ./grafana-dashboards:/etc/grafana/provisioning/dashboards
```

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [å‘Šè­¦è§„åˆ™è®¾è®¡](./å‘Šè­¦è§„åˆ™è®¾è®¡.md)
- [SLO_SLAç®¡ç†](./SLO_SLAç®¡ç†.md)
- [æ€§èƒ½è°ƒä¼˜](../æ€§èƒ½è°ƒä¼˜/æ€§èƒ½é—®é¢˜è¯†åˆ«.md)
