# 容量预测模型

## 目录

- [容量预测模型](#容量预测模型)
  - [目录](#目录)
  - [概述](#概述)
  - [时间序列预测](#时间序列预测)
    - [移动平均法](#移动平均法)
    - [指数平滑法](#指数平滑法)
  - [增长模型](#增长模型)
    - [线性增长](#线性增长)
    - [指数增长](#指数增长)
    - [Rust 实现](#rust-实现)
  - [容量规划方法](#容量规划方法)
    - [基于负载的规划](#基于负载的规划)
  - [OTLP 容量预测](#otlp-容量预测)
    - [Span 增长预测](#span-增长预测)

## 概述

容量预测帮助提前规划资源需求，避免容量不足或资源浪费。

## 时间序列预测

### 移动平均法

```rust
pub struct MovingAverage {
    window_size: usize,
    values: Vec<f64>,
}

impl MovingAverage {
    pub fn new(window_size: usize) -> Self {
        Self {
            window_size,
            values: Vec::new(),
        }
    }

    pub fn add_value(&mut self, value: f64) {
        self.values.push(value);
        if self.values.len() > self.window_size {
            self.values.remove(0);
        }
    }

    pub fn predict(&self) -> f64 {
        if self.values.is_empty() {
            return 0.0;
        }
        self.values.iter().sum::<f64>() / self.values.len() as f64
    }
}
```

### 指数平滑法

```rust
pub struct ExponentialSmoothing {
    alpha: f64,
    last_value: Option<f64>,
}

impl ExponentialSmoothing {
    pub fn new(alpha: f64) -> Self {
        Self {
            alpha: alpha.clamp(0.0, 1.0),
            last_value: None,
        }
    }

    pub fn update(&mut self, value: f64) -> f64 {
        let smoothed = match self.last_value {
            None => value,
            Some(last) => self.alpha * value + (1.0 - self.alpha) * last,
        };
        self.last_value = Some(smoothed);
        smoothed
    }

    pub fn predict(&self) -> f64 {
        self.last_value.unwrap_or(0.0)
    }
}
```

## 增长模型

### 线性增长

```text
y(t) = a + b×t
```

### 指数增长

```text
y(t) = a × e^(b×t)
```

### Rust 实现

```rust
pub struct GrowthModel {
    data_points: Vec<(f64, f64)>, // (time, value)
}

impl GrowthModel {
    pub fn new() -> Self {
        Self {
            data_points: Vec::new(),
        }
    }

    pub fn add_point(&mut self, time: f64, value: f64) {
        self.data_points.push((time, value));
    }

    /// 线性回归预测
    pub fn linear_predict(&self, future_time: f64) -> f64 {
        if self.data_points.len() < 2 {
            return 0.0;
        }

        let n = self.data_points.len() as f64;
        let sum_x: f64 = self.data_points.iter().map(|(t, _)| t).sum();
        let sum_y: f64 = self.data_points.iter().map(|(_, v)| v).sum();
        let sum_xy: f64 = self.data_points.iter().map(|(t, v)| t * v).sum();
        let sum_x2: f64 = self.data_points.iter().map(|(t, _)| t * t).sum();

        let b = (n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x * sum_x);
        let a = (sum_y - b * sum_x) / n;

        a + b * future_time
    }
}
```

## 容量规划方法

### 基于负载的规划

```rust
pub struct CapacityPlanner {
    current_qps: f64,
    current_resources: Resources,
    target_headroom: f64, // 预留容量比例
}

#[derive(Debug, Clone)]
pub struct Resources {
    pub cpu_cores: usize,
    pub memory_gb: usize,
    pub storage_gb: usize,
}

impl CapacityPlanner {
    pub fn plan_for_qps(&self, target_qps: f64) -> Resources {
        let scale_factor = target_qps / self.current_qps;
        let with_headroom = scale_factor * (1.0 + self.target_headroom);

        Resources {
            cpu_cores: (self.current_resources.cpu_cores as f64 * with_headroom).ceil() as usize,
            memory_gb: (self.current_resources.memory_gb as f64 * with_headroom).ceil() as usize,
            storage_gb: (self.current_resources.storage_gb as f64 * with_headroom).ceil() as usize,
        }
    }
}
```

## OTLP 容量预测

### Span 增长预测

```rust
pub struct SpanGrowthPredictor {
    historical_data: Vec<(u64, u64)>, // (timestamp, span_count)
    growth_model: GrowthModel,
}

impl SpanGrowthPredictor {
    pub fn predict_daily_spans(&self, days_ahead: u64) -> u64 {
        let future_time = days_ahead as f64;
        self.growth_model.linear_predict(future_time) as u64
    }

    pub fn required_storage(&self, days_ahead: u64, retention_days: usize) -> u64 {
        let daily_spans = self.predict_daily_spans(days_ahead);
        let avg_span_size = 1024; // bytes
        daily_spans * retention_days as u64 * avg_span_size
    }
}
```

---

**相关文档**：

- [资源使用分析](./资源使用分析.md)
- [扩容决策](./扩容决策.md)
