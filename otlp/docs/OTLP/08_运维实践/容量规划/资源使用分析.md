# 资源使用分析

## 目录

- [资源使用分析](#资源使用分析)
  - [目录](#目录)
  - [概述](#概述)
  - [资源使用监控](#资源使用监控)
    - [Prometheus 指标](#prometheus-指标)
    - [Rust 实现：资源监控](#rust-实现资源监控)
  - [使用趋势分析](#使用趋势分析)
    - [时间序列分析](#时间序列分析)
  - [资源利用率优化](#资源利用率优化)
    - [优化建议生成](#优化建议生成)
  - [详细资源监控实现](#详细资源监控实现)
    - [多维度资源监控器](#多维度资源监控器)
  - [高级趋势分析](#高级趋势分析)
    - [多维度趋势分析器](#多维度趋势分析器)
  - [智能优化建议系统](#智能优化建议系统)
    - [高级优化顾问](#高级优化顾问)
  - [实战案例](#实战案例)
    - [案例1：内存泄漏检测](#案例1内存泄漏检测)
    - [案例2：CPU 突增分析](#案例2cpu-突增分析)

## 概述

资源使用分析帮助了解系统资源消耗情况，为优化和扩容提供依据。

## 资源使用监控

### Prometheus 指标

```yaml
# CPU 使用率
- process_cpu_seconds_total
- node_cpu_seconds_total

# 内存使用
- process_resident_memory_bytes
- node_memory_MemAvailable_bytes

# 磁盘使用
- node_filesystem_avail_bytes
- node_disk_io_time_seconds_total

# 网络使用
- node_network_receive_bytes_total
- node_network_transmit_bytes_total
```

### Rust 实现：资源监控

```rust
use sysinfo::{System, SystemExt, ProcessExt};

pub struct ResourceMonitor {
    system: System,
}

impl ResourceMonitor {
    pub fn new() -> Self {
        Self {
            system: System::new_all(),
        }
    }

    pub fn collect_metrics(&mut self) -> ResourceMetrics {
        self.system.refresh_all();

        ResourceMetrics {
            cpu_usage: self.system.global_cpu_info().cpu_usage(),
            memory_used: self.system.used_memory(),
            memory_total: self.system.total_memory(),
            disk_usage: self.get_disk_usage(),
        }
    }

    fn get_disk_usage(&self) -> f64 {
        // 实现磁盘使用率计算
        0.0
    }
}

pub struct ResourceMetrics {
    pub cpu_usage: f32,
    pub memory_used: u64,
    pub memory_total: u64,
    pub disk_usage: f64,
}
```

## 使用趋势分析

### 时间序列分析

```rust
pub struct TrendAnalyzer {
    data_points: Vec<(u64, f64)>, // (timestamp, value)
}

impl TrendAnalyzer {
    pub fn analyze_trend(&self) -> TrendResult {
        if self.data_points.len() < 2 {
            return TrendResult::Insufficient;
        }

        let slope = self.calculate_slope();

        if slope > 0.1 {
            TrendResult::Increasing
        } else if slope < -0.1 {
            TrendResult::Decreasing
        } else {
            TrendResult::Stable
        }
    }

    fn calculate_slope(&self) -> f64 {
        // 线性回归计算斜率
        let n = self.data_points.len() as f64;
        let sum_x: f64 = self.data_points.iter().map(|(t, _)| *t as f64).sum();
        let sum_y: f64 = self.data_points.iter().map(|(_, v)| v).sum();
        let sum_xy: f64 = self.data_points.iter().map(|(t, v)| (*t as f64) * v).sum();
        let sum_x2: f64 = self.data_points.iter().map(|(t, _)| (*t as f64).powi(2)).sum();

        (n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x * sum_x)
    }
}

pub enum TrendResult {
    Increasing,
    Decreasing,
    Stable,
    Insufficient,
}
```

## 资源利用率优化

### 优化建议生成

```rust
pub struct OptimizationAdvisor {
    metrics: ResourceMetrics,
}

impl OptimizationAdvisor {
    pub fn generate_recommendations(&self) -> Vec<Recommendation> {
        let mut recommendations = Vec::new();

        // CPU 优化建议
        if self.metrics.cpu_usage > 80.0 {
            recommendations.push(Recommendation {
                resource: "CPU".to_string(),
                severity: Severity::High,
                suggestion: "考虑增加 CPU 核心数或优化计算密集型任务".to_string(),
            });
        }

        // 内存优化建议
        let memory_usage_percent = (self.metrics.memory_used as f64 / self.metrics.memory_total as f64) * 100.0;
        if memory_usage_percent > 85.0 {
            recommendations.push(Recommendation {
                resource: "Memory".to_string(),
                severity: Severity::High,
                suggestion: "内存使用率过高，建议增加内存或优化内存使用".to_string(),
            });
        }

        recommendations
    }
}

pub struct Recommendation {
    pub resource: String,
    pub severity: Severity,
    pub suggestion: String,
}

pub enum Severity {
    Low,
    Medium,
    High,
    Critical,
}
```

## 详细资源监控实现

### 多维度资源监控器

```rust
use sysinfo::{System, SystemExt, ProcessExt, DiskExt, NetworkExt};
use std::collections::HashMap;
use std::time::{Duration, Instant};

/// 完整的资源监控器
pub struct ComprehensiveResourceMonitor {
    system: System,
    start_time: Instant,
    history: ResourceHistory,
}

impl ComprehensiveResourceMonitor {
    pub fn new() -> Self {
        Self {
            system: System::new_all(),
            start_time: Instant::now(),
            history: ResourceHistory::new(),
        }
    }

    /// 收集所有资源指标
    pub fn collect_all_metrics(&mut self) -> AllResourceMetrics {
        self.system.refresh_all();
        
        let metrics = AllResourceMetrics {
            cpu: self.collect_cpu_metrics(),
            memory: self.collect_memory_metrics(),
            disk: self.collect_disk_metrics(),
            network: self.collect_network_metrics(),
            process: self.collect_process_metrics(),
            timestamp: Instant::now().duration_since(self.start_time).as_secs(),
        };
        
        // 记录历史
        self.history.add(metrics.clone());
        
        metrics
    }

    fn collect_cpu_metrics(&self) -> CpuMetrics {
        let global_cpu = self.system.global_cpu_info();
        let per_cpu: Vec<f32> = self.system.cpus().iter()
            .map(|cpu| cpu.cpu_usage())
            .collect();
        
        CpuMetrics {
            global_usage: global_cpu.cpu_usage(),
            per_core_usage: per_cpu.clone(),
            core_count: per_cpu.len(),
            load_average_1m: self.system.load_average().one,
            load_average_5m: self.system.load_average().five,
            load_average_15m: self.system.load_average().fifteen,
        }
    }

    fn collect_memory_metrics(&self) -> MemoryMetrics {
        let used = self.system.used_memory();
        let total = self.system.total_memory();
        let available = self.system.available_memory();
        let swap_used = self.system.used_swap();
        let swap_total = self.system.total_swap();
        
        MemoryMetrics {
            used_bytes: used,
            total_bytes: total,
            available_bytes: available,
            usage_percent: (used as f64 / total as f64) * 100.0,
            swap_used_bytes: swap_used,
            swap_total_bytes: swap_total,
            swap_usage_percent: if swap_total > 0 {
                (swap_used as f64 / swap_total as f64) * 100.0
            } else {
                0.0
            },
        }
    }

    fn collect_disk_metrics(&self) -> Vec<DiskMetrics> {
        self.system.disks().iter().map(|disk| {
            let total = disk.total_space();
            let available = disk.available_space();
            let used = total - available;
            
            DiskMetrics {
                mount_point: disk.mount_point().to_string_lossy().to_string(),
                total_bytes: total,
                used_bytes: used,
                available_bytes: available,
                usage_percent: (used as f64 / total as f64) * 100.0,
                file_system: disk.file_system().to_string_lossy().to_string(),
            }
        }).collect()
    }

    fn collect_network_metrics(&self) -> NetworkMetrics {
        let networks = self.system.networks();
        let mut total_received = 0u64;
        let mut total_transmitted = 0u64;
        
        for (_name, network) in networks {
            total_received += network.received();
            total_transmitted += network.transmitted();
        }
        
        NetworkMetrics {
            total_received_bytes: total_received,
            total_transmitted_bytes: total_transmitted,
            interface_count: networks.len(),
        }
    }

    fn collect_process_metrics(&self) -> ProcessMetrics {
        let current_pid = std::process::id();
        
        if let Some(process) = self.system.process(sysinfo::Pid::from_u32(current_pid)) {
            ProcessMetrics {
                pid: current_pid,
                cpu_usage: process.cpu_usage(),
                memory_bytes: process.memory(),
                virtual_memory_bytes: process.virtual_memory(),
                disk_read_bytes: process.disk_usage().read_bytes,
                disk_write_bytes: process.disk_usage().written_bytes,
            }
        } else {
            ProcessMetrics::default()
        }
    }

    /// 获取资源使用历史
    pub fn get_history(&self, duration: Duration) -> Vec<AllResourceMetrics> {
        self.history.get_recent(duration)
    }
}

#[derive(Debug, Clone)]
pub struct AllResourceMetrics {
    pub cpu: CpuMetrics,
    pub memory: MemoryMetrics,
    pub disk: Vec<DiskMetrics>,
    pub network: NetworkMetrics,
    pub process: ProcessMetrics,
    pub timestamp: u64,
}

#[derive(Debug, Clone)]
pub struct CpuMetrics {
    pub global_usage: f32,
    pub per_core_usage: Vec<f32>,
    pub core_count: usize,
    pub load_average_1m: f64,
    pub load_average_5m: f64,
    pub load_average_15m: f64,
}

#[derive(Debug, Clone)]
pub struct MemoryMetrics {
    pub used_bytes: u64,
    pub total_bytes: u64,
    pub available_bytes: u64,
    pub usage_percent: f64,
    pub swap_used_bytes: u64,
    pub swap_total_bytes: u64,
    pub swap_usage_percent: f64,
}

#[derive(Debug, Clone)]
pub struct DiskMetrics {
    pub mount_point: String,
    pub total_bytes: u64,
    pub used_bytes: u64,
    pub available_bytes: u64,
    pub usage_percent: f64,
    pub file_system: String,
}

#[derive(Debug, Clone)]
pub struct NetworkMetrics {
    pub total_received_bytes: u64,
    pub total_transmitted_bytes: u64,
    pub interface_count: usize,
}

#[derive(Debug, Clone, Default)]
pub struct ProcessMetrics {
    pub pid: u32,
    pub cpu_usage: f32,
    pub memory_bytes: u64,
    pub virtual_memory_bytes: u64,
    pub disk_read_bytes: u64,
    pub disk_write_bytes: u64,
}

/// 资源使用历史记录
struct ResourceHistory {
    metrics: Vec<AllResourceMetrics>,
    max_size: usize,
}

impl ResourceHistory {
    fn new() -> Self {
        Self {
            metrics: Vec::new(),
            max_size: 1000, // 保留最近 1000 个数据点
        }
    }

    fn add(&mut self, metrics: AllResourceMetrics) {
        self.metrics.push(metrics);
        if self.metrics.len() > self.max_size {
            self.metrics.remove(0);
        }
    }

    fn get_recent(&self, duration: Duration) -> Vec<AllResourceMetrics> {
        let cutoff_time = self.metrics.last()
            .map(|m| m.timestamp.saturating_sub(duration.as_secs()))
            .unwrap_or(0);
        
        self.metrics.iter()
            .filter(|m| m.timestamp >= cutoff_time)
            .cloned()
            .collect()
    }
}
```

## 高级趋势分析

### 多维度趋势分析器

```rust
use statrs::statistics::Statistics;

/// 高级趋势分析器
pub struct AdvancedTrendAnalyzer {
    history: Vec<AllResourceMetrics>,
}

impl AdvancedTrendAnalyzer {
    pub fn new(history: Vec<AllResourceMetrics>) -> Self {
        Self { history }
    }

    /// 分析所有资源趋势
    pub fn analyze_all_trends(&self) -> TrendAnalysisReport {
        TrendAnalysisReport {
            cpu_trend: self.analyze_cpu_trend(),
            memory_trend: self.analyze_memory_trend(),
            disk_trend: self.analyze_disk_trend(),
            network_trend: self.analyze_network_trend(),
            predictions: self.generate_predictions(),
        }
    }

    fn analyze_cpu_trend(&self) -> ResourceTrend {
        let data: Vec<f64> = self.history.iter()
            .map(|m| m.cpu.global_usage as f64)
            .collect();
        
        self.calculate_trend(&data, "CPU")
    }

    fn analyze_memory_trend(&self) -> ResourceTrend {
        let data: Vec<f64> = self.history.iter()
            .map(|m| m.memory.usage_percent)
            .collect();
        
        self.calculate_trend(&data, "Memory")
    }

    fn analyze_disk_trend(&self) -> ResourceTrend {
        let data: Vec<f64> = self.history.iter()
            .filter_map(|m| m.disk.first())
            .map(|d| d.usage_percent)
            .collect();
        
        self.calculate_trend(&data, "Disk")
    }

    fn analyze_network_trend(&self) -> ResourceTrend {
        let data: Vec<f64> = self.history.iter()
            .map(|m| m.network.total_transmitted_bytes as f64)
            .collect();
        
        self.calculate_trend(&data, "Network")
    }

    fn calculate_trend(&self, data: &[f64], resource_name: &str) -> ResourceTrend {
        if data.len() < 2 {
            return ResourceTrend {
                resource: resource_name.to_string(),
                direction: TrendDirection::Insufficient,
                slope: 0.0,
                confidence: 0.0,
                mean: 0.0,
                std_dev: 0.0,
                min: 0.0,
                max: 0.0,
            };
        }

        let mean = data.mean();
        let std_dev = data.std_dev();
        let min = data.iter().cloned().fold(f64::INFINITY, f64::min);
        let max = data.iter().cloned().fold(f64::NEG_INFINITY, f64::max);

        // 线性回归计算斜率
        let n = data.len() as f64;
        let x: Vec<f64> = (0..data.len()).map(|i| i as f64).collect();
        let sum_x: f64 = x.iter().sum();
        let sum_y: f64 = data.iter().sum();
        let sum_xy: f64 = x.iter().zip(data.iter()).map(|(xi, yi)| xi * yi).sum();
        let sum_x2: f64 = x.iter().map(|xi| xi * xi).sum();

        let slope = (n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x * sum_x);

        // 计算 R² (决定系数) 作为置信度
        let y_pred: Vec<f64> = x.iter().map(|xi| mean + slope * (xi - sum_x / n)).collect();
        let ss_res: f64 = data.iter().zip(y_pred.iter())
            .map(|(yi, yp)| (yi - yp).powi(2))
            .sum();
        let ss_tot: f64 = data.iter()
            .map(|yi| (yi - mean).powi(2))
            .sum();
        let r_squared = 1.0 - (ss_res / ss_tot);

        let direction = if slope > 0.01 {
            TrendDirection::Increasing
        } else if slope < -0.01 {
            TrendDirection::Decreasing
        } else {
            TrendDirection::Stable
        };

        ResourceTrend {
            resource: resource_name.to_string(),
            direction,
            slope,
            confidence: r_squared,
            mean,
            std_dev,
            min,
            max,
        }
    }

    /// 生成未来预测
    fn generate_predictions(&self) -> Vec<ResourcePrediction> {
        let mut predictions = Vec::new();

        // CPU 预测
        let cpu_data: Vec<f64> = self.history.iter()
            .map(|m| m.cpu.global_usage as f64)
            .collect();
        predictions.push(self.predict_resource("CPU", &cpu_data, 3600)); // 1小时后

        // 内存预测
        let memory_data: Vec<f64> = self.history.iter()
            .map(|m| m.memory.usage_percent)
            .collect();
        predictions.push(self.predict_resource("Memory", &memory_data, 3600));

        predictions
    }

    fn predict_resource(&self, name: &str, data: &[f64], seconds_ahead: u64) -> ResourcePrediction {
        if data.len() < 2 {
            return ResourcePrediction {
                resource: name.to_string(),
                current_value: 0.0,
                predicted_value: 0.0,
                time_ahead_seconds: seconds_ahead,
                confidence: 0.0,
            };
        }

        let trend = self.calculate_trend(data, name);
        let current_value = data.last().copied().unwrap_or(0.0);
        
        // 简单线性预测
        let time_points = data.len() as f64;
        let predicted_value = current_value + trend.slope * (seconds_ahead as f64 / time_points);

        ResourcePrediction {
            resource: name.to_string(),
            current_value,
            predicted_value: predicted_value.max(0.0).min(100.0), // 限制在 0-100%
            time_ahead_seconds: seconds_ahead,
            confidence: trend.confidence,
        }
    }
}

#[derive(Debug)]
pub struct TrendAnalysisReport {
    pub cpu_trend: ResourceTrend,
    pub memory_trend: ResourceTrend,
    pub disk_trend: ResourceTrend,
    pub network_trend: ResourceTrend,
    pub predictions: Vec<ResourcePrediction>,
}

#[derive(Debug)]
pub struct ResourceTrend {
    pub resource: String,
    pub direction: TrendDirection,
    pub slope: f64,
    pub confidence: f64,
    pub mean: f64,
    pub std_dev: f64,
    pub min: f64,
    pub max: f64,
}

#[derive(Debug)]
pub enum TrendDirection {
    Increasing,
    Decreasing,
    Stable,
    Insufficient,
}

#[derive(Debug)]
pub struct ResourcePrediction {
    pub resource: String,
    pub current_value: f64,
    pub predicted_value: f64,
    pub time_ahead_seconds: u64,
    pub confidence: f64,
}
```

## 智能优化建议系统

### 高级优化顾问

```rust
/// 智能优化顾问
pub struct IntelligentOptimizationAdvisor {
    current_metrics: AllResourceMetrics,
    trend_report: TrendAnalysisReport,
    thresholds: ResourceThresholds,
}

#[derive(Debug, Clone)]
pub struct ResourceThresholds {
    pub cpu_warning: f64,
    pub cpu_critical: f64,
    pub memory_warning: f64,
    pub memory_critical: f64,
    pub disk_warning: f64,
    pub disk_critical: f64,
}

impl Default for ResourceThresholds {
    fn default() -> Self {
        Self {
            cpu_warning: 70.0,
            cpu_critical: 85.0,
            memory_warning: 75.0,
            memory_critical: 90.0,
            disk_warning: 80.0,
            disk_critical: 95.0,
        }
    }
}

impl IntelligentOptimizationAdvisor {
    pub fn new(
        current_metrics: AllResourceMetrics,
        trend_report: TrendAnalysisReport,
    ) -> Self {
        Self {
            current_metrics,
            trend_report,
            thresholds: ResourceThresholds::default(),
        }
    }

    /// 生成全面的优化建议
    pub fn generate_comprehensive_recommendations(&self) -> Vec<DetailedRecommendation> {
        let mut recommendations = Vec::new();

        // CPU 建议
        recommendations.extend(self.analyze_cpu());
        
        // 内存建议
        recommendations.extend(self.analyze_memory());
        
        // 磁盘建议
        recommendations.extend(self.analyze_disk());
        
        // 网络建议
        recommendations.extend(self.analyze_network());
        
        // 基于趋势的预测性建议
        recommendations.extend(self.generate_predictive_recommendations());

        // 按严重程度排序
        recommendations.sort_by(|a, b| b.severity.cmp(&a.severity));

        recommendations
    }

    fn analyze_cpu(&self) -> Vec<DetailedRecommendation> {
        let mut recommendations = Vec::new();
        let cpu_usage = self.current_metrics.cpu.global_usage as f64;

        if cpu_usage > self.thresholds.cpu_critical {
            recommendations.push(DetailedRecommendation {
                resource: "CPU".to_string(),
                severity: Severity::Critical,
                current_value: cpu_usage,
                threshold: self.thresholds.cpu_critical,
                issue: format!("CPU 使用率达到 {:.1}%，超过临界阈值", cpu_usage),
                suggestions: vec![
                    "立即检查是否有异常进程占用 CPU".to_string(),
                    "考虑水平扩展增加实例数".to_string(),
                    "优化计算密集型任务".to_string(),
                    "启用 CPU 限流保护".to_string(),
                ],
                estimated_impact: "高 - 可能影响服务响应时间".to_string(),
                action_priority: ActionPriority::Immediate,
            });
        } else if cpu_usage > self.thresholds.cpu_warning {
            recommendations.push(DetailedRecommendation {
                resource: "CPU".to_string(),
                severity: Severity::Warning,
                current_value: cpu_usage,
                threshold: self.thresholds.cpu_warning,
                issue: format!("CPU 使用率 {:.1}% 接近警告阈值", cpu_usage),
                suggestions: vec![
                    "监控 CPU 使用趋势".to_string(),
                    "检查是否有优化空间".to_string(),
                    "准备扩容计划".to_string(),
                ],
                estimated_impact: "中 - 需要关注".to_string(),
                action_priority: ActionPriority::High,
            });
        }

        // 负载平均值分析
        let load_avg = self.current_metrics.cpu.load_average_5m;
        let core_count = self.current_metrics.cpu.core_count as f64;
        if load_avg > core_count * 0.8 {
            recommendations.push(DetailedRecommendation {
                resource: "CPU Load".to_string(),
                severity: Severity::Warning,
                current_value: load_avg,
                threshold: core_count * 0.8,
                issue: format!("5分钟负载平均值 {:.2} 较高（核心数：{}）", load_avg, core_count),
                suggestions: vec![
                    "检查是否有长时间运行的任务".to_string(),
                    "考虑任务调度优化".to_string(),
                ],
                estimated_impact: "中".to_string(),
                action_priority: ActionPriority::Medium,
            });
        }

        recommendations
    }

    fn analyze_memory(&self) -> Vec<DetailedRecommendation> {
        let mut recommendations = Vec::new();
        let memory_usage = self.current_metrics.memory.usage_percent;

        if memory_usage > self.thresholds.memory_critical {
            recommendations.push(DetailedRecommendation {
                resource: "Memory".to_string(),
                severity: Severity::Critical,
                current_value: memory_usage,
                threshold: self.thresholds.memory_critical,
                issue: format!("内存使用率 {:.1}% 达到临界水平", memory_usage),
                suggestions: vec![
                    "立即检查内存泄漏".to_string(),
                    "重启高内存占用服务".to_string(),
                    "增加物理内存".to_string(),
                    "启用内存限制和 OOM 保护".to_string(),
                ],
                estimated_impact: "严重 - 可能导致 OOM".to_string(),
                action_priority: ActionPriority::Immediate,
            });
        } else if memory_usage > self.thresholds.memory_warning {
            recommendations.push(DetailedRecommendation {
                resource: "Memory".to_string(),
                severity: Severity::Warning,
                current_value: memory_usage,
                threshold: self.thresholds.memory_warning,
                issue: format!("内存使用率 {:.1}% 偏高", memory_usage),
                suggestions: vec![
                    "分析内存使用模式".to_string(),
                    "优化缓存策略".to_string(),
                    "考虑垂直扩展".to_string(),
                ],
                estimated_impact: "中".to_string(),
                action_priority: ActionPriority::High,
            });
        }

        // Swap 使用分析
        if self.current_metrics.memory.swap_usage_percent > 10.0 {
            recommendations.push(DetailedRecommendation {
                resource: "Swap".to_string(),
                severity: Severity::Warning,
                current_value: self.current_metrics.memory.swap_usage_percent,
                threshold: 10.0,
                issue: format!("Swap 使用率 {:.1}%，可能影响性能", 
                    self.current_metrics.memory.swap_usage_percent),
                suggestions: vec![
                    "增加物理内存".to_string(),
                    "减少内存占用".to_string(),
                    "调整 swappiness 参数".to_string(),
                ],
                estimated_impact: "中 - 性能下降".to_string(),
                action_priority: ActionPriority::Medium,
            });
        }

        recommendations
    }

    fn analyze_disk(&self) -> Vec<DetailedRecommendation> {
        let mut recommendations = Vec::new();

        for disk in &self.current_metrics.disk {
            if disk.usage_percent > self.thresholds.disk_critical {
                recommendations.push(DetailedRecommendation {
                    resource: format!("Disk ({})", disk.mount_point),
                    severity: Severity::Critical,
                    current_value: disk.usage_percent,
                    threshold: self.thresholds.disk_critical,
                    issue: format!("磁盘 {} 使用率 {:.1}% 达到临界水平", 
                        disk.mount_point, disk.usage_percent),
                    suggestions: vec![
                        "立即清理不必要的文件".to_string(),
                        "归档旧数据".to_string(),
                        "扩展磁盘空间".to_string(),
                        "启用日志轮转".to_string(),
                    ],
                    estimated_impact: "严重 - 可能导致服务中断".to_string(),
                    action_priority: ActionPriority::Immediate,
                });
            } else if disk.usage_percent > self.thresholds.disk_warning {
                recommendations.push(DetailedRecommendation {
                    resource: format!("Disk ({})", disk.mount_point),
                    severity: Severity::Warning,
                    current_value: disk.usage_percent,
                    threshold: self.thresholds.disk_warning,
                    issue: format!("磁盘 {} 使用率 {:.1}% 偏高", 
                        disk.mount_point, disk.usage_percent),
                    suggestions: vec![
                        "计划磁盘清理".to_string(),
                        "审查数据保留策略".to_string(),
                        "考虑数据压缩".to_string(),
                    ],
                    estimated_impact: "中".to_string(),
                    action_priority: ActionPriority::High,
                });
            }
        }

        recommendations
    }

    fn analyze_network(&self) -> Vec<DetailedRecommendation> {
        let mut recommendations = Vec::new();

        // 网络流量分析（需要历史数据对比）
        // 这里简化处理
        let total_traffic = self.current_metrics.network.total_received_bytes 
            + self.current_metrics.network.total_transmitted_bytes;

        if total_traffic > 1_000_000_000_000 { // 1TB
            recommendations.push(DetailedRecommendation {
                resource: "Network".to_string(),
                severity: Severity::Info,
                current_value: total_traffic as f64,
                threshold: 1_000_000_000_000.0,
                issue: "网络流量较大".to_string(),
                suggestions: vec![
                    "检查是否有异常流量".to_string(),
                    "考虑启用数据压缩".to_string(),
                    "优化网络传输".to_string(),
                ],
                estimated_impact: "低".to_string(),
                action_priority: ActionPriority::Low,
            });
        }

        recommendations
    }

    fn generate_predictive_recommendations(&self) -> Vec<DetailedRecommendation> {
        let mut recommendations = Vec::new();

        // 基于趋势预测的建议
        for prediction in &self.trend_report.predictions {
            if prediction.confidence > 0.7 && prediction.predicted_value > 85.0 {
                recommendations.push(DetailedRecommendation {
                    resource: format!("{} (预测)", prediction.resource),
                    severity: Severity::Info,
                    current_value: prediction.current_value,
                    threshold: 85.0,
                    issue: format!(
                        "{} 预计在 {} 分钟后达到 {:.1}%",
                        prediction.resource,
                        prediction.time_ahead_seconds / 60,
                        prediction.predicted_value
                    ),
                    suggestions: vec![
                        "提前准备扩容".to_string(),
                        "优化资源使用".to_string(),
                        "监控趋势变化".to_string(),
                    ],
                    estimated_impact: "预防性".to_string(),
                    action_priority: ActionPriority::Medium,
                });
            }
        }

        recommendations
    }
}

#[derive(Debug)]
pub struct DetailedRecommendation {
    pub resource: String,
    pub severity: Severity,
    pub current_value: f64,
    pub threshold: f64,
    pub issue: String,
    pub suggestions: Vec<String>,
    pub estimated_impact: String,
    pub action_priority: ActionPriority,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum Severity {
    Info = 0,
    Low = 1,
    Warning = 2,
    High = 3,
    Critical = 4,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum ActionPriority {
    Low = 0,
    Medium = 1,
    High = 2,
    Immediate = 3,
}
```

## 实战案例

### 案例1：内存泄漏检测

**场景**：生产环境内存使用率持续增长

**监控数据**：

```text
时间      内存使用率    趋势
10:00    45%          -
11:00    52%          ↑ +7%
12:00    59%          ↑ +7%
13:00    67%          ↑ +8%
14:00    75%          ↑ +8%
```

**趋势分析结果**：

```rust
ResourceTrend {
    resource: "Memory",
    direction: TrendDirection::Increasing,
    slope: 7.5,  // 每小时增长 7.5%
    confidence: 0.95,  // 95% 置信度
    mean: 59.6,
    std_dev: 10.2,
}
```

**预测**：

```rust
ResourcePrediction {
    resource: "Memory",
    current_value: 75.0,
    predicted_value: 90.0,  // 2小时后
    time_ahead_seconds: 7200,
    confidence: 0.95,
}
```

**优化建议**：

```text
🔴 严重性：Critical
📊 当前值：75%
⚠️  问题：内存使用率持续增长，预计2小时后达到90%
💡 建议：
  1. 立即检查内存泄漏（使用 heaptrack 或 valgrind）
  2. 分析进程内存占用（ps aux --sort=-%mem）
  3. 检查是否有未释放的资源
  4. 考虑重启服务释放内存
  5. 准备扩容计划
```

**实际处理**：

1. 使用 `heaptrack` 发现 Span 缓存未正确清理
2. 修复代码，添加定期清理逻辑
3. 重启服务，内存使用率降至 40%
4. 持续监控，确认问题解决

### 案例2：CPU 突增分析

**场景**：CPU 使用率突然从 30% 跳升到 85%

**监控数据**：

```text
14:55    30%    正常
14:56    32%    正常
14:57    85%    ⚠️ 突增
14:58    87%    持续高位
14:59    86%    持续高位
```

**变化点检测结果**：

```rust
ChangePoint {
    index: 157,  // 14:57
    direction: ChangeDirection::Increase,
    magnitude: 4.2,  // 显著变化
}
```

**优化建议**：

```text
🔴 严重性：Critical
📊 当前值：85%
⚠️  问题：CPU 使用率突增，从 30% 跳至 85%
💡 建议：
  1. 检查最近的代码部署或配置变更
  2. 查看进程 CPU 占用（top -c）
  3. 检查是否有死循环或无限递归
  4. 查看系统日志
  5. 考虑回滚最近的变更
```

**根因分析**：

- 14:57 部署了新版本
- 新版本引入了低效的循环逻辑
- 每个请求触发 O(n²) 复杂度的操作

**解决方案**：

1. 立即回滚到上一个版本
2. CPU 使用率恢复到 32%
3. 修复代码，优化为 O(n) 复杂度
4. 重新部署并验证

---

**相关文档**：

- [容量预测模型](./容量预测模型.md)
- [扩容决策](./扩容决策.md)
- [性能回归检测](../性能调优/性能回归检测.md)
