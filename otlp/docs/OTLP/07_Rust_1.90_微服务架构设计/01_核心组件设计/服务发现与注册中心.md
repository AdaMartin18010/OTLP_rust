# æœåŠ¡å‘ç°ä¸æ³¨å†Œä¸­å¿ƒ - Rust 1.90 å¾®æœåŠ¡æ¶æ„è®¾è®¡

## ç›®å½•

- [æœåŠ¡å‘ç°ä¸æ³¨å†Œä¸­å¿ƒ - Rust 1.90 å¾®æœåŠ¡æ¶æ„è®¾è®¡](#æœåŠ¡å‘ç°ä¸æ³¨å†Œä¸­å¿ƒ---rust-190-å¾®æœåŠ¡æ¶æ„è®¾è®¡)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ—ï¸ æ¶æ„è®¾è®¡](#ï¸-æ¶æ„è®¾è®¡)
    - [1. æ•´ä½“æ¶æ„å›¾](#1-æ•´ä½“æ¶æ„å›¾)
    - [2. æ ¸å¿ƒç»„ä»¶](#2-æ ¸å¿ƒç»„ä»¶)
      - [2.1 æœåŠ¡æ³¨å†Œå™¨ (Service Registrar)](#21-æœåŠ¡æ³¨å†Œå™¨-service-registrar)
      - [2.2 æœåŠ¡å‘ç°å™¨ (Service Discovery)](#22-æœåŠ¡å‘ç°å™¨-service-discovery)
      - [2.3 å¥åº·æ£€æŸ¥å™¨ (Health Checker)](#23-å¥åº·æ£€æŸ¥å™¨-health-checker)
      - [2.4 è´Ÿè½½å‡è¡¡å™¨ (Load Balancer)](#24-è´Ÿè½½å‡è¡¡å™¨-load-balancer)
  - [ğŸ”§ é…ç½®ç®¡ç†](#-é…ç½®ç®¡ç†)
    - [1. é…ç½®ç»“æ„](#1-é…ç½®ç»“æ„)
    - [2. é…ç½®åŠ è½½å™¨](#2-é…ç½®åŠ è½½å™¨)
  - [ğŸš€ ä½¿ç”¨ç¤ºä¾‹](#-ä½¿ç”¨ç¤ºä¾‹)
    - [1. åŸºæœ¬ä½¿ç”¨](#1-åŸºæœ¬ä½¿ç”¨)
    - [2. é«˜çº§é…ç½®](#2-é«˜çº§é…ç½®)
  - [ğŸ“Š æ€§èƒ½ä¼˜åŒ–](#-æ€§èƒ½ä¼˜åŒ–)
    - [1. ç¼“å­˜ä¼˜åŒ–](#1-ç¼“å­˜ä¼˜åŒ–)
    - [2. å¹¶å‘ä¼˜åŒ–](#2-å¹¶å‘ä¼˜åŒ–)
  - [ğŸ”’ å®‰å…¨è€ƒè™‘](#-å®‰å…¨è€ƒè™‘)
    - [1. è®¤è¯ä¸æˆæƒ](#1-è®¤è¯ä¸æˆæƒ)
  - [ğŸ“ˆ ç›‘æ§ä¸æŒ‡æ ‡](#-ç›‘æ§ä¸æŒ‡æ ‡)
    - [1. æŒ‡æ ‡æ”¶é›†](#1-æŒ‡æ ‡æ”¶é›†)
  - [ğŸ¯ æ€»ç»“](#-æ€»ç»“)

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†é˜è¿°äº†åŸºäº Rust 1.90 è¯­è¨€ç‰¹æ€§çš„æœåŠ¡å‘ç°ä¸æ³¨å†Œä¸­å¿ƒè®¾è®¡ï¼Œå±•ç¤ºäº†å¦‚ä½•æ„å»ºé«˜æ€§èƒ½ã€é«˜å¯ç”¨çš„å¾®æœåŠ¡å‘ç°æœºåˆ¶ã€‚

## ğŸ—ï¸ æ¶æ„è®¾è®¡

### 1. æ•´ä½“æ¶æ„å›¾

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æœåŠ¡å‘ç°ä¸æ³¨å†Œä¸­å¿ƒæ¶æ„                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   æœåŠ¡æ³¨å†Œå±‚     â”‚   æœåŠ¡å‘ç°å±‚     â”‚   å¥åº·æ£€æŸ¥å±‚     â”‚   é…ç½®ç®¡ç†å±‚ â”‚
â”‚  (Registration) â”‚  (Discovery)    â”‚ (Health Check)  â”‚ (Config)    â”‚
â”‚                 â”‚                 â”‚                 â”‚             â”‚
â”‚ â€¢ æœåŠ¡æ³¨å†Œ       â”‚ â€¢ æœåŠ¡æŸ¥è¯¢      â”‚ â€¢ å¥åº·ç›‘æ§       â”‚ â€¢ é…ç½®å­˜å‚¨   â”‚
â”‚ â€¢ æœåŠ¡æ³¨é”€       â”‚ â€¢ è´Ÿè½½å‡è¡¡      â”‚ â€¢ æ•…éšœæ£€æµ‹       â”‚ â€¢ åŠ¨æ€æ›´æ–°   â”‚
â”‚ â€¢ å…ƒæ•°æ®ç®¡ç†     â”‚ â€¢ æœåŠ¡è·¯ç”±       â”‚ â€¢ è‡ªåŠ¨æ¢å¤       â”‚ â€¢ ç‰ˆæœ¬æ§åˆ¶   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   å­˜å‚¨åç«¯å±‚     â”‚
                    â”‚(Storage Backend)â”‚
                    â”‚                 â”‚
                    â”‚ â€¢ Consul        â”‚
                    â”‚ â€¢ etcd          â”‚
                    â”‚ â€¢ Kubernetes    â”‚
                    â”‚ â€¢ Redis         â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. æ ¸å¿ƒç»„ä»¶

#### 2.1 æœåŠ¡æ³¨å†Œå™¨ (Service Registrar)

```rust
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use serde::{Deserialize, Serialize};

/// æœåŠ¡å®ä¾‹ä¿¡æ¯
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServiceInstance {
    pub id: String,
    pub name: String,
    pub address: String,
    pub port: u16,
    pub tags: Vec<String>,
    pub metadata: HashMap<String, String>,
    pub health_status: HealthStatus,
    pub last_heartbeat: chrono::DateTime<chrono::Utc>,
}

/// å¥åº·çŠ¶æ€
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum HealthStatus {
    Healthy,
    Unhealthy,
    Unknown,
}

/// æœåŠ¡æ³¨å†Œå™¨ - åˆ©ç”¨ Rust 1.90 ç‰¹æ€§
pub struct ServiceRegistrar {
    registry: Arc<RwLock<HashMap<String, Vec<ServiceInstance>>>>,
    health_checker: Arc<HealthChecker>,
    event_bus: Arc<EventBus>,
}

impl ServiceRegistrar {
    /// åˆ›å»ºæ–°çš„æœåŠ¡æ³¨å†Œå™¨
    pub fn new(health_checker: Arc<HealthChecker>, event_bus: Arc<EventBus>) -> Self {
        Self {
            registry: Arc::new(RwLock::new(HashMap::new())),
            health_checker,
            event_bus,
        }
    }
    
    /// æ³¨å†ŒæœåŠ¡å®ä¾‹ - åˆ©ç”¨æ”¹è¿›çš„å¼‚æ­¥ç‰¹æ€§
    pub async fn register(&self, instance: ServiceInstance) -> Result<(), RegistryError> {
        let service_name = instance.name.clone();
        
        // å†™å…¥æ³¨å†Œè¡¨
        {
            let mut registry = self.registry.write().await;
            let instances = registry.entry(service_name.clone()).or_insert_with(Vec::new);
            
            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒIDçš„å®ä¾‹
            if let Some(existing_index) = instances.iter().position(|i| i.id == instance.id) {
                instances[existing_index] = instance.clone();
            } else {
                instances.push(instance.clone());
            }
        }
        
        // å¯åŠ¨å¥åº·æ£€æŸ¥
        self.health_checker.start_monitoring(instance.clone()).await?;
        
        // å‘å¸ƒæ³¨å†Œäº‹ä»¶
        self.event_bus.publish(RegistryEvent::ServiceRegistered {
            service_name,
            instance: instance.clone(),
        }).await?;
        
        tracing::info!("æœåŠ¡å®ä¾‹å·²æ³¨å†Œ: {}:{}", instance.name, instance.id);
        Ok(())
    }
    
    /// æ³¨é”€æœåŠ¡å®ä¾‹
    pub async fn deregister(&self, service_name: &str, instance_id: &str) -> Result<(), RegistryError> {
        let removed_instance = {
            let mut registry = self.registry.write().await;
            if let Some(instances) = registry.get_mut(service_name) {
                if let Some(index) = instances.iter().position(|i| i.id == instance_id) {
                    let removed = instances.remove(index);
                    if instances.is_empty() {
                        registry.remove(service_name);
                    }
                    Some(removed)
                } else {
                    None
                }
            } else {
                None
            }
        };
        
        if let Some(instance) = removed_instance {
            // åœæ­¢å¥åº·æ£€æŸ¥
            self.health_checker.stop_monitoring(&instance.id).await?;
            
            // å‘å¸ƒæ³¨é”€äº‹ä»¶
            self.event_bus.publish(RegistryEvent::ServiceDeregistered {
                service_name: service_name.to_string(),
                instance_id: instance_id.to_string(),
            }).await?;
            
            tracing::info!("æœåŠ¡å®ä¾‹å·²æ³¨é”€: {}:{}", service_name, instance_id);
        }
        
        Ok(())
    }
    
    /// è·å–æœåŠ¡å®ä¾‹åˆ—è¡¨
    pub async fn get_instances(&self, service_name: &str) -> Result<Vec<ServiceInstance>, RegistryError> {
        let registry = self.registry.read().await;
        let instances = registry.get(service_name)
            .cloned()
            .unwrap_or_default();
        
        Ok(instances)
    }
    
    /// è·å–å¥åº·çš„æœåŠ¡å®ä¾‹
    pub async fn get_healthy_instances(&self, service_name: &str) -> Result<Vec<ServiceInstance>, RegistryError> {
        let instances = self.get_instances(service_name).await?;
        let healthy_instances = instances.into_iter()
            .filter(|instance| instance.health_status == HealthStatus::Healthy)
            .collect();
        
        Ok(healthy_instances)
    }
}
```

#### 2.2 æœåŠ¡å‘ç°å™¨ (Service Discovery)

```rust
/// æœåŠ¡å‘ç°å™¨ - åˆ©ç”¨ Rust 1.90 çš„å¼‚æ­¥ç‰¹æ€§
pub struct ServiceDiscovery {
    registrar: Arc<ServiceRegistrar>,
    load_balancer: Arc<LoadBalancer>,
    cache: Arc<RwLock<HashMap<String, CachedServiceInfo>>>,
    cache_ttl: Duration,
}

/// ç¼“å­˜çš„æœåŠ¡ä¿¡æ¯
#[derive(Debug, Clone)]
struct CachedServiceInfo {
    instances: Vec<ServiceInstance>,
    last_updated: chrono::DateTime<chrono::Utc>,
}

impl ServiceDiscovery {
    /// åˆ›å»ºæ–°çš„æœåŠ¡å‘ç°å™¨
    pub fn new(
        registrar: Arc<ServiceRegistrar>,
        load_balancer: Arc<LoadBalancer>,
        cache_ttl: Duration,
    ) -> Self {
        Self {
            registrar,
            load_balancer,
            cache: Arc::new(RwLock::new(HashMap::new())),
            cache_ttl,
        }
    }
    
    /// å‘ç°æœåŠ¡å®ä¾‹ - åˆ©ç”¨æ”¹è¿›çš„å¼‚æ­¥ç‰¹æ€§
    pub async fn discover(&self, service_name: &str) -> Result<Vec<ServiceInstance>, DiscoveryError> {
        // æ£€æŸ¥ç¼“å­˜
        if let Some(cached) = self.get_cached_instances(service_name).await? {
            return Ok(cached.instances);
        }
        
        // ä»æ³¨å†Œè¡¨è·å–å®ä¾‹
        let instances = self.registrar.get_healthy_instances(service_name).await?;
        
        // æ›´æ–°ç¼“å­˜
        self.update_cache(service_name, instances.clone()).await?;
        
        Ok(instances)
    }
    
    /// é€‰æ‹©æœåŠ¡å®ä¾‹ï¼ˆè´Ÿè½½å‡è¡¡ï¼‰
    pub async fn select_instance(
        &self,
        service_name: &str,
        strategy: LoadBalanceStrategy,
    ) -> Result<ServiceInstance, DiscoveryError> {
        let instances = self.discover(service_name).await?;
        
        if instances.is_empty() {
            return Err(DiscoveryError::NoHealthyInstances);
        }
        
        // ä½¿ç”¨è´Ÿè½½å‡è¡¡å™¨é€‰æ‹©å®ä¾‹
        let selected = self.load_balancer.select_instance(instances, strategy).await?;
        Ok(selected)
    }
    
    /// è·å–ç¼“å­˜çš„æœåŠ¡å®ä¾‹
    async fn get_cached_instances(&self, service_name: &str) -> Result<Option<CachedServiceInfo>, DiscoveryError> {
        let cache = self.cache.read().await;
        if let Some(cached) = cache.get(service_name) {
            let now = chrono::Utc::now();
            if now.signed_duration_since(cached.last_updated) < self.cache_ttl {
                return Ok(Some(cached.clone()));
            }
        }
        Ok(None)
    }
    
    /// æ›´æ–°ç¼“å­˜
    async fn update_cache(&self, service_name: &str, instances: Vec<ServiceInstance>) -> Result<(), DiscoveryError> {
        let mut cache = self.cache.write().await;
        cache.insert(service_name.to_string(), CachedServiceInfo {
            instances,
            last_updated: chrono::Utc::now(),
        });
        Ok(())
    }
}
```

#### 2.3 å¥åº·æ£€æŸ¥å™¨ (Health Checker)

```rust
use tokio::time::{interval, Duration};
use std::collections::HashMap;

/// å¥åº·æ£€æŸ¥å™¨ - åˆ©ç”¨ Rust 1.90 çš„å¹¶å‘ç‰¹æ€§
pub struct HealthChecker {
    checks: Arc<RwLock<HashMap<String, HealthCheck>>>,
    interval: Duration,
    timeout: Duration,
    http_client: reqwest::Client,
}

/// å¥åº·æ£€æŸ¥é…ç½®
#[derive(Debug, Clone)]
struct HealthCheck {
    instance: ServiceInstance,
    check_type: HealthCheckType,
    endpoint: String,
    interval: Duration,
}

/// å¥åº·æ£€æŸ¥ç±»å‹
#[derive(Debug, Clone)]
enum HealthCheckType {
    Http,
    Tcp,
    Custom,
}

impl HealthChecker {
    /// åˆ›å»ºæ–°çš„å¥åº·æ£€æŸ¥å™¨
    pub fn new(interval: Duration, timeout: Duration) -> Self {
        Self {
            checks: Arc::new(RwLock::new(HashMap::new())),
            interval,
            timeout,
            http_client: reqwest::Client::builder()
                .timeout(timeout)
                .build()
                .expect("Failed to create HTTP client"),
        }
    }
    
    /// å¼€å§‹ç›‘æ§æœåŠ¡å®ä¾‹
    pub async fn start_monitoring(&self, instance: ServiceInstance) -> Result<(), HealthCheckError> {
        let health_check = HealthCheck {
            instance: instance.clone(),
            check_type: HealthCheckType::Http,
            endpoint: format!("http://{}:{}/health", instance.address, instance.port),
            interval: self.interval,
        };
        
        // æ·»åŠ åˆ°æ£€æŸ¥åˆ—è¡¨
        {
            let mut checks = self.checks.write().await;
            checks.insert(instance.id.clone(), health_check.clone());
        }
        
        // å¯åŠ¨å¼‚æ­¥å¥åº·æ£€æŸ¥ä»»åŠ¡
        self.spawn_health_check_task(health_check).await;
        
        Ok(())
    }
    
    /// åœæ­¢ç›‘æ§æœåŠ¡å®ä¾‹
    pub async fn stop_monitoring(&self, instance_id: &str) -> Result<(), HealthCheckError> {
        let mut checks = self.checks.write().await;
        checks.remove(instance_id);
        Ok(())
    }
    
    /// ç”Ÿæˆå¥åº·æ£€æŸ¥ä»»åŠ¡
    async fn spawn_health_check_task(&self, health_check: HealthCheck) {
        let checks = Arc::clone(&self.checks);
        let http_client = self.http_client.clone();
        let instance_id = health_check.instance.id.clone();
        
        tokio::spawn(async move {
            let mut interval = tokio::time::interval(health_check.interval);
            
            loop {
                interval.tick().await;
                
                // æ£€æŸ¥æ˜¯å¦è¿˜åœ¨ç›‘æ§åˆ—è¡¨ä¸­
                {
                    let checks_guard = checks.read().await;
                    if !checks_guard.contains_key(&instance_id) {
                        break; // åœæ­¢ç›‘æ§
                    }
                }
                
                // æ‰§è¡Œå¥åº·æ£€æŸ¥
                match Self::perform_health_check(&http_client, &health_check).await {
                    Ok(is_healthy) => {
                        // æ›´æ–°å¥åº·çŠ¶æ€
                        Self::update_health_status(&checks, &instance_id, is_healthy).await;
                    }
                    Err(e) => {
                        tracing::warn!("å¥åº·æ£€æŸ¥å¤±è´¥ {}: {}", instance_id, e);
                        Self::update_health_status(&checks, &instance_id, false).await;
                    }
                }
            }
        });
    }
    
    /// æ‰§è¡Œå¥åº·æ£€æŸ¥
    async fn perform_health_check(
        client: &reqwest::Client,
        health_check: &HealthCheck,
    ) -> Result<bool, HealthCheckError> {
        match health_check.check_type {
            HealthCheckType::Http => {
                let response = client
                    .get(&health_check.endpoint)
                    .send()
                    .await?;
                
                Ok(response.status().is_success())
            }
            HealthCheckType::Tcp => {
                // TCP è¿æ¥æ£€æŸ¥å®ç°
                Self::check_tcp_connection(&health_check.endpoint).await
            }
            HealthCheckType::Custom => {
                // è‡ªå®šä¹‰å¥åº·æ£€æŸ¥å®ç°
                Self::perform_custom_check(health_check).await
            }
        }
    }
    
    /// æ›´æ–°å¥åº·çŠ¶æ€
    async fn update_health_status(
        checks: &Arc<RwLock<HashMap<String, HealthCheck>>>,
        instance_id: &str,
        is_healthy: bool,
    ) {
        let mut checks_guard = checks.write().await;
        if let Some(health_check) = checks_guard.get_mut(instance_id) {
            health_check.instance.health_status = if is_healthy {
                HealthStatus::Healthy
            } else {
                HealthStatus::Unhealthy
            };
            health_check.instance.last_heartbeat = chrono::Utc::now();
        }
    }
}
```

#### 2.4 è´Ÿè½½å‡è¡¡å™¨ (Load Balancer)

```rust
use rand::Rng;

/// è´Ÿè½½å‡è¡¡ç­–ç•¥
#[derive(Debug, Clone)]
pub enum LoadBalanceStrategy {
    RoundRobin,
    WeightedRoundRobin,
    LeastConnections,
    Random,
    ConsistentHash,
}

/// è´Ÿè½½å‡è¡¡å™¨ - åˆ©ç”¨ Rust 1.90 ç‰¹æ€§
pub struct LoadBalancer {
    round_robin_counters: Arc<RwLock<HashMap<String, usize>>>,
    connection_counts: Arc<RwLock<HashMap<String, usize>>>,
    hash_ring: Arc<RwLock<ConsistentHashRing>>,
}

/// ä¸€è‡´æ€§å“ˆå¸Œç¯
#[derive(Debug)]
struct ConsistentHashRing {
    nodes: Vec<HashNode>,
}

#[derive(Debug)]
struct HashNode {
    hash: u32,
    instance: ServiceInstance,
}

impl LoadBalancer {
    /// åˆ›å»ºæ–°çš„è´Ÿè½½å‡è¡¡å™¨
    pub fn new() -> Self {
        Self {
            round_robin_counters: Arc::new(RwLock::new(HashMap::new())),
            connection_counts: Arc::new(RwLock::new(HashMap::new())),
            hash_ring: Arc::new(RwLock::new(ConsistentHashRing::new())),
        }
    }
    
    /// é€‰æ‹©æœåŠ¡å®ä¾‹
    pub async fn select_instance(
        &self,
        instances: Vec<ServiceInstance>,
        strategy: LoadBalanceStrategy,
    ) -> Result<ServiceInstance, LoadBalanceError> {
        if instances.is_empty() {
            return Err(LoadBalanceError::NoInstances);
        }
        
        match strategy {
            LoadBalanceStrategy::RoundRobin => {
                self.select_round_robin(instances).await
            }
            LoadBalanceStrategy::WeightedRoundRobin => {
                self.select_weighted_round_robin(instances).await
            }
            LoadBalanceStrategy::LeastConnections => {
                self.select_least_connections(instances).await
            }
            LoadBalanceStrategy::Random => {
                self.select_random(instances).await
            }
            LoadBalanceStrategy::ConsistentHash => {
                self.select_consistent_hash(instances).await
            }
        }
    }
    
    /// è½®è¯¢é€‰æ‹©
    async fn select_round_robin(&self, instances: Vec<ServiceInstance>) -> Result<ServiceInstance, LoadBalanceError> {
        let service_name = instances[0].name.clone();
        let mut counters = self.round_robin_counters.write().await;
        
        let counter = counters.entry(service_name).or_insert(0);
        let index = *counter % instances.len();
        *counter += 1;
        
        Ok(instances[index].clone())
    }
    
    /// åŠ æƒè½®è¯¢é€‰æ‹©
    async fn select_weighted_round_robin(&self, instances: Vec<ServiceInstance>) -> Result<ServiceInstance, LoadBalanceError> {
        // å®ç°åŠ æƒè½®è¯¢é€»è¾‘
        let total_weight: usize = instances.iter()
            .map(|i| i.metadata.get("weight").unwrap_or(&"1".to_string()).parse::<usize>().unwrap_or(1))
            .sum();
        
        let mut counters = self.round_robin_counters.write().await;
        let service_name = instances[0].name.clone();
        let counter = counters.entry(service_name).or_insert(0);
        
        let mut current_weight = 0;
        for instance in &instances {
            let weight = instance.metadata.get("weight").unwrap_or(&"1".to_string()).parse::<usize>().unwrap_or(1);
            current_weight += weight;
            
            if *counter < current_weight {
                *counter += 1;
                return Ok(instance.clone());
            }
        }
        
        // é‡ç½®è®¡æ•°å™¨
        *counter = 0;
        Ok(instances[0].clone())
    }
    
    /// æœ€å°‘è¿æ¥é€‰æ‹©
    async fn select_least_connections(&self, instances: Vec<ServiceInstance>) -> Result<ServiceInstance, LoadBalanceError> {
        let mut connection_counts = self.connection_counts.read().await;
        
        let selected = instances.iter()
            .min_by_key(|instance| connection_counts.get(&instance.id).unwrap_or(&0))
            .ok_or(LoadBalanceError::NoInstances)?;
        
        // å¢åŠ è¿æ¥è®¡æ•°
        let count = connection_counts.entry(selected.id.clone()).or_insert(0);
        *count += 1;
        
        Ok(selected.clone())
    }
    
    /// éšæœºé€‰æ‹©
    async fn select_random(&self, instances: Vec<ServiceInstance>) -> Result<ServiceInstance, LoadBalanceError> {
        let mut rng = rand::thread_rng();
        let index = rng.gen_range(0..instances.len());
        Ok(instances[index].clone())
    }
    
    /// ä¸€è‡´æ€§å“ˆå¸Œé€‰æ‹©
    async fn select_consistent_hash(&self, instances: Vec<ServiceInstance>) -> Result<ServiceInstance, LoadBalanceError> {
        let mut hash_ring = self.hash_ring.write().await;
        hash_ring.update_nodes(instances.clone());
        
        // ä½¿ç”¨è¯·æ±‚çš„æŸç§æ ‡è¯†ç¬¦ï¼ˆå¦‚ç”¨æˆ·IDï¼‰è¿›è¡Œå“ˆå¸Œ
        let request_key = "default_key"; // å®é™…åº”ç”¨ä¸­åº”è¯¥ä½¿ç”¨çœŸå®çš„è¯·æ±‚æ ‡è¯†
        let selected = hash_ring.get_node(request_key)?;
        
        Ok(selected.clone())
    }
}
```

## ğŸ”§ é…ç½®ç®¡ç†

### 1. é…ç½®ç»“æ„

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// æœåŠ¡å‘ç°é…ç½®
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServiceDiscoveryConfig {
    pub registry: RegistryConfig,
    pub discovery: DiscoveryConfig,
    pub health_check: HealthCheckConfig,
    pub load_balancer: LoadBalancerConfig,
}

/// æ³¨å†Œä¸­å¿ƒé…ç½®
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RegistryConfig {
    pub backend: RegistryBackend,
    pub consul: Option<ConsulConfig>,
    pub etcd: Option<EtcdConfig>,
    pub kubernetes: Option<KubernetesConfig>,
}

/// æ³¨å†Œä¸­å¿ƒåç«¯ç±»å‹
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RegistryBackend {
    Consul,
    Etcd,
    Kubernetes,
    InMemory,
}

/// Consul é…ç½®
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConsulConfig {
    pub address: String,
    pub datacenter: Option<String>,
    pub token: Option<String>,
    pub tls: Option<TlsConfig>,
}

/// æœåŠ¡å‘ç°é…ç½®
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DiscoveryConfig {
    pub cache_ttl: Duration,
    pub refresh_interval: Duration,
    pub max_retries: u32,
    pub retry_delay: Duration,
}

/// å¥åº·æ£€æŸ¥é…ç½®
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HealthCheckConfig {
    pub interval: Duration,
    pub timeout: Duration,
    pub max_failures: u32,
    pub recovery_threshold: u32,
}

/// è´Ÿè½½å‡è¡¡é…ç½®
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LoadBalancerConfig {
    pub default_strategy: LoadBalanceStrategy,
    pub strategies: HashMap<String, LoadBalanceStrategy>,
}
```

### 2. é…ç½®åŠ è½½å™¨

```rust
/// é…ç½®åŠ è½½å™¨ - åˆ©ç”¨ Rust 1.90 ç‰¹æ€§
pub struct ConfigLoader {
    config_path: String,
    config: Option<ServiceDiscoveryConfig>,
}

impl ConfigLoader {
    /// åˆ›å»ºæ–°çš„é…ç½®åŠ è½½å™¨
    pub fn new(config_path: String) -> Self {
        Self {
            config_path,
            config: None,
        }
    }
    
    /// åŠ è½½é…ç½®
    pub async fn load(&mut self) -> Result<ServiceDiscoveryConfig, ConfigError> {
        let content = tokio::fs::read_to_string(&self.config_path).await?;
        let config: ServiceDiscoveryConfig = toml::from_str(&content)?;
        self.config = Some(config.clone());
        Ok(config)
    }
    
    /// çƒ­é‡è½½é…ç½®
    pub async fn reload(&mut self) -> Result<ServiceDiscoveryConfig, ConfigError> {
        self.load().await
    }
    
    /// è·å–å½“å‰é…ç½®
    pub fn get_config(&self) -> Option<&ServiceDiscoveryConfig> {
        self.config.as_ref()
    }
}
```

## ğŸš€ ä½¿ç”¨ç¤ºä¾‹

### 1. åŸºæœ¬ä½¿ç”¨

```rust
use std::time::Duration;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // åˆå§‹åŒ–æ—¥å¿—
    tracing_subscriber::init();
    
    // åˆ›å»ºå¥åº·æ£€æŸ¥å™¨
    let health_checker = Arc::new(HealthChecker::new(
        Duration::from_secs(30),
        Duration::from_secs(5),
    ));
    
    // åˆ›å»ºäº‹ä»¶æ€»çº¿
    let event_bus = Arc::new(EventBus::new());
    
    // åˆ›å»ºæœåŠ¡æ³¨å†Œå™¨
    let registrar = Arc::new(ServiceRegistrar::new(health_checker, event_bus));
    
    // åˆ›å»ºè´Ÿè½½å‡è¡¡å™¨
    let load_balancer = Arc::new(LoadBalancer::new());
    
    // åˆ›å»ºæœåŠ¡å‘ç°å™¨
    let discovery = ServiceDiscovery::new(
        registrar.clone(),
        load_balancer,
        Duration::from_secs(60),
    );
    
    // æ³¨å†ŒæœåŠ¡å®ä¾‹
    let instance = ServiceInstance {
        id: "service-1".to_string(),
        name: "user-service".to_string(),
        address: "127.0.0.1".to_string(),
        port: 8080,
        tags: vec!["v1".to_string(), "production".to_string()],
        metadata: HashMap::new(),
        health_status: HealthStatus::Healthy,
        last_heartbeat: chrono::Utc::now(),
    };
    
    registrar.register(instance).await?;
    
    // å‘ç°æœåŠ¡å®ä¾‹
    let instances = discovery.discover("user-service").await?;
    println!("å‘ç°æœåŠ¡å®ä¾‹: {:?}", instances);
    
    // é€‰æ‹©æœåŠ¡å®ä¾‹
    let selected = discovery.select_instance("user-service", LoadBalanceStrategy::RoundRobin).await?;
    println!("é€‰æ‹©çš„å®ä¾‹: {:?}", selected);
    
    Ok(())
}
```

### 2. é«˜çº§é…ç½®

```rust
/// é«˜çº§æœåŠ¡å‘ç°é…ç½®ç¤ºä¾‹
pub async fn create_advanced_service_discovery() -> Result<ServiceDiscovery, Box<dyn std::error::Error>> {
    // åˆ›å»º Consul é…ç½®
    let consul_config = ConsulConfig {
        address: "http://localhost:8500".to_string(),
        datacenter: Some("dc1".to_string()),
        token: None,
        tls: None,
    };
    
    // åˆ›å»ºæ³¨å†Œä¸­å¿ƒé…ç½®
    let registry_config = RegistryConfig {
        backend: RegistryBackend::Consul,
        consul: Some(consul_config),
        etcd: None,
        kubernetes: None,
    };
    
    // åˆ›å»ºæœåŠ¡å‘ç°é…ç½®
    let discovery_config = ServiceDiscoveryConfig {
        registry: registry_config,
        discovery: DiscoveryConfig {
            cache_ttl: Duration::from_secs(60),
            refresh_interval: Duration::from_secs(30),
            max_retries: 3,
            retry_delay: Duration::from_secs(1),
        },
        health_check: HealthCheckConfig {
            interval: Duration::from_secs(30),
            timeout: Duration::from_secs(5),
            max_failures: 3,
            recovery_threshold: 2,
        },
        load_balancer: LoadBalancerConfig {
            default_strategy: LoadBalanceStrategy::RoundRobin,
            strategies: HashMap::new(),
        },
    };
    
    // æ ¹æ®é…ç½®åˆ›å»ºç›¸åº”çš„ç»„ä»¶
    // ... å®ç°ç»†èŠ‚
    
    Ok(discovery)
}
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–

### 1. ç¼“å­˜ä¼˜åŒ–

```rust
/// é«˜æ€§èƒ½ç¼“å­˜å®ç°
pub struct HighPerformanceCache {
    cache: Arc<RwLock<HashMap<String, CacheEntry>>>,
    max_size: usize,
    ttl: Duration,
}

#[derive(Debug, Clone)]
struct CacheEntry {
    value: Vec<ServiceInstance>,
    created_at: chrono::DateTime<chrono::Utc>,
    access_count: usize,
}

impl HighPerformanceCache {
    /// è·å–ç¼“å­˜é¡¹
    pub async fn get(&self, key: &str) -> Option<Vec<ServiceInstance>> {
        let mut cache = self.cache.write().await;
        
        if let Some(entry) = cache.get_mut(key) {
            let now = chrono::Utc::now();
            if now.signed_duration_since(entry.created_at) < self.ttl {
                entry.access_count += 1;
                return Some(entry.value.clone());
            } else {
                cache.remove(key);
            }
        }
        
        None
    }
    
    /// è®¾ç½®ç¼“å­˜é¡¹
    pub async fn set(&self, key: String, value: Vec<ServiceInstance>) {
        let mut cache = self.cache.write().await;
        
        // æ£€æŸ¥ç¼“å­˜å¤§å°é™åˆ¶
        if cache.len() >= self.max_size {
            self.evict_least_used(&mut cache).await;
        }
        
        let entry = CacheEntry {
            value,
            created_at: chrono::Utc::now(),
            access_count: 1,
        };
        
        cache.insert(key, entry);
    }
    
    /// æ·˜æ±°æœ€å°‘ä½¿ç”¨çš„ç¼“å­˜é¡¹
    async fn evict_least_used(&self, cache: &mut HashMap<String, CacheEntry>) {
        if let Some((key, _)) = cache.iter()
            .min_by_key(|(_, entry)| entry.access_count)
            .map(|(k, v)| (k.clone(), v.clone())) {
            cache.remove(&key);
        }
    }
}
```

### 2. å¹¶å‘ä¼˜åŒ–

```rust
/// å¹¶å‘ä¼˜åŒ–çš„æœåŠ¡å‘ç°å™¨
pub struct ConcurrentServiceDiscovery {
    discovery: Arc<ServiceDiscovery>,
    cache: Arc<HighPerformanceCache>,
    semaphore: Arc<tokio::sync::Semaphore>,
}

impl ConcurrentServiceDiscovery {
    /// å¹¶å‘å‘ç°æœåŠ¡
    pub async fn discover_concurrent(&self, service_names: Vec<String>) -> Result<HashMap<String, Vec<ServiceInstance>>, DiscoveryError> {
        let mut futures = Vec::new();
        
        for service_name in service_names {
            let discovery = Arc::clone(&self.discovery);
            let cache = Arc::clone(&self.cache);
            let permit = self.semaphore.clone().acquire_owned().await?;
            
            let future = tokio::spawn(async move {
                let _permit = permit;
                
                // é¦–å…ˆæ£€æŸ¥ç¼“å­˜
                if let Some(cached) = cache.get(&service_name).await {
                    return Ok((service_name, cached));
                }
                
                // ä»æœåŠ¡å‘ç°å™¨è·å–
                let instances = discovery.discover(&service_name).await?;
                
                // æ›´æ–°ç¼“å­˜
                cache.set(service_name.clone(), instances.clone()).await;
                
                Ok((service_name, instances))
            });
            
            futures.push(future);
        }
        
        // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        let results = futures::future::try_join_all(futures).await?;
        
        let mut result_map = HashMap::new();
        for result in results {
            let (service_name, instances) = result?;
            result_map.insert(service_name, instances);
        }
        
        Ok(result_map)
    }
}
```

## ğŸ”’ å®‰å…¨è€ƒè™‘

### 1. è®¤è¯ä¸æˆæƒ

```rust
/// å®‰å…¨çš„æœåŠ¡æ³¨å†Œå™¨
pub struct SecureServiceRegistrar {
    registrar: ServiceRegistrar,
    auth_manager: Arc<AuthManager>,
}

impl SecureServiceRegistrar {
    /// æ³¨å†ŒæœåŠ¡ï¼ˆéœ€è¦è®¤è¯ï¼‰
    pub async fn register_secure(&self, instance: ServiceInstance, token: &str) -> Result<(), RegistryError> {
        // éªŒè¯è®¤è¯ä»¤ç‰Œ
        if !self.auth_manager.validate_token(token).await? {
            return Err(RegistryError::Unauthorized);
        }
        
        // æ‰§è¡Œæ³¨å†Œ
        self.registrar.register(instance).await
    }
    
    /// æ³¨é”€æœåŠ¡ï¼ˆéœ€è¦è®¤è¯ï¼‰
    pub async fn deregister_secure(&self, service_name: &str, instance_id: &str, token: &str) -> Result<(), RegistryError> {
        // éªŒè¯è®¤è¯ä»¤ç‰Œ
        if !self.auth_manager.validate_token(token).await? {
            return Err(RegistryError::Unauthorized);
        }
        
        // æ‰§è¡Œæ³¨é”€
        self.registrar.deregister(service_name, instance_id).await
    }
}
```

## ğŸ“ˆ ç›‘æ§ä¸æŒ‡æ ‡

### 1. æŒ‡æ ‡æ”¶é›†

```rust
/// æœåŠ¡å‘ç°æŒ‡æ ‡æ”¶é›†å™¨
pub struct ServiceDiscoveryMetrics {
    registry_operations: prometheus::CounterVec,
    discovery_operations: prometheus::CounterVec,
    health_check_failures: prometheus::CounterVec,
    cache_hit_ratio: prometheus::GaugeVec,
}

impl ServiceDiscoveryMetrics {
    /// åˆ›å»ºæ–°çš„æŒ‡æ ‡æ”¶é›†å™¨
    pub fn new() -> Result<Self, prometheus::Error> {
        Ok(Self {
            registry_operations: prometheus::CounterVec::new(
                prometheus::Opts::new("service_discovery_registry_operations_total", "Total registry operations"),
                &["operation", "service_name", "status"]
            )?,
            discovery_operations: prometheus::CounterVec::new(
                prometheus::Opts::new("service_discovery_discovery_operations_total", "Total discovery operations"),
                &["service_name", "status"]
            )?,
            health_check_failures: prometheus::CounterVec::new(
                prometheus::Opts::new("service_discovery_health_check_failures_total", "Total health check failures"),
                &["service_name", "instance_id"]
            )?,
            cache_hit_ratio: prometheus::GaugeVec::new(
                prometheus::Opts::new("service_discovery_cache_hit_ratio", "Cache hit ratio"),
                &["cache_type"]
            )?,
        })
    }
    
    /// è®°å½•æ³¨å†Œæ“ä½œ
    pub fn record_registry_operation(&self, operation: &str, service_name: &str, status: &str) {
        self.registry_operations.with_label_values(&[operation, service_name, status]).inc();
    }
    
    /// è®°å½•å‘ç°æ“ä½œ
    pub fn record_discovery_operation(&self, service_name: &str, status: &str) {
        self.discovery_operations.with_label_values(&[service_name, status]).inc();
    }
    
    /// è®°å½•å¥åº·æ£€æŸ¥å¤±è´¥
    pub fn record_health_check_failure(&self, service_name: &str, instance_id: &str) {
        self.health_check_failures.with_label_values(&[service_name, instance_id]).inc();
    }
    
    /// æ›´æ–°ç¼“å­˜å‘½ä¸­ç‡
    pub fn update_cache_hit_ratio(&self, cache_type: &str, ratio: f64) {
        self.cache_hit_ratio.with_label_values(&[cache_type]).set(ratio);
    }
}
```

## ğŸ¯ æ€»ç»“

åŸºäº Rust 1.90 çš„æœåŠ¡å‘ç°ä¸æ³¨å†Œä¸­å¿ƒè®¾è®¡æä¾›äº†ï¼š

1. **é«˜æ€§èƒ½**: åˆ©ç”¨å¼‚æ­¥ç‰¹æ€§å’Œé›¶æ‹·è´ä¼˜åŒ–
2. **é«˜å¯ç”¨**: å¥åº·æ£€æŸ¥å’Œæ•…éšœè½¬ç§»æœºåˆ¶
3. **å¯æ‰©å±•**: æ”¯æŒå¤šç§è´Ÿè½½å‡è¡¡ç­–ç•¥å’Œå­˜å‚¨åç«¯
4. **ç±»å‹å®‰å…¨**: å……åˆ†åˆ©ç”¨ Rust çš„ç±»å‹ç³»ç»Ÿ
5. **å¯è§‚æµ‹æ€§**: å®Œæ•´çš„ç›‘æ§å’ŒæŒ‡æ ‡æ”¶é›†

è¿™ä¸ªè®¾è®¡ä¸ºå¾®æœåŠ¡æ¶æ„æä¾›äº†å¯é çš„æœåŠ¡å‘ç°åŸºç¡€è®¾æ–½ï¼Œæ”¯æŒç°ä»£äº‘åŸç”Ÿåº”ç”¨çš„éƒ¨ç½²å’Œè¿ç»´éœ€æ±‚ã€‚
