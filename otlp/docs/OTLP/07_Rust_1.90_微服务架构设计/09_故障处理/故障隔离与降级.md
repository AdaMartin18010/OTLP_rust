# 故障隔离与降级

## 目录

- [故障隔离与降级](#故障隔离与降级)
  - [目录](#目录)
  - [📋 概述](#-概述)
  - [🎯 故障隔离模式](#-故障隔离模式)
  - [⚡ 服务降级策略](#-服务降级策略)
  - [🔒 舱壁隔离](#-舱壁隔离)
  - [🎯 最佳实践](#-最佳实践)

## 📋 概述

故障隔离和服务降级是保证微服务系统高可用的关键机制,通过限制故障影响范围和提供降级服务,确保系统整体稳定。

## 🎯 故障隔离模式

```rust
/// 故障隔离器
pub struct FaultIsolator {
    circuit_breaker: Arc<CircuitBreaker>,
    bulkhead: Arc<Semaphore>,
    timeout: Duration,
}

impl FaultIsolator {
    pub async fn execute<F, T>(&self, operation: F) -> Result<T, IsolationError>
    where
        F: Future<Output = Result<T, Box<dyn std::error::Error>>>,
    {
        // 1. 检查断路器
        if !self.circuit_breaker.allow_request() {
            return Err(IsolationError::CircuitBreakerOpen);
        }
        
        // 2. 获取舱壁许可
        let _permit = self.bulkhead.acquire().await
            .map_err(|_| IsolationError::BulkheadFull)?;
        
        // 3. 执行带超时的操作
        match tokio::time::timeout(self.timeout, operation).await {
            Ok(Ok(result)) => {
                self.circuit_breaker.record_success();
                Ok(result)
            }
            Ok(Err(e)) => {
                self.circuit_breaker.record_failure();
                Err(IsolationError::OperationFailed(e.to_string()))
            }
            Err(_) => {
                self.circuit_breaker.record_failure();
                Err(IsolationError::Timeout)
            }
        }
    }
}
```

## ⚡ 服务降级策略

```rust
/// 降级策略
pub enum DegradationStrategy {
    /// 返回缓存数据
    ReturnCached,
    /// 返回默认值
    ReturnDefault,
    /// 返回空结果
    ReturnEmpty,
    /// 调用备用服务
    Fallback(String),
}

/// 降级处理器
pub struct DegradationHandler {
    cache: Arc<Cache>,
    fallback_service: Arc<FallbackService>,
}

impl DegradationHandler {
    pub async fn handle_with_degradation<T>(
        &self,
        operation: impl Future<Output = Result<T, ServiceError>>,
        strategy: DegradationStrategy,
    ) -> Result<T, DegradationError>
    where
        T: Default + Clone + Serialize + DeserializeOwned,
    {
        match operation.await {
            Ok(result) => Ok(result),
            Err(e) => {
                tracing::warn!("Service failed, applying degradation: {:?}", e);
                
                match strategy {
                    DegradationStrategy::ReturnCached => {
                        self.cache.get("last_success")
                            .ok_or(DegradationError::NoCachedData)
                    }
                    DegradationStrategy::ReturnDefault => {
                        Ok(T::default())
                    }
                    DegradationStrategy::ReturnEmpty => {
                        Ok(T::default())
                    }
                    DegradationStrategy::Fallback(service_name) => {
                        self.fallback_service.call(&service_name).await
                    }
                }
            }
        }
    }
}
```

## 🔒 舱壁隔离

```rust
/// 舱壁隔离 - 线程池隔离
pub struct BulkheadIsolation {
    pools: HashMap<String, Arc<Semaphore>>,
}

impl BulkheadIsolation {
    pub fn new() -> Self {
        let mut pools = HashMap::new();
        
        // 为不同服务分配独立的资源池
        pools.insert("user-service".to_string(), Arc::new(Semaphore::new(100)));
        pools.insert("order-service".to_string(), Arc::new(Semaphore::new(50)));
        pools.insert("payment-service".to_string(), Arc::new(Semaphore::new(30)));
        
        Self { pools }
    }
    
    pub async fn execute<F, T>(
        &self,
        service_name: &str,
        operation: F,
    ) -> Result<T, BulkheadError>
    where
        F: Future<Output = T>,
    {
        let pool = self.pools.get(service_name)
            .ok_or(BulkheadError::UnknownService)?;
        
        let _permit = pool.acquire().await
            .map_err(|_| BulkheadError::ResourceExhausted)?;
        
        Ok(operation.await)
    }
}
```

## 🎯 最佳实践

1. **故障隔离**: 使用断路器和舱壁模式隔离故障
2. **优雅降级**: 提供降级服务而不是直接失败
3. **快速失败**: 超时快速失败,避免级联故障
4. **资源隔离**: 为不同服务分配独立资源池
5. **监控告警**: 监控降级率和故障率

---

**总结**: 故障隔离和服务降级是构建高可用微服务系统的基石。
