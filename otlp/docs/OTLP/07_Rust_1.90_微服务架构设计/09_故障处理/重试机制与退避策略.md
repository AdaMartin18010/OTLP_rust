# 重试机制与退避策略

## 目录

- [重试机制与退避策略](#重试机制与退避策略)
  - [目录](#目录)
  - [📋 概述](#-概述)
  - [🎯 重试策略](#-重试策略)
  - [⚡ 退避算法](#-退避算法)
  - [🔄 幂等性保证](#-幂等性保证)
  - [🎯 最佳实践](#-最佳实践)

## 📋 概述

重试机制和退避策略是提高系统可靠性的重要手段,通过合理的重试和退避,可以应对临时性故障,提高请求成功率。

## 🎯 重试策略

```rust
/// 重试策略
pub struct RetryPolicy {
    pub max_attempts: usize,
    pub backoff: BackoffStrategy,
    pub retryable_errors: Vec<ErrorType>,
}

#[derive(Debug, Clone)]
pub enum BackoffStrategy {
    Fixed(Duration),
    Linear { initial: Duration, increment: Duration },
    Exponential { initial: Duration, multiplier: f64, max: Duration },
    ExponentialWithJitter { initial: Duration, multiplier: f64, max: Duration },
}

/// 重试执行器
pub struct RetryExecutor {
    policy: RetryPolicy,
    metrics: Arc<RetryMetrics>,
}

impl RetryExecutor {
    pub async fn execute<F, T>(&self, operation: F) -> Result<T, RetryError>
    where
        F: Fn() -> BoxFuture<'static, Result<T, ServiceError>>,
    {
        let mut attempts = 0;
        let mut last_error = None;
        
        while attempts < self.policy.max_attempts {
            attempts += 1;
            
            match operation().await {
                Ok(result) => {
                    self.metrics.record_success(attempts);
                    return Ok(result);
                }
                Err(e) => {
                    // 检查是否可重试
                    if !self.is_retryable(&e) {
                        self.metrics.record_non_retryable();
                        return Err(RetryError::NonRetryable(e));
                    }
                    
                    last_error = Some(e);
                    
                    // 最后一次尝试不需要等待
                    if attempts < self.policy.max_attempts {
                        let delay = self.calculate_backoff(attempts);
                        tokio::time::sleep(delay).await;
                    }
                }
            }
        }
        
        self.metrics.record_exhausted();
        Err(RetryError::MaxAttemptsExceeded(last_error.unwrap()))
    }
    
    fn is_retryable(&self, error: &ServiceError) -> bool {
        self.policy.retryable_errors.iter()
            .any(|err_type| error.matches(err_type))
    }
    
    fn calculate_backoff(&self, attempt: usize) -> Duration {
        match &self.policy.backoff {
            BackoffStrategy::Fixed(duration) => *duration,
            BackoffStrategy::Linear { initial, increment } => {
                *initial + *increment * (attempt as u32 - 1)
            }
            BackoffStrategy::Exponential { initial, multiplier, max } => {
                let delay = *initial * (*multiplier).powi(attempt as i32 - 1);
                delay.min(*max)
            }
            BackoffStrategy::ExponentialWithJitter { initial, multiplier, max } => {
                let base_delay = *initial * (*multiplier).powi(attempt as i32 - 1);
                let jitter = rand::random::<f64>() * 0.3 + 0.85;  // 0.85 ~ 1.15
                let delay = Duration::from_secs_f64(base_delay.as_secs_f64() * jitter);
                delay.min(*max)
            }
        }
    }
}
```

## ⚡ 退避算法

```rust
/// 指数退避实现
pub struct ExponentialBackoff {
    initial_delay: Duration,
    max_delay: Duration,
    multiplier: f64,
    current_attempt: usize,
}

impl ExponentialBackoff {
    pub fn new(initial_delay: Duration, max_delay: Duration) -> Self {
        Self {
            initial_delay,
            max_delay,
            multiplier: 2.0,
            current_attempt: 0,
        }
    }
    
    pub fn next_delay(&mut self) -> Duration {
        self.current_attempt += 1;
        
        let delay = self.initial_delay.as_secs_f64() 
            * self.multiplier.powi(self.current_attempt as i32 - 1);
        
        Duration::from_secs_f64(delay.min(self.max_delay.as_secs_f64()))
    }
    
    pub fn reset(&mut self) {
        self.current_attempt = 0;
    }
}

/// 带抖动的退避
pub struct JitteredBackoff {
    backoff: ExponentialBackoff,
}

impl JitteredBackoff {
    pub fn next_delay(&mut self) -> Duration {
        let base_delay = self.backoff.next_delay();
        let jitter = rand::random::<f64>();
        
        // 添加 ±30% 的随机抖动
        let jittered = base_delay.as_secs_f64() * (0.7 + jitter * 0.6);
        Duration::from_secs_f64(jittered)
    }
}
```

## 🔄 幂等性保证

```rust
/// 幂等性令牌
pub struct IdempotencyToken {
    token: String,
    created_at: Instant,
    ttl: Duration,
}

impl IdempotencyToken {
    pub fn new(ttl: Duration) -> Self {
        Self {
            token: Uuid::new_v4().to_string(),
            created_at: Instant::now(),
            ttl,
        }
    }
    
    pub fn is_expired(&self) -> bool {
        self.created_at.elapsed() > self.ttl
    }
}

/// 幂等性管理器
pub struct IdempotencyManager {
    tokens: Arc<RwLock<HashMap<String, IdempotencyResult>>>,
}

impl IdempotencyManager {
    pub async fn execute_idempotent<F, T>(
        &self,
        token: &str,
        operation: F,
    ) -> Result<T, IdempotencyError>
    where
        F: Future<Output = Result<T, ServiceError>>,
        T: Clone,
    {
        // 检查是否已执行过
        {
            let tokens = self.tokens.read().await;
            if let Some(result) = tokens.get(token) {
                if !result.is_expired() {
                    return Ok(result.value.clone());
                }
            }
        }
        
        // 执行操作
        let result = operation.await?;
        
        // 存储结果
        {
            let mut tokens = self.tokens.write().await;
            tokens.insert(token.to_string(), IdempotencyResult {
                value: result.clone(),
                created_at: Instant::now(),
                ttl: Duration::from_secs(3600),
            });
        }
        
        Ok(result)
    }
}
```

## 🎯 最佳实践

1. **区分错误类型**: 只对临时性错误重试
2. **指数退避**: 使用指数退避避免雪崩
3. **添加抖动**: 避免重试风暴
4. **幂等性**: 确保重试操作的幂等性
5. **限制重试次数**: 设置合理的最大重试次数

---

**总结**: 合理的重试机制和退避策略可以显著提高系统的可靠性和容错能力。
