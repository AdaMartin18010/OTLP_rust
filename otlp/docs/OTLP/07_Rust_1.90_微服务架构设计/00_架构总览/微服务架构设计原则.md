# 微服务架构设计原则

## 目录

- [微服务架构设计原则](#微服务架构设计原则)
  - [目录](#目录)
  - [📋 概述](#-概述)
  - [🎯 核心设计原则](#-核心设计原则)
    - [1. 单一职责原则 (Single Responsibility Principle)](#1-单一职责原则-single-responsibility-principle)
    - [2. 服务自治原则 (Service Autonomy)](#2-服务自治原则-service-autonomy)
    - [3. 去中心化治理 (Decentralized Governance)](#3-去中心化治理-decentralized-governance)
    - [4. 故障隔离原则 (Failure Isolation)](#4-故障隔离原则-failure-isolation)
    - [5. 可观测性优先 (Observability First)](#5-可观测性优先-observability-first)
  - [🏗️ 架构设计模式](#️-架构设计模式)
    - [1. API 网关模式](#1-api-网关模式)
    - [2. 服务发现模式](#2-服务发现模式)
    - [3. 断路器模式](#3-断路器模式)
    - [4. 事件驱动架构](#4-事件驱动架构)
    - [5. CQRS 模式](#5-cqrs-模式)
  - [📊 数据管理原则](#-数据管理原则)
    - [1. 数据库独立原则](#1-数据库独立原则)
    - [2. 最终一致性](#2-最终一致性)
    - [3. Saga 模式](#3-saga-模式)
  - [🔒 安全设计原则](#-安全设计原则)
    - [1. 零信任架构](#1-零信任架构)
    - [2. 深度防御](#2-深度防御)
    - [3. 最小权限原则](#3-最小权限原则)
  - [⚡ 性能设计原则](#-性能设计原则)
    - [1. 异步优先](#1-异步优先)
    - [2. 缓存策略](#2-缓存策略)
    - [3. 负载均衡](#3-负载均衡)
  - [🎯 实践建议](#-实践建议)

## 📋 概述

微服务架构设计原则是构建可扩展、可维护、高可用分布式系统的基础。本文档基于 Rust 1.90 的特性,结合 OTLP 可观测性平台的实践经验,阐述微服务架构的核心设计原则和最佳实践。

## 🎯 核心设计原则

### 1. 单一职责原则 (Single Responsibility Principle)

每个微服务应该只负责一个业务能力,保持高内聚、低耦合。

```rust
// ❌ 错误示例: 服务职责过多
pub struct UserService {
    user_repository: UserRepository,
    order_repository: OrderRepository,      // 不应该在用户服务中
    payment_processor: PaymentProcessor,    // 不应该在用户服务中
    notification_sender: NotificationSender, // 不应该在用户服务中
}

// ✅ 正确示例: 单一职责
pub struct UserService {
    user_repository: UserRepository,
    event_publisher: EventPublisher, // 通过事件与其他服务通信
}

impl UserService {
    /// 用户服务只负责用户相关的核心业务
    pub async fn create_user(&self, user_data: CreateUserRequest) -> Result<User, UserError> {
        // 1. 创建用户
        let user = self.user_repository.create(user_data).await?;
        
        // 2. 发布用户创建事件,让其他服务响应
        self.event_publisher.publish(UserCreatedEvent {
            user_id: user.id.clone(),
            email: user.email.clone(),
            created_at: user.created_at,
        }).await?;
        
        Ok(user)
    }
}

// 订单服务独立负责订单业务
pub struct OrderService {
    order_repository: OrderRepository,
}

// 支付服务独立负责支付业务
pub struct PaymentService {
    payment_gateway: PaymentGateway,
}
```

**服务边界划分原则**:

```rust
/// 服务边界定义
pub trait ServiceBoundary {
    /// 服务名称
    fn service_name(&self) -> &str;
    
    /// 服务负责的业务领域
    fn business_domain(&self) -> BusinessDomain;
    
    /// 服务对外提供的能力
    fn capabilities(&self) -> Vec<ServiceCapability>;
}

/// 业务领域
#[derive(Debug, Clone)]
pub enum BusinessDomain {
    UserManagement,      // 用户管理
    OrderProcessing,     // 订单处理
    PaymentProcessing,   // 支付处理
    InventoryManagement, // 库存管理
    Notification,        // 通知服务
}

/// 用户服务的边界定义
pub struct UserServiceBoundary;

impl ServiceBoundary for UserServiceBoundary {
    fn service_name(&self) -> &str {
        "user-service"
    }
    
    fn business_domain(&self) -> BusinessDomain {
        BusinessDomain::UserManagement
    }
    
    fn capabilities(&self) -> Vec<ServiceCapability> {
        vec![
            ServiceCapability::CreateUser,
            ServiceCapability::UpdateUser,
            ServiceCapability::GetUser,
            ServiceCapability::DeleteUser,
            ServiceCapability::AuthenticateUser,
        ]
    }
}
```

### 2. 服务自治原则 (Service Autonomy)

每个服务应该能够独立开发、部署、扩展和运行,不依赖其他服务的内部实现。

```rust
/// 自治服务的核心特征
pub struct AutonomousService {
    /// 独立的数据存储
    database: Arc<Database>,
    
    /// 独立的配置管理
    config: Arc<ServiceConfig>,
    
    /// 独立的日志系统
    logger: Arc<Logger>,
    
    /// 独立的监控指标
    metrics: Arc<MetricsCollector>,
    
    /// 独立的健康检查
    health_checker: Arc<HealthChecker>,
}

impl AutonomousService {
    /// 服务启动 - 完全自主
    pub async fn start(&self) -> Result<(), ServiceError> {
        // 1. 初始化数据库连接
        self.database.connect().await?;
        
        // 2. 加载配置
        self.config.load().await?;
        
        // 3. 启动健康检查
        self.health_checker.start().await?;
        
        // 4. 注册到服务注册中心
        self.register_to_discovery().await?;
        
        // 5. 启动 HTTP/gRPC 服务器
        self.start_server().await?;
        
        Ok(())
    }
    
    /// 服务关闭 - 优雅退出
    pub async fn shutdown(&self) -> Result<(), ServiceError> {
        // 1. 从服务注册中心注销
        self.deregister_from_discovery().await?;
        
        // 2. 停止接收新请求
        self.stop_accepting_requests().await?;
        
        // 3. 等待现有请求完成
        self.wait_for_active_requests().await?;
        
        // 4. 关闭数据库连接
        self.database.disconnect().await?;
        
        Ok(())
    }
}
```

**服务版本管理**:

```rust
/// 服务版本化 API
#[derive(Debug, Clone)]
pub struct VersionedApi {
    version: ApiVersion,
    endpoints: Vec<Endpoint>,
}

#[derive(Debug, Clone)]
pub enum ApiVersion {
    V1,
    V2,
    V3,
}

/// 支持多版本并存
pub struct MultiVersionService {
    v1_handler: Arc<V1Handler>,
    v2_handler: Arc<V2Handler>,
    v3_handler: Arc<V3Handler>,
}

impl MultiVersionService {
    /// 根据版本路由请求
    pub async fn handle_request(&self, request: HttpRequest) -> Result<HttpResponse, ApiError> {
        match self.extract_api_version(&request)? {
            ApiVersion::V1 => self.v1_handler.handle(request).await,
            ApiVersion::V2 => self.v2_handler.handle(request).await,
            ApiVersion::V3 => self.v3_handler.handle(request).await,
        }
    }
    
    fn extract_api_version(&self, request: &HttpRequest) -> Result<ApiVersion, ApiError> {
        // 从 URL 路径提取版本: /api/v1/users
        if request.path.starts_with("/api/v1/") {
            Ok(ApiVersion::V1)
        } else if request.path.starts_with("/api/v2/") {
            Ok(ApiVersion::V2)
        } else if request.path.starts_with("/api/v3/") {
            Ok(ApiVersion::V3)
        } else {
            Err(ApiError::InvalidVersion)
        }
    }
}
```

### 3. 去中心化治理 (Decentralized Governance)

避免中心化的数据库和共享库,每个团队可以选择最适合的技术栈。

```rust
/// 服务技术栈选择
pub struct ServiceTechStack {
    language: ProgrammingLanguage,
    database: DatabaseType,
    message_queue: MessageQueueType,
    cache: CacheType,
}

#[derive(Debug, Clone)]
pub enum ProgrammingLanguage {
    Rust,
    Go,
    Java,
    Python,
}

#[derive(Debug, Clone)]
pub enum DatabaseType {
    PostgreSQL,
    MySQL,
    MongoDB,
    Redis,
    Cassandra,
}

/// 用户服务选择 Rust + PostgreSQL
pub fn user_service_stack() -> ServiceTechStack {
    ServiceTechStack {
        language: ProgrammingLanguage::Rust,
        database: DatabaseType::PostgreSQL,
        message_queue: MessageQueueType::Kafka,
        cache: CacheType::Redis,
    }
}

/// 订单服务选择 Rust + MongoDB
pub fn order_service_stack() -> ServiceTechStack {
    ServiceTechStack {
        language: ProgrammingLanguage::Rust,
        database: DatabaseType::MongoDB,
        message_queue: MessageQueueType::Kafka,
        cache: CacheType::Redis,
    }
}
```

**标准化接口契约**:

```rust
/// 服务间通信的标准契约
pub trait ServiceContract {
    /// API 规范 (OpenAPI/gRPC)
    fn api_specification(&self) -> ApiSpec;
    
    /// 事件规范 (CloudEvents)
    fn event_specification(&self) -> EventSpec;
    
    /// 可观测性规范 (OTLP)
    fn observability_specification(&self) -> ObservabilitySpec;
}

/// API 规范
#[derive(Debug, Clone)]
pub struct ApiSpec {
    pub format: ApiFormat,
    pub version: String,
    pub endpoints: Vec<EndpointSpec>,
}

#[derive(Debug, Clone)]
pub enum ApiFormat {
    RestOpenApi,
    Grpc,
    GraphQL,
}

/// 事件规范
#[derive(Debug, Clone)]
pub struct EventSpec {
    pub format: EventFormat,
    pub events: Vec<EventDefinition>,
}

#[derive(Debug, Clone)]
pub enum EventFormat {
    CloudEvents,
    CustomJson,
}
```

### 4. 故障隔离原则 (Failure Isolation)

一个服务的失败不应该导致整个系统崩溃,通过隔离机制限制故障影响范围。

```rust
use std::sync::Arc;
use tokio::sync::Semaphore;

/// 故障隔离器
pub struct FailureIsolator {
    /// 断路器
    circuit_breaker: Arc<CircuitBreaker>,
    
    /// 舱壁隔离 (限制并发)
    bulkhead: Arc<Semaphore>,
    
    /// 超时控制
    timeout: Duration,
    
    /// 重试策略
    retry_policy: RetryPolicy,
}

impl FailureIsolator {
    /// 执行隔离的调用
    pub async fn execute<F, T>(&self, operation: F) -> Result<T, IsolationError>
    where
        F: Future<Output = Result<T, Box<dyn std::error::Error>>>,
    {
        // 1. 检查断路器状态
        if !self.circuit_breaker.allow_request() {
            return Err(IsolationError::CircuitBreakerOpen);
        }
        
        // 2. 获取舱壁许可 (限制并发)
        let _permit = self.bulkhead.acquire().await
            .map_err(|_| IsolationError::BulkheadFull)?;
        
        // 3. 带超时执行操作
        let result = tokio::time::timeout(self.timeout, operation).await;
        
        match result {
            Ok(Ok(value)) => {
                // 成功 - 记录成功
                self.circuit_breaker.record_success();
                Ok(value)
            }
            Ok(Err(e)) => {
                // 失败 - 记录失败
                self.circuit_breaker.record_failure();
                Err(IsolationError::OperationFailed(e.to_string()))
            }
            Err(_) => {
                // 超时 - 记录失败
                self.circuit_breaker.record_failure();
                Err(IsolationError::Timeout)
            }
        }
    }
}

/// 断路器实现
pub struct CircuitBreaker {
    state: Arc<RwLock<CircuitBreakerState>>,
    failure_threshold: usize,
    success_threshold: usize,
    timeout: Duration,
}

#[derive(Debug, Clone)]
enum CircuitBreakerState {
    Closed { failure_count: usize },
    Open { opened_at: Instant },
    HalfOpen { success_count: usize },
}

impl CircuitBreaker {
    pub fn allow_request(&self) -> bool {
        let state = self.state.read().unwrap();
        match *state {
            CircuitBreakerState::Closed { .. } => true,
            CircuitBreakerState::Open { opened_at } => {
                // 超时后进入半开状态
                opened_at.elapsed() > self.timeout
            }
            CircuitBreakerState::HalfOpen { .. } => true,
        }
    }
    
    pub fn record_success(&self) {
        let mut state = self.state.write().unwrap();
        match *state {
            CircuitBreakerState::Closed { .. } => {
                // 保持关闭状态
            }
            CircuitBreakerState::HalfOpen { success_count } => {
                if success_count + 1 >= self.success_threshold {
                    // 恢复到关闭状态
                    *state = CircuitBreakerState::Closed { failure_count: 0 };
                } else {
                    *state = CircuitBreakerState::HalfOpen { success_count: success_count + 1 };
                }
            }
            CircuitBreakerState::Open { .. } => {
                // 进入半开状态
                *state = CircuitBreakerState::HalfOpen { success_count: 1 };
            }
        }
    }
    
    pub fn record_failure(&self) {
        let mut state = self.state.write().unwrap();
        match *state {
            CircuitBreakerState::Closed { failure_count } => {
                if failure_count + 1 >= self.failure_threshold {
                    // 打开断路器
                    *state = CircuitBreakerState::Open { opened_at: Instant::now() };
                } else {
                    *state = CircuitBreakerState::Closed { failure_count: failure_count + 1 };
                }
            }
            CircuitBreakerState::HalfOpen { .. } => {
                // 重新打开断路器
                *state = CircuitBreakerState::Open { opened_at: Instant::now() };
            }
            CircuitBreakerState::Open { .. } => {
                // 保持打开状态
            }
        }
    }
}
```

### 5. 可观测性优先 (Observability First)

从设计阶段就考虑可观测性,确保系统的运行状态可见、可追踪、可分析。

```rust
use opentelemetry::trace::{Tracer, Span};
use opentelemetry::metrics::Meter;

/// 可观测性集成的服务
pub struct ObservableService {
    tracer: Arc<Tracer>,
    meter: Arc<Meter>,
    logger: Arc<Logger>,
}

impl ObservableService {
    /// 处理请求 - 完整的可观测性
    pub async fn handle_request(&self, request: Request) -> Result<Response, ServiceError> {
        // 1. 创建追踪 Span
        let span = self.tracer.start("handle_request");
        let _guard = span.enter();
        
        // 添加请求属性
        span.set_attribute("request.id", request.id.clone());
        span.set_attribute("request.method", request.method.as_str());
        span.set_attribute("request.path", request.path.as_str());
        
        // 2. 记录指标
        let start_time = Instant::now();
        self.meter.create_counter("requests_total").add(1, &[]);
        
        // 3. 记录日志
        tracing::info!(
            request_id = %request.id,
            method = %request.method,
            path = %request.path,
            "Processing request"
        );
        
        // 4. 执行业务逻辑
        let result = self.process_request(request).await;
        
        // 5. 记录结果
        let duration = start_time.elapsed();
        match &result {
            Ok(response) => {
                span.set_attribute("response.status", "success");
                span.set_attribute("response.status_code", response.status_code as i64);
                self.meter.create_histogram("request_duration_ms").record(duration.as_millis() as f64, &[]);
                tracing::info!(duration_ms = duration.as_millis(), "Request completed successfully");
            }
            Err(e) => {
                span.set_attribute("response.status", "error");
                span.set_attribute("error.message", e.to_string());
                self.meter.create_counter("requests_failed_total").add(1, &[]);
                tracing::error!(error = %e, duration_ms = duration.as_millis(), "Request failed");
            }
        }
        
        result
    }
}
```

## 🏗️ 架构设计模式

### 1. API 网关模式

```rust
/// API 网关 - 统一入口
pub struct ApiGateway {
    router: Arc<Router>,
    auth_service: Arc<AuthService>,
    rate_limiter: Arc<RateLimiter>,
    tracer: Arc<Tracer>,
}

impl ApiGateway {
    pub async fn handle_request(&self, request: HttpRequest) -> Result<HttpResponse, GatewayError> {
        let span = self.tracer.start("api_gateway_request");
        let _guard = span.enter();
        
        // 1. 认证
        let user = self.auth_service.authenticate(&request).await?;
        span.set_attribute("user.id", user.id.clone());
        
        // 2. 限流
        self.rate_limiter.check_rate_limit(&user.id).await?;
        
        // 3. 路由到后端服务
        let backend_service = self.router.route(&request)?;
        span.set_attribute("backend.service", backend_service.name.clone());
        
        // 4. 转发请求
        let response = self.forward_to_backend(backend_service, request).await?;
        
        Ok(response)
    }
}
```

### 2. 服务发现模式

```rust
/// 服务发现客户端
pub struct ServiceDiscoveryClient {
    registry: Arc<ServiceRegistry>,
    load_balancer: Arc<LoadBalancer>,
    cache: Arc<RwLock<HashMap<String, Vec<ServiceInstance>>>>,
}

impl ServiceDiscoveryClient {
    /// 发现服务实例
    pub async fn discover(&self, service_name: &str) -> Result<ServiceInstance, DiscoveryError> {
        // 1. 从缓存获取
        if let Some(instances) = self.get_from_cache(service_name).await {
            return self.load_balancer.select(instances).await;
        }
        
        // 2. 从注册中心获取
        let instances = self.registry.get_instances(service_name).await?;
        
        // 3. 更新缓存
        self.update_cache(service_name, instances.clone()).await;
        
        // 4. 负载均衡选择
        self.load_balancer.select(instances).await
    }
}
```

### 3. 断路器模式

已在故障隔离原则中详细说明。

### 4. 事件驱动架构

```rust
/// 事件发布器
pub struct EventPublisher {
    kafka_producer: Arc<KafkaProducer>,
    tracer: Arc<Tracer>,
}

impl EventPublisher {
    /// 发布领域事件
    pub async fn publish<E: DomainEvent>(&self, event: E) -> Result<(), PublishError> {
        let span = self.tracer.start("publish_event");
        let _guard = span.enter();
        
        span.set_attribute("event.type", event.event_type());
        span.set_attribute("event.id", event.event_id());
        
        // 序列化事件
        let payload = serde_json::to_vec(&event)?;
        
        // 发布到 Kafka
        self.kafka_producer.send(event.topic(), payload).await?;
        
        Ok(())
    }
}

/// 事件消费者
pub struct EventConsumer {
    kafka_consumer: Arc<KafkaConsumer>,
    handlers: HashMap<String, Box<dyn EventHandler>>,
    tracer: Arc<Tracer>,
}

impl EventConsumer {
    /// 消费事件
    pub async fn consume(&self) -> Result<(), ConsumeError> {
        loop {
            let message = self.kafka_consumer.poll().await?;
            
            let span = self.tracer.start("consume_event");
            let _guard = span.enter();
            
            // 提取事件类型
            let event_type = self.extract_event_type(&message)?;
            span.set_attribute("event.type", event_type.clone());
            
            // 查找处理器
            if let Some(handler) = self.handlers.get(&event_type) {
                handler.handle(message).await?;
            }
        }
    }
}
```

### 5. CQRS 模式

```rust
/// 命令处理器 (写操作)
pub struct CommandHandler {
    write_db: Arc<WriteDatabase>,
    event_publisher: Arc<EventPublisher>,
}

impl CommandHandler {
    pub async fn handle_create_order(&self, cmd: CreateOrderCommand) -> Result<OrderId, CommandError> {
        // 1. 验证命令
        self.validate_command(&cmd)?;
        
        // 2. 创建订单 (写入主数据库)
        let order_id = self.write_db.create_order(cmd).await?;
        
        // 3. 发布事件
        self.event_publisher.publish(OrderCreatedEvent {
            order_id: order_id.clone(),
            user_id: cmd.user_id,
            items: cmd.items,
            created_at: Utc::now(),
        }).await?;
        
        Ok(order_id)
    }
}

/// 查询处理器 (读操作)
pub struct QueryHandler {
    read_db: Arc<ReadDatabase>, // 可以是不同的数据库或缓存
}

impl QueryHandler {
    pub async fn get_order(&self, order_id: &OrderId) -> Result<OrderView, QueryError> {
        // 从读优化的数据库查询
        self.read_db.get_order(order_id).await
    }
    
    pub async fn get_user_orders(&self, user_id: &UserId) -> Result<Vec<OrderView>, QueryError> {
        // 从读优化的数据库查询
        self.read_db.get_user_orders(user_id).await
    }
}
```

## 📊 数据管理原则

### 1. 数据库独立原则

每个服务拥有自己的数据库,避免共享数据库。

```rust
/// 用户服务的数据库
pub struct UserDatabase {
    pool: Arc<PgPool>, // PostgreSQL
}

/// 订单服务的数据库
pub struct OrderDatabase {
    client: Arc<MongoClient>, // MongoDB
}

/// 产品服务的数据库
pub struct ProductDatabase {
    pool: Arc<PgPool>, // PostgreSQL
}
```

### 2. 最终一致性

通过事件驱动实现最终一致性。

```rust
/// 订单服务 - 创建订单
pub async fn create_order(order: CreateOrderRequest) -> Result<Order, OrderError> {
    // 1. 创建订单
    let order = order_db.create(order).await?;
    
    // 2. 发布订单创建事件
    event_publisher.publish(OrderCreatedEvent {
        order_id: order.id.clone(),
        user_id: order.user_id.clone(),
        items: order.items.clone(),
    }).await?;
    
    Ok(order)
}

/// 库存服务 - 监听订单创建事件
pub async fn on_order_created(event: OrderCreatedEvent) -> Result<(), InventoryError> {
    // 扣减库存
    for item in event.items {
        inventory_db.decrease_stock(item.product_id, item.quantity).await?;
    }
    
    // 发布库存扣减事件
    event_publisher.publish(InventoryDecreasedEvent {
        order_id: event.order_id,
        items: event.items,
    }).await?;
    
    Ok(())
}
```

### 3. Saga 模式

分布式事务的补偿机制。

```rust
/// Saga 编排器
pub struct SagaOrchestrator {
    steps: Vec<SagaStep>,
    compensation_steps: Vec<CompensationStep>,
}

impl SagaOrchestrator {
    /// 执行 Saga
    pub async fn execute(&self) -> Result<(), SagaError> {
        let mut completed_steps = Vec::new();
        
        // 执行所有步骤
        for step in &self.steps {
            match step.execute().await {
                Ok(_) => completed_steps.push(step),
                Err(e) => {
                    // 失败 - 执行补偿
                    self.compensate(completed_steps).await?;
                    return Err(SagaError::StepFailed(e));
                }
            }
        }
        
        Ok(())
    }
    
    /// 执行补偿
    async fn compensate(&self, completed_steps: Vec<&SagaStep>) -> Result<(), SagaError> {
        // 反向执行补偿步骤
        for step in completed_steps.iter().rev() {
            step.compensate().await?;
        }
        Ok(())
    }
}

/// 订单 Saga 示例
pub async fn create_order_saga(order: CreateOrderRequest) -> Result<Order, SagaError> {
    let saga = SagaOrchestrator::new()
        // 步骤 1: 创建订单
        .add_step(CreateOrderStep { order: order.clone() })
        .with_compensation(CancelOrderStep { order_id: order.id })
        
        // 步骤 2: 扣减库存
        .add_step(DecreaseInventoryStep { items: order.items.clone() })
        .with_compensation(RestoreInventoryStep { items: order.items.clone() })
        
        // 步骤 3: 处理支付
        .add_step(ProcessPaymentStep { amount: order.total_amount })
        .with_compensation(RefundPaymentStep { amount: order.total_amount });
    
    saga.execute().await
}
```

## 🔒 安全设计原则

### 1. 零信任架构

```rust
/// 零信任认证中间件
pub struct ZeroTrustMiddleware {
    auth_service: Arc<AuthService>,
    policy_engine: Arc<PolicyEngine>,
}

impl ZeroTrustMiddleware {
    pub async fn authenticate(&self, request: &HttpRequest) -> Result<AuthContext, AuthError> {
        // 1. 验证 JWT Token
        let token = self.extract_token(request)?;
        let claims = self.auth_service.verify_token(&token).await?;
        
        // 2. 检查权限策略
        let allowed = self.policy_engine.evaluate_policy(
            &claims.user_id,
            &request.method,
            &request.path,
        ).await?;
        
        if !allowed {
            return Err(AuthError::Forbidden);
        }
        
        Ok(AuthContext {
            user_id: claims.user_id,
            roles: claims.roles,
        })
    }
}
```

### 2. 深度防御

多层安全防护。

### 3. 最小权限原则

服务只获取必要的权限。

## ⚡ 性能设计原则

### 1. 异步优先

使用 Tokio 异步运行时。

### 2. 缓存策略

```rust
/// 多级缓存
pub struct MultiLevelCache {
    l1_cache: Arc<LocalCache>,      // 本地缓存
    l2_cache: Arc<RedisCache>,      // Redis 缓存
    database: Arc<Database>,         // 数据库
}

impl MultiLevelCache {
    pub async fn get(&self, key: &str) -> Result<Value, CacheError> {
        // 1. L1 缓存
        if let Some(value) = self.l1_cache.get(key) {
            return Ok(value);
        }
        
        // 2. L2 缓存
        if let Some(value) = self.l2_cache.get(key).await? {
            self.l1_cache.set(key, value.clone());
            return Ok(value);
        }
        
        // 3. 数据库
        let value = self.database.get(key).await?;
        self.l2_cache.set(key, value.clone()).await?;
        self.l1_cache.set(key, value.clone());
        
        Ok(value)
    }
}
```

### 3. 负载均衡

已在服务发现模式中说明。

## 🎯 实践建议

1. **从单体开始**: 不要过早微服务化,先构建单体应用,理解业务边界后再拆分
2. **渐进式拆分**: 逐步将单体拆分为微服务,而不是一次性重写
3. **自动化优先**: 投资自动化测试、CI/CD、监控告警
4. **文档驱动**: 维护 API 文档、架构决策记录(ADR)
5. **团队自治**: 每个团队负责端到端的服务生命周期

---

**总结**: 微服务架构设计原则为构建可扩展、可维护的分布式系统提供了指导。通过遵循这些原则,结合 Rust 的性能和安全特性,可以构建出高质量的微服务系统。
