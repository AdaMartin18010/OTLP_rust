# å†…å­˜ç®¡ç†ä¸é›¶æ‹·è´

## ç›®å½•

- [å†…å­˜ç®¡ç†ä¸é›¶æ‹·è´](#å†…å­˜ç®¡ç†ä¸é›¶æ‹·è´)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ¯ Rust å†…å­˜ç®¡ç†](#-rust-å†…å­˜ç®¡ç†)
  - [âš¡ é›¶æ‹·è´æŠ€æœ¯](#-é›¶æ‹·è´æŠ€æœ¯)
  - [ğŸ“Š å†…å­˜æ± ](#-å†…å­˜æ± )
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)

## ğŸ“‹ æ¦‚è¿°

Rust çš„æ‰€æœ‰æƒç³»ç»Ÿæä¾›äº†å†…å­˜å®‰å…¨ä¿è¯,åŒæ—¶é›¶æ‹·è´æŠ€æœ¯å¯ä»¥æ˜¾è‘—æå‡æ€§èƒ½ã€‚
æœ¬æ–‡æ¡£ä»‹ç»åœ¨å¾®æœåŠ¡ä¸­å¦‚ä½•ä¼˜åŒ–å†…å­˜ç®¡ç†ã€‚

## ğŸ¯ Rust å†…å­˜ç®¡ç†

```rust
/// æ™ºèƒ½æŒ‡é’ˆä½¿ç”¨
pub struct ServiceData {
    // ä½¿ç”¨ Arc å®ç°çº¿ç¨‹å®‰å…¨çš„å…±äº«æ‰€æœ‰æƒ
    shared_config: Arc<Config>,
    
    // ä½¿ç”¨ Box å †åˆ†é…å¤§å¯¹è±¡
    large_buffer: Box<[u8; 1024 * 1024]>,
    
    // ä½¿ç”¨ Rc å•çº¿ç¨‹å…±äº«æ‰€æœ‰æƒ
    cache: Rc<RefCell<HashMap<String, Value>>>,
}

/// å†…å­˜å¯¹é½ä¼˜åŒ–
#[repr(align(64))]  // ç¼“å­˜è¡Œå¯¹é½
pub struct AlignedData {
    counter: AtomicU64,
    _padding: [u8; 56],  // å¡«å……åˆ° 64 å­—èŠ‚
}
```

## âš¡ é›¶æ‹·è´æŠ€æœ¯

```rust
use bytes::{Bytes, BytesMut};

/// é›¶æ‹·è´ç¼“å†²åŒº
pub struct ZeroCopyBuffer {
    data: Bytes,
}

impl ZeroCopyBuffer {
    /// ä»åˆ‡ç‰‡åˆ›å»º (é›¶æ‹·è´)
    pub fn from_slice(slice: &[u8]) -> Self {
        Self {
            data: Bytes::copy_from_slice(slice),
        }
    }
    
    /// åˆ‡ç‰‡æ“ä½œ (é›¶æ‹·è´)
    pub fn slice(&self, range: std::ops::Range<usize>) -> Bytes {
        self.data.slice(range)
    }
}

/// é›¶æ‹·è´ç½‘ç»œä¼ è¾“
pub async fn send_zero_copy(socket: &mut TcpStream, data: Bytes) -> io::Result<()> {
    // ä½¿ç”¨ sendfile ç³»ç»Ÿè°ƒç”¨ (é›¶æ‹·è´)
    socket.write_all(&data).await
}
```

## ğŸ“Š å†…å­˜æ± 

```rust
/// å¯¹è±¡æ± 
pub struct ObjectPool<T> {
    objects: Arc<Mutex<Vec<T>>>,
    factory: Arc<dyn Fn() -> T + Send + Sync>,
}

impl<T: Send + 'static> ObjectPool<T> {
    pub fn new<F>(factory: F, initial_size: usize) -> Self
    where
        F: Fn() -> T + Send + Sync + 'static,
    {
        let factory = Arc::new(factory);
        let objects = (0..initial_size)
            .map(|_| factory())
            .collect();
        
        Self {
            objects: Arc::new(Mutex::new(objects)),
            factory,
        }
    }
    
    pub async fn acquire(&self) -> PooledObject<T> {
        let mut objects = self.objects.lock().await;
        let object = objects.pop().unwrap_or_else(|| (self.factory)());
        
        PooledObject {
            object: Some(object),
            pool: Arc::clone(&self.objects),
        }
    }
}

pub struct PooledObject<T> {
    object: Option<T>,
    pool: Arc<Mutex<Vec<T>>>,
}

impl<T> Drop for PooledObject<T> {
    fn drop(&mut self) {
        if let Some(object) = self.object.take() {
            if let Ok(mut pool) = self.pool.try_lock() {
                pool.push(object);
            }
        }
    }
}
```

## ğŸ¯ æœ€ä½³å®è·µ

1. **é¿å…ä¸å¿…è¦çš„å…‹éš†**: ä½¿ç”¨å¼•ç”¨å’Œå€Ÿç”¨
2. **ä½¿ç”¨ Cow**: å†™æ—¶å¤åˆ¶ä¼˜åŒ–
3. **é¢„åˆ†é…å®¹é‡**: `Vec::with_capacity`
4. **å†…å­˜æ± **: å¤ç”¨å¯¹è±¡å‡å°‘åˆ†é…
5. **é›¶æ‹·è´**: ä½¿ç”¨ `Bytes` å’Œ `BytesMut`

---

**æ€»ç»“**: åˆç†çš„å†…å­˜ç®¡ç†å’Œé›¶æ‹·è´æŠ€æœ¯å¯ä»¥æ˜¾è‘—æå‡å¾®æœåŠ¡æ€§èƒ½ã€‚
