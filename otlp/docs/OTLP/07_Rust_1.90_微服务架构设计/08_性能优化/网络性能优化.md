# 网络性能优化

## 目录

- [网络性能优化](#网络性能优化)
  - [目录](#目录)
  - [📋 概述](#-概述)
  - [🎯 HTTP/2 优化](#-http2-优化)
  - [⚡ gRPC 性能调优](#-grpc-性能调优)
  - [🔄 连接复用](#-连接复用)
  - [🎯 最佳实践](#-最佳实践)

## 📋 概述

网络通信是微服务性能的关键瓶颈,通过优化网络层可以显著提升整体性能。

## 🎯 HTTP/2 优化

```rust
use hyper::server::Server;
use hyper::service::{make_service_fn, service_fn};

/// HTTP/2 服务器配置
pub async fn create_http2_server() -> Result<(), ServerError> {
    let addr = ([0, 0, 0, 0], 8080).into();
    
    let make_svc = make_service_fn(|_conn| async {
        Ok::<_, hyper::Error>(service_fn(handle_request))
    });
    
    Server::bind(&addr)
        .http2_only(true)
        .http2_initial_stream_window_size(1024 * 1024)  // 1MB
        .http2_initial_connection_window_size(10 * 1024 * 1024)  // 10MB
        .http2_max_concurrent_streams(1000)
        .serve(make_svc)
        .await?;
    
    Ok(())
}
```

## ⚡ gRPC 性能调优

```rust
use tonic::transport::Server;

/// gRPC 服务器配置
pub async fn create_grpc_server() -> Result<(), ServerError> {
    Server::builder()
        .concurrency_limit_per_connection(256)
        .tcp_nodelay(true)
        .tcp_keepalive(Some(Duration::from_secs(60)))
        .http2_keepalive_interval(Some(Duration::from_secs(30)))
        .http2_keepalive_timeout(Some(Duration::from_secs(10)))
        .add_service(MyServiceServer::new(MyServiceImpl))
        .serve(addr)
        .await?;
    
    Ok(())
}

/// gRPC 客户端连接池
pub struct GrpcClientPool {
    clients: Vec<MyServiceClient<Channel>>,
    current: AtomicUsize,
}

impl GrpcClientPool {
    pub async fn new(endpoint: &str, pool_size: usize) -> Result<Self, ClientError> {
        let mut clients = Vec::with_capacity(pool_size);
        
        for _ in 0..pool_size {
            let channel = Channel::from_shared(endpoint.to_string())?
                .connect_timeout(Duration::from_secs(5))
                .timeout(Duration::from_secs(30))
                .tcp_nodelay(true)
                .http2_keep_alive_interval(Duration::from_secs(30))
                .connect()
                .await?;
            
            clients.push(MyServiceClient::new(channel));
        }
        
        Ok(Self {
            clients,
            current: AtomicUsize::new(0),
        })
    }
    
    pub fn get_client(&self) -> &MyServiceClient<Channel> {
        let index = self.current.fetch_add(1, Ordering::Relaxed) % self.clients.len();
        &self.clients[index]
    }
}
```

## 🔄 连接复用

```rust
/// HTTP 客户端连接池
pub struct HttpClientPool {
    client: reqwest::Client,
}

impl HttpClientPool {
    pub fn new() -> Self {
        let client = reqwest::Client::builder()
            .pool_max_idle_per_host(10)
            .pool_idle_timeout(Duration::from_secs(90))
            .timeout(Duration::from_secs(30))
            .tcp_nodelay(true)
            .http2_prior_knowledge()
            .build()
            .unwrap();
        
        Self { client }
    }
    
    pub async fn get(&self, url: &str) -> Result<Response, ClientError> {
        self.client.get(url).send().await.map_err(Into::into)
    }
}
```

## 🎯 最佳实践

1. **启用 HTTP/2**: 利用多路复用减少连接数
2. **TCP 优化**: 启用 TCP_NODELAY 和 keepalive
3. **连接池**: 复用连接减少握手开销
4. **压缩**: 启用 gzip/brotli 压缩
5. **超时设置**: 合理设置连接和请求超时

---

**总结**: 网络层优化是提升微服务性能的重要手段。
