# 服务网格监控

## 目录

- [服务网格监控](#服务网格监控)
  - [目录](#目录)
  - [📋 概述](#-概述)
  - [🎯 服务网格监控架构](#-服务网格监控架构)
  - [📊 核心监控指标](#-核心监控指标)
    - [1. 流量指标 (Golden Signals)](#1-流量指标-golden-signals)
    - [2. 服务网格控制平面指标](#2-服务网格控制平面指标)
    - [3. 数据平面指标](#3-数据平面指标)
  - [🔍 OTLP 集成](#-otlp-集成)
    - [1. Envoy Sidecar OTLP 导出](#1-envoy-sidecar-otlp-导出)
    - [2. Istio 遥测集成](#2-istio-遥测集成)
  - [📈 可视化与告警](#-可视化与告警)
  - [🎯 最佳实践](#-最佳实践)

## 📋 概述

服务网格监控是确保微服务系统可观测性的关键组件。通过 OTLP 协议,我们可以统一收集服务网格的指标、追踪和日志数据,实现全面的可观测性。

## 🎯 服务网格监控架构

```text
┌─────────────────────────────────────────────────────────────────┐
│                    服务网格监控架构                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐       │
│  │  Service A   │    │  Service B   │    │  Service C   │       │
│  │  ┌────────┐  │    │  ┌────────┐  │    │  ┌────────┐  │       │
│  │  │  App   │  │    │  │  App   │  │    │  │  App   │  │       │
│  │  └────┬───┘  │    │  └────┬───┘  │    │  └────┬───┘  │       │
│  │  ┌────▼───┐  │    │  ┌────▼───┐  │    │  ┌────▼───┐  │       │
│  │  │ Envoy  │──┼───┼─▶│ Envoy  │──┼────┼─▶│ Envoy  │  │       │
│  │  │Sidecar │  │    │  │Sidecar │  │    │  │Sidecar │  │       │
│  │  └────┬───┘  │    │  └────┬───┘  │    │  └────┬───┘  │       │
│  └───────┼──────┘    └───────┼──────┘    └───────┼──────┘       │
│          │ OTLP              │ OTLP              │ OTLP         │
│          │                   │                   │              │
│          └───────────────────┴───────────────────┘              │
│                              │                                  │
│                    ┌─────────▼─────────┐                        │
│                    │ OTLP Collector    │                        │
│                    │ (聚合 & 处理)      │                        │
│                    └─────────┬─────────┘                        │
│                              │                                  │
│          ┌───────────────────┼───────────────────┐              │
│          │                   │                   │              │
│    ┌─────▼─────┐       ┌─────▼─────┐      ┌─────▼─────┐         │
│    │  Jaeger   │       │Prometheus │      │    ELK    │         │
│    │ (Traces)  │       │ (Metrics) │      │  (Logs)   │         │
│    └───────────┘       └───────────┘      └───────────┘         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## 📊 核心监控指标

### 1. 流量指标 (Golden Signals)

```rust
use prometheus::{Counter, Histogram, Gauge};

/// 服务网格流量指标收集器
pub struct ServiceMeshMetrics {
    /// 请求总数
    request_total: Counter,
    
    /// 请求延迟
    request_duration: Histogram,
    
    /// 错误率
    error_rate: Counter,
    
    /// 饱和度 (并发连接数)
    active_connections: Gauge,
}

impl ServiceMeshMetrics {
    pub fn new() -> Result<Self, prometheus::Error> {
        Ok(Self {
            request_total: Counter::new(
                "service_mesh_requests_total",
                "Total number of requests"
            )?,
            request_duration: Histogram::new(
                "service_mesh_request_duration_seconds",
                "Request duration in seconds"
            )?,
            error_rate: Counter::new(
                "service_mesh_errors_total",
                "Total number of errors"
            )?,
            active_connections: Gauge::new(
                "service_mesh_active_connections",
                "Number of active connections"
            )?,
        })
    }
    
    /// 记录请求
    pub fn record_request(&self, duration: Duration, status_code: u16) {
        self.request_total.inc();
        self.request_duration.observe(duration.as_secs_f64());
        
        if status_code >= 500 {
            self.error_rate.inc();
        }
    }
    
    /// 更新活跃连接数
    pub fn update_active_connections(&self, count: i64) {
        self.active_connections.set(count as f64);
    }
}
```

### 2. 服务网格控制平面指标

```rust
/// Istio 控制平面指标
pub struct ControlPlaneMetrics {
    /// Pilot 推送配置次数
    pilot_xds_pushes: Counter,
    
    /// Pilot 连接的 Envoy 数量
    pilot_proxy_connections: Gauge,
    
    /// Citadel 证书签发次数
    citadel_cert_issuances: Counter,
    
    /// Galley 配置验证错误
    galley_validation_errors: Counter,
}

impl ControlPlaneMetrics {
    /// 导出为 OTLP 指标
    pub fn export_to_otlp(&self) -> Vec<OtlpMetric> {
        vec![
            OtlpMetric {
                name: "istio_pilot_xds_pushes_total".to_string(),
                description: "Total XDS pushes from Pilot".to_string(),
                unit: "1".to_string(),
                data: MetricData::Counter {
                    data_points: vec![NumberDataPoint {
                        value: self.pilot_xds_pushes.get(),
                        time_unix_nano: SystemTime::now()
                            .duration_since(UNIX_EPOCH)
                            .unwrap()
                            .as_nanos() as u64,
                        attributes: vec![],
                        start_time_unix_nano: 0,
                    }],
                },
            },
            // ... 其他指标
        ]
    }
}
```

### 3. 数据平面指标

```rust
/// Envoy Sidecar 指标
pub struct EnvoyMetrics {
    /// 上游连接数
    upstream_connections: Gauge,
    
    /// 上游请求总数
    upstream_requests: Counter,
    
    /// 上游请求延迟
    upstream_request_duration: Histogram,
    
    /// 下游连接数
    downstream_connections: Gauge,
    
    /// 熔断触发次数
    circuit_breaker_trips: Counter,
}

impl EnvoyMetrics {
    /// 从 Envoy 统计信息解析指标
    pub fn parse_from_envoy_stats(stats: &EnvoyStats) -> Self {
        Self {
            upstream_connections: Gauge::from_value(stats.upstream_cx_active as f64),
            upstream_requests: Counter::from_value(stats.upstream_rq_total as f64),
            upstream_request_duration: Histogram::from_samples(
                &stats.upstream_rq_time_samples
            ),
            downstream_connections: Gauge::from_value(stats.downstream_cx_active as f64),
            circuit_breaker_trips: Counter::from_value(stats.circuit_breaker_trips as f64),
        }
    }
}
```

## 🔍 OTLP 集成

### 1. Envoy Sidecar OTLP 导出

```yaml
# Envoy 配置 - OTLP 导出
static_resources:
  listeners:
  - name: listener_0
    address:
      socket_address:
        address: 0.0.0.0
        port_value: 10000
    filter_chains:
    - filters:
      - name: envoy.filters.network.http_connection_manager
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
          stat_prefix: ingress_http
          tracing:
            provider:
              name: envoy.tracers.opentelemetry
              typed_config:
                "@type": type.googleapis.com/envoy.config.trace.v3.OpenTelemetryConfig
                grpc_service:
                  envoy_grpc:
                    cluster_name: otlp_collector
                  timeout: 0.250s
                service_name: my-service
```

```rust
/// Envoy OTLP 追踪配置
pub struct EnvoyOtlpConfig {
    pub collector_endpoint: String,
    pub service_name: String,
    pub sampling_rate: f64,
}

impl EnvoyOtlpConfig {
    /// 生成 Envoy 配置
    pub fn to_envoy_config(&self) -> String {
        format!(r#"
tracing:
  provider:
    name: envoy.tracers.opentelemetry
    typed_config:
      "@type": type.googleapis.com/envoy.config.trace.v3.OpenTelemetryConfig
      grpc_service:
        envoy_grpc:
          cluster_name: otlp_collector
        timeout: 0.250s
      service_name: {}
      sampler:
        name: envoy.tracers.opentelemetry.samplers.always_on
        typed_config:
          "@type": type.googleapis.com/envoy.config.trace.v3.TraceServiceConfig
"#, self.service_name)
    }
}
```

### 2. Istio 遥测集成

```rust
/// Istio 遥测配置
pub struct IstioTelemetryConfig {
    pub otlp_endpoint: String,
    pub metrics_enabled: bool,
    pub tracing_enabled: bool,
    pub logging_enabled: bool,
}

impl IstioTelemetryConfig {
    /// 生成 Istio Telemetry CRD
    pub fn to_k8s_manifest(&self) -> String {
        format!(r#"
apiVersion: telemetry.istio.io/v1alpha1
kind: Telemetry
metadata:
  name: mesh-default
  namespace: istio-system
spec:
  tracing:
  - providers:
    - name: otlp
    customTags:
      service.name:
        literal:
          value: "{{.ServiceName}}"
  metrics:
  - providers:
    - name: prometheus
  accessLogging:
  - providers:
    - name: otlp
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: istio-otlp
  namespace: istio-system
data:
  mesh: |
    extensionProviders:
    - name: otlp
      opentelemetry:
        service: opentelemetry-collector.observability.svc.cluster.local
        port: 4317
"#)
    }
}
```

## 📈 可视化与告警

```rust
/// Grafana 仪表板生成器
pub struct ServiceMeshDashboard {
    panels: Vec<DashboardPanel>,
}

impl ServiceMeshDashboard {
    /// 创建服务网格监控仪表板
    pub fn create_mesh_dashboard() -> Self {
        Self {
            panels: vec![
                // Golden Signals
                DashboardPanel::graph("Request Rate", r#"
                    rate(service_mesh_requests_total[5m])
                "#),
                DashboardPanel::graph("Error Rate", r#"
                    rate(service_mesh_errors_total[5m]) / 
                    rate(service_mesh_requests_total[5m])
                "#),
                DashboardPanel::graph("Request Duration P99", r#"
                    histogram_quantile(0.99, 
                        rate(service_mesh_request_duration_seconds_bucket[5m])
                    )
                "#),
                DashboardPanel::gauge("Active Connections", r#"
                    service_mesh_active_connections
                "#),
                
                // 服务拓扑
                DashboardPanel::service_graph("Service Topology"),
                
                // 追踪
                DashboardPanel::traces("Recent Traces"),
            ],
        }
    }
    
    /// 导出为 JSON
    pub fn to_json(&self) -> String {
        serde_json::to_string_pretty(&self).unwrap()
    }
}

/// 告警规则
pub struct AlertRules {
    rules: Vec<AlertRule>,
}

impl AlertRules {
    /// 创建服务网格告警规则
    pub fn create_mesh_alerts() -> Self {
        Self {
            rules: vec![
                AlertRule {
                    name: "HighErrorRate".to_string(),
                    expr: r#"
                        rate(service_mesh_errors_total[5m]) / 
                        rate(service_mesh_requests_total[5m]) > 0.05
                    "#.to_string(),
                    duration: Duration::from_secs(300),
                    severity: Severity::Critical,
                    annotations: vec![
                        ("summary".to_string(), "High error rate detected".to_string()),
                        ("description".to_string(), "Error rate is above 5%".to_string()),
                    ],
                },
                AlertRule {
                    name: "HighLatency".to_string(),
                    expr: r#"
                        histogram_quantile(0.99, 
                            rate(service_mesh_request_duration_seconds_bucket[5m])
                        ) > 1.0
                    "#.to_string(),
                    duration: Duration::from_secs(300),
                    severity: Severity::Warning,
                    annotations: vec![
                        ("summary".to_string(), "High latency detected".to_string()),
                        ("description".to_string(), "P99 latency is above 1s".to_string()),
                    ],
                },
            ],
        }
    }
}
```

## 🎯 最佳实践

1. **统一遥测标准**: 使用 OTLP 协议统一收集所有遥测数据
2. **合理采样**: 对追踪数据进行智能采样,平衡可观测性和性能
3. **关联分析**: 关联指标、追踪和日志,快速定位问题
4. **自动化告警**: 基于 SLO 设置自动化告警规则
5. **持续优化**: 定期审查监控指标,优化监控策略

---

**总结**: 通过 OTLP 协议集成服务网格监控,可以实现统一、高效的可观测性平台,为微服务系统的稳定运行提供保障。
