# 混沌工程

## 目录

- [概述](#概述)
- [混沌工程原则](#混沌工程原则)
- [故障注入](#故障注入)
- [实验设计](#实验设计)
- [OTLP 混沌实践](#otlp-混沌实践)

## 概述

混沌工程通过主动注入故障来验证系统的弹性和容错能力。

## 混沌工程原则

### 核心原则

1. **建立稳态假设**：定义系统正常运行的指标
2. **多样化真实世界事件**：模拟各种故障场景
3. **在生产环境运行实验**：最真实的测试环境
4. **自动化持续运行**：集成到 CI/CD
5. **最小化爆炸半径**：控制影响范围

## 故障注入

### 故障类型

```rust
pub enum ChaosExperiment {
    NetworkLatency { delay_ms: u64 },
    NetworkPartition { duration_sec: u64 },
    PodFailure { pod_name: String },
    ResourceExhaustion { resource_type: ResourceType },
    DiskFull { percentage: u8 },
}

pub enum ResourceType {
    CPU,
    Memory,
    Disk,
    Network,
}
```

### Rust 实现：故障注入器

```rust
use tokio::time::{sleep, Duration};

pub struct ChaosInjector {
    enabled: bool,
    failure_rate: f64,
}

impl ChaosInjector {
    pub fn new(enabled: bool, failure_rate: f64) -> Self {
        Self {
            enabled,
            failure_rate: failure_rate.clamp(0.0, 1.0),
        }
    }

    /// 随机注入延迟
    pub async fn maybe_inject_latency(&self, base_latency: Duration) -> Duration {
        if !self.enabled || rand::random::<f64>() > self.failure_rate {
            return base_latency;
        }

        let chaos_latency = Duration::from_millis(rand::random::<u64>() % 1000);
        sleep(chaos_latency).await;
        base_latency + chaos_latency
    }

    /// 随机注入错误
    pub fn maybe_inject_error<T, E>(&self, result: Result<T, E>, error: E) -> Result<T, E> {
        if !self.enabled || rand::random::<f64>() > self.failure_rate {
            return result;
        }

        Err(error)
    }

    /// 注入资源耗尽
    pub fn inject_memory_pressure(&self, size_mb: usize) -> Vec<u8> {
        if !self.enabled {
            return Vec::new();
        }

        vec![0u8; size_mb * 1024 * 1024]
    }
}
```

## 实验设计

### 实验模板

```yaml
# Chaos Mesh 实验配置
apiVersion: chaos-mesh.org/v1alpha1
kind: PodChaos
metadata:
  name: otlp-collector-pod-failure
spec:
  action: pod-failure
  mode: one
  duration: "30s"
  selector:
    namespaces:
      - otlp
    labelSelectors:
      app: otlp-collector
  scheduler:
    cron: "@every 1h"
```

### 实验流程

```rust
pub struct ChaosExperimentRunner {
    name: String,
    steady_state: SteadyStateHypothesis,
    chaos_action: ChaosExperiment,
    duration: Duration,
}

pub struct SteadyStateHypothesis {
    pub name: String,
    pub metric: String,
    pub threshold: f64,
}

impl ChaosExperimentRunner {
    pub async fn run_experiment(&self) -> ExperimentResult {
        println!("开始混沌实验: {}", self.name);

        // 1. 验证稳态
        println!("验证稳态假设...");
        let baseline = self.measure_steady_state().await;
        if !baseline.is_stable {
            return ExperimentResult::BaselineUnstable;
        }

        // 2. 注入故障
        println!("注入故障: {:?}", self.chaos_action);
        self.inject_chaos().await;

        // 3. 观察系统行为
        println!("观察系统行为...");
        sleep(self.duration).await;

        // 4. 测量影响
        let impact = self.measure_impact().await;

        // 5. 恢复系统
        println!("恢复系统...");
        self.recover().await;

        // 6. 验证恢复
        let recovery = self.measure_steady_state().await;

        ExperimentResult::Completed {
            baseline,
            impact,
            recovery,
        }
    }

    async fn measure_steady_state(&self) -> SteadyStateMeasurement {
        SteadyStateMeasurement {
            is_stable: true,
            metric_value: 0.0,
        }
    }

    async fn inject_chaos(&self) {
        // 实际故障注入逻辑
    }

    async fn measure_impact(&self) -> ImpactMeasurement {
        ImpactMeasurement {
            availability: 99.5,
            latency_p99: 150.0,
            error_rate: 0.5,
        }
    }

    async fn recover(&self) {
        // 恢复系统
    }
}

pub struct SteadyStateMeasurement {
    pub is_stable: bool,
    pub metric_value: f64,
}

pub struct ImpactMeasurement {
    pub availability: f64,
    pub latency_p99: f64,
    pub error_rate: f64,
}

pub enum ExperimentResult {
    BaselineUnstable,
    Completed {
        baseline: SteadyStateMeasurement,
        impact: ImpactMeasurement,
        recovery: SteadyStateMeasurement,
    },
}
```

## OTLP 混沌实践

### 实验场景

#### 1. Collector 节点故障

```yaml
apiVersion: chaos-mesh.org/v1alpha1
kind: PodChaos
metadata:
  name: collector-pod-kill
spec:
  action: pod-kill
  mode: fixed
  value: "1"
  selector:
    labelSelectors:
      app: otlp-collector
  duration: "60s"
```

#### 2. 网络延迟注入

```yaml
apiVersion: chaos-mesh.org/v1alpha1
kind: NetworkChaos
metadata:
  name: collector-network-delay
spec:
  action: delay
  mode: all
  selector:
    labelSelectors:
      app: otlp-collector
  delay:
    latency: "100ms"
    correlation: "50"
    jitter: "10ms"
  duration: "5m"
```

#### 3. 存储故障

```yaml
apiVersion: chaos-mesh.org/v1alpha1
kind: IOChaos
metadata:
  name: storage-io-fault
spec:
  action: fault
  mode: one
  selector:
    labelSelectors:
      app: otlp-storage
  volumePath: /data
  path: /data/**/*
  errno: 5  # EIO
  percent: 10
  duration: "2m"
```

### 实验检查清单

```markdown
## 混沌实验检查清单

### 实验前
- [ ] 定义稳态假设
- [ ] 确定影响范围
- [ ] 准备回滚方案
- [ ] 通知相关团队
- [ ] 确认监控就绪

### 实验中
- [ ] 记录开始时间
- [ ] 监控关键指标
- [ ] 记录异常现象
- [ ] 准备紧急停止

### 实验后
- [ ] 验证系统恢复
- [ ] 分析实验结果
- [ ] 记录改进建议
- [ ] 更新文档
- [ ] 分享经验教训
```

### 自动化实验

```rust
pub struct AutomatedChaosRunner {
    experiments: Vec<ChaosExperimentRunner>,
    schedule: String, // Cron 表达式
}

impl AutomatedChaosRunner {
    pub async fn run_scheduled_experiments(&self) {
        // 定期运行混沌实验
        loop {
            for experiment in &self.experiments {
                let result = experiment.run_experiment().await;
                self.report_result(&result).await;
            }

            sleep(Duration::from_secs(3600)).await; // 每小时一次
        }
    }

    async fn report_result(&self, result: &ExperimentResult) {
        // 将结果发送到监控系统
    }
}
```

---

**相关文档**：

- [故障检测算法](../07_理论基础/容错理论/故障检测算法.md)
- [恢复策略模型](../07_理论基础/容错理论/恢复策略模型.md)
