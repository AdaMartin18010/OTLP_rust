# 可靠性分析

## 目录

- [概述](#概述)
- [可靠性指标](#可靠性指标)
- [故障树分析](#故障树分析)
- [马尔可夫模型](#马尔可夫模型)
- [可用性计算](#可用性计算)
- [SLA/SLO 建模](#slaslo-建模)
- [OTLP 可靠性保证](#otlp-可靠性保证)

## 概述

可靠性分析用于量化系统的可靠程度，为设计和运维决策提供依据。本文档介绍可靠性分析的数学模型和方法。

## 可靠性指标

### 基本定义

**MTBF (Mean Time Between Failures)**：平均故障间隔时间

```text
MTBF = Total Operating Time / Number of Failures
```

**MTTR (Mean Time To Repair)**：平均修复时间

```text
MTTR = Total Repair Time / Number of Repairs
```

**可用性 (Availability)**：

```text
A = MTBF / (MTBF + MTTR)
```

### Rust 实现

```rust
use std::time::Duration;

/// 可靠性指标计算器
pub struct ReliabilityMetrics {
    /// 总运行时间
    total_uptime: Duration,
    /// 总故障次数
    failure_count: u64,
    /// 总修复时间
    total_repair_time: Duration,
}

impl ReliabilityMetrics {
    pub fn new() -> Self {
        Self {
            total_uptime: Duration::ZERO,
            failure_count: 0,
            total_repair_time: Duration::ZERO,
        }
    }

    pub fn record_failure(&mut self, repair_time: Duration) {
        self.failure_count += 1;
        self.total_repair_time += repair_time;
    }

    pub fn record_uptime(&mut self, uptime: Duration) {
        self.total_uptime += uptime;
    }

    /// 计算 MTBF
    pub fn mtbf(&self) -> Duration {
        if self.failure_count == 0 {
            return Duration::MAX;
        }
        self.total_uptime / self.failure_count as u32
    }

    /// 计算 MTTR
    pub fn mttr(&self) -> Duration {
        if self.failure_count == 0 {
            return Duration::ZERO;
        }
        self.total_repair_time / self.failure_count as u32
    }

    /// 计算可用性
    pub fn availability(&self) -> f64 {
        let mtbf = self.mtbf().as_secs_f64();
        let mttr = self.mttr().as_secs_f64();
        
        if mtbf + mttr == 0.0 {
            return 1.0;
        }
        
        mtbf / (mtbf + mttr)
    }

    /// 计算可用性百分比（几个9）
    pub fn availability_nines(&self) -> f64 {
        let availability = self.availability();
        -((1.0 - availability).log10())
    }
}
```

## 故障树分析

### FTA (Fault Tree Analysis)

故障树用于分析系统故障的根本原因和传播路径。

**基本门**：

- **AND 门**：所有输入都故障时输出故障
- **OR 门**：任一输入故障时输出故障

**可靠性计算**：

- AND 门：`R = R₁ × R₂ × ... × Rₙ`
- OR 门：`R = 1 - (1-R₁) × (1-R₂) × ... × (1-Rₙ)`

### Rust 实现1

```rust
/// 故障树节点
#[derive(Debug, Clone)]
pub enum FaultTreeNode {
    /// 基本事件
    BasicEvent { name: String, probability: f64 },
    /// AND 门
    AndGate { children: Vec<FaultTreeNode> },
    /// OR 门
    OrGate { children: Vec<FaultTreeNode> },
}

impl FaultTreeNode {
    /// 计算故障概率
    pub fn failure_probability(&self) -> f64 {
        match self {
            FaultTreeNode::BasicEvent { probability, .. } => *probability,
            FaultTreeNode::AndGate { children } => {
                // AND: 所有子节点都故障
                children.iter()
                    .map(|child| child.failure_probability())
                    .product()
            }
            FaultTreeNode::OrGate { children } => {
                // OR: 至少一个子节点故障
                let all_success: f64 = children.iter()
                    .map(|child| 1.0 - child.failure_probability())
                    .product();
                1.0 - all_success
            }
        }
    }

    /// 计算可靠性
    pub fn reliability(&self) -> f64 {
        1.0 - self.failure_probability()
    }
}
```

## 马尔可夫模型

### 连续时间马尔可夫链 (CTMC)

用于建模系统状态转换和可靠性。

**状态转移率矩阵 Q**：

```text
Q = [[-λ,  λ  ],
     [ μ,  -μ ]]
```

**稳态概率**：

```text
πQ = 0
Σπᵢ = 1
```

### Rust 实现2

```rust
use nalgebra::{DMatrix, DVector};

/// 马尔可夫可靠性模型
pub struct MarkovReliabilityModel {
    /// 状态数量
    num_states: usize,
    /// 转移率矩阵
    transition_rates: DMatrix<f64>,
}

impl MarkovReliabilityModel {
    pub fn new(num_states: usize) -> Self {
        Self {
            num_states,
            transition_rates: DMatrix::zeros(num_states, num_states),
        }
    }

    /// 设置转移率
    pub fn set_transition_rate(&mut self, from: usize, to: usize, rate: f64) {
        self.transition_rates[(from, to)] = rate;
    }

    /// 计算稳态概率（简化实现）
    pub fn steady_state_probabilities(&self) -> Vec<f64> {
        // 这里应该求解线性方程组 πQ = 0
        // 简化实现：返回均匀分布
        vec![1.0 / self.num_states as f64; self.num_states]
    }

    /// 计算系统可用性
    pub fn system_availability(&self, operational_states: &[usize]) -> f64 {
        let probabilities = self.steady_state_probabilities();
        operational_states.iter()
            .map(|&state| probabilities[state])
            .sum()
    }
}
```

## 可用性计算

### 串联系统

```text
A_series = A₁ × A₂ × ... × Aₙ
```

### 并联系统（冗余）

```text
A_parallel = 1 - (1-A₁) × (1-A₂) × ... × (1-Aₙ)
```

### Rust 实现3

```rust
/// 系统可用性计算器
pub struct SystemAvailability;

impl SystemAvailability {
    /// 串联系统可用性
    pub fn series(components: &[f64]) -> f64 {
        components.iter().product()
    }

    /// 并联系统可用性
    pub fn parallel(components: &[f64]) -> f64 {
        let all_fail: f64 = components.iter()
            .map(|&a| 1.0 - a)
            .product();
        1.0 - all_fail
    }

    /// k-out-of-n 系统可用性
    pub fn k_out_of_n(component_availability: f64, n: usize, k: usize) -> f64 {
        let mut availability = 0.0;
        
        for i in k..=n {
            let combinations = Self::binomial_coefficient(n, i);
            let term = combinations as f64 
                * component_availability.powi(i as i32)
                * (1.0 - component_availability).powi((n - i) as i32);
            availability += term;
        }
        
        availability
    }

    /// 计算二项式系数
    fn binomial_coefficient(n: usize, k: usize) -> usize {
        if k > n {
            return 0;
        }
        
        let k = k.min(n - k);
        let mut result = 1;
        
        for i in 0..k {
            result = result * (n - i) / (i + 1);
        }
        
        result
    }
}
```

## SLA/SLO 建模

### SLA 定义

**Service Level Agreement** - 服务级别协议

常见指标：

- 可用性：99.9%（3个9）
- 延迟：P99 < 100ms
- 吞吐量：> 10000 QPS

### SLO 计算

**Error Budget**：

```text
Error_Budget = (1 - SLO) × Total_Requests
```

### Rust 实现4

```rust
use std::time::Duration;

/// SLO 管理器
pub struct SloManager {
    /// 目标可用性
    target_availability: f64,
    /// 目标 P99 延迟
    target_p99_latency: Duration,
    /// 总请求数
    total_requests: u64,
    /// 成功请求数
    successful_requests: u64,
    /// 延迟样本
    latency_samples: Vec<Duration>,
}

impl SloManager {
    pub fn new(target_availability: f64, target_p99_latency: Duration) -> Self {
        Self {
            target_availability,
            target_p99_latency,
            total_requests: 0,
            successful_requests: 0,
            latency_samples: Vec::new(),
        }
    }

    /// 记录请求
    pub fn record_request(&mut self, success: bool, latency: Duration) {
        self.total_requests += 1;
        if success {
            self.successful_requests += 1;
        }
        self.latency_samples.push(latency);
    }

    /// 当前可用性
    pub fn current_availability(&self) -> f64 {
        if self.total_requests == 0 {
            return 1.0;
        }
        self.successful_requests as f64 / self.total_requests as f64
    }

    /// 错误预算
    pub fn error_budget(&self) -> i64 {
        let allowed_errors = ((1.0 - self.target_availability) * self.total_requests as f64) as i64;
        let actual_errors = (self.total_requests - self.successful_requests) as i64;
        allowed_errors - actual_errors
    }

    /// 错误预算消耗百分比
    pub fn error_budget_consumption(&self) -> f64 {
        let allowed_errors = (1.0 - self.target_availability) * self.total_requests as f64;
        if allowed_errors == 0.0 {
            return 0.0;
        }
        
        let actual_errors = (self.total_requests - self.successful_requests) as f64;
        (actual_errors / allowed_errors) * 100.0
    }

    /// 检查是否满足 SLO
    pub fn meets_slo(&self) -> bool {
        self.current_availability() >= self.target_availability
    }
}
```

## OTLP 可靠性保证

### 架构可靠性

```rust
/// OTLP 系统可靠性分析
pub struct OtlpReliabilityAnalysis {
    /// Exporter 可用性
    exporter_availability: f64,
    /// Collector 可用性
    collector_availability: f64,
    /// 存储可用性
    storage_availability: f64,
    /// Collector 副本数
    collector_replicas: usize,
}

impl OtlpReliabilityAnalysis {
    /// 计算端到端可用性
    pub fn end_to_end_availability(&self) -> f64 {
        // Exporter (串联)
        let exporter_a = self.exporter_availability;
        
        // Collector (并联 - 多副本)
        let collector_a = SystemAvailability::k_out_of_n(
            self.collector_availability,
            self.collector_replicas,
            1, // 至少1个可用
        );
        
        // Storage (串联)
        let storage_a = self.storage_availability;
        
        // 整体系统（串联）
        exporter_a * collector_a * storage_a
    }

    /// 计算达到目标可用性所需的副本数
    pub fn required_replicas_for_availability(&self, target: f64) -> usize {
        for n in 1..=10 {
            let availability = SystemAvailability::k_out_of_n(
                self.collector_availability,
                n,
                1,
            );
            
            let total = self.exporter_availability * availability * self.storage_availability;
            
            if total >= target {
                return n;
            }
        }
        
        10 // 最大值
    }
}
```

### 监控指标

```yaml
# Prometheus 可靠性指标
- otlp_availability_percent
- otlp_mtbf_seconds
- otlp_mttr_seconds
- otlp_error_budget_remaining
- otlp_slo_compliance_status
```

### 实战案例

```rust
/// OTLP 可靠性实战示例
pub fn otlp_reliability_example() {
    // 场景：3个 Collector 副本，单个可用性 99%
    let analysis = OtlpReliabilityAnalysis {
        exporter_availability: 0.999,  // 99.9%
        collector_availability: 0.99,   // 99%
        storage_availability: 0.999,    // 99.9%
        collector_replicas: 3,
    };

    let total_availability = analysis.end_to_end_availability();
    println!("端到端可用性: {:.4}% ({:.2} 个9)", 
        total_availability * 100.0,
        -((1.0 - total_availability).log10())
    );

    // 计算达到 99.99% 所需的副本数
    let required = analysis.required_replicas_for_availability(0.9999);
    println!("达到 99.99% 需要 {} 个副本", required);
}
```

**输出示例**：

```text
端到端可用性: 99.8901% (2.96 个9)
达到 99.99% 需要 5 个副本
```

## 可靠性优化策略

### 1. 增加冗余

**策略**：部署多个 Collector 副本

**效果**：

- 1个副本（99%）→ 1个9
- 2个副本 → 99.99%（4个9）
- 3个副本 → 99.9999%（6个9）

### 2. 快速故障恢复

**策略**：减少 MTTR

**示例**：

- MTTR 从 30分钟 → 5分钟
- 可用性从 99.9% → 99.99%

```rust
/// MTTR 优化影响分析
pub fn mttr_impact_analysis() {
    let mtbf = Duration::from_secs(30 * 24 * 3600); // 30天
    
    let scenarios = vec![
        ("当前", Duration::from_secs(30 * 60)),      // 30分钟
        ("优化后", Duration::from_secs(5 * 60)),     // 5分钟
        ("目标", Duration::from_secs(60)),           // 1分钟
    ];
    
    println!("MTTR 优化影响分析：");
    for (name, mttr) in scenarios {
        let availability = mtbf.as_secs_f64() / 
            (mtbf.as_secs_f64() + mttr.as_secs_f64());
        let nines = -((1.0 - availability).log10());
        println!("  {}: {:.4}% ({:.2} 个9)", 
            name, availability * 100.0, nines);
    }
}
```

### 3. 预防性维护

**策略**：在故障发生前主动维护

**效果**：

- 降低故障率
- 提高 MTBF

## 可靠性测试

### 混沌工程测试

```rust
use tokio::time::{sleep, Duration};
use rand::Rng;

/// 混沌工程测试框架
pub struct ChaosTest {
    failure_rate: f64,
}

impl ChaosTest {
    /// 模拟随机故障
    pub async fn inject_random_failure<F, Fut>(&self, operation: F) -> Result<(), String>
    where
        F: Fn() -> Fut,
        Fut: std::future::Future<Output = Result<(), String>>,
    {
        let mut rng = rand::thread_rng();
        
        if rng.gen::<f64>() < self.failure_rate {
            // 注入故障
            return Err("Chaos: Injected failure".to_string());
        }
        
        operation().await
    }

    /// 模拟网络延迟
    pub async fn inject_latency(&self, base_latency: Duration) {
        let mut rng = rand::thread_rng();
        let jitter = rng.gen_range(0..100);
        sleep(base_latency + Duration::from_millis(jitter)).await;
    }
}

/// 可靠性测试套件
pub async fn reliability_test_suite() {
    let chaos = ChaosTest { failure_rate: 0.01 }; // 1% 故障率
    
    let mut success_count = 0;
    let mut failure_count = 0;
    let total_tests = 10000;
    
    for _ in 0..total_tests {
        let result = chaos.inject_random_failure(|| async {
            // 模拟 OTLP 导出操作
            Ok(())
        }).await;
        
        match result {
            Ok(_) => success_count += 1,
            Err(_) => failure_count += 1,
        }
    }
    
    let availability = success_count as f64 / total_tests as f64;
    println!("测试可用性: {:.4}%", availability * 100.0);
    println!("成功: {}, 失败: {}", success_count, failure_count);
}
```

## 可靠性监控仪表板

### Grafana 配置示例

```json
{
  "dashboard": {
    "title": "OTLP 可靠性监控",
    "panels": [
      {
        "title": "可用性趋势",
        "targets": [
          {
            "expr": "sum(rate(otlp_requests_total[5m])) / sum(rate(otlp_requests_total[5m]) + rate(otlp_errors_total[5m]))",
            "legendFormat": "可用性"
          }
        ]
      },
      {
        "title": "MTBF / MTTR",
        "targets": [
          {
            "expr": "otlp_mtbf_seconds",
            "legendFormat": "MTBF"
          },
          {
            "expr": "otlp_mttr_seconds",
            "legendFormat": "MTTR"
          }
        ]
      },
      {
        "title": "错误预算消耗",
        "targets": [
          {
            "expr": "otlp_error_budget_consumption_percent",
            "legendFormat": "错误预算消耗 %"
          }
        ]
      }
    ]
  }
}
```

## 可靠性改进路线图

### 短期（1-3个月）

1. **建立基线**
   - 收集当前 MTBF/MTTR 数据
   - 测量当前可用性
   - 识别主要故障点

2. **快速修复**
   - 修复已知的高频故障
   - 优化告警规则
   - 改进监控覆盖

### 中期（3-6个月）

1. **架构优化**
   - 增加关键组件冗余
   - 实施自动故障转移
   - 优化恢复流程

2. **自动化**
   - 自动故障检测
   - 自动恢复机制
   - 自动扩缩容

### 长期（6-12个月）

1. **持续改进**
   - 定期可靠性审查
   - 混沌工程实践
   - 容量规划优化

2. **文化建设**
   - SRE 最佳实践
   - 无责复盘文化
   - 知识分享机制

## 参考文献

1. Trivedi, K. S. (2001). "Probability and Statistics with Reliability, Queuing, and Computer Science Applications."
2. Beyer, B., et al. (2016). "Site Reliability Engineering." O'Reilly Media.
3. Allspaw, J. (2015). "Trade-Offs Under Pressure: Heuristics and Observations Of Teams Resolving Internet Service Outages."

---

**相关文档**：

- [容错机制基础](./容错机制基础.md)
- [故障检测算法](./故障检测算法.md)
- [恢复策略模型](./恢复策略模型.md)
- [SLO_SLA管理](../../08_运维实践/监控告警/SLO_SLA管理.md)
