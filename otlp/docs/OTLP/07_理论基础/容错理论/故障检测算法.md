# 故障检测算法

## 目录

- [故障检测算法](#故障检测算法)
  - [目录](#目录)
  - [概述](#概述)
  - [心跳检测](#心跳检测)
    - [基本原理](#基本原理)
    - [Rust 实现](#rust-实现)
  - [超时检测](#超时检测)
    - [自适应超时](#自适应超时)
    - [Rust 实现1](#rust-实现1)
  - [Phi Accrual 故障检测器](#phi-accrual-故障检测器)
    - [理论基础](#理论基础)
    - [Rust 实现2](#rust-实现2)
  - [SWIM 协议](#swim-协议)
    - [协议概述](#协议概述)
    - [基本流程](#基本流程)
  - [健康检查机制](#健康检查机制)
    - [HTTP 健康检查](#http-健康检查)
  - [OTLP 故障检测实践](#otlp-故障检测实践)
    - [Collector 健康检查](#collector-健康检查)
    - [监控指标](#监控指标)
  - [参考文献](#参考文献)

## 概述

故障检测是分布式系统容错的基础，用于及时发现节点或服务的异常状态。本文档介绍常用的故障检测算法及其在 OTLP 中的应用。

## 心跳检测

### 基本原理

节点周期性发送心跳消息，如果在超时时间内未收到心跳，则判定为故障。

**参数**：

- `T_heartbeat`: 心跳间隔
- `T_timeout`: 超时阈值（通常为 `k × T_heartbeat`，k ≥ 3）

### Rust 实现

```rust
use std::time::{Duration, Instant};
use std::collections::HashMap;
use tokio::time::interval;

/// 心跳检测器
pub struct HeartbeatDetector {
    /// 心跳间隔
    interval: Duration,
    /// 超时阈值
    timeout: Duration,
    /// 最后心跳时间
    last_heartbeat: HashMap<String, Instant>,
}

impl HeartbeatDetector {
    pub fn new(interval: Duration, timeout_multiplier: u32) -> Self {
        Self {
            interval,
            timeout: interval * timeout_multiplier,
            last_heartbeat: HashMap::new(),
        }
    }

    /// 记录心跳
    pub fn record_heartbeat(&mut self, node_id: impl Into<String>) {
        self.last_heartbeat.insert(node_id.into(), Instant::now());
    }

    /// 检查节点是否存活
    pub fn is_alive(&self, node_id: &str) -> bool {
        if let Some(&last_time) = self.last_heartbeat.get(node_id) {
            last_time.elapsed() < self.timeout
        } else {
            false
        }
    }

    /// 获取所有故障节点
    pub fn get_failed_nodes(&self) -> Vec<String> {
        self.last_heartbeat
            .iter()
            .filter(|(_, &time)| time.elapsed() >= self.timeout)
            .map(|(id, _)| id.clone())
            .collect()
    }
}
```

## 超时检测

### 自适应超时

根据历史延迟动态调整超时阈值：

```text
T_timeout = μ + k × σ
```

其中：

- `μ`: 平均延迟
- `σ`: 标准差
- `k`: 安全系数（通常为 3-5）

### Rust 实现1

```rust
use std::collections::VecDeque;
use std::time::Duration;

/// 自适应超时检测器
pub struct AdaptiveTimeoutDetector {
    /// 延迟样本窗口
    samples: VecDeque<f64>,
    /// 窗口大小
    window_size: usize,
    /// 安全系数
    safety_factor: f64,
}

impl AdaptiveTimeoutDetector {
    pub fn new(window_size: usize, safety_factor: f64) -> Self {
        Self {
            samples: VecDeque::with_capacity(window_size),
            window_size,
            safety_factor,
        }
    }

    /// 添加延迟样本
    pub fn add_sample(&mut self, latency: Duration) {
        if self.samples.len() >= self.window_size {
            self.samples.pop_front();
        }
        self.samples.push_back(latency.as_secs_f64());
    }

    /// 计算当前超时阈值
    pub fn calculate_timeout(&self) -> Duration {
        if self.samples.is_empty() {
            return Duration::from_secs(5); // 默认值
        }

        let mean = self.samples.iter().sum::<f64>() / self.samples.len() as f64;
        let variance = self.samples.iter()
            .map(|&x| (x - mean).powi(2))
            .sum::<f64>() / self.samples.len() as f64;
        let std_dev = variance.sqrt();

        let timeout = mean + self.safety_factor * std_dev;
        Duration::from_secs_f64(timeout.max(0.1)) // 最小 100ms
    }
}
```

## Phi Accrual 故障检测器

### 理论基础

Phi Accrual 使用连续的怀疑度（suspicion level）而非二元判断，更适合动态网络环境。

**Phi 值计算**：

```text
Φ(t) = -log₁₀(P(t_now - t_last))
```

其中 `P(t)` 是心跳间隔的概率分布。

### Rust 实现2

```rust
use std::time::{Duration, Instant};
use std::collections::HashMap;

/// Phi Accrual 故障检测器
pub struct PhiAccrualDetector {
    /// 心跳间隔历史
    intervals: HashMap<String, Vec<f64>>,
    /// 最后心跳时间
    last_heartbeat: HashMap<String, Instant>,
    /// Phi 阈值
    phi_threshold: f64,
    /// 最大历史记录数
    max_history: usize,
}

impl PhiAccrualDetector {
    pub fn new(phi_threshold: f64, max_history: usize) -> Self {
        Self {
            intervals: HashMap::new(),
            last_heartbeat: HashMap::new(),
            phi_threshold,
            max_history,
        }
    }

    /// 记录心跳
    pub fn heartbeat(&mut self, node_id: impl Into<String>) {
        let node_id = node_id.into();
        let now = Instant::now();

        if let Some(&last) = self.last_heartbeat.get(&node_id) {
            let interval = now.duration_since(last).as_secs_f64();
            
            let intervals = self.intervals.entry(node_id.clone()).or_insert_with(Vec::new);
            intervals.push(interval);
            
            if intervals.len() > self.max_history {
                intervals.remove(0);
            }
        }

        self.last_heartbeat.insert(node_id, now);
    }

    /// 计算 Phi 值
    pub fn phi(&self, node_id: &str) -> f64 {
        let last_time = match self.last_heartbeat.get(node_id) {
            Some(&t) => t,
            None => return f64::INFINITY,
        };

        let intervals = match self.intervals.get(node_id) {
            Some(i) if !i.is_empty() => i,
            _ => return 0.0,
        };

        let elapsed = last_time.elapsed().as_secs_f64();
        
        // 计算均值和标准差
        let mean = intervals.iter().sum::<f64>() / intervals.len() as f64;
        let variance = intervals.iter()
            .map(|&x| (x - mean).powi(2))
            .sum::<f64>() / intervals.len() as f64;
        let std_dev = variance.sqrt();

        if std_dev == 0.0 {
            return if elapsed > mean { f64::INFINITY } else { 0.0 };
        }

        // 使用正态分布计算概率
        let z = (elapsed - mean) / std_dev;
        let p = Self::normal_cdf(z);
        
        -p.log10()
    }

    /// 判断节点是否存活
    pub fn is_alive(&self, node_id: &str) -> bool {
        self.phi(node_id) < self.phi_threshold
    }

    /// 正态分布累积分布函数（简化实现）
    fn normal_cdf(z: f64) -> f64 {
        0.5 * (1.0 + Self::erf(z / std::f64::consts::SQRT_2))
    }

    /// 误差函数（简化实现）
    fn erf(x: f64) -> f64 {
        let t = 1.0 / (1.0 + 0.5 * x.abs());
        let tau = t * (-x * x - 1.26551223 +
            t * (1.00002368 +
            t * (0.37409196 +
            t * (0.09678418 +
            t * (-0.18628806 +
            t * (0.27886807 +
            t * (-1.13520398 +
            t * (1.48851587 +
            t * (-0.82215223 +
            t * 0.17087277)))))))));
        
        if x >= 0.0 { 1.0 - tau } else { tau - 1.0 }
    }
}
```

## SWIM 协议

### 协议概述

SWIM (Scalable Weakly-consistent Infection-style Process Group Membership Protocol) 是一种高效的分布式故障检测协议。

**特点**：

- O(1) 消息复杂度
- 快速故障检测
- 低误报率

### 基本流程

1. **Ping**: 随机选择节点发送 ping
2. **Ping-Req**: 如果超时，请求其他节点代为 ping
3. **Suspect**: 如果仍超时，标记为可疑
4. **Confirm**: 经过一段时间后确认故障

## 健康检查机制

### HTTP 健康检查

```rust
use reqwest::Client;
use std::time::Duration;

/// HTTP 健康检查器
pub struct HttpHealthChecker {
    client: Client,
    timeout: Duration,
}

impl HttpHealthChecker {
    pub fn new(timeout: Duration) -> Self {
        let client = Client::builder()
            .timeout(timeout)
            .build()
            .unwrap();
        
        Self { client, timeout }
    }

    /// 执行健康检查
    pub async fn check(&self, url: &str) -> bool {
        match self.client.get(url).send().await {
            Ok(response) => response.status().is_success(),
            Err(_) => false,
        }
    }
}
```

## OTLP 故障检测实践

### Collector 健康检查

```rust
/// OTLP Collector 健康检测
pub struct OtlpCollectorHealthCheck {
    detector: PhiAccrualDetector,
    http_checker: HttpHealthChecker,
}

impl OtlpCollectorHealthCheck {
    pub fn new() -> Self {
        Self {
            detector: PhiAccrualDetector::new(8.0, 100),
            http_checker: HttpHealthChecker::new(Duration::from_secs(5)),
        }
    }

    /// 检查 Collector 健康状态
    pub async fn check_collector(&mut self, collector_id: &str, health_url: &str) -> bool {
        // HTTP 健康检查
        let http_ok = self.http_checker.check(health_url).await;
        
        if http_ok {
            self.detector.heartbeat(collector_id);
        }
        
        // 结合 Phi Accrual 判断
        http_ok && self.detector.is_alive(collector_id)
    }
}
```

### 监控指标

```yaml
# Prometheus 指标
- otlp_collector_health_status{collector_id}
- otlp_collector_phi_value{collector_id}
- otlp_collector_last_heartbeat_seconds{collector_id}
```

## 参考文献

1. Hayashibara, N., et al. (2004). "The φ Accrual Failure Detector."
2. Das, A., et al. (2002). "SWIM: Scalable Weakly-consistent Infection-style Process Group Membership Protocol."

---

**相关文档**：

- [容错机制基础](./容错机制基础.md)
- [恢复策略模型](./恢复策略模型.md)
- [可靠性分析](./可靠性分析.md)
