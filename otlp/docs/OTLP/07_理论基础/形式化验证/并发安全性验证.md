# 并发安全性验证

## 目录

- [并发安全性验证](#并发安全性验证)
  - [目录](#目录)
  - [概述](#概述)
  - [数据竞争检测](#数据竞争检测)
    - [形式化定义](#形式化定义)
    - [Rust 实现](#rust-实现)
  - [死锁检测](#死锁检测)
    - [银行家算法](#银行家算法)
  - [原子性验证](#原子性验证)
    - [无锁数据结构](#无锁数据结构)
  - [Rust 并发安全](#rust-并发安全)
    - [Send 和 Sync Trait](#send-和-sync-trait)

## 概述

并发安全性验证确保多线程环境下系统的正确性。

## 数据竞争检测

### 形式化定义

两个操作存在数据竞争当且仅当：

1. 访问同一内存位置
2. 至少一个是写操作
3. 不存在 happens-before 关系

### Rust 实现

```rust
use std::sync::Arc;
use parking_lot::RwLock;

pub struct SafeCounter {
    value: Arc<RwLock<u64>>,
}

impl SafeCounter {
    pub fn new() -> Self {
        Self {
            value: Arc::new(RwLock::new(0)),
        }
    }

    pub fn increment(&self) {
        let mut val = self.value.write();
        *val += 1;
    }

    pub fn get(&self) -> u64 {
        *self.value.read()
    }
}
```

## 死锁检测

### 银行家算法

```rust
pub struct DeadlockDetector {
    available: Vec<usize>,
    allocation: Vec<Vec<usize>>,
    max_need: Vec<Vec<usize>>,
}

impl DeadlockDetector {
    pub fn is_safe_state(&self) -> bool {
        let n = self.allocation.len();
        let m = self.available.len();
        
        let mut work = self.available.clone();
        let mut finish = vec![false; n];
        
        loop {
            let mut found = false;
            
            for i in 0..n {
                if finish[i] {
                    continue;
                }
                
                let need: Vec<usize> = (0..m)
                    .map(|j| self.max_need[i][j] - self.allocation[i][j])
                    .collect();
                
                if need.iter().zip(&work).all(|(n, w)| n <= w) {
                    for j in 0..m {
                        work[j] += self.allocation[i][j];
                    }
                    finish[i] = true;
                    found = true;
                }
            }
            
            if !found {
                break;
            }
        }
        
        finish.iter().all(|&f| f)
    }
}
```

## 原子性验证

### 无锁数据结构

```rust
use std::sync::atomic::{AtomicPtr, AtomicUsize, Ordering};
use std::ptr;

pub struct LockFreeStack<T> {
    head: AtomicPtr<Node<T>>,
    size: AtomicUsize,
}

struct Node<T> {
    data: T,
    next: *mut Node<T>,
}

impl<T> LockFreeStack<T> {
    pub fn new() -> Self {
        Self {
            head: AtomicPtr::new(ptr::null_mut()),
            size: AtomicUsize::new(0),
        }
    }

    pub fn push(&self, data: T) {
        let new_node = Box::into_raw(Box::new(Node {
            data,
            next: ptr::null_mut(),
        }));

        loop {
            let head = self.head.load(Ordering::Acquire);
            unsafe { (*new_node).next = head; }

            if self.head
                .compare_exchange(head, new_node, Ordering::Release, Ordering::Acquire)
                .is_ok()
            {
                self.size.fetch_add(1, Ordering::Relaxed);
                break;
            }
        }
    }

    pub fn pop(&self) -> Option<T> {
        loop {
            let head = self.head.load(Ordering::Acquire);
            if head.is_null() {
                return None;
            }

            let next = unsafe { (*head).next };

            if self.head
                .compare_exchange(head, next, Ordering::Release, Ordering::Acquire)
                .is_ok()
            {
                self.size.fetch_sub(1, Ordering::Relaxed);
                let data = unsafe { Box::from_raw(head).data };
                return Some(data);
            }
        }
    }
}
```

## Rust 并发安全

### Send 和 Sync Trait

```rust
// 自动实现 Send 和 Sync
pub struct SafeData {
    value: Arc<RwLock<Vec<u8>>>,
}

// 手动实现（需要 unsafe）
pub struct UnsafeData {
    ptr: *mut u8,
}

unsafe impl Send for UnsafeData {}
unsafe impl Sync for UnsafeData {}
```

---

**相关文档**：

- [协议形式化规范](./协议形式化规范.md)
- [算法正确性证明](./算法正确性证明.md)
