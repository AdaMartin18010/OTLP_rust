# æ€§èƒ½æ•°å­¦æ¨¡å‹

## ç›®å½•

- [æ€§èƒ½æ•°å­¦æ¨¡å‹](#æ€§èƒ½æ•°å­¦æ¨¡å‹)
  - [ç›®å½•](#ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
  - [1. æ’é˜Ÿè®ºæ¨¡å‹](#1-æ’é˜Ÿè®ºæ¨¡å‹)
    - [1.1 M/M/1 é˜Ÿåˆ—æ¨¡å‹](#11-mm1-é˜Ÿåˆ—æ¨¡å‹)
    - [1.2 M/M/c é˜Ÿåˆ—æ¨¡å‹ï¼ˆå¤šæœåŠ¡å™¨ï¼‰](#12-mmc-é˜Ÿåˆ—æ¨¡å‹å¤šæœåŠ¡å™¨)
    - [1.3 å®é™…åº”ç”¨ç¤ºä¾‹](#13-å®é™…åº”ç”¨ç¤ºä¾‹)
  - [2. å»¶è¿Ÿåˆ†ææ¨¡å‹](#2-å»¶è¿Ÿåˆ†ææ¨¡å‹)
    - [2.1 å»¶è¿Ÿç»„æˆåˆ†è§£](#21-å»¶è¿Ÿç»„æˆåˆ†è§£)
    - [2.2 ç™¾åˆ†ä½æ•°å»¶è¿Ÿ](#22-ç™¾åˆ†ä½æ•°å»¶è¿Ÿ)
    - [2.3 å»¶è¿Ÿé¢„ç®—åˆ†é…](#23-å»¶è¿Ÿé¢„ç®—åˆ†é…)
  - [3. ååé‡æ¨¡å‹](#3-ååé‡æ¨¡å‹)
    - [3.1 Amdahl å®šå¾‹](#31-amdahl-å®šå¾‹)
    - [3.2 Universal Scalability Law (USL)](#32-universal-scalability-law-usl)
  - [4. èµ„æºåˆ©ç”¨ç‡æ¨¡å‹](#4-èµ„æºåˆ©ç”¨ç‡æ¨¡å‹)
    - [4.1 CPU åˆ©ç”¨ç‡](#41-cpu-åˆ©ç”¨ç‡)
    - [4.2 å†…å­˜ä½¿ç”¨æ¨¡å‹](#42-å†…å­˜ä½¿ç”¨æ¨¡å‹)
    - [4.3 èµ„æºå®¹é‡è§„åˆ’](#43-èµ„æºå®¹é‡è§„åˆ’)
  - [5. æ€§èƒ½ä¼˜åŒ–ç†è®º](#5-æ€§èƒ½ä¼˜åŒ–ç†è®º)
    - [5.1 è¾¹é™…æ•ˆç›Šé€’å‡](#51-è¾¹é™…æ•ˆç›Šé€’å‡)
    - [5.2 80/20 æ³•åˆ™](#52-8020-æ³•åˆ™)
  - [6. æ€»ç»“](#6-æ€»ç»“)
  - [å‚è€ƒæ–‡çŒ®](#å‚è€ƒæ–‡çŒ®)

## æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›OTLPç³»ç»Ÿæ€§èƒ½çš„æ•°å­¦å»ºæ¨¡ã€åˆ†ææ–¹æ³•å’Œä¼˜åŒ–ç†è®ºåŸºç¡€ã€‚

## 1. æ’é˜Ÿè®ºæ¨¡å‹

### 1.1 M/M/1 é˜Ÿåˆ—æ¨¡å‹

OTLP è¯·æ±‚å¤„ç†å¯ä»¥å»ºæ¨¡ä¸º M/M/1 é˜Ÿåˆ—ç³»ç»Ÿï¼š

- M: æ³Šæ¾åˆ°è¾¾è¿‡ç¨‹ï¼ˆMarkovian arrivalsï¼‰
- M: æŒ‡æ•°æœåŠ¡æ—¶é—´ï¼ˆMarkovian serviceï¼‰
- 1: å•ä¸ªæœåŠ¡å™¨

**ç³»ç»Ÿå‚æ•°**ï¼š

- `Î»`: è¯·æ±‚åˆ°è¾¾ç‡ï¼ˆrequests/secondï¼‰
- `Î¼`: æœåŠ¡ç‡ï¼ˆrequests/secondï¼‰
- `Ï = Î»/Î¼`: åˆ©ç”¨ç‡ï¼ˆå¿…é¡» < 1 æ‰ç¨³å®šï¼‰

**å…³é”®æŒ‡æ ‡å…¬å¼**ï¼š

```text
å¹³å‡ç­‰å¾…æ—¶é—´ï¼ˆé˜Ÿåˆ—ä¸­ï¼‰:
W_q = Ï / (Î¼(1-Ï)) = Î» / (Î¼(Î¼-Î»))

å¹³å‡å“åº”æ—¶é—´ï¼ˆç³»ç»Ÿä¸­ï¼‰:
W = W_q + 1/Î¼ = 1 / (Î¼-Î»)

å¹³å‡é˜Ÿåˆ—é•¿åº¦:
L_q = Î»W_q = Î»Â² / (Î¼(Î¼-Î»)) = ÏÂ² / (1-Ï)

å¹³å‡ç³»ç»Ÿå†…è¯·æ±‚æ•°:
L = Î»W = Î» / (Î¼-Î») = Ï / (1-Ï)
```

**å®šç† 1.1ï¼ˆLittle's Lawï¼‰**ï¼š

```text
L = Î»W
```

å¹³å‡ç³»ç»Ÿå†…è¯·æ±‚æ•° = åˆ°è¾¾ç‡ Ã— å¹³å‡å“åº”æ—¶é—´

**è¯æ˜**ï¼š
è®¾åœ¨ `[0, T]` æ—¶é—´å†…ï¼š

- `A(T)`: åˆ°è¾¾è¯·æ±‚æ•°
- `D(T)`: ç¦»å¼€è¯·æ±‚æ•°  
- `âˆ«â‚€áµ€ N(t)dt`: ç³»ç»Ÿå†…è¯·æ±‚æ•°çš„ç´¯ç§¯

åˆ™ï¼š

```text
âˆ«â‚€áµ€ N(t)dt = Î£áµ¢ Wáµ¢  // æ‰€æœ‰è¯·æ±‚çš„æ€»ç­‰å¾…æ—¶é—´

å½“ T â†’ âˆ æ—¶ï¼š
L = lim(Tâ†’âˆ) [âˆ«â‚€áµ€ N(t)dt / T]  // å¹³å‡è¯·æ±‚æ•°
W = lim(Tâ†’âˆ) [Î£áµ¢ Wáµ¢ / A(T)]     // å¹³å‡ç­‰å¾…æ—¶é—´
Î» = lim(Tâ†’âˆ) [A(T) / T]         // åˆ°è¾¾ç‡

å› æ­¤ï¼š
L = lim(Tâ†’âˆ) [âˆ«â‚€áµ€ N(t)dt / T]
  = lim(Tâ†’âˆ) [Î£áµ¢ Wáµ¢ / T]
  = lim(Tâ†’âˆ) [(Î£áµ¢ Wáµ¢ / A(T)) Ã— (A(T) / T)]
  = W Ã— Î» âˆ
```

### 1.2 M/M/c é˜Ÿåˆ—æ¨¡å‹ï¼ˆå¤šæœåŠ¡å™¨ï¼‰

å¯¹äºæœ‰ `c` ä¸ªå¤„ç†çº¿ç¨‹çš„ç³»ç»Ÿï¼š

**Erlang C å…¬å¼**ï¼ˆè¯·æ±‚éœ€è¦ç­‰å¾…çš„æ¦‚ç‡ï¼‰ï¼š

```text
P(wait) = C(c, Ï) Ã— c^c Ã— Ï^c / (c! Ã— (1 - Ï))
         â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
         Î£(k=0 to c-1) Ï^k/k! + c^cÃ—Ï^c/(c!(1-Ï))
```

å…¶ä¸­ `Ï = Î»/(cÎ¼)` æ˜¯æ¯ä¸ªæœåŠ¡å™¨çš„åˆ©ç”¨ç‡ã€‚

**å¹³å‡ç­‰å¾…æ—¶é—´**ï¼š

```text
W_q = P(wait) / (cÎ¼ - Î»)

W = W_q + 1/Î¼
```

### 1.3 å®é™…åº”ç”¨ç¤ºä¾‹

```rust
/// æ’é˜Ÿè®ºæ€§èƒ½æ¨¡å‹
pub struct QueueingModel {
    arrival_rate: f64,     // Î» (req/s)
    service_rate: f64,     // Î¼ (req/s)
    num_servers: usize,    // c
}

impl QueueingModel {
    pub fn new(arrival_rate: f64, service_rate: f64, num_servers: usize) -> Self {
        Self {
            arrival_rate,
            service_rate,
            num_servers,
        }
    }
    
    /// è®¡ç®—åˆ©ç”¨ç‡
    pub fn utilization(&self) -> f64 {
        self.arrival_rate / (self.num_servers as f64 * self.service_rate)
    }
    
    /// åˆ¤æ–­ç³»ç»Ÿæ˜¯å¦ç¨³å®š
    pub fn is_stable(&self) -> bool {
        self.utilization() < 1.0
    }
    
    /// è®¡ç®—å¹³å‡å“åº”æ—¶é—´ (M/M/1)
    pub fn avg_response_time_mm1(&self) -> Option<f64> {
        if self.num_servers != 1 || !self.is_stable() {
            return None;
        }
        
        Some(1.0 / (self.service_rate - self.arrival_rate))
    }
    
    /// è®¡ç®—å¹³å‡é˜Ÿåˆ—é•¿åº¦ (M/M/1)
    pub fn avg_queue_length_mm1(&self) -> Option<f64> {
        if self.num_servers != 1 || !self.is_stable() {
            return None;
        }
        
        let rho = self.utilization();
        Some(rho * rho / (1.0 - rho))
    }
    
    /// è®¡ç®— Erlang Cï¼ˆç­‰å¾…æ¦‚ç‡ï¼‰
    pub fn erlang_c(&self) -> f64 {
        let c = self.num_servers as f64;
        let rho = self.arrival_rate / self.service_rate;
        
        // è®¡ç®—åˆ†å­
        let numerator = (c * rho).powf(c) / factorial(self.num_servers) 
                       * (c / (c - rho));
        
        // è®¡ç®—åˆ†æ¯
        let mut denominator = 0.0;
        for k in 0..self.num_servers {
            denominator += rho.powi(k as i32) / factorial(k) as f64;
        }
        denominator += numerator;
        
        numerator / denominator
    }
    
    /// è®¡ç®—å¹³å‡å“åº”æ—¶é—´ (M/M/c)
    pub fn avg_response_time_mmc(&self) -> Option<f64> {
        if !self.is_stable() {
            return None;
        }
        
        let c = self.num_servers as f64;
        let wait_prob = self.erlang_c();
        let wait_time = wait_prob / (c * self.service_rate - self.arrival_rate);
        
        Some(wait_time + 1.0 / self.service_rate)
    }
    
    /// æ€§èƒ½é¢„æµ‹ï¼šå¦‚æœåˆ°è¾¾ç‡å¢åŠ ä¼šæ€æ ·ï¼Ÿ
    pub fn predict_performance(&self, new_arrival_rate: f64) -> PerformancePrediction {
        let mut model = self.clone();
        model.arrival_rate = new_arrival_rate;
        
        PerformancePrediction {
            arrival_rate: new_arrival_rate,
            utilization: model.utilization(),
            stable: model.is_stable(),
            avg_response_time: model.avg_response_time_mmc(),
            recommendation: model.get_recommendation(),
        }
    }
    
    fn get_recommendation(&self) -> String {
        let util = self.utilization();
        
        if util >= 1.0 {
            format!("ğŸ”´ ç³»ç»Ÿè¿‡è½½ï¼éœ€è¦è‡³å°‘ {} ä¸ªæœåŠ¡å™¨",
                   (self.arrival_rate / self.service_rate).ceil() as usize + 1)
        } else if util >= 0.8 {
            "ğŸŸ¡ åˆ©ç”¨ç‡åé«˜ï¼Œå»ºè®®æ‰©å®¹".to_string()
        } else if util >= 0.5 {
            "ğŸŸ¢ è¿è¡Œæ­£å¸¸".to_string()
        } else {
            "ğŸ”µ èµ„æºåˆ©ç”¨ç‡ä½ï¼Œå¯ä»¥è€ƒè™‘ç¼©å®¹".to_string()
        }
    }
}

fn factorial(n: usize) -> usize {
    (1..=n).product()
}

#[derive(Debug, Clone)]
pub struct PerformancePrediction {
    pub arrival_rate: f64,
    pub utilization: f64,
    pub stable: bool,
    pub avg_response_time: Option<f64>,
    pub recommendation: String,
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let model = QueueingModel::new(
        80.0,   // 80 req/s
        100.0,  // 100 req/s å¤„ç†èƒ½åŠ›
        1       // 1 ä¸ªæœåŠ¡å™¨
    );
    
    println!("å½“å‰æ€§èƒ½:");
    println!("  åˆ©ç”¨ç‡: {:.1}%", model.utilization() * 100.0);
    println!("  å¹³å‡å“åº”æ—¶é—´: {:.2}ms", 
             model.avg_response_time_mm1().unwrap() * 1000.0);
    println!("  å¹³å‡é˜Ÿåˆ—é•¿åº¦: {:.2}", 
             model.avg_queue_length_mm1().unwrap());
    
    // é¢„æµ‹ï¼šå¦‚æœæµé‡å¢åŠ åˆ° 95 req/s
    println!("\nå¦‚æœæµé‡å¢åŠ åˆ° 95 req/s:");
    let prediction = model.predict_performance(95.0);
    println!("  åˆ©ç”¨ç‡: {:.1}%", prediction.utilization * 100.0);
    if let Some(rt) = prediction.avg_response_time {
        println!("  å¹³å‡å“åº”æ—¶é—´: {:.2}ms", rt * 1000.0);
    }
    println!("  å»ºè®®: {}", prediction.recommendation);
}
```

**è¾“å‡ºç¤ºä¾‹**ï¼š

```text
å½“å‰æ€§èƒ½:
  åˆ©ç”¨ç‡: 80.0%
  å¹³å‡å“åº”æ—¶é—´: 50.00ms
  å¹³å‡é˜Ÿåˆ—é•¿åº¦: 3.20

å¦‚æœæµé‡å¢åŠ åˆ° 95 req/s:
  åˆ©ç”¨ç‡: 95.0%
  å¹³å‡å“åº”æ—¶é—´: 200.00ms
  å»ºè®®: ğŸŸ¡ åˆ©ç”¨ç‡åé«˜ï¼Œå»ºè®®æ‰©å®¹
```

## 2. å»¶è¿Ÿåˆ†ææ¨¡å‹

### 2.1 å»¶è¿Ÿç»„æˆåˆ†è§£

æ€»å»¶è¿Ÿå¯ä»¥åˆ†è§£ä¸ºå¤šä¸ªç»„æˆéƒ¨åˆ†ï¼š

```text
T_total = T_queue + T_service + T_network + T_downstream

å…¶ä¸­ï¼š
- T_queue: é˜Ÿåˆ—ç­‰å¾…æ—¶é—´
- T_service: æœ¬åœ°å¤„ç†æ—¶é—´
- T_network: ç½‘ç»œä¼ è¾“æ—¶é—´
- T_downstream: ä¸‹æ¸¸æœåŠ¡è°ƒç”¨æ—¶é—´
```

**å®šç† 2.1ï¼ˆæ–¹å·®å¯åŠ æ€§ï¼‰**ï¼š
å¯¹äºç‹¬ç«‹çš„å»¶è¿Ÿç»„ä»¶ï¼š

```text
Var(T_total) = Var(T_queue) + Var(T_service) + Var(T_network) + Var(T_downstream)
```

### 2.2 ç™¾åˆ†ä½æ•°å»¶è¿Ÿ

**P99 å»¶è¿Ÿçš„é‡è¦æ€§**ï¼š

å‡è®¾ç³»ç»Ÿå¤„ç†ä¸€ä¸ªç”¨æˆ·è¯·æ±‚éœ€è¦è°ƒç”¨ `n` ä¸ªæœåŠ¡ï¼Œæ¯ä¸ªæœåŠ¡çš„ P99 å»¶è¿Ÿä¸º `p`ã€‚
ç”¨æˆ·ä½“éªŒåˆ° P99 å»¶è¿Ÿçš„æ¦‚ç‡ä¸ºï¼š

```text
P(è‡³å°‘ä¸€ä¸ªæœåŠ¡æ…¢) = 1 - (1-0.01)^n â‰ˆ n Ã— 0.01
```

**ç¤ºä¾‹**ï¼š

- 1 ä¸ªæœåŠ¡ï¼šP99 æ¦‚ç‡ = 1%
- 10 ä¸ªæœåŠ¡ï¼šP99 æ¦‚ç‡ â‰ˆ 10%
- 100 ä¸ªæœåŠ¡ï¼šP99 æ¦‚ç‡ â‰ˆ 63%

**ç»“è®º**ï¼šå¾®æœåŠ¡æ¶æ„ä¸­ï¼Œå°¾å»¶è¿Ÿæ”¾å¤§æ•ˆåº”æ˜¾è‘—ï¼

### 2.3 å»¶è¿Ÿé¢„ç®—åˆ†é…

**ç›®æ ‡**ï¼šæ€»ä½“ P99 å»¶è¿Ÿ < 100ms

**åˆ†é…ç­–ç•¥**ï¼š

```text
ç»„ä»¶                é¢„ç®—(ms)    å®é™…(ms)    ä½™é‡(ms)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
API Gateway         10          8           2
OTLP Collector      30          25          5
æ•°æ®å¤„ç†            20          18          2
æ•°æ®åº“æŸ¥è¯¢          25          22          3
ç½‘ç»œä¼ è¾“            15          12          3
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
æ€»è®¡                100         85          15
```

```rust
/// å»¶è¿Ÿé¢„ç®—ç®¡ç†å™¨
pub struct LatencyBudgetManager {
    components: Vec<LatencyComponent>,
    target_p99: Duration,
}

#[derive(Debug, Clone)]
pub struct LatencyComponent {
    name: String,
    budget: Duration,
    actual_p99: Duration,
}

impl LatencyBudgetManager {
    pub fn check_compliance(&self) -> BudgetReport {
        let mut total_budget = Duration::ZERO;
        let mut total_actual = Duration::ZERO;
        let mut violations = Vec::new();
        
        for comp in &self.components {
            total_budget += comp.budget;
            total_actual += comp.actual_p99;
            
            if comp.actual_p99 > comp.budget {
                violations.push(format!(
                    "{}: è¶…å‡º {}ms (é¢„ç®—: {}ms, å®é™…: {}ms)",
                    comp.name,
                    (comp.actual_p99 - comp.budget).as_millis(),
                    comp.budget.as_millis(),
                    comp.actual_p99.as_millis()
                ));
            }
        }
        
        BudgetReport {
            target: self.target_p99,
            total_budget,
            total_actual,
            compliant: total_actual <= self.target_p99 && violations.is_empty(),
            violations,
        }
    }
}

#[derive(Debug)]
pub struct BudgetReport {
    target: Duration,
    total_budget: Duration,
    total_actual: Duration,
    compliant: bool,
    violations: Vec<String>,
}

impl BudgetReport {
    pub fn print(&self) {
        println!("=== Latency Budget Report ===");
        println!("Target P99: {}ms", self.target.as_millis());
        println!("Total Budget: {}ms", self.total_budget.as_millis());
        println!("Total Actual: {}ms", self.total_actual.as_millis());
        println!("Margin: {}ms", 
                (self.target.as_millis() as i64 - self.total_actual.as_millis() as i64));
        
        if self.compliant {
            println!("âœ“ Within budget");
        } else {
            println!("âœ— Budget exceeded");
            println!("\nViolations:");
            for v in &self.violations {
                println!("  - {}", v);
            }
        }
    }
}
```

## 3. ååé‡æ¨¡å‹

### 3.1 Amdahl å®šå¾‹

**å®šç† 3.1ï¼ˆAmdahl's Lawï¼‰**ï¼š
å¦‚æœç¨‹åºä¸­æœ‰æ¯”ä¾‹ `p` å¯ä»¥å¹¶è¡ŒåŒ–ï¼Œä½¿ç”¨ `n` ä¸ªå¤„ç†å™¨ï¼ŒåŠ é€Ÿæ¯”ä¸ºï¼š

```text
Speedup(n) = 1 / ((1-p) + p/n)
```

**æ¨è®º**ï¼š

- å½“ `n â†’ âˆ` æ—¶ï¼Œ`Speedup_max = 1/(1-p)`
- å¦‚æœ 90% å¯å¹¶è¡Œï¼Œæœ€å¤§åŠ é€Ÿæ¯” = 10x
- å¦‚æœ 50% å¯å¹¶è¡Œï¼Œæœ€å¤§åŠ é€Ÿæ¯” = 2x

**å®é™…æ„ä¹‰**ï¼š
ä¸²è¡Œéƒ¨åˆ†é™åˆ¶äº†æ•´ä½“æ€§èƒ½æå‡ï¼

### 3.2 Universal Scalability Law (USL)

è€ƒè™‘å¹¶å‘å¼€é”€å’Œä¸€è‡´æ€§å¼€é”€ï¼š

```text
Throughput(n) = n / (1 + Î±(n-1) + Î²n(n-1))
```

å…¶ä¸­ï¼š

- `n`: å¹¶å‘æ•°
- `Î±`: ç«äº‰ç³»æ•°ï¼ˆé”ç«äº‰ç­‰ï¼‰
- `Î²`: ä¸€è‡´æ€§ç³»æ•°ï¼ˆç¼“å­˜ä¸€è‡´æ€§ç­‰ï¼‰

**ç‰¹æ€§**ï¼š

- å½“ `Î² = 0` æ—¶ï¼Œé€€åŒ–ä¸º Amdahl å®šå¾‹
- å½“ `Î² > 0` æ—¶ï¼Œååé‡ä¼šåœ¨æŸä¸ªç‚¹åä¸‹é™

```rust
/// Universal Scalability Law æ¨¡å‹
pub struct UslModel {
    alpha: f64,  // ç«äº‰ç³»æ•°
    beta: f64,   // ä¸€è‡´æ€§ç³»æ•°
}

impl UslModel {
    pub fn new(alpha: f64, beta: f64) -> Self {
        Self { alpha, beta }
    }
    
    /// è®¡ç®—ååé‡
    pub fn throughput(&self, concurrency: f64) -> f64 {
        let n = concurrency;
        n / (1.0 + self.alpha * (n - 1.0) + self.beta * n * (n - 1.0))
    }
    
    /// è®¡ç®—ç›¸å¯¹äºå•çº¿ç¨‹çš„åŠ é€Ÿæ¯”
    pub fn speedup(&self, concurrency: f64) -> f64 {
        self.throughput(concurrency) / self.throughput(1.0)
    }
    
    /// æ‰¾åˆ°æœ€ä¼˜å¹¶å‘æ•°
    pub fn optimal_concurrency(&self) -> f64 {
        if self.beta == 0.0 {
            return f64::INFINITY;
        }
        ((1.0 - self.alpha) / self.beta).sqrt()
    }
    
    /// æ‹Ÿåˆå®éªŒæ•°æ®
    pub fn fit(measurements: &[(f64, f64)]) -> Self {
        // ä½¿ç”¨æœ€å°äºŒä¹˜æ³•æ‹Ÿåˆ Î± å’Œ Î²
        // ç®€åŒ–ç‰ˆæœ¬ï¼šå‡è®¾å·²çŸ¥
        Self {
            alpha: 0.05,  // 5% ç«äº‰å¼€é”€
            beta: 0.001,  // 0.1% ä¸€è‡´æ€§å¼€é”€
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn analyze_scalability() {
    let model = UslModel::new(0.05, 0.001);
    
    println!("å¹¶å‘æ•°\tååé‡\tåŠ é€Ÿæ¯”");
    println!("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    
    for n in [1, 2, 4, 8, 16, 32, 64].iter() {
        let throughput = model.throughput(*n as f64);
        let speedup = model.speedup(*n as f64);
        println!("{}\t{:.2}\t{:.2}x", n, throughput, speedup);
    }
    
    let optimal = model.optimal_concurrency();
    println!("\næœ€ä¼˜å¹¶å‘æ•°: {:.0}", optimal);
}
```

**è¾“å‡ºç¤ºä¾‹**ï¼š

```text
å¹¶å‘æ•°    ååé‡    åŠ é€Ÿæ¯”
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1       1.00    1.00x
2       1.91    1.91x
4       3.51    3.51x
8       6.10    6.10x
16      9.76    9.76x
32      13.79   13.79x
64      15.24   15.24x

æœ€ä¼˜å¹¶å‘æ•°: 31
```

## 4. èµ„æºåˆ©ç”¨ç‡æ¨¡å‹

### 4.1 CPU åˆ©ç”¨ç‡

**åˆ©ç”¨ç‡å®šå¾‹**ï¼š

```text
U = Î» Ã— S

å…¶ä¸­ï¼š
- U: CPU åˆ©ç”¨ç‡
- Î»: è¯·æ±‚åˆ°è¾¾ç‡
- S: å¹³å‡æœåŠ¡æ—¶é—´
```

**æ¨è®º**ï¼š

```text
å“åº”æ—¶é—´ R = S / (1 - U)

å½“ U â†’ 1 æ—¶ï¼ŒR â†’ âˆ
```

### 4.2 å†…å­˜ä½¿ç”¨æ¨¡å‹

**å·¥ä½œé›†æ¨¡å‹**ï¼š

```text
M(t) = f(W(t))

å…¶ä¸­ï¼š
- M(t): æ—¶åˆ» t çš„å†…å­˜ä½¿ç”¨
- W(t): å·¥ä½œé›†å¤§å°
- f: æ˜ å°„å‡½æ•°
```

å¯¹äº OTLP ç³»ç»Ÿï¼š

```text
M = M_base + n_connections Ã— M_conn + n_spans Ã— M_span

å…¶ä¸­ï¼š
- M_base: åŸºç¡€å†…å­˜
- n_connections: è¿æ¥æ•°
- M_conn: æ¯ä¸ªè¿æ¥çš„å†…å­˜
- n_spans: å†…å­˜ä¸­çš„ span æ•°
- M_span: æ¯ä¸ª span çš„å†…å­˜
```

### 4.3 èµ„æºå®¹é‡è§„åˆ’

```rust
/// å®¹é‡è§„åˆ’æ¨¡å‹
pub struct CapacityPlanner {
    // å•æœºå®¹é‡
    cpu_cores: usize,
    memory_gb: f64,
    disk_iops: usize,
    network_mbps: f64,
    
    // èµ„æºæ¶ˆè€—
    cpu_per_request: f64,      // CPU ms per request
    memory_per_span: f64,       // MB per span
    disk_per_span: f64,         // KB per span
    network_per_request: f64,   // KB per request
}

impl CapacityPlanner {
    /// è®¡ç®—æœ€å¤§ååé‡
    pub fn max_throughput(&self) -> Throughput {
        // åŸºäºå„é¡¹èµ„æºè®¡ç®—ä¸Šé™
        let cpu_limit = (self.cpu_cores as f64 * 1000.0) 
                       / self.cpu_per_request;
        
        let memory_limit = (self.memory_gb * 1024.0 * 0.8)  // 80% å¯ç”¨
                          / self.memory_per_span;
        
        let disk_limit = (self.disk_iops as f64 * self.disk_per_span)
                        / 1024.0;  // Convert to MB/s
        
        let network_limit = (self.network_mbps * 1024.0)
                           / self.network_per_request;
        
        Throughput {
            cpu_bound: cpu_limit,
            memory_bound: memory_limit,
            disk_bound: disk_limit,
            network_bound: network_limit,
            bottleneck: self.identify_bottleneck(
                cpu_limit, memory_limit, disk_limit, network_limit
            ),
        }
    }
    
    fn identify_bottleneck(&self, cpu: f64, mem: f64, disk: f64, net: f64) 
        -> String {
        let min = cpu.min(mem).min(disk).min(net);
        
        if (min - cpu).abs() < 0.01 {
            "CPU".to_string()
        } else if (min - mem).abs() < 0.01 {
            "Memory".to_string()
        } else if (min - disk).abs() < 0.01 {
            "Disk".to_string()
        } else {
            "Network".to_string()
        }
    }
    
    /// è®¡ç®—éœ€è¦å¤šå°‘å°æœåŠ¡å™¨
    pub fn servers_needed(&self, target_rps: f64, redundancy: f64) -> usize {
        let max_rps = self.max_throughput().bottleneck_value();
        let servers = (target_rps / max_rps * (1.0 + redundancy)).ceil() as usize;
        servers.max(2)  // è‡³å°‘2å°ä»¥ä¿è¯é«˜å¯ç”¨
    }
}

#[derive(Debug)]
pub struct Throughput {
    cpu_bound: f64,
    memory_bound: f64,
    disk_bound: f64,
    network_bound: f64,
    bottleneck: String,
}

impl Throughput {
    pub fn bottleneck_value(&self) -> f64 {
        match self.bottleneck.as_str() {
            "CPU" => self.cpu_bound,
            "Memory" => self.memory_bound,
            "Disk" => self.disk_bound,
            "Network" => self.network_bound,
            _ => 0.0,
        }
    }
    
    pub fn print(&self) {
        println!("=== Capacity Analysis ===");
        println!("CPU bound: {:.0} RPS", self.cpu_bound);
        println!("Memory bound: {:.0} spans/s", self.memory_bound);
        println!("Disk bound: {:.0} spans/s", self.disk_bound);
        println!("Network bound: {:.0} RPS", self.network_bound);
        println!("\nğŸ” Bottleneck: {}", self.bottleneck);
        println!("Max throughput: {:.0}", self.bottleneck_value());
    }
}
```

## 5. æ€§èƒ½ä¼˜åŒ–ç†è®º

### 5.1 è¾¹é™…æ•ˆç›Šé€’å‡

**å®šç† 5.1ï¼ˆè¾¹é™…æ•ˆç›Šé€’å‡ï¼‰**ï¼š
æ¯æ¬¡ä¼˜åŒ–çš„æ”¶ç›Šä¼šé€’å‡ã€‚

```text
è®¾ç¬¬ n æ¬¡ä¼˜åŒ–åçš„æ€§èƒ½ä¸º P(n)ï¼Œåˆ™ï¼š
P(n) - P(n-1) < P(n-1) - P(n-2)
```

**å®è·µå¯ç¤º**ï¼š

- ä¼˜å…ˆä¼˜åŒ–æœ€å¤§ç“¶é¢ˆ
- ä¸è¦è¿‡åº¦ä¼˜åŒ–éç“¶é¢ˆéƒ¨åˆ†
- å¹³è¡¡å¼€å‘æˆæœ¬å’Œä¼˜åŒ–æ”¶ç›Š

### 5.2 80/20 æ³•åˆ™

**ç»éªŒæ³•åˆ™**ï¼š

- 80% çš„æ€§èƒ½é—®é¢˜ç”± 20% çš„ä»£ç é€ æˆ
- ä¼˜åŒ–è¿™ 20% çš„ä»£ç å¯è·å¾— 80% çš„æ”¶ç›Š

**åº”ç”¨**ï¼š

1. ä½¿ç”¨æ€§èƒ½åˆ†æå·¥å…·æ‰¾åˆ°çƒ­ç‚¹
2. ä¸“æ³¨ä¼˜åŒ–çƒ­ç‚¹ä»£ç 
3. é¿å…è¿‡æ—©ä¼˜åŒ–

## 6. æ€»ç»“

æœ¬æ–‡æ¡£æä¾›äº†å®Œæ•´çš„æ€§èƒ½æ•°å­¦æ¨¡å‹ï¼š

âœ… **æ’é˜Ÿè®º**ï¼šM/M/1 å’Œ M/M/c æ¨¡å‹  
âœ… **å»¶è¿Ÿåˆ†æ**ï¼šå»¶è¿Ÿåˆ†è§£å’Œç™¾åˆ†ä½æ•°  
âœ… **ååé‡**ï¼šAmdahl å®šå¾‹å’Œ USL  
âœ… **èµ„æºæ¨¡å‹**ï¼šåˆ©ç”¨ç‡å’Œå®¹é‡è§„åˆ’  
âœ… **ä¼˜åŒ–ç†è®º**ï¼šè¾¹é™…æ•ˆç›Šå’Œ 80/20 æ³•åˆ™  

è¿™äº›æ¨¡å‹ä¸º OTLP ç³»ç»Ÿçš„æ€§èƒ½åˆ†æå’Œä¼˜åŒ–æä¾›äº†ç†è®ºåŸºç¡€ã€‚

## å‚è€ƒæ–‡çŒ®

1. Kleinrock, L. (1975). "Queueing Systems, Volume 1: Theory"
2. Amdahl, G. M. (1967). "Validity of the Single Processor Approach"
3. Gunther, N. J. (2007). "Guerrilla Capacity Planning"
4. Little, J. D. C. (1961). "A Proof for the Queuing Formula: L = Î»W"
