# 因果关系与偏序理论

## 目录

- [因果关系与偏序理论](#因果关系与偏序理论)
  - [目录](#目录)
  - [概述](#概述)
  - [基础定义](#基础定义)
    - [事件与进程](#事件与进程)
    - [Happens-Before 关系](#happens-before-关系)
    - [并发关系](#并发关系)
  - [Lamport 时钟](#lamport-时钟)
    - [逻辑时钟定义](#逻辑时钟定义)
    - [时钟更新规则](#时钟更新规则)
    - [正确性证明](#正确性证明)
    - [Rust 实现](#rust-实现)
  - [向量时钟 (Vector Clock)](#向量时钟-vector-clock)
    - [向量时钟定义](#向量时钟定义)
    - [向量时钟操作](#向量时钟操作)
    - [因果关系判定](#因果关系判定)
    - [正确性证明1](#正确性证明1)
    - [Rust 实现1](#rust-实现1)
  - [偏序与全序](#偏序与全序)
    - [偏序性质](#偏序性质)
    - [全序化算法](#全序化算法)
    - [一致性保证](#一致性保证)
  - [因果一致性](#因果一致性)
    - [因果一致性定义](#因果一致性定义)
    - [实现机制](#实现机制)
    - [性能分析](#性能分析)
  - [在 OTLP 中的应用](#在-otlp-中的应用)
    - [Span 因果关系](#span-因果关系)
    - [分布式追踪排序](#分布式追踪排序)
    - [异常检测](#异常检测)
  - [参考文献](#参考文献)

## 概述

因果关系是分布式系统中最基本的概念之一。在 OTLP 分布式追踪系统中，正确理解和维护事件之间的因果关系对于准确重建系统行为至关重要。

**核心问题**：

- 如何在没有全局时钟的情况下确定事件顺序？
- 如何判断两个事件是否存在因果关系？
- 如何高效地维护和查询因果关系？

## 基础定义

### 事件与进程

**定义 1 (进程)**：进程 \( P_i \) 是一个事件序列：

\[
P_i = \langle e_i^1, e_i^2, e_i^3, \ldots \rangle
\]

其中 \( e_i^k \) 表示进程 \( P_i \) 的第 \( k \) 个事件。

**定义 2 (事件类型)**：

- **本地事件**：只影响单个进程的事件
- **发送事件**：向其他进程发送消息的事件
- **接收事件**：从其他进程接收消息的事件

### Happens-Before 关系

**定义 3 (Happens-Before 关系 →)**：

Happens-before 关系 \( \rightarrow \) 是满足以下条件的最小关系：

1. **同进程顺序**：如果 \( a \) 和 \( b \) 是同一进程中的事件，且 \( a \) 在 \( b \) 之前发生，则 \( a \rightarrow b \)

2. **消息传递**：如果 \( a \) 是发送消息 \( m \) 的事件，\( b \) 是接收消息 \( m \) 的事件，则 \( a \rightarrow b \)

3. **传递性**：如果 \( a \rightarrow b \) 且 \( b \rightarrow c \)，则 \( a \rightarrow c \)

**性质**：

- **非自反性**：\( \neg (a \rightarrow a) \)
- **反对称性**：如果 \( a \rightarrow b \)，则 \( \neg (b \rightarrow a) \)
- **传递性**：如果 \( a \rightarrow b \) 且 \( b \rightarrow c \)，则 \( a \rightarrow c \)

因此，happens-before 是一个**严格偏序关系**。

### 并发关系

**定义 4 (并发关系 ||)**：

两个事件 \( a \) 和 \( b \) 是并发的，记作 \( a \parallel b \)，当且仅当：

\[
\neg (a \rightarrow b) \land \neg (b \rightarrow a)
\]

**重要性质**：

- 并发事件可能以任意顺序被观察到
- 并发事件的相对顺序不影响系统正确性（在因果一致性模型下）

## Lamport 时钟

### 逻辑时钟定义

**定义 5 (Lamport 逻辑时钟)**：

为每个进程 \( P_i \) 维护一个逻辑时钟 \( C_i \)，满足：

**时钟条件**：如果 \( a \rightarrow b \)，则 \( C(a) < C(b) \)

注意：逆命题不成立，即 \( C(a) < C(b) \) 不能推出 \( a \rightarrow b \)。

### 时钟更新规则

**规则 IR1**：进程 \( P_i \) 在两个连续事件之间递增 \( C_i \)：

\[
C_i := C_i + 1
\]

**规则 IR2**：

- 当进程 \( P_i \) 发送消息 \( m \) 时，将 \( C_i \) 的值附加到消息中：\( m.timestamp = C_i \)
- 当进程 \( P_j \) 接收消息 \( m \) 时：

\[
C_j := \max(C_j, m.timestamp) + 1
\]

### 正确性证明

**定理 1**：Lamport 时钟满足时钟条件。

**证明**：

分三种情况：

1. **同进程内的连续事件**：
   - 设 \( a \) 和 \( b \) 是进程 \( P_i \) 中的连续事件，\( a \) 在 \( b \) 之前
   - 根据规则 IR1，\( C_i \) 在 \( a \) 和 \( b \) 之间递增
   - 因此 \( C(a) < C(b) \)

2. **消息发送和接收**：
   - 设 \( a \) 是发送消息 \( m \) 的事件，\( b \) 是接收消息 \( m \) 的事件
   - 根据规则 IR2，\( C(b) = \max(C_j, m.timestamp) + 1 \geq m.timestamp + 1 = C(a) + 1 \)
   - 因此 \( C(a) < C(b) \)

3. **传递性**：
   - 设 \( a \rightarrow b \) 且 \( b \rightarrow c \)
   - 根据前两种情况，\( C(a) < C(b) \) 且 \( C(b) < C(c) \)
   - 因此 \( C(a) < C(c) \)

综上，时钟条件得证。∎

### Rust 实现

```rust
use std::sync::atomic::{AtomicU64, Ordering};

/// Lamport 逻辑时钟
pub struct LamportClock {
    counter: AtomicU64,
}

impl LamportClock {
    pub fn new() -> Self {
        Self {
            counter: AtomicU64::new(0),
        }
    }

    /// 本地事件：递增时钟
    pub fn tick(&self) -> u64 {
        self.counter.fetch_add(1, Ordering::SeqCst)
    }

    /// 发送事件：获取当前时间戳
    pub fn send(&self) -> u64 {
        self.tick()
    }

    /// 接收事件：更新时钟
    pub fn receive(&self, message_timestamp: u64) -> u64 {
        let mut current = self.counter.load(Ordering::SeqCst);
        loop {
            let new_value = current.max(message_timestamp) + 1;
            match self.counter.compare_exchange(
                current,
                new_value,
                Ordering::SeqCst,
                Ordering::SeqCst,
            ) {
                Ok(_) => return new_value,
                Err(actual) => current = actual,
            }
        }
    }

    /// 获取当前时钟值
    pub fn now(&self) -> u64 {
        self.counter.load(Ordering::SeqCst)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_lamport_clock_monotonic() {
        let clock = LamportClock::new();
        let t1 = clock.tick();
        let t2 = clock.tick();
        assert!(t1 < t2, "时钟应该单调递增");
    }

    #[test]
    fn test_lamport_clock_message_passing() {
        let clock_a = LamportClock::new();
        let clock_b = LamportClock::new();

        // A 发送消息
        let _ = clock_a.tick();
        let send_time = clock_a.send();

        // B 接收消息
        let receive_time = clock_b.receive(send_time);

        assert!(send_time < receive_time, "接收时间应该大于发送时间");
    }
}
```

## 向量时钟 (Vector Clock)

### 向量时钟定义

**定义 6 (向量时钟)**：

对于 \( n \) 个进程的系统，进程 \( P_i \) 的向量时钟 \( VC_i \) 是一个长度为 \( n \) 的向量：

\[
VC_i = [c_1, c_2, \ldots, c_n]
\]

其中 \( c_j \) 表示进程 \( P_i \) 已知的进程 \( P_j \) 的逻辑时间。

### 向量时钟操作

**初始化**：
\[
VC_i[j] = 0, \quad \forall j \in [1, n]
\]

**本地事件**：
\[
VC_i[i] := VC_i[i] + 1
\]

**发送消息**：

- 递增本地时钟：\( VC_i[i] := VC_i[i] + 1 \)
- 将 \( VC_i \) 附加到消息中

**接收消息**：

- 更新向量时钟：\( VC_i[j] := \max(VC_i[j], VC_m[j]), \quad \forall j \)
- 递增本地时钟：\( VC_i[i] := VC_i[i] + 1 \)

### 因果关系判定

**定义 7 (向量时钟偏序)**：

对于向量时钟 \( VC_a \) 和 \( VC_b \)：

\[
VC_a \leq VC_b \iff \forall i: VC_a[i] \leq VC_b[i]
\]

\[
VC_a < VC_b \iff (VC_a \leq VC_b) \land (VC_a \neq VC_b)
\]

**定理 2 (向量时钟正确性)**：

\[
a \rightarrow b \iff VC(a) < VC(b)
\]

这意味着向量时钟可以**完全刻画** happens-before 关系。

### 正确性证明1

**证明**：

**充分性** (\( a \rightarrow b \Rightarrow VC(a) < VC(b) \))：

对 happens-before 关系的定义进行归纳：

1. **基础情况**：同进程内的连续事件
   - 设 \( a \) 和 \( b \) 是进程 \( P_i \) 的连续事件
   - \( VC[b](i) = VC[a](i) + 1 \)
   - \( VC[b](j) = VC[a](j), \quad \forall j \neq i \)
   - 因此 \( VC(a) < VC(b) \)

2. **消息传递**：
   - 设 \( a \) 是发送事件，\( b \) 是接收事件
   - 接收时：\( VC[b](j) = \max(VC_b[j], VC_m[j]) \geq VC_m[j] = VC[a](j), \quad \forall j \)
   - 且 \( VC[b](i) = VC_b[i] + 1 > VC_b[i] \geq VC[a](i) \)
   - 因此 \( VC(a) < VC(b) \)

3. **传递性**：
   - 设 \( a \rightarrow b \) 且 \( b \rightarrow c \)
   - 由归纳假设，\( VC(a) < VC(b) \) 且 \( VC(b) < VC(c) \)
   - 因此 \( VC(a) < VC(c) \)

**必要性** (\( VC(a) < VC(b) \Rightarrow a \rightarrow b \))：

反证法：假设 \( VC(a) < VC(b) \) 但 \( \neg (a \rightarrow b) \)

- 如果 \( \neg (a \rightarrow b) \)，则 \( a \) 和 \( b \) 要么并发，要么 \( b \rightarrow a \)
- 如果 \( a \parallel b \)，则存在某个 \( i \) 使得 \( VC[a](i) > VC[b](i) \)，与 \( VC(a) < VC(b) \) 矛盾
- 如果 \( b \rightarrow a \)，由充分性得 \( VC(b) < VC(a) \)，与 \( VC(a) < VC(b) \) 矛盾

因此必要性得证。∎

### Rust 实现1

```rust
use std::collections::HashMap;
use std::cmp::Ordering as CmpOrdering;

/// 向量时钟
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct VectorClock {
    /// 进程 ID -> 时钟值
    clocks: HashMap<String, u64>,
    /// 当前进程 ID
    process_id: String,
}

impl VectorClock {
    pub fn new(process_id: String) -> Self {
        let mut clocks = HashMap::new();
        clocks.insert(process_id.clone(), 0);
        Self { clocks, process_id }
    }

    /// 本地事件：递增本地时钟
    pub fn tick(&mut self) {
        *self.clocks.entry(self.process_id.clone()).or_insert(0) += 1;
    }

    /// 发送事件：递增并返回当前向量时钟
    pub fn send(&mut self) -> VectorClock {
        self.tick();
        self.clone()
    }

    /// 接收事件：合并向量时钟
    pub fn receive(&mut self, other: &VectorClock) {
        for (process, &timestamp) in &other.clocks {
            let entry = self.clocks.entry(process.clone()).or_insert(0);
            *entry = (*entry).max(timestamp);
        }
        self.tick();
    }

    /// 判断因果关系
    pub fn happens_before(&self, other: &VectorClock) -> bool {
        // self < other: self 的所有分量 <= other，且至少有一个分量 <
        let mut all_less_or_equal = true;
        let mut at_least_one_less = false;

        // 检查 self 中的所有进程
        for (process, &self_time) in &self.clocks {
            let other_time = other.clocks.get(process).copied().unwrap_or(0);
            if self_time > other_time {
                all_less_or_equal = false;
                break;
            }
            if self_time < other_time {
                at_least_one_less = true;
            }
        }

        // 检查 other 中存在但 self 中不存在的进程
        for (process, &other_time) in &other.clocks {
            if !self.clocks.contains_key(process) && other_time > 0 {
                at_least_one_less = true;
            }
        }

        all_less_or_equal && at_least_one_less
    }

    /// 判断并发关系
    pub fn is_concurrent(&self, other: &VectorClock) -> bool {
        !self.happens_before(other) && !other.happens_before(self)
    }

    /// 比较两个向量时钟
    pub fn partial_cmp(&self, other: &VectorClock) -> Option<CmpOrdering> {
        if self == other {
            Some(CmpOrdering::Equal)
        } else if self.happens_before(other) {
            Some(CmpOrdering::Less)
        } else if other.happens_before(self) {
            Some(CmpOrdering::Greater)
        } else {
            None // 并发
        }
    }

    /// 获取指定进程的时钟值
    pub fn get(&self, process_id: &str) -> u64 {
        self.clocks.get(process_id).copied().unwrap_or(0)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vector_clock_causality() {
        let mut vc_a = VectorClock::new("A".to_string());
        let mut vc_b = VectorClock::new("B".to_string());

        // A 发生本地事件
        vc_a.tick();
        assert_eq!(vc_a.get("A"), 1);

        // A 发送消息给 B
        let msg = vc_a.send();
        assert_eq!(msg.get("A"), 2);

        // B 接收消息
        vc_b.receive(&msg);
        assert_eq!(vc_b.get("A"), 2);
        assert_eq!(vc_b.get("B"), 1);

        // 验证因果关系
        assert!(msg.happens_before(&vc_b), "发送应该 happens-before 接收");
    }

    #[test]
    fn test_vector_clock_concurrency() {
        let mut vc_a = VectorClock::new("A".to_string());
        let mut vc_b = VectorClock::new("B".to_string());

        // A 和 B 各自发生本地事件
        vc_a.tick();
        vc_b.tick();

        // 它们应该是并发的
        assert!(vc_a.is_concurrent(&vc_b), "独立事件应该是并发的");
    }
}
```

## 偏序与全序

### 偏序性质

Happens-before 关系定义了事件的**偏序**：

- **自反性**：\( a \leq a \) (如果包含相等)
- **反对称性**：如果 \( a \leq b \) 且 \( b \leq a \)，则 \( a = b \)
- **传递性**：如果 \( a \leq b \) 且 \( b \leq c \)，则 \( a \leq c \)

但并非所有事件对都可比较（存在并发事件），因此不是全序。

### 全序化算法

**目标**：将偏序扩展为全序，同时保持因果关系。

**算法**：使用 Lamport 时间戳打破并发事件的平局：

\[
a <_{total} b \iff (C(a) < C(b)) \lor (C(a) = C(b) \land P_a < P_b)
\]

其中 \( P_a \) 和 \( P_b \) 是进程 ID。

**性质**：

- 如果 \( a \rightarrow b \)，则 \( a <_{total} b \)
- 对于任意两个事件 \( a \) 和 \( b \)，要么 \( a <_{total} b \)，要么 \( b <_{total} a \)

### 一致性保证

**定理 3**：全序化算法保持因果一致性。

**证明**：

如果 \( a \rightarrow b \)，根据 Lamport 时钟的时钟条件，\( C(a) < C(b) \)，因此 \( a <_{total} b \)。∎

## 因果一致性

### 因果一致性定义

**定义 8 (因果一致性)**：

一个系统满足因果一致性，当且仅当：

\[
\forall a, b: a \rightarrow b \Rightarrow \text{所有进程以相同顺序观察到 } a \text{ 和 } b
\]

**更强的定义**：

- 如果写操作 \( W(x) \) happens-before 读操作 \( R(x) \)，则 \( R(x) \) 必须读取 \( W(x) \) 或更新的值
- 并发写操作可以被不同进程以不同顺序观察到

### 实现机制

**基于向量时钟的因果一致性协议**：

1. **写操作**：
   - 递增本地向量时钟
   - 将数据和向量时钟一起传播

2. **读操作**：
   - 只读取满足因果依赖的数据
   - 即：数据的向量时钟 \( \leq \) 本地向量时钟

3. **缓冲机制**：
   - 缓冲因果依赖未满足的数据
   - 当依赖满足时再应用

```rust
use std::collections::{HashMap, VecDeque};

/// 因果一致性存储
pub struct CausalStore {
    /// 本地向量时钟
    clock: VectorClock,
    /// 已提交的数据
    committed: HashMap<String, (String, VectorClock)>,
    /// 等待因果依赖的数据
    pending: VecDeque<(String, String, VectorClock)>,
}

impl CausalStore {
    pub fn new(process_id: String) -> Self {
        Self {
            clock: VectorClock::new(process_id),
            committed: HashMap::new(),
            pending: VecDeque::new(),
        }
    }

    /// 本地写操作
    pub fn write(&mut self, key: String, value: String) {
        self.clock.tick();
        self.committed.insert(key, (value, self.clock.clone()));
    }

    /// 接收远程写操作
    pub fn receive_write(&mut self, key: String, value: String, vc: VectorClock) {
        // 检查因果依赖是否满足
        if self.is_causally_ready(&vc) {
            self.apply_write(key, value, vc);
            self.process_pending();
        } else {
            // 缓冲等待
            self.pending.push_back((key, value, vc));
        }
    }

    /// 检查因果依赖是否满足
    fn is_causally_ready(&self, vc: &VectorClock) -> bool {
        vc.happens_before(&self.clock) || vc == &self.clock
    }

    /// 应用写操作
    fn apply_write(&mut self, key: String, value: String, vc: VectorClock) {
        self.clock.receive(&vc);
        self.committed.insert(key, (value, vc));
    }

    /// 处理等待队列
    fn process_pending(&mut self) {
        let mut i = 0;
        while i < self.pending.len() {
            let (key, value, vc) = &self.pending[i];
            if self.is_causally_ready(vc) {
                let (key, value, vc) = self.pending.remove(i).unwrap();
                self.apply_write(key, value, vc);
            } else {
                i += 1;
            }
        }
    }

    /// 读操作
    pub fn read(&self, key: &str) -> Option<&String> {
        self.committed.get(key).map(|(value, _)| value)
    }
}
```

### 性能分析

**时间复杂度**：

- 向量时钟更新：\( O(n) \)，其中 \( n \) 是进程数
- 因果依赖检查：\( O(n) \)
- 等待队列处理：\( O(m \cdot n) \)，其中 \( m \) 是等待队列长度

**空间复杂度**：

- 向量时钟：\( O(n) \) 每个事件
- 等待队列：\( O(m \cdot n) \)

**优化策略**：

- **向量时钟压缩**：只保留活跃进程的时钟
- **垃圾回收**：删除过时的向量时钟信息
- **混合时钟**：结合物理时钟和逻辑时钟

## 在 OTLP 中的应用

### Span 因果关系

在 OTLP 中，Span 之间的因果关系通过以下方式建立：

1. **父子关系**：`parent_span_id` 字段
2. **链接关系**：`links` 字段
3. **时间戳**：`start_time` 和 `end_time`

**向量时钟增强**：

```rust
use opentelemetry::trace::{Span, SpanContext};

/// 带向量时钟的 Span
pub struct CausalSpan {
    span: Box<dyn Span>,
    vector_clock: VectorClock,
}

impl CausalSpan {
    pub fn new(span: Box<dyn Span>, process_id: String) -> Self {
        Self {
            span,
            vector_clock: VectorClock::new(process_id),
        }
    }

    /// 开始 Span
    pub fn start(&mut self) {
        self.vector_clock.tick();
    }

    /// 传播向量时钟
    pub fn propagate(&mut self) -> VectorClock {
        self.vector_clock.send()
    }

    /// 接收父 Span 的向量时钟
    pub fn receive_parent(&mut self, parent_vc: &VectorClock) {
        self.vector_clock.receive(parent_vc);
    }
}
```

### 分布式追踪排序

使用向量时钟对 Span 进行因果排序：

```rust
use std::collections::HashMap;

/// Trace 排序器
pub struct TraceSorter {
    spans: HashMap<String, (opentelemetry_proto::tonic::trace::v1::Span, VectorClock)>,
}

impl TraceSorter {
    pub fn new() -> Self {
        Self {
            spans: HashMap::new(),
        }
    }

    /// 添加 Span
    pub fn add_span(
        &mut self,
        span: opentelemetry_proto::tonic::trace::v1::Span,
        vc: VectorClock,
    ) {
        self.spans.insert(hex::encode(&span.span_id), (span, vc));
    }

    /// 获取因果排序的 Span 列表
    pub fn get_sorted_spans(&self) -> Vec<&opentelemetry_proto::tonic::trace::v1::Span> {
        let mut spans: Vec<_> = self.spans.values().collect();

        // 使用向量时钟排序
        spans.sort_by(|a, b| {
            a.1.partial_cmp(&b.1)
                .unwrap_or(std::cmp::Ordering::Equal)
        });

        spans.iter().map(|(span, _)| *span).collect()
    }

    /// 检测因果异常
    pub fn detect_anomalies(&self) -> Vec<String> {
        let mut anomalies = Vec::new();

        for (span_id, (span, vc)) in &self.spans {
            // 检查父 Span 的因果关系
            if !span.parent_span_id.is_empty() {
                let parent_id = hex::encode(&span.parent_span_id);
                if let Some((_, parent_vc)) = self.spans.get(&parent_id) {
                    if !parent_vc.happens_before(vc) {
                        anomalies.push(format!(
                            "因果异常: Span {} 的父 Span {} 不满足 happens-before 关系",
                            span_id, parent_id
                        ));
                    }
                }
            }
        }

        anomalies
    }
}
```

### 异常检测

使用因果关系检测追踪异常：

1. **时间戳不一致**：子 Span 的开始时间早于父 Span
2. **因果违反**：Span 的向量时钟与父子关系不一致
3. **丢失 Span**：因果链中缺失的 Span

```rust
/// 因果异常检测器
pub struct CausalAnomalyDetector;

impl CausalAnomalyDetector {
    /// 检测时间戳异常
    pub fn detect_timestamp_anomaly(
        parent: &opentelemetry_proto::tonic::trace::v1::Span,
        child: &opentelemetry_proto::tonic::trace::v1::Span,
    ) -> Option<String> {
        if child.start_time_unix_nano < parent.start_time_unix_nano {
            return Some(format!(
                "时间戳异常: 子 Span 开始时间 {} 早于父 Span {}",
                child.start_time_unix_nano, parent.start_time_unix_nano
            ));
        }
        None
    }

    /// 检测因果违反
    pub fn detect_causality_violation(
        parent_vc: &VectorClock,
        child_vc: &VectorClock,
    ) -> Option<String> {
        if !parent_vc.happens_before(child_vc) && parent_vc != child_vc {
            return Some(format!(
                "因果违反: 父 Span 的向量时钟 {:?} 不 happens-before 子 Span {:?}",
                parent_vc, child_vc
            ));
        }
        None
    }

    /// 检测丢失 Span
    pub fn detect_missing_spans(
        spans: &HashMap<String, VectorClock>,
    ) -> Vec<String> {
        let mut missing = Vec::new();

        for (span_id, vc) in spans {
            // 检查向量时钟中引用的所有进程是否都有对应的 Span
            for process_id in vc.clocks.keys() {
                if !spans.contains_key(process_id) {
                    missing.push(format!(
                        "丢失 Span: Span {} 引用的进程 {} 没有对应的 Span",
                        span_id, process_id
                    ));
                }
            }
        }

        missing
    }
}
```

## 参考文献

1. **Lamport, L.** (1978). "Time, Clocks, and the Ordering of Events in a Distributed System". _Communications of the ACM_, 21(7), 558-565.

2. **Fidge, C. J.** (1988). "Timestamps in Message-Passing Systems That Preserve the Partial Ordering". _Proceedings of the 11th Australian Computer Science Conference_, 56-66.

3. **Mattern, F.** (1989). "Virtual Time and Global States of Distributed Systems". _Parallel and Distributed Algorithms_, 215-226.

4. **Schwarz, R., & Mattern, F.** (1994). "Detecting Causal Relationships in Distributed Computations: In Search of the Holy Grail". _Distributed Computing_, 7(3), 149-174.

5. **Raynal, M., & Singhal, M.** (1996). "Logical Time: Capturing Causality in Distributed Systems". _Computer_, 29(2), 49-56.

6. **OpenTelemetry Specification** - Trace Semantic Conventions: <https://opentelemetry.io/docs/specs/otel/trace/semantic_conventions/>

---

_本文档提供了因果关系与偏序理论的完整形式化定义、证明和实现，为 OTLP 分布式追踪系统提供了坚实的理论基础。_
