# ç®—æ³•åˆ†æ

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†åˆ†æäº†OTLP Rusté¡¹ç›®ä¸­çš„æ ¸å¿ƒç®—æ³•è®¾è®¡ï¼ŒåŒ…æ‹¬å¤æ‚åº¦åˆ†æã€æ€§èƒ½åŸºå‡†æµ‹è¯•ã€ä¼˜åŒ–ç­–ç•¥ç­‰å†…å®¹ã€‚

**åˆ›å»ºæ—¶é—´**: 2025å¹´9æœˆ26æ—¥  
**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**ç»´æŠ¤è€…**: OTLPç®—æ³•å›¢é˜Ÿ  

## ğŸ¯ æ ¸å¿ƒç®—æ³•æ¦‚è§ˆ

### 1. æ‰¹å¤„ç†ç®—æ³•

- **æ—¶é—´å¤æ‚åº¦**: O(1) æ·»åŠ ï¼ŒO(n) æ‰¹å¤„ç†
- **ç©ºé—´å¤æ‚åº¦**: O(n) ç¼“å†²åŒºå¤§å°
- **ä¼˜åŒ–ç­–ç•¥**: è‡ªé€‚åº”æ‰¹å¤„ç†å¤§å°
- **åº”ç”¨åœºæ™¯**: é«˜ååé‡æ•°æ®æ”¶é›†

### 2. é‡‡æ ·ç®—æ³•

- **æ—¶é—´å¤æ‚åº¦**: O(1) é‡‡æ ·å†³ç­–
- **ç©ºé—´å¤æ‚åº¦**: O(1) å¸¸é‡ç©ºé—´
- **ä¼˜åŒ–ç­–ç•¥**: è‡ªé€‚åº”é‡‡æ ·ç‡
- **åº”ç”¨åœºæ™¯**: å¤§è§„æ¨¡åˆ†å¸ƒå¼ç³»ç»Ÿ

### 3. å‹ç¼©ç®—æ³•

- **æ—¶é—´å¤æ‚åº¦**: O(n) å‹ç¼©ï¼ŒO(n) è§£å‹
- **ç©ºé—´å¤æ‚åº¦**: O(n) å‹ç¼©ç¼“å†²åŒº
- **ä¼˜åŒ–ç­–ç•¥**: å¤šçº§å‹ç¼©
- **åº”ç”¨åœºæ™¯**: ç½‘ç»œä¼ è¾“ä¼˜åŒ–

### 4. å¹¶å‘æ§åˆ¶ç®—æ³•

- **æ—¶é—´å¤æ‚åº¦**: O(1) æ— é”æ“ä½œ
- **ç©ºé—´å¤æ‚åº¦**: O(n) é˜Ÿåˆ—å¤§å°
- **ä¼˜åŒ–ç­–ç•¥**: æ— é”æ•°æ®ç»“æ„
- **åº”ç”¨åœºæ™¯**: é«˜å¹¶å‘å¤„ç†

## ğŸ—ï¸ ç®—æ³•è®¾è®¡æ¨¡å¼

### 1. å»ºé€ è€…æ¨¡å¼ (Builder Pattern)

#### æ‰¹å¤„ç†é…ç½®æ„å»º

```rust
pub struct BatchConfigBuilder {
    max_batch_size: Option<usize>,
    export_timeout: Option<Duration>,
    max_queue_size: Option<usize>,
    scheduled_delay: Option<Duration>,
}

impl BatchConfigBuilder {
    pub fn new() -> Self {
        Self {
            max_batch_size: None,
            export_timeout: None,
            max_queue_size: None,
            scheduled_delay: None,
        }
    }
    
    pub fn with_max_batch_size(mut self, size: usize) -> Self {
        self.max_batch_size = Some(size);
        self
    }
    
    pub fn with_export_timeout(mut self, timeout: Duration) -> Self {
        self.export_timeout = Some(timeout);
        self
    }
    
    pub fn build(self) -> BatchConfig {
        BatchConfig {
            max_export_batch_size: self.max_batch_size.unwrap_or(512),
            export_timeout: self.export_timeout.unwrap_or(Duration::from_millis(5000)),
            max_queue_size: self.max_queue_size.unwrap_or(2048),
            scheduled_delay: self.scheduled_delay.unwrap_or(Duration::from_millis(5000)),
        }
    }
}
```

### 2. ç­–ç•¥æ¨¡å¼ (Strategy Pattern)

#### é‡‡æ ·ç­–ç•¥é€‰æ‹©

```rust
pub trait SamplingStrategy {
    fn should_sample(&self, trace_id: &str, attributes: &HashMap<String, String>) -> bool;
    fn get_sampling_rate(&self) -> f64;
}

pub struct FixedSamplingStrategy {
    rate: f64,
}

impl SamplingStrategy for FixedSamplingStrategy {
    fn should_sample(&self, _trace_id: &str, _attributes: &HashMap<String, String>) -> bool {
        rand::random::<f64>() < self.rate
    }
    
    fn get_sampling_rate(&self) -> f64 {
        self.rate
    }
}

pub struct AdaptiveSamplingStrategy {
    base_rate: f64,
    current_load: f64,
    max_rate: f64,
}

impl SamplingStrategy for AdaptiveSamplingStrategy {
    fn should_sample(&self, _trace_id: &str, _attributes: &HashMap<String, String>) -> bool {
        let adjusted_rate = self.base_rate * (1.0 - self.current_load).max(0.1);
        let final_rate = adjusted_rate.min(self.max_rate);
        rand::random::<f64>() < final_rate
    }
    
    fn get_sampling_rate(&self) -> f64 {
        self.base_rate * (1.0 - self.current_load).max(0.1).min(self.max_rate)
    }
}
```

### 3. è§‚å¯Ÿè€…æ¨¡å¼ (Observer Pattern)

#### æŒ‡æ ‡æ”¶é›†å™¨

```rust
pub trait MetricObserver {
    fn on_metric_received(&self, metric: &MetricData);
    fn on_batch_processed(&self, count: usize, duration: Duration);
    fn on_error_occurred(&self, error: &OtlpError);
}

pub struct MetricCollector {
    observers: Vec<Box<dyn MetricObserver + Send + Sync>>,
}

impl MetricCollector {
    pub fn new() -> Self {
        Self {
            observers: Vec::new(),
        }
    }
    
    pub fn add_observer(&mut self, observer: Box<dyn MetricObserver + Send + Sync>) {
        self.observers.push(observer);
    }
    
    pub fn notify_metric_received(&self, metric: &MetricData) {
        for observer in &self.observers {
            observer.on_metric_received(metric);
        }
    }
    
    pub fn notify_batch_processed(&self, count: usize, duration: Duration) {
        for observer in &self.observers {
            observer.on_batch_processed(count, duration);
        }
    }
    
    pub fn notify_error_occurred(&self, error: &OtlpError) {
        for observer in &self.observers {
            observer.on_error_occurred(error);
        }
    }
}
```

## ğŸš€ æ ¸å¿ƒç®—æ³•å®ç°

### 1. æ‰¹å¤„ç†ç®—æ³•1

#### åŸºç¡€æ‰¹å¤„ç†å™¨

```rust
use std::time::{Duration, Instant};
use std::collections::VecDeque;

pub struct BatchProcessor<T> {
    buffer: VecDeque<T>,
    max_batch_size: usize,
    max_wait_time: Duration,
    last_flush: Instant,
    flush_callback: Box<dyn Fn(Vec<T>) -> Result<(), Box<dyn std::error::Error + Send + Sync>> + Send + Sync>,
}

impl<T> BatchProcessor<T> {
    pub fn new<F>(
        max_batch_size: usize,
        max_wait_time: Duration,
        flush_callback: F,
    ) -> Self
    where
        F: Fn(Vec<T>) -> Result<(), Box<dyn std::error::Error + Send + Sync>> + Send + Sync + 'static,
    {
        Self {
            buffer: VecDeque::with_capacity(max_batch_size),
            max_batch_size,
            max_wait_time,
            last_flush: Instant::now(),
            flush_callback: Box::new(flush_callback),
        }
    }
    
    pub fn add(&mut self, item: T) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        self.buffer.push_back(item);
        
        if self.should_flush() {
            self.flush()?;
        }
        
        Ok(())
    }
    
    fn should_flush(&self) -> bool {
        self.buffer.len() >= self.max_batch_size ||
        self.last_flush.elapsed() >= self.max_wait_time
    }
    
    fn flush(&mut self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        if self.buffer.is_empty() {
            return Ok(());
        }
        
        let batch: Vec<T> = self.buffer.drain(..).collect();
        self.last_flush = Instant::now();
        
        (self.flush_callback)(batch)?;
        Ok(())
    }
    
    pub fn force_flush(&mut self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        self.flush()
    }
}
```

#### è‡ªé€‚åº”æ‰¹å¤„ç†å™¨

```rust
pub struct AdaptiveBatchProcessor<T> {
    base_processor: BatchProcessor<T>,
    current_load: f64,
    load_history: VecDeque<f64>,
    max_history_size: usize,
}

impl<T> AdaptiveBatchProcessor<T> {
    pub fn new<F>(
        initial_batch_size: usize,
        max_wait_time: Duration,
        flush_callback: F,
    ) -> Self
    where
        F: Fn(Vec<T>) -> Result<(), Box<dyn std::error::Error + Send + Sync>> + Send + Sync + 'static,
    {
        Self {
            base_processor: BatchProcessor::new(initial_batch_size, max_wait_time, flush_callback),
            current_load: 0.0,
            load_history: VecDeque::new(),
            max_history_size: 100,
        }
    }
    
    pub fn add(&mut self, item: T) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        self.update_load_estimation();
        self.adjust_batch_size();
        self.base_processor.add(item)
    }
    
    fn update_load_estimation(&mut self) {
        // åŸºäºé˜Ÿåˆ—é•¿åº¦å’Œç­‰å¾…æ—¶é—´ä¼°ç®—è´Ÿè½½
        let queue_length = self.base_processor.buffer.len();
        let wait_time = self.base_processor.last_flush.elapsed();
        
        let load = (queue_length as f64 / self.base_processor.max_batch_size as f64)
            .min(1.0) * (wait_time.as_millis() as f64 / 1000.0);
        
        self.load_history.push_back(load);
        if self.load_history.len() > self.max_history_size {
            self.load_history.pop_front();
        }
        
        self.current_load = self.load_history.iter().sum::<f64>() / self.load_history.len() as f64;
    }
    
    fn adjust_batch_size(&mut self) {
        // æ ¹æ®è´Ÿè½½è°ƒæ•´æ‰¹å¤„ç†å¤§å°
        let adjustment_factor = if self.current_load > 0.8 {
            0.5  // é«˜è´Ÿè½½æ—¶å‡å°æ‰¹å¤„ç†å¤§å°
        } else if self.current_load < 0.2 {
            1.5  // ä½è´Ÿè½½æ—¶å¢å¤§æ‰¹å¤„ç†å¤§å°
        } else {
            1.0  // æ­£å¸¸è´Ÿè½½æ—¶ä¿æŒ
        };
        
        let new_size = (self.base_processor.max_batch_size as f64 * adjustment_factor) as usize;
        self.base_processor.max_batch_size = new_size.max(1).min(10000);
    }
}
```

### 2. é‡‡æ ·ç®—æ³•1

#### æ¦‚ç‡é‡‡æ ·å™¨

```rust
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};

pub struct ProbabilisticSampler {
    sampling_rate: f64,
    threshold: u64,
}

impl ProbabilisticSampler {
    pub fn new(sampling_rate: f64) -> Self {
        Self {
            sampling_rate: sampling_rate.clamp(0.0, 1.0),
            threshold: (sampling_rate * u64::MAX as f64) as u64,
        }
    }
    
    pub fn should_sample(&self, trace_id: &str) -> bool {
        let mut hasher = DefaultHasher::new();
        trace_id.hash(&mut hasher);
        let hash = hasher.finish();
        
        hash < self.threshold
    }
    
    pub fn get_sampling_rate(&self) -> f64 {
        self.sampling_rate
    }
}
```

#### è‡ªé€‚åº”é‡‡æ ·å™¨

```rust
pub struct AdaptiveSampler {
    base_rate: f64,
    current_load: f64,
    min_rate: f64,
    max_rate: f64,
    adjustment_factor: f64,
}

impl AdaptiveSampler {
    pub fn new(base_rate: f64, min_rate: f64, max_rate: f64) -> Self {
        Self {
            base_rate,
            current_load: 0.0,
            min_rate: min_rate.clamp(0.0, 1.0),
            max_rate: max_rate.clamp(0.0, 1.0),
            adjustment_factor: 0.1,
        }
    }
    
    pub fn should_sample(&self, trace_id: &str) -> bool {
        let adjusted_rate = self.get_adjusted_rate();
        let mut hasher = DefaultHasher::new();
        trace_id.hash(&mut hasher);
        let hash = hasher.finish();
        let threshold = (adjusted_rate * u64::MAX as f64) as u64;
        
        hash < threshold
    }
    
    pub fn update_load(&mut self, load: f64) {
        self.current_load = load.clamp(0.0, 1.0);
    }
    
    fn get_adjusted_rate(&self) -> f64 {
        let adjustment = if self.current_load > 0.8 {
            -self.adjustment_factor * (self.current_load - 0.8) / 0.2
        } else if self.current_load < 0.2 {
            self.adjustment_factor * (0.2 - self.current_load) / 0.2
        } else {
            0.0
        };
        
        let new_rate = self.base_rate + adjustment;
        new_rate.clamp(self.min_rate, self.max_rate)
    }
}
```

### 3. å‹ç¼©ç®—æ³•1

#### å¤šçº§å‹ç¼©å™¨

```rust
use flate2::write::{GzEncoder, GzDecoder};
use flate2::Compression;
use std::io::{Write, Read};

pub enum CompressionLevel {
    None,
    Fast,
    Balanced,
    Best,
}

pub struct MultiLevelCompressor {
    level: CompressionLevel,
}

impl MultiLevelCompressor {
    pub fn new(level: CompressionLevel) -> Self {
        Self { level }
    }
    
    pub fn compress(&self, data: &[u8]) -> Result<Vec<u8>, Box<dyn std::error::Error + Send + Sync>> {
        match self.level {
            CompressionLevel::None => Ok(data.to_vec()),
            CompressionLevel::Fast => self.compress_gzip(data, Compression::fast()),
            CompressionLevel::Balanced => self.compress_gzip(data, Compression::default()),
            CompressionLevel::Best => self.compress_gzip(data, Compression::best()),
        }
    }
    
    pub fn decompress(&self, data: &[u8]) -> Result<Vec<u8>, Box<dyn std::error::Error + Send + Sync>> {
        match self.level {
            CompressionLevel::None => Ok(data.to_vec()),
            _ => self.decompress_gzip(data),
        }
    }
    
    fn compress_gzip(&self, data: &[u8], compression: Compression) -> Result<Vec<u8>, Box<dyn std::error::Error + Send + Sync>> {
        let mut encoder = GzEncoder::new(Vec::new(), compression);
        encoder.write_all(data)?;
        Ok(encoder.finish()?)
    }
    
    fn decompress_gzip(&self, data: &[u8]) -> Result<Vec<u8>, Box<dyn std::error::Error + Send + Sync>> {
        let mut decoder = GzDecoder::new(Vec::new());
        decoder.write_all(data)?;
        Ok(decoder.finish()?)
    }
}
```

## ğŸ“Š æ€§èƒ½åŸºå‡†æµ‹è¯•

### 1. æ‰¹å¤„ç†æ€§èƒ½æµ‹è¯•

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};

fn benchmark_batch_processing(c: &mut Criterion) {
    let mut group = c.benchmark_group("batch_processing");
    
    for batch_size in [10, 100, 1000, 10000].iter() {
        group.bench_with_input(
            BenchmarkId::new("add_items", batch_size),
            batch_size,
            |b, &size| {
                let mut processor = BatchProcessor::new(
                    size,
                    Duration::from_millis(100),
                    |_| Ok(()),
                );
                b.iter(|| {
                    for i in 0..size {
                        processor.add(black_box(i)).unwrap();
                    }
                });
            },
        );
    }
    
    group.finish();
}

fn benchmark_sampling(c: &mut Criterion) {
    let mut group = c.benchmark_group("sampling");
    
    for rate in [0.01, 0.1, 0.5, 1.0].iter() {
        group.bench_with_input(
            BenchmarkId::new("probabilistic", rate),
            rate,
            |b, &rate| {
                let sampler = ProbabilisticSampler::new(rate);
                b.iter(|| {
                    for i in 0..1000 {
                        sampler.should_sample(black_box(&format!("trace_{}", i)));
                    }
                });
            },
        );
    }
    
    group.finish();
}

criterion_group!(benches, benchmark_batch_processing, benchmark_sampling);
criterion_main!(benches);
```

### 2. å‹ç¼©æ€§èƒ½æµ‹è¯•

```rust
fn benchmark_compression(c: &mut Criterion) {
    let mut group = c.benchmark_group("compression");
    
    let test_data = vec![0u8; 1024 * 1024]; // 1MB test data
    
    for level in [CompressionLevel::Fast, CompressionLevel::Balanced, CompressionLevel::Best].iter() {
        group.bench_with_input(
            BenchmarkId::new("compress", format!("{:?}", level)),
            level,
            |b, level| {
                let compressor = MultiLevelCompressor::new(*level);
                b.iter(|| {
                    compressor.compress(black_box(&test_data)).unwrap();
                });
            },
        );
    }
    
    group.finish();
}
```

## ğŸ” å¤æ‚åº¦åˆ†æ

### 1. æ—¶é—´å¤æ‚åº¦åˆ†æ

| ç®—æ³• | æœ€ä½³æƒ…å†µ | å¹³å‡æƒ…å†µ | æœ€åæƒ…å†µ | è¯´æ˜ |
|------|----------|----------|----------|------|
| æ‰¹å¤„ç†æ·»åŠ  | O(1) | O(1) | O(1) | ç›´æ¥æ·»åŠ åˆ°ç¼“å†²åŒº |
| æ‰¹å¤„ç†åˆ·æ–° | O(n) | O(n) | O(n) | nä¸ºæ‰¹å¤„ç†å¤§å° |
| æ¦‚ç‡é‡‡æ · | O(1) | O(1) | O(1) | å“ˆå¸Œè®¡ç®—å’Œæ¯”è¾ƒ |
| è‡ªé€‚åº”é‡‡æ · | O(1) | O(1) | O(1) | è´Ÿè½½è®¡ç®—å’Œè°ƒæ•´ |
| Gzipå‹ç¼© | O(n) | O(n) | O(n) | nä¸ºæ•°æ®å¤§å° |
| è§£å‹ç¼© | O(n) | O(n) | O(n) | nä¸ºå‹ç¼©æ•°æ®å¤§å° |

### 2. ç©ºé—´å¤æ‚åº¦åˆ†æ

| ç®—æ³• | ç©ºé—´å¤æ‚åº¦ | è¯´æ˜ |
|------|------------|------|
| æ‰¹å¤„ç†å™¨ | O(n) | nä¸ºæœ€å¤§æ‰¹å¤„ç†å¤§å° |
| è‡ªé€‚åº”æ‰¹å¤„ç†å™¨ | O(n + m) | nä¸ºæ‰¹å¤„ç†å¤§å°ï¼Œmä¸ºå†å²è®°å½• |
| é‡‡æ ·å™¨ | O(1) | å¸¸é‡ç©ºé—´ |
| å‹ç¼©å™¨ | O(n) | nä¸ºæ•°æ®å¤§å° |

## ğŸš€ ä¼˜åŒ–ç­–ç•¥

### 1. æ‰¹å¤„ç†ä¼˜åŒ–

- **è‡ªé€‚åº”å¤§å°**: æ ¹æ®ç³»ç»Ÿè´Ÿè½½åŠ¨æ€è°ƒæ•´æ‰¹å¤„ç†å¤§å°
- **æ—¶é—´çª—å£**: ä½¿ç”¨æ—¶é—´çª—å£é¿å…é•¿æ—¶é—´ç­‰å¾…
- **èƒŒå‹æ§åˆ¶**: å®ç°èƒŒå‹æœºåˆ¶é˜²æ­¢å†…å­˜æº¢å‡º
- **æ‰¹é‡ä¼˜åŒ–**: ä¼˜åŒ–æ‰¹é‡æ“ä½œå‡å°‘ç³»ç»Ÿè°ƒç”¨

### 2. é‡‡æ ·ä¼˜åŒ–

- **åˆ†å±‚é‡‡æ ·**: å¯¹ä¸åŒç±»å‹çš„æ•°æ®ä½¿ç”¨ä¸åŒé‡‡æ ·ç‡
- **æ™ºèƒ½é‡‡æ ·**: åŸºäºæ•°æ®é‡è¦æ€§è¿›è¡Œæ™ºèƒ½é‡‡æ ·
- **è´Ÿè½½æ„ŸçŸ¥**: æ ¹æ®ç³»ç»Ÿè´Ÿè½½è°ƒæ•´é‡‡æ ·ç‡
- **ç¼“å­˜ä¼˜åŒ–**: ç¼“å­˜é‡‡æ ·å†³ç­–å‡å°‘è®¡ç®—å¼€é”€

### 3. å‹ç¼©ä¼˜åŒ–

- **å¤šçº§å‹ç¼©**: æ ¹æ®æ•°æ®ç‰¹å¾é€‰æ‹©æœ€ä½³å‹ç¼©ç®—æ³•
- **æµå¼å‹ç¼©**: ä½¿ç”¨æµå¼å‹ç¼©å‡å°‘å†…å­˜ä½¿ç”¨
- **å¹¶è¡Œå‹ç¼©**: åˆ©ç”¨å¤šæ ¸CPUè¿›è¡Œå¹¶è¡Œå‹ç¼©
- **é¢„å‹ç¼©**: å¯¹é‡å¤æ•°æ®è¿›è¡Œé¢„å‹ç¼©

### 4. å¹¶å‘ä¼˜åŒ–

- **æ— é”è®¾è®¡**: ä½¿ç”¨æ— é”æ•°æ®ç»“æ„æé«˜å¹¶å‘æ€§èƒ½
- **å·¥ä½œçªƒå–**: å®ç°å·¥ä½œçªƒå–ç®—æ³•å¹³è¡¡è´Ÿè½½
- **å†…å­˜å±éšœ**: æ­£ç¡®ä½¿ç”¨å†…å­˜å±éšœä¿è¯æ•°æ®ä¸€è‡´æ€§
- **NUMAæ„ŸçŸ¥**: è€ƒè™‘NUMAæ¶æ„ä¼˜åŒ–å†…å­˜è®¿é—®

## ğŸ“š å­¦ä¹ è·¯å¾„

### åˆå­¦è€…è·¯å¾„

1. ç†è§£åŸºç¡€ç®—æ³•æ¦‚å¿µ
2. å­¦ä¹ æ‰¹å¤„ç†ç®—æ³•å®ç°
3. æŒæ¡é‡‡æ ·ç®—æ³•åŸç†
4. å®è·µæ€§èƒ½æµ‹è¯•æ–¹æ³•

### è¿›é˜¶å­¦ä¹ 

1. æ·±å…¥ç®—æ³•å¤æ‚åº¦åˆ†æ
2. å­¦ä¹ é«˜çº§ä¼˜åŒ–æŠ€æœ¯
3. æŒæ¡å¹¶å‘ç®—æ³•è®¾è®¡
4. å®è·µå¤§è§„æ¨¡ç³»ç»Ÿä¼˜åŒ–

## ğŸ”— ç›¸å…³æ–‡æ¡£

- [æ€§èƒ½ä¼˜åŒ–](æ€§èƒ½ä¼˜åŒ–.md) - æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯
- [å¹¶å‘æ§åˆ¶](å¹¶å‘æ§åˆ¶.md) - å¹¶å‘å’Œå¼‚æ­¥å¤„ç†
- [å½¢å¼åŒ–éªŒè¯](å½¢å¼åŒ–éªŒè¯.md) - ç®—æ³•æ­£ç¡®æ€§éªŒè¯
- [æ¶æ„è®¾è®¡](../04_æ¶æ„è®¾è®¡/README.md) - ç³»ç»Ÿæ¶æ„è®¾è®¡

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025å¹´9æœˆ26æ—¥  
**ç»´æŠ¤è€…**: OTLPç®—æ³•å›¢é˜Ÿ
