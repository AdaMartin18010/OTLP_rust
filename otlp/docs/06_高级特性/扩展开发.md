# æ‰©å±•å¼€å‘

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»äº†OTLP Rusté¡¹ç›®çš„æ‰©å±•å¼€å‘æŠ€æœ¯ï¼Œæ¶µç›–æ’ä»¶æ¶æ„ã€æ‰©å±•æ¥å£ã€è‡ªå®šä¹‰ä¼ è¾“ã€è‡ªå®šä¹‰å¤„ç†å™¨ç­‰å†…å®¹ã€‚

**åˆ›å»ºæ—¶é—´**: 2025å¹´9æœˆ26æ—¥  
**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**ç»´æŠ¤è€…**: OTLPæ‰©å±•å¼€å‘å›¢é˜Ÿ  

## ğŸ¯ æ‰©å±•å¼€å‘æ¦‚è§ˆ

### 1. æ’ä»¶æ¶æ„

- **æ’ä»¶ç³»ç»Ÿ**: åŠ¨æ€åŠ è½½å’Œå¸è½½æ’ä»¶
- **æ’ä»¶æ¥å£**: æ ‡å‡†åŒ–çš„æ’ä»¶æ¥å£
- **æ’ä»¶ç®¡ç†**: æ’ä»¶çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†
- **æ’ä»¶é€šä¿¡**: æ’ä»¶é—´çš„é€šä¿¡æœºåˆ¶

### 2. æ‰©å±•æ¥å£

- **ä¼ è¾“æ‰©å±•**: è‡ªå®šä¹‰ä¼ è¾“åè®®
- **å¤„ç†å™¨æ‰©å±•**: è‡ªå®šä¹‰æ•°æ®å¤„ç†é€»è¾‘
- **é‡‡æ ·å™¨æ‰©å±•**: è‡ªå®šä¹‰é‡‡æ ·ç­–ç•¥
- **å¯¼å‡ºå™¨æ‰©å±•**: è‡ªå®šä¹‰æ•°æ®å¯¼å‡ºæ–¹å¼

### 3. è‡ªå®šä¹‰ç»„ä»¶

- **è‡ªå®šä¹‰ä¼ è¾“**: å®ç°æ–°çš„ä¼ è¾“åè®®
- **è‡ªå®šä¹‰å¤„ç†å™¨**: å®ç°æ–°çš„æ•°æ®å¤„ç†é€»è¾‘
- **è‡ªå®šä¹‰é‡‡æ ·å™¨**: å®ç°æ–°çš„é‡‡æ ·ç­–ç•¥
- **è‡ªå®šä¹‰å¯¼å‡ºå™¨**: å®ç°æ–°çš„æ•°æ®å¯¼å‡ºæ–¹å¼

### 4. é›†æˆå¼€å‘

- **ç¬¬ä¸‰æ–¹é›†æˆ**: ä¸ç¬¬ä¸‰æ–¹ç³»ç»Ÿé›†æˆ
- **ä¸­é—´ä»¶å¼€å‘**: å¼€å‘ä¸­é—´ä»¶ç»„ä»¶
- **å·¥å…·é“¾é›†æˆ**: ä¸å¼€å‘å·¥å…·é“¾é›†æˆ
- **ç›‘æ§é›†æˆ**: ä¸ç›‘æ§ç³»ç»Ÿé›†æˆ

## ğŸ—ï¸ æ‰©å±•å¼€å‘æ¶æ„

### æ•´ä½“æ¶æ„

```text
æ‰©å±•å¼€å‘ç³»ç»Ÿ
â”œâ”€â”€ æ’ä»¶ç®¡ç†å±‚
â”‚   â”œâ”€â”€ æ’ä»¶åŠ è½½å™¨
â”‚   â”œâ”€â”€ æ’ä»¶æ³¨å†Œè¡¨
â”‚   â”œâ”€â”€ æ’ä»¶ç”Ÿå‘½å‘¨æœŸç®¡ç†
â”‚   â””â”€â”€ æ’ä»¶é€šä¿¡æœºåˆ¶
â”œâ”€â”€ æ‰©å±•æ¥å£å±‚
â”‚   â”œâ”€â”€ ä¼ è¾“æ¥å£
â”‚   â”œâ”€â”€ å¤„ç†å™¨æ¥å£
â”‚   â”œâ”€â”€ é‡‡æ ·å™¨æ¥å£
â”‚   â””â”€â”€ å¯¼å‡ºå™¨æ¥å£
â”œâ”€â”€ è‡ªå®šä¹‰ç»„ä»¶å±‚
â”‚   â”œâ”€â”€ ä¼ è¾“å®ç°
â”‚   â”œâ”€â”€ å¤„ç†å™¨å®ç°
â”‚   â”œâ”€â”€ é‡‡æ ·å™¨å®ç°
â”‚   â””â”€â”€ å¯¼å‡ºå™¨å®ç°
â””â”€â”€ é›†æˆå¼€å‘å±‚
    â”œâ”€â”€ ç¬¬ä¸‰æ–¹é›†æˆ
    â”œâ”€â”€ ä¸­é—´ä»¶å¼€å‘
    â”œâ”€â”€ å·¥å…·é“¾é›†æˆ
    â””â”€â”€ ç›‘æ§é›†æˆ
```

## ğŸš€ æ ¸å¿ƒæ‰©å±•æŠ€æœ¯

### 1. æ’ä»¶æ¶æ„1

#### æ’ä»¶ç³»ç»Ÿæ ¸å¿ƒ

```rust
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use std::any::Any;
use std::path::Path;

pub trait Plugin: Send + Sync {
    fn name(&self) -> &str;
    fn version(&self) -> &str;
    fn description(&self) -> &str;
    fn initialize(&mut self, config: PluginConfig) -> Result<(), PluginError>;
    fn shutdown(&mut self) -> Result<(), PluginError>;
    fn get_interface(&self) -> Box<dyn PluginInterface>;
}

pub trait PluginInterface: Send + Sync {
    fn get_type(&self) -> PluginType;
    fn get_capabilities(&self) -> Vec<PluginCapability>;
    fn execute(&self, input: &dyn Any) -> Result<Box<dyn Any>, PluginError>;
}

#[derive(Debug, Clone)]
pub enum PluginType {
    Transport,
    Processor,
    Sampler,
    Exporter,
    Middleware,
}

#[derive(Debug, Clone)]
pub enum PluginCapability {
    AsyncProcessing,
    BatchProcessing,
    Streaming,
    Compression,
    Encryption,
    Authentication,
}

#[derive(Debug, Clone)]
pub struct PluginConfig {
    pub name: String,
    pub version: String,
    pub config: HashMap<String, String>,
    pub dependencies: Vec<String>,
}

#[derive(Debug)]
pub enum PluginError {
    InitializationFailed(String),
    ConfigurationError(String),
    ExecutionError(String),
    DependencyError(String),
    UnsupportedOperation(String),
}

pub struct PluginManager {
    plugins: Arc<RwLock<HashMap<String, Box<dyn Plugin>>>>,
    plugin_paths: Vec<String>,
}

impl PluginManager {
    pub fn new() -> Self {
        Self {
            plugins: Arc::new(RwLock::new(HashMap::new())),
            plugin_paths: Vec::new(),
        }
    }
    
    pub fn add_plugin_path(&mut self, path: String) {
        self.plugin_paths.push(path);
    }
    
    pub async fn load_plugin(&self, name: &str, config: PluginConfig) -> Result<(), PluginError> {
        // æŸ¥æ‰¾æ’ä»¶æ–‡ä»¶
        let plugin_path = self.find_plugin(name)?;
        
        // åŠ è½½æ’ä»¶
        let plugin = self.load_plugin_from_path(&plugin_path)?;
        
        // åˆå§‹åŒ–æ’ä»¶
        let mut plugin_instance = plugin;
        plugin_instance.initialize(config)?;
        
        // æ³¨å†Œæ’ä»¶
        let mut plugins = self.plugins.write().unwrap();
        plugins.insert(name.to_string(), plugin_instance);
        
        Ok(())
    }
    
    pub fn unload_plugin(&self, name: &str) -> Result<(), PluginError> {
        let mut plugins = self.plugins.write().unwrap();
        
        if let Some(mut plugin) = plugins.remove(name) {
            plugin.shutdown()?;
        }
        
        Ok(())
    }
    
    pub fn get_plugin(&self, name: &str) -> Option<Box<dyn PluginInterface>> {
        let plugins = self.plugins.read().unwrap();
        plugins.get(name).map(|plugin| plugin.get_interface())
    }
    
    pub fn list_plugins(&self) -> Vec<String> {
        let plugins = self.plugins.read().unwrap();
        plugins.keys().cloned().collect()
    }
    
    fn find_plugin(&self, name: &str) -> Result<String, PluginError> {
        for path in &self.plugin_paths {
            let plugin_path = Path::new(path).join(format!("{}.so", name));
            if plugin_path.exists() {
                return Ok(plugin_path.to_string_lossy().to_string());
            }
        }
        Err(PluginError::DependencyError(format!("Plugin {} not found", name)))
    }
    
    fn load_plugin_from_path(&self, path: &str) -> Result<Box<dyn Plugin>, PluginError> {
        // è¿™é‡Œåº”è¯¥ä½¿ç”¨åŠ¨æ€åº“åŠ è½½æœºåˆ¶
        // ä¸ºäº†ç¤ºä¾‹ï¼Œæˆ‘ä»¬è¿”å›ä¸€ä¸ªæ¨¡æ‹Ÿçš„æ’ä»¶
        Ok(Box::new(MockPlugin::new()))
    }
}

// æ¨¡æ‹Ÿæ’ä»¶å®ç°
struct MockPlugin {
    name: String,
    version: String,
    description: String,
}

impl MockPlugin {
    fn new() -> Self {
        Self {
            name: "mock_plugin".to_string(),
            version: "1.0.0".to_string(),
            description: "Mock plugin for testing".to_string(),
        }
    }
}

impl Plugin for MockPlugin {
    fn name(&self) -> &str {
        &self.name
    }
    
    fn version(&self) -> &str {
        &self.version
    }
    
    fn description(&self) -> &str {
        &self.description
    }
    
    fn initialize(&mut self, _config: PluginConfig) -> Result<(), PluginError> {
        println!("Mock plugin initialized");
        Ok(())
    }
    
    fn shutdown(&mut self) -> Result<(), PluginError> {
        println!("Mock plugin shutdown");
        Ok(())
    }
    
    fn get_interface(&self) -> Box<dyn PluginInterface> {
        Box::new(MockPluginInterface)
    }
}

struct MockPluginInterface;

impl PluginInterface for MockPluginInterface {
    fn get_type(&self) -> PluginType {
        PluginType::Processor
    }
    
    fn get_capabilities(&self) -> Vec<PluginCapability> {
        vec![
            PluginCapability::AsyncProcessing,
            PluginCapability::BatchProcessing,
        ]
    }
    
    fn execute(&self, _input: &dyn Any) -> Result<Box<dyn Any>, PluginError> {
        Ok(Box::new("processed".to_string()))
    }
}
```

### 2. æ‰©å±•æ¥å£1

#### ä¼ è¾“æ‰©å±•æ¥å£

```rust
use async_trait::async_trait;
use std::collections::HashMap;

#[async_trait]
pub trait TransportExtension: Send + Sync {
    async fn connect(&mut self, endpoint: &str) -> Result<(), TransportError>;
    async fn disconnect(&mut self) -> Result<(), TransportError>;
    async fn send(&mut self, data: &[u8]) -> Result<(), TransportError>;
    async fn receive(&mut self) -> Result<Vec<u8>, TransportError>;
    fn get_config(&self) -> &TransportConfig;
    fn set_config(&mut self, config: TransportConfig);
}

#[derive(Debug, Clone)]
pub struct TransportConfig {
    pub endpoint: String,
    pub timeout: std::time::Duration,
    pub retry_count: u32,
    pub compression: bool,
    pub encryption: bool,
    pub headers: HashMap<String, String>,
}

#[derive(Debug)]
pub enum TransportError {
    ConnectionFailed(String),
    SendFailed(String),
    ReceiveFailed(String),
    Timeout,
    InvalidData,
    UnsupportedOperation,
}

// è‡ªå®šä¹‰HTTPä¼ è¾“å®ç°
pub struct CustomHttpTransport {
    config: TransportConfig,
    client: reqwest::Client,
    connected: bool,
}

impl CustomHttpTransport {
    pub fn new(config: TransportConfig) -> Self {
        let client = reqwest::Client::builder()
            .timeout(config.timeout)
            .build()
            .unwrap();
        
        Self {
            config,
            client,
            connected: false,
        }
    }
}

#[async_trait]
impl TransportExtension for CustomHttpTransport {
    async fn connect(&mut self, endpoint: &str) -> Result<(), TransportError> {
        self.config.endpoint = endpoint.to_string();
        
        // æµ‹è¯•è¿æ¥
        let response = self.client
            .get(&endpoint)
            .send()
            .await
            .map_err(|e| TransportError::ConnectionFailed(e.to_string()))?;
        
        if response.status().is_success() {
            self.connected = true;
            Ok(())
        } else {
            Err(TransportError::ConnectionFailed("Connection test failed".to_string()))
        }
    }
    
    async fn disconnect(&mut self) -> Result<(), TransportError> {
        self.connected = false;
        Ok(())
    }
    
    async fn send(&mut self, data: &[u8]) -> Result<(), TransportError> {
        if !self.connected {
            return Err(TransportError::ConnectionFailed("Not connected".to_string()));
        }
        
        let mut request = self.client
            .post(&self.config.endpoint)
            .body(data.to_vec());
        
        // æ·»åŠ è‡ªå®šä¹‰å¤´éƒ¨
        for (key, value) in &self.config.headers {
            request = request.header(key, value);
        }
        
        let response = request
            .send()
            .await
            .map_err(|e| TransportError::SendFailed(e.to_string()))?;
        
        if response.status().is_success() {
            Ok(())
        } else {
            Err(TransportError::SendFailed("Send failed".to_string()))
        }
    }
    
    async fn receive(&mut self) -> Result<Vec<u8>, TransportError> {
        if !self.connected {
            return Err(TransportError::ConnectionFailed("Not connected".to_string()));
        }
        
        let response = self.client
            .get(&self.config.endpoint)
            .send()
            .await
            .map_err(|e| TransportError::ReceiveFailed(e.to_string()))?;
        
        let data = response
            .bytes()
            .await
            .map_err(|e| TransportError::ReceiveFailed(e.to_string()))?;
        
        Ok(data.to_vec())
    }
    
    fn get_config(&self) -> &TransportConfig {
        &self.config
    }
    
    fn set_config(&mut self, config: TransportConfig) {
        self.config = config;
    }
}
```

#### å¤„ç†å™¨æ‰©å±•æ¥å£

```rust
use async_trait::async_trait;
use std::collections::HashMap;

#[async_trait]
pub trait ProcessorExtension: Send + Sync {
    async fn process(&mut self, data: &[u8]) -> Result<Vec<u8>, ProcessorError>;
    fn get_config(&self) -> &ProcessorConfig;
    fn set_config(&mut self, config: ProcessorConfig);
    fn get_metrics(&self) -> ProcessorMetrics;
}

#[derive(Debug, Clone)]
pub struct ProcessorConfig {
    pub name: String,
    pub enabled: bool,
    pub batch_size: usize,
    pub timeout: std::time::Duration,
    pub parameters: HashMap<String, String>,
}

#[derive(Debug)]
pub enum ProcessorError {
    ProcessingFailed(String),
    InvalidInput(String),
    ConfigurationError(String),
    Timeout,
}

#[derive(Debug, Clone)]
pub struct ProcessorMetrics {
    pub processed_count: u64,
    pub error_count: u64,
    pub average_processing_time: std::time::Duration,
    pub last_processing_time: std::time::Instant,
}

// è‡ªå®šä¹‰æ•°æ®è½¬æ¢å¤„ç†å™¨
pub struct DataTransformProcessor {
    config: ProcessorConfig,
    metrics: ProcessorMetrics,
    transform_rules: Vec<TransformRule>,
}

#[derive(Debug, Clone)]
pub struct TransformRule {
    pub source_field: String,
    pub target_field: String,
    pub transform_type: TransformType,
    pub parameters: HashMap<String, String>,
}

#[derive(Debug, Clone)]
pub enum TransformType {
    Copy,
    Convert,
    Filter,
    Aggregate,
    Custom(String),
}

impl DataTransformProcessor {
    pub fn new(config: ProcessorConfig) -> Self {
        Self {
            config,
            metrics: ProcessorMetrics {
                processed_count: 0,
                error_count: 0,
                average_processing_time: std::time::Duration::ZERO,
                last_processing_time: std::time::Instant::now(),
            },
            transform_rules: Vec::new(),
        }
    }
    
    pub fn add_transform_rule(&mut self, rule: TransformRule) {
        self.transform_rules.push(rule);
    }
    
    fn apply_transforms(&self, data: &[u8]) -> Result<Vec<u8>, ProcessorError> {
        // è§£æè¾“å…¥æ•°æ®
        let mut parsed_data = self.parse_data(data)?;
        
        // åº”ç”¨è½¬æ¢è§„åˆ™
        for rule in &self.transform_rules {
            parsed_data = self.apply_rule(parsed_data, rule)?;
        }
        
        // åºåˆ—åŒ–è¾“å‡ºæ•°æ®
        self.serialize_data(parsed_data)
    }
    
    fn parse_data(&self, data: &[u8]) -> Result<HashMap<String, String>, ProcessorError> {
        // ç®€å•çš„JSONè§£æç¤ºä¾‹
        let json_str = std::str::from_utf8(data)
            .map_err(|e| ProcessorError::InvalidInput(e.to_string()))?;
        
        let parsed: HashMap<String, String> = serde_json::from_str(json_str)
            .map_err(|e| ProcessorError::InvalidInput(e.to_string()))?;
        
        Ok(parsed)
    }
    
    fn apply_rule(&self, mut data: HashMap<String, String>, rule: &TransformRule) -> Result<HashMap<String, String>, ProcessorError> {
        match rule.transform_type {
            TransformType::Copy => {
                if let Some(value) = data.get(&rule.source_field) {
                    data.insert(rule.target_field.clone(), value.clone());
                }
            }
            TransformType::Convert => {
                if let Some(value) = data.get(&rule.source_field) {
                    let converted_value = self.convert_value(value, &rule.parameters)?;
                    data.insert(rule.target_field.clone(), converted_value);
                }
            }
            TransformType::Filter => {
                if let Some(condition) = rule.parameters.get("condition") {
                    if !self.evaluate_condition(&data, condition)? {
                        data.remove(&rule.source_field);
                    }
                }
            }
            TransformType::Aggregate => {
                // å®ç°èšåˆé€»è¾‘
            }
            TransformType::Custom(ref custom_type) => {
                // å®ç°è‡ªå®šä¹‰è½¬æ¢é€»è¾‘
                println!("Applying custom transform: {}", custom_type);
            }
        }
        
        Ok(data)
    }
    
    fn convert_value(&self, value: &str, parameters: &HashMap<String, String>) -> Result<String, ProcessorError> {
        if let Some(target_type) = parameters.get("type") {
            match target_type.as_str() {
                "uppercase" => Ok(value.to_uppercase()),
                "lowercase" => Ok(value.to_lowercase()),
                "trim" => Ok(value.trim().to_string()),
                _ => Ok(value.to_string()),
            }
        } else {
            Ok(value.to_string())
        }
    }
    
    fn evaluate_condition(&self, data: &HashMap<String, String>, condition: &str) -> Result<bool, ProcessorError> {
        // ç®€å•çš„æ¡ä»¶è¯„ä¼°
        Ok(true)
    }
    
    fn serialize_data(&self, data: HashMap<String, String>) -> Result<Vec<u8>, ProcessorError> {
        let json_str = serde_json::to_string(&data)
            .map_err(|e| ProcessorError::ProcessingFailed(e.to_string()))?;
        Ok(json_str.into_bytes())
    }
}

#[async_trait]
impl ProcessorExtension for DataTransformProcessor {
    async fn process(&mut self, data: &[u8]) -> Result<Vec<u8>, ProcessorError> {
        let start_time = std::time::Instant::now();
        
        let result = self.apply_transforms(data);
        
        let processing_time = start_time.elapsed();
        
        // æ›´æ–°æŒ‡æ ‡
        self.metrics.processed_count += 1;
        self.metrics.last_processing_time = start_time;
        
        if result.is_err() {
            self.metrics.error_count += 1;
        } else {
            // æ›´æ–°å¹³å‡å¤„ç†æ—¶é—´
            let total_time = self.metrics.average_processing_time.as_nanos() as u64 * (self.metrics.processed_count - 1) + processing_time.as_nanos() as u64;
            self.metrics.average_processing_time = std::time::Duration::from_nanos(total_time / self.metrics.processed_count);
        }
        
        result
    }
    
    fn get_config(&self) -> &ProcessorConfig {
        &self.config
    }
    
    fn set_config(&mut self, config: ProcessorConfig) {
        self.config = config;
    }
    
    fn get_metrics(&self) -> ProcessorMetrics {
        self.metrics.clone()
    }
}
```

### 3. è‡ªå®šä¹‰ç»„ä»¶1

#### è‡ªå®šä¹‰é‡‡æ ·å™¨

```rust
use async_trait::async_trait;
use std::collections::HashMap;
use std::sync::atomic::{AtomicU64, Ordering};

#[async_trait]
pub trait SamplerExtension: Send + Sync {
    async fn should_sample(&mut self, trace_id: &str, attributes: &HashMap<String, String>) -> Result<bool, SamplerError>;
    fn get_sampling_rate(&self) -> f64;
    fn update_sampling_rate(&mut self, rate: f64);
    fn get_metrics(&self) -> SamplerMetrics;
}

#[derive(Debug)]
pub enum SamplerError {
    SamplingFailed(String),
    InvalidConfiguration(String),
    RateLimitExceeded,
}

#[derive(Debug, Clone)]
pub struct SamplerMetrics {
    pub total_requests: u64,
    pub sampled_requests: u64,
    pub current_rate: f64,
    pub last_update: std::time::Instant,
}

// è‡ªé€‚åº”é‡‡æ ·å™¨
pub struct AdaptiveSampler {
    base_rate: f64,
    current_rate: f64,
    min_rate: f64,
    max_rate: f64,
    adjustment_factor: f64,
    total_requests: AtomicU64,
    sampled_requests: AtomicU64,
    last_update: std::time::Instant,
    load_history: Vec<f64>,
    max_history_size: usize,
}

impl AdaptiveSampler {
    pub fn new(base_rate: f64, min_rate: f64, max_rate: f64) -> Self {
        Self {
            base_rate,
            current_rate: base_rate,
            min_rate,
            max_rate,
            adjustment_factor: 0.1,
            total_requests: AtomicU64::new(0),
            sampled_requests: AtomicU64::new(0),
            last_update: std::time::Instant::now(),
            load_history: Vec::new(),
            max_history_size: 100,
        }
    }
    
    pub fn update_load(&mut self, load: f64) {
        self.load_history.push(load);
        if self.load_history.len() > self.max_history_size {
            self.load_history.remove(0);
        }
        
        self.adjust_sampling_rate();
    }
    
    fn adjust_sampling_rate(&mut self) {
        if self.load_history.is_empty() {
            return;
        }
        
        let average_load = self.load_history.iter().sum::<f64>() / self.load_history.len() as f64;
        
        let adjustment = if average_load > 0.8 {
            -self.adjustment_factor * (average_load - 0.8) / 0.2
        } else if average_load < 0.2 {
            self.adjustment_factor * (0.2 - average_load) / 0.2
        } else {
            0.0
        };
        
        self.current_rate = (self.base_rate + adjustment)
            .max(self.min_rate)
            .min(self.max_rate);
    }
    
    fn calculate_hash(&self, trace_id: &str) -> u64 {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};
        
        let mut hasher = DefaultHasher::new();
        trace_id.hash(&mut hasher);
        hasher.finish()
    }
}

#[async_trait]
impl SamplerExtension for AdaptiveSampler {
    async fn should_sample(&mut self, trace_id: &str, _attributes: &HashMap<String, String>) -> Result<bool, SamplerError> {
        self.total_requests.fetch_add(1, Ordering::AcqRel);
        
        let hash = self.calculate_hash(trace_id);
        let threshold = (self.current_rate * u64::MAX as f64) as u64;
        
        let should_sample = hash < threshold;
        
        if should_sample {
            self.sampled_requests.fetch_add(1, Ordering::AcqRel);
        }
        
        Ok(should_sample)
    }
    
    fn get_sampling_rate(&self) -> f64 {
        self.current_rate
    }
    
    fn update_sampling_rate(&mut self, rate: f64) {
        self.current_rate = rate.clamp(self.min_rate, self.max_rate);
    }
    
    fn get_metrics(&self) -> SamplerMetrics {
        let total = self.total_requests.load(Ordering::Acquire);
        let sampled = self.sampled_requests.load(Ordering::Acquire);
        
        SamplerMetrics {
            total_requests: total,
            sampled_requests: sampled,
            current_rate: self.current_rate,
            last_update: self.last_update,
        }
    }
}
```

### 4. é›†æˆå¼€å‘1

#### ç¬¬ä¸‰æ–¹ç³»ç»Ÿé›†æˆ

```rust
use async_trait::async_trait;
use std::collections::HashMap;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IntegrationConfig {
    pub name: String,
    pub endpoint: String,
    pub api_key: Option<String>,
    pub timeout: std::time::Duration,
    pub retry_count: u32,
    pub custom_headers: HashMap<String, String>,
}

pub trait ThirdPartyIntegration: Send + Sync {
    fn get_name(&self) -> &str;
    fn get_config(&self) -> &IntegrationConfig;
    fn set_config(&mut self, config: IntegrationConfig);
    async fn test_connection(&self) -> Result<(), IntegrationError>;
    async fn send_data(&self, data: &[u8]) -> Result<(), IntegrationError>;
    async fn receive_data(&self) -> Result<Vec<u8>, IntegrationError>;
}

#[derive(Debug)]
pub enum IntegrationError {
    ConnectionFailed(String),
    AuthenticationFailed(String),
    DataSendFailed(String),
    DataReceiveFailed(String),
    ConfigurationError(String),
    Timeout,
    RateLimitExceeded,
}

// Prometheusé›†æˆ
pub struct PrometheusIntegration {
    config: IntegrationConfig,
    client: reqwest::Client,
}

impl PrometheusIntegration {
    pub fn new(config: IntegrationConfig) -> Self {
        let client = reqwest::Client::builder()
            .timeout(config.timeout)
            .build()
            .unwrap();
        
        Self { config, client }
    }
    
    async fn format_metrics(&self, data: &[u8]) -> Result<String, IntegrationError> {
        // å°†OTLPæ•°æ®è½¬æ¢ä¸ºPrometheusæ ¼å¼
        let otlp_data = serde_json::from_slice::<serde_json::Value>(data)
            .map_err(|e| IntegrationError::DataSendFailed(e.to_string()))?;
        
        // ç®€å•çš„è½¬æ¢é€»è¾‘
        let mut prometheus_metrics = String::new();
        
        if let Some(metrics) = otlp_data.get("metrics") {
            for metric in metrics.as_array().unwrap_or(&vec![]) {
                if let Some(name) = metric.get("name") {
                    if let Some(value) = metric.get("value") {
                        prometheus_metrics.push_str(&format!("{} {}\n", name, value));
                    }
                }
            }
        }
        
        Ok(prometheus_metrics)
    }
}

impl ThirdPartyIntegration for PrometheusIntegration {
    fn get_name(&self) -> &str {
        &self.config.name
    }
    
    fn get_config(&self) -> &IntegrationConfig {
        &self.config
    }
    
    fn set_config(&mut self, config: IntegrationConfig) {
        self.config = config;
    }
    
    async fn test_connection(&self) -> Result<(), IntegrationError> {
        let response = self.client
            .get(&self.config.endpoint)
            .send()
            .await
            .map_err(|e| IntegrationError::ConnectionFailed(e.to_string()))?;
        
        if response.status().is_success() {
            Ok(())
        } else {
            Err(IntegrationError::ConnectionFailed("Connection test failed".to_string()))
        }
    }
    
    async fn send_data(&self, data: &[u8]) -> Result<(), IntegrationError> {
        let prometheus_data = self.format_metrics(data).await?;
        
        let mut request = self.client
            .post(&self.config.endpoint)
            .body(prometheus_data);
        
        // æ·»åŠ APIå¯†é’¥
        if let Some(api_key) = &self.config.api_key {
            request = request.header("Authorization", format!("Bearer {}", api_key));
        }
        
        // æ·»åŠ è‡ªå®šä¹‰å¤´éƒ¨
        for (key, value) in &self.config.custom_headers {
            request = request.header(key, value);
        }
        
        let response = request
            .send()
            .await
            .map_err(|e| IntegrationError::DataSendFailed(e.to_string()))?;
        
        if response.status().is_success() {
            Ok(())
        } else {
            Err(IntegrationError::DataSendFailed("Send failed".to_string()))
        }
    }
    
    async fn receive_data(&self) -> Result<Vec<u8>, IntegrationError> {
        let response = self.client
            .get(&self.config.endpoint)
            .send()
            .await
            .map_err(|e| IntegrationError::DataReceiveFailed(e.to_string()))?;
        
        let data = response
            .bytes()
            .await
            .map_err(|e| IntegrationError::DataReceiveFailed(e.to_string()))?;
        
        Ok(data.to_vec())
    }
}

// é›†æˆç®¡ç†å™¨
pub struct IntegrationManager {
    integrations: HashMap<String, Box<dyn ThirdPartyIntegration>>,
}

impl IntegrationManager {
    pub fn new() -> Self {
        Self {
            integrations: HashMap::new(),
        }
    }
    
    pub fn add_integration(&mut self, name: String, integration: Box<dyn ThirdPartyIntegration>) {
        self.integrations.insert(name, integration);
    }
    
    pub fn get_integration(&self, name: &str) -> Option<&dyn ThirdPartyIntegration> {
        self.integrations.get(name).map(|integration| integration.as_ref())
    }
    
    pub fn list_integrations(&self) -> Vec<String> {
        self.integrations.keys().cloned().collect()
    }
    
    pub async fn test_all_connections(&self) -> HashMap<String, Result<(), IntegrationError>> {
        let mut results = HashMap::new();
        
        for (name, integration) in &self.integrations {
            let result = integration.test_connection().await;
            results.insert(name.clone(), result);
        }
        
        results
    }
}
```

## ğŸ“Š æ‰©å±•å¼€å‘å·¥å…·

### 1. æ’ä»¶å¼€å‘å·¥å…·

```rust
use std::path::Path;
use std::process::Command;

pub struct PluginDevelopmentTools {
    plugin_template_path: String,
    build_script_path: String,
}

impl PluginDevelopmentTools {
    pub fn new() -> Self {
        Self {
            plugin_template_path: "templates/plugin_template.rs".to_string(),
            build_script_path: "scripts/build_plugin.sh".to_string(),
        }
    }
    
    pub fn create_plugin_template(&self, plugin_name: &str, plugin_type: PluginType) -> Result<(), std::io::Error> {
        let template_content = self.generate_template(plugin_name, plugin_type);
        let file_path = format!("plugins/{}.rs", plugin_name);
        
        std::fs::write(file_path, template_content)?;
        Ok(())
    }
    
    pub fn build_plugin(&self, plugin_name: &str) -> Result<(), std::io::Error> {
        let output = Command::new("cargo")
            .args(&["build", "--release", "--lib"])
            .current_dir(format!("plugins/{}", plugin_name))
            .output()?;
        
        if output.status.success() {
            println!("Plugin {} built successfully", plugin_name);
        } else {
            eprintln!("Failed to build plugin {}: {}", plugin_name, String::from_utf8_lossy(&output.stderr));
        }
        
        Ok(())
    }
    
    pub fn test_plugin(&self, plugin_name: &str) -> Result<(), std::io::Error> {
        let output = Command::new("cargo")
            .args(&["test"])
            .current_dir(format!("plugins/{}", plugin_name))
            .output()?;
        
        if output.status.success() {
            println!("Plugin {} tests passed", plugin_name);
        } else {
            eprintln!("Plugin {} tests failed: {}", plugin_name, String::from_utf8_lossy(&output.stderr));
        }
        
        Ok(())
    }
    
    fn generate_template(&self, plugin_name: &str, plugin_type: PluginType) -> String {
        match plugin_type {
            PluginType::Transport => self.generate_transport_template(plugin_name),
            PluginType::Processor => self.generate_processor_template(plugin_name),
            PluginType::Sampler => self.generate_sampler_template(plugin_name),
            PluginType::Exporter => self.generate_exporter_template(plugin_name),
            PluginType::Middleware => self.generate_middleware_template(plugin_name),
        }
    }
    
    fn generate_transport_template(&self, plugin_name: &str) -> String {
        format!(r#"
use async_trait::async_trait;
use std::collections::HashMap;

pub struct {}Transport {{
    config: TransportConfig,
}}

impl {}Transport {{
    pub fn new(config: TransportConfig) -> Self {{
        Self {{ config }}
    }}
}}

#[async_trait]
impl TransportExtension for {}Transport {{
    async fn connect(&mut self, endpoint: &str) -> Result<(), TransportError> {{
        // TODO: Implement connection logic
        Ok(())
    }}
    
    async fn disconnect(&mut self) -> Result<(), TransportError> {{
        // TODO: Implement disconnection logic
        Ok(())
    }}
    
    async fn send(&mut self, data: &[u8]) -> Result<(), TransportError> {{
        // TODO: Implement send logic
        Ok(())
    }}
    
    async fn receive(&mut self) -> Result<Vec<u8>, TransportError> {{
        // TODO: Implement receive logic
        Ok(vec![])
    }}
    
    fn get_config(&self) -> &TransportConfig {{
        &self.config
    }}
    
    fn set_config(&mut self, config: TransportConfig) {{
        self.config = config;
    }}
}}
"#, plugin_name, plugin_name, plugin_name)
    }
    
    fn generate_processor_template(&self, plugin_name: &str) -> String {
        format!(r#"
use async_trait::async_trait;
use std::collections::HashMap;

pub struct {}Processor {{
    config: ProcessorConfig,
    metrics: ProcessorMetrics,
}}

impl {}Processor {{
    pub fn new(config: ProcessorConfig) -> Self {{
        Self {{
            config,
            metrics: ProcessorMetrics {{
                processed_count: 0,
                error_count: 0,
                average_processing_time: std::time::Duration::ZERO,
                last_processing_time: std::time::Instant::now(),
            }},
        }}
    }}
}}

#[async_trait]
impl ProcessorExtension for {}Processor {{
    async fn process(&mut self, data: &[u8]) -> Result<Vec<u8>, ProcessorError> {{
        // TODO: Implement processing logic
        Ok(data.to_vec())
    }}
    
    fn get_config(&self) -> &ProcessorConfig {{
        &self.config
    }}
    
    fn set_config(&mut self, config: ProcessorConfig) {{
        self.config = config;
    }}
    
    fn get_metrics(&self) -> ProcessorMetrics {{
        self.metrics.clone()
    }}
}}
"#, plugin_name, plugin_name, plugin_name)
    }
    
    fn generate_sampler_template(&self, plugin_name: &str) -> String {
        format!(r#"
use async_trait::async_trait;
use std::collections::HashMap;

pub struct {}Sampler {{
    config: SamplerConfig,
    metrics: SamplerMetrics,
}}

impl {}Sampler {{
    pub fn new(config: SamplerConfig) -> Self {{
        Self {{
            config,
            metrics: SamplerMetrics {{
                total_requests: 0,
                sampled_requests: 0,
                current_rate: config.base_rate,
                last_update: std::time::Instant::now(),
            }},
        }}
    }}
}}

#[async_trait]
impl SamplerExtension for {}Sampler {{
    async fn should_sample(&mut self, trace_id: &str, attributes: &HashMap<String, String>) -> Result<bool, SamplerError> {{
        // TODO: Implement sampling logic
        Ok(true)
    }}
    
    fn get_sampling_rate(&self) -> f64 {{
        self.config.base_rate
    }}
    
    fn update_sampling_rate(&mut self, rate: f64) {{
        self.config.base_rate = rate;
    }}
    
    fn get_metrics(&self) -> SamplerMetrics {{
        self.metrics.clone()
    }}
}}
"#, plugin_name, plugin_name, plugin_name)
    }
    
    fn generate_exporter_template(&self, plugin_name: &str) -> String {
        format!(r#"
use async_trait::async_trait;
use std::collections::HashMap;

pub struct {}Exporter {{
    config: ExporterConfig,
    metrics: ExporterMetrics,
}}

impl {}Exporter {{
    pub fn new(config: ExporterConfig) -> Self {{
        Self {{
            config,
            metrics: ExporterMetrics {{
                exported_count: 0,
                failed_count: 0,
                last_export_time: std::time::Instant::now(),
            }},
        }}
    }}
}}

#[async_trait]
impl ExporterExtension for {}Exporter {{
    async fn export(&mut self, data: &[u8]) -> Result<(), ExporterError> {{
        // TODO: Implement export logic
        Ok(())
    }}
    
    fn get_config(&self) -> &ExporterConfig {{
        &self.config
    }}
    
    fn set_config(&mut self, config: ExporterConfig) {{
        self.config = config;
    }}
    
    fn get_metrics(&self) -> ExporterMetrics {{
        self.metrics.clone()
    }}
}}
"#, plugin_name, plugin_name, plugin_name)
    }
    
    fn generate_middleware_template(&self, plugin_name: &str) -> String {
        format!(r#"
use async_trait::async_trait;
use std::collections::HashMap;

pub struct {}Middleware {{
    config: MiddlewareConfig,
}}

impl {}Middleware {{
    pub fn new(config: MiddlewareConfig) -> Self {{
        Self {{ config }}
    }}
}}

#[async_trait]
impl MiddlewareExtension for {}Middleware {{
    async fn process_request(&mut self, request: &mut Request) -> Result<(), MiddlewareError> {{
        // TODO: Implement request processing logic
        Ok(())
    }}
    
    async fn process_response(&mut self, response: &mut Response) -> Result<(), MiddlewareError> {{
        // TODO: Implement response processing logic
        Ok(())
    }}
    
    fn get_config(&self) -> &MiddlewareConfig {{
        &self.config
    }}
    
    fn set_config(&mut self, config: MiddlewareConfig) {{
        self.config = config;
    }}
}}
"#, plugin_name, plugin_name, plugin_name)
    }
}
```

## ğŸš€ æœ€ä½³å®è·µ

### 1. æ’ä»¶å¼€å‘æœ€ä½³å®è·µ

- **æ ‡å‡†åŒ–æ¥å£**: ä½¿ç”¨æ ‡å‡†åŒ–çš„æ’ä»¶æ¥å£
- **é”™è¯¯å¤„ç†**: å®ç°å®Œå–„çš„é”™è¯¯å¤„ç†æœºåˆ¶
- **é…ç½®ç®¡ç†**: æ”¯æŒçµæ´»çš„é…ç½®ç®¡ç†
- **ç”Ÿå‘½å‘¨æœŸç®¡ç†**: æ­£ç¡®ç®¡ç†æ’ä»¶çš„ç”Ÿå‘½å‘¨æœŸ

### 2. æ‰©å±•å¼€å‘æœ€ä½³å®è·µ

- **æ¨¡å—åŒ–è®¾è®¡**: é‡‡ç”¨æ¨¡å—åŒ–çš„è®¾è®¡æ–¹æ³•
- **å¼‚æ­¥ä¼˜å…ˆ**: ä¼˜å…ˆä½¿ç”¨å¼‚æ­¥ç¼–ç¨‹æ¨¡å‹
- **æ€§èƒ½ä¼˜åŒ–**: å…³æ³¨æ‰©å±•çš„æ€§èƒ½è¡¨ç°
- **æµ‹è¯•è¦†ç›–**: æä¾›å®Œæ•´çš„æµ‹è¯•è¦†ç›–

### 3. é›†æˆå¼€å‘æœ€ä½³å®è·µ

- **æ ‡å‡†åŒ–åè®®**: ä½¿ç”¨æ ‡å‡†åŒ–çš„é€šä¿¡åè®®
- **é”™è¯¯æ¢å¤**: å®ç°é”™è¯¯æ¢å¤æœºåˆ¶
- **ç›‘æ§é›†æˆ**: é›†æˆç›‘æ§å’Œæ—¥å¿—ç³»ç»Ÿ
- **æ–‡æ¡£å®Œå–„**: æä¾›å®Œæ•´çš„é›†æˆæ–‡æ¡£

### 4. ç»´æŠ¤å’Œæ›´æ–°æœ€ä½³å®è·µ

- **ç‰ˆæœ¬ç®¡ç†**: ä½¿ç”¨è¯­ä¹‰åŒ–ç‰ˆæœ¬ç®¡ç†
- **å‘åå…¼å®¹**: ä¿æŒå‘åå…¼å®¹æ€§
- **è¿ç§»æŒ‡å—**: æä¾›ç‰ˆæœ¬è¿ç§»æŒ‡å—
- **ç¤¾åŒºæ”¯æŒ**: å»ºç«‹ç¤¾åŒºæ”¯æŒæœºåˆ¶

## ğŸ“š å­¦ä¹ è·¯å¾„

### åˆå­¦è€…è·¯å¾„

1. ç†è§£æ’ä»¶æ¶æ„åŸºç¡€
2. å­¦ä¹ æ‰©å±•æ¥å£è®¾è®¡
3. æŒæ¡è‡ªå®šä¹‰ç»„ä»¶å¼€å‘
4. å®è·µç®€å•æ’ä»¶å¼€å‘

### è¿›é˜¶å­¦ä¹ 

1. æ·±å…¥ç†è§£æ’ä»¶ç³»ç»Ÿ
2. å­¦ä¹ é«˜çº§æ‰©å±•æŠ€æœ¯
3. æŒæ¡é›†æˆå¼€å‘æ–¹æ³•
4. å®è·µå¤æ‚æ‰©å±•å¼€å‘

## ğŸ”— ç›¸å…³æ–‡æ¡£

- [ç®—æ³•åˆ†æ](ç®—æ³•åˆ†æ.md) - æ ¸å¿ƒç®—æ³•åˆ†æ
- [æ€§èƒ½ä¼˜åŒ–](æ€§èƒ½ä¼˜åŒ–.md) - æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯
- [å¹¶å‘æ§åˆ¶](å¹¶å‘æ§åˆ¶.md) - å¹¶å‘å’Œå¼‚æ­¥å¤„ç†
- [æ¶æ„è®¾è®¡](../04_æ¶æ„è®¾è®¡/README.md) - ç³»ç»Ÿæ¶æ„è®¾è®¡

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025å¹´9æœˆ26æ—¥  
**ç»´æŠ¤è€…**: OTLPæ‰©å±•å¼€å‘å›¢é˜Ÿ
