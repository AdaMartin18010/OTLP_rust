# ä»»åŠ¡3: Tracezipå‹ç¼©é›†æˆ - è¯¦ç»†å®æ–½æŒ‡å—

**ğŸ“… å¯åŠ¨æ—¥æœŸ**: 2025å¹´12æœˆ4æ—¥  
**â±ï¸ é¢„è®¡å·¥æœŸ**: 3-4å‘¨  
**ğŸ¯ ç›®æ ‡**: å®ç°ä¼ è¾“é‡å‡å°‘50%+çš„é«˜æ•ˆå‹ç¼©  
**ğŸ“Š ä¼˜å…ˆçº§**: P1ï¼ˆé«˜ï¼‰

---

## ğŸ“‹ ä»»åŠ¡æ¦‚è§ˆ

### ç›®æ ‡

é›†æˆTracezipå‹ç¼©æŠ€æœ¯ï¼Œé€šè¿‡æ™ºèƒ½å»é‡å’Œé«˜æ•ˆç¼–ç æ˜¾è‘—å‡å°‘traceæ•°æ®çš„ä¼ è¾“é‡ï¼ŒåŒæ—¶ä¿æŒå®Œå…¨çš„OTLPå…¼å®¹æ€§å’Œå‘åå…¼å®¹æ€§ã€‚

### é¢„æœŸæˆæœ

```yaml
æ€§èƒ½ç›®æ ‡:
  ä¼ è¾“é‡å‡å°‘: 50%+
  CPUå¼€é”€: <5%
  å†…å­˜å¼€é”€: <10%
  å‹ç¼©å»¶è¿Ÿ: <10ms
  è§£å‹å»¶è¿Ÿ: <5ms

åŠŸèƒ½è¦æ±‚:
  å®Œå…¨OTLPå…¼å®¹: 100%
  é€æ˜å‹ç¼©/è§£å‹: æ˜¯
  å¯é…ç½®å¼€å…³: æ˜¯
  å‘åå…¼å®¹: æ˜¯
  æ‰¹é‡å¤„ç†: æ”¯æŒ
```

---

## ğŸ—“ï¸ å®æ–½æ—¶é—´çº¿

### Week 1: ç ”ç©¶å’Œè®¾è®¡ (12/4-12/10)

**ç›®æ ‡**: å®ŒæˆæŠ€æœ¯è°ƒç ”å’Œè¯¦ç»†è®¾è®¡

```yaml
å‘¨ä¸€ (12/4):
  ä»»åŠ¡: é˜…è¯»Tracezipè®ºæ–‡å’Œè§„èŒƒ
  æ´»åŠ¨:
    - TracezipæŠ€æœ¯è®ºæ–‡é˜…è¯»
    - OTLPå‹ç¼©æ‰©å±•è§„èŒƒç ”ç©¶
    - ç«å“åˆ†æï¼ˆJaegerã€Zipkinï¼‰
  äº§å‡º:
    - æŠ€æœ¯ç†è§£æ–‡æ¡£
    - æ ¸å¿ƒç®—æ³•ç¬”è®°
  
å‘¨äºŒ (12/5):
  ä»»åŠ¡: åˆ†æå‹ç¼©ç®—æ³•
  æ´»åŠ¨:
    - Spanå»é‡ç®—æ³•åˆ†æ
    - å¢é‡ç¼–ç æ–¹æ¡ˆç ”ç©¶
    - å­—ç¬¦ä¸²è¡¨ä¼˜åŒ–åˆ†æ
  äº§å‡º:
    - ç®—æ³•è®¾è®¡æ–‡æ¡£
    - æ€§èƒ½é¢„æµ‹æ¨¡å‹

å‘¨ä¸‰ (12/6):
  ä»»åŠ¡: è®¾è®¡å®ç°æ–¹æ¡ˆ
  æ´»åŠ¨:
    - æ•°æ®ç»“æ„è®¾è®¡
    - APIæ¥å£è®¾è®¡
    - é›†æˆç‚¹è¯†åˆ«
  äº§å‡º:
    - æ¶æ„è®¾è®¡æ–‡æ¡£v1.0
    - APIè®¾è®¡è‰å›¾

å‘¨å›› (12/7):
  ä»»åŠ¡: æ€§èƒ½é¢„æµ‹å’ŒåŸå‹
  æ´»åŠ¨:
    - å‹ç¼©ç‡ä¼°ç®—
    - æ€§èƒ½å¼€é”€è¯„ä¼°
    - ç®€å•åŸå‹éªŒè¯
  äº§å‡º:
    - æ€§èƒ½é¢„æµ‹æŠ¥å‘Š
    - åŸå‹ä»£ç 

å‘¨äº” (12/8):
  ä»»åŠ¡: è®¾è®¡è¯„å®¡å’Œè°ƒæ•´
  æ´»åŠ¨:
    - å›¢é˜Ÿè®¾è®¡è¯„å®¡
    - é£é™©è¯†åˆ«
    - æ–¹æ¡ˆä¼˜åŒ–
  äº§å‡º:
    - æœ€ç»ˆè®¾è®¡æ–‡æ¡£
    - é£é™©åº”å¯¹æ–¹æ¡ˆ
```

### Week 2-3: æ ¸å¿ƒå®ç° (12/11-12/24)

#### Week 2 (12/11-12/17)

```yaml
å‘¨ä¸€ (12/11):
  ä»»åŠ¡: å®ç°Spanå»é‡ç®—æ³•
  å®ç°:
    - å“ˆå¸Œè®¡ç®—
    - é‡å¤æ£€æµ‹
    - å¼•ç”¨æ„å»º
  äº§å‡º:
    - src/compression/tracezip/dedup.rs
    - å•å…ƒæµ‹è¯•

å‘¨äºŒ (12/12):
  ä»»åŠ¡: å®ç°å¢é‡ç¼–ç 
  å®ç°:
    - å­—æ®µå·®å¼‚è®¡ç®—
    - å¢é‡ç¼–ç å™¨
    - è§£ç å™¨
  äº§å‡º:
    - src/compression/tracezip/delta.rs
    - å•å…ƒæµ‹è¯•

å‘¨ä¸‰ (12/13):
  ä»»åŠ¡: å®ç°å­—ç¬¦ä¸²è¡¨ä¼˜åŒ–
  å®ç°:
    - å­—ç¬¦ä¸²å»é‡
    - å­—å…¸ç¼–ç 
    - å‹ç¼©ç¼–ç 
  äº§å‡º:
    - src/compression/tracezip/string_table.rs
    - å•å…ƒæµ‹è¯•

å‘¨å›› (12/14):
  ä»»åŠ¡: å®ç°å‹ç¼©å™¨æ ¸å¿ƒ
  å®ç°:
    - TraceCompressor struct
    - æ‰¹é‡å‹ç¼©é€»è¾‘
    - çŠ¶æ€ç®¡ç†
  äº§å‡º:
    - src/compression/tracezip/compressor.rs
    - å•å…ƒæµ‹è¯•

å‘¨äº” (12/15):
  ä»»åŠ¡: å®ç°è§£å‹å™¨
  å®ç°:
    - TraceDecompressor struct
    - å¼•ç”¨è§£æ
    - å®Œæ•´traceé‡å»º
  äº§å‡º:
    - src/compression/tracezip/decompressor.rs
    - å•å…ƒæµ‹è¯•
```

#### Week 3 (12/18-12/24)

```yaml
å‘¨ä¸€ (12/18):
  ä»»åŠ¡: é›†æˆåˆ°å¯¼å‡ºå™¨
  å®ç°:
    - OtlpExporteré›†æˆ
    - é…ç½®é€‰é¡¹
    - é€æ˜å‹ç¼©
  äº§å‡º:
    - å¯¼å‡ºå™¨æ›´æ–°
    - é›†æˆæµ‹è¯•

å‘¨äºŒ (12/19):
  ä»»åŠ¡: æ‰¹é‡å¤„ç†ä¼˜åŒ–
  å®ç°:
    - æ‰¹é‡å‹ç¼©
    - å†…å­˜æ± 
    - å¹¶å‘å¤„ç†
  äº§å‡º:
    - æ‰¹å¤„ç†æ¨¡å—
    - æ€§èƒ½æµ‹è¯•

å‘¨ä¸‰ (12/20):
  ä»»åŠ¡: å‘åå…¼å®¹æ€§
  å®ç°:
    - ç‰ˆæœ¬æ£€æµ‹
    - è‡ªåŠ¨é™çº§
    - å…¼å®¹æ¨¡å¼
  äº§å‡º:
    - å…¼å®¹æ€§å±‚
    - å…¼å®¹æ€§æµ‹è¯•

å‘¨å›› (12/21):
  ä»»åŠ¡: é…ç½®å’Œç›‘æ§
  å®ç°:
    - é…ç½®é€‰é¡¹
    - å‹ç¼©ç»Ÿè®¡
    - ç›‘æ§æŒ‡æ ‡
  äº§å‡º:
    - é…ç½®æ¨¡å—
    - ç›‘æ§é›†æˆ

å‘¨äº” (12/22):
  ä»»åŠ¡: æ–‡æ¡£å’Œç¤ºä¾‹
  å®ç°:
    - APIæ–‡æ¡£
    - ä½¿ç”¨æŒ‡å—
    - ç¤ºä¾‹ä»£ç 
  äº§å‡º:
    - å®Œæ•´æ–‡æ¡£
    - ç¤ºä¾‹é¡¹ç›®
```

### Week 4: æµ‹è¯•å’Œä¼˜åŒ– (12/25-12/31)

```yaml
å‘¨ä¸€-å‘¨äºŒ (12/25-12/26):
  ä»»åŠ¡: æ€§èƒ½æµ‹è¯•
  æ´»åŠ¨:
    - å‹ç¼©ç‡æµ‹è¯•ï¼ˆå„ç§åœºæ™¯ï¼‰
    - CPUå¼€é”€æµ‹è¯•
    - å†…å­˜å ç”¨æµ‹è¯•
    - å»¶è¿Ÿæµ‹è¯•
  äº§å‡º:
    - æ€§èƒ½æµ‹è¯•æŠ¥å‘Š
    - åŸºå‡†æµ‹è¯•å¥—ä»¶

å‘¨ä¸‰ (12/27):
  ä»»åŠ¡: ç®—æ³•ä¼˜åŒ–
  æ´»åŠ¨:
    - çƒ­ç‚¹åˆ†æ
    - ç®—æ³•è°ƒä¼˜
    - å†…å­˜ä¼˜åŒ–
  äº§å‡º:
    - ä¼˜åŒ–åçš„ä»£ç 
    - æ€§èƒ½å¯¹æ¯”æŠ¥å‘Š

å‘¨å›› (12/28):
  ä»»åŠ¡: å¹¶å‘ä¼˜åŒ–
  æ´»åŠ¨:
    - å¹¶å‘æ€§èƒ½æµ‹è¯•
    - é”ä¼˜åŒ–
    - æ— é”ç®—æ³•åº”ç”¨
  äº§å‡º:
    - å¹¶å‘ä¼˜åŒ–ä»£ç 
    - å¹¶å‘æµ‹è¯•æŠ¥å‘Š

å‘¨äº” (12/29):
  ä»»åŠ¡: æœ€ç»ˆæµ‹è¯•å’Œæ–‡æ¡£
  æ´»åŠ¨:
    - å®Œæ•´æµ‹è¯•å¥—ä»¶è¿è¡Œ
    - æ–‡æ¡£å®¡æŸ¥
    - ä»£ç å®¡æŸ¥
  äº§å‡º:
    - æµ‹è¯•æŠ¥å‘Š
    - æœ€ç»ˆæ–‡æ¡£

å‘¨æœ« (12/30-12/31):
  ä»»åŠ¡: å‡†å¤‡å‘å¸ƒ
  æ´»åŠ¨:
    - CHANGELOGæ›´æ–°
    - å‘å¸ƒè¯´æ˜ç¼–å†™
    - PRå‡†å¤‡
  äº§å‡º:
    - å‘å¸ƒææ–™
    - PRæäº¤
```

---

## ğŸ’» æŠ€æœ¯å®ç°

### 1. æ ¸å¿ƒæ¶æ„

```rust
// src/compression/tracezip/mod.rs

pub mod dedup;
pub mod delta;
pub mod string_table;
pub mod compressor;
pub mod decompressor;

use std::collections::HashMap;

/// Tracezipå‹ç¼©å™¨é…ç½®
#[derive(Debug, Clone)]
pub struct TracezipConfig {
    /// æ˜¯å¦å¯ç”¨å‹ç¼©
    pub enabled: bool,
    
    /// æœ€å°æ‰¹é‡å¤§å°ï¼ˆå°äºæ­¤å¤§å°ä¸å‹ç¼©ï¼‰
    pub min_batch_size: usize,
    
    /// æœ€å¤§å­—ç¬¦ä¸²è¡¨å¤§å°
    pub max_string_table_size: usize,
    
    /// æ˜¯å¦å¯ç”¨å¢é‡ç¼–ç 
    pub enable_delta_encoding: bool,
    
    /// æ˜¯å¦å¯ç”¨Spanå»é‡
    pub enable_dedup: bool,
}

impl Default for TracezipConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            min_batch_size: 10,
            max_string_table_size: 10000,
            enable_delta_encoding: true,
            enable_dedup: true,
        }
    }
}

/// Tracezipå‹ç¼©ç»Ÿè®¡
#[derive(Debug, Default, Clone)]
pub struct CompressionStats {
    /// åŸå§‹å¤§å°ï¼ˆå­—èŠ‚ï¼‰
    pub original_size: u64,
    
    /// å‹ç¼©åå¤§å°ï¼ˆå­—èŠ‚ï¼‰
    pub compressed_size: u64,
    
    /// å‹ç¼©ç‡
    pub compression_ratio: f64,
    
    /// å¤„ç†çš„Spanæ•°é‡
    pub span_count: u64,
    
    /// å»é‡çš„Spanæ•°é‡
    pub deduped_spans: u64,
    
    /// å‹ç¼©è€—æ—¶ï¼ˆå¾®ç§’ï¼‰
    pub compression_time_us: u64,
}

impl CompressionStats {
    pub fn compression_percentage(&self) -> f64 {
        if self.original_size == 0 {
            return 0.0;
        }
        (1.0 - self.compression_ratio) * 100.0
    }
}
```

### 2. Spanå»é‡ç®—æ³•

```rust
// src/compression/tracezip/dedup.rs

use std::collections::HashMap;
use std::hash::{Hash, Hasher};
use ahash::AHasher;
use crate::proto::trace::v1::Span;

/// Spanå»é‡å™¨
pub struct SpanDeduplicator {
    /// Spanå“ˆå¸Œåˆ°IDçš„æ˜ å°„
    hash_to_id: HashMap<u64, SpanId>,
    
    /// ä¸‹ä¸€ä¸ªSpan ID
    next_id: u32,
}

impl SpanDeduplicator {
    pub fn new() -> Self {
        Self {
            hash_to_id: HashMap::new(),
            next_id: 0,
        }
    }
    
    /// å¤„ç†ä¸€æ‰¹Spanï¼Œè¿”å›å»é‡åçš„æ•°æ®
    pub fn deduplicate(&mut self, spans: &[Span]) -> DeduplicatedSpans {
        let mut unique_spans = Vec::new();
        let mut span_refs = Vec::new();
        
        for span in spans {
            let hash = self.hash_span(span);
            
            if let Some(&span_id) = self.hash_to_id.get(&hash) {
                // é‡å¤çš„Spanï¼Œåªä¿å­˜å¼•ç”¨
                span_refs.push(SpanRef {
                    original_index: span_refs.len(),
                    referenced_id: span_id,
                });
            } else {
                // æ–°çš„Spanï¼Œä¿å­˜å®Œæ•´æ•°æ®
                let span_id = SpanId(self.next_id);
                self.next_id += 1;
                self.hash_to_id.insert(hash, span_id);
                
                unique_spans.push((span_id, span.clone()));
                span_refs.push(SpanRef {
                    original_index: span_refs.len(),
                    referenced_id: span_id,
                });
            }
        }
        
        DeduplicatedSpans {
            unique_spans,
            span_refs,
        }
    }
    
    /// è®¡ç®—Spançš„å“ˆå¸Œå€¼
    fn hash_span(&self, span: &Span) -> u64 {
        let mut hasher = AHasher::default();
        
        // å“ˆå¸Œå…³é”®å­—æ®µ
        span.name.hash(&mut hasher);
        span.kind.hash(&mut hasher);
        
        // å“ˆå¸Œå±æ€§ï¼ˆæ’åºåï¼‰
        let mut attrs: Vec<_> = span.attributes.iter().collect();
        attrs.sort_by_key(|a| &a.key);
        for attr in attrs {
            attr.key.hash(&mut hasher);
            // ç®€åŒ–ï¼šåªå“ˆå¸Œå€¼çš„ç±»å‹ï¼Œä¸å“ˆå¸Œå…·ä½“å€¼
            std::mem::discriminant(&attr.value).hash(&mut hasher);
        }
        
        hasher.finish()
    }
}

/// Span ID
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct SpanId(u32);

/// Spanå¼•ç”¨
#[derive(Debug, Clone)]
pub struct SpanRef {
    /// åŸå§‹ç´¢å¼•
    pub original_index: usize,
    
    /// å¼•ç”¨çš„Span ID
    pub referenced_id: SpanId,
}

/// å»é‡åçš„Spanæ•°æ®
pub struct DeduplicatedSpans {
    /// å”¯ä¸€çš„Spanï¼ˆID + Spanæ•°æ®ï¼‰
    pub unique_spans: Vec<(SpanId, Span)>,
    
    /// Spanå¼•ç”¨åˆ—è¡¨
    pub span_refs: Vec<SpanRef>,
}
```

### 3. å¢é‡ç¼–ç 

```rust
// src/compression/tracezip/delta.rs

use crate::proto::trace::v1::Span;

/// å¢é‡ç¼–ç å™¨
pub struct DeltaEncoder {
    /// å‰ä¸€ä¸ªSpanï¼ˆç”¨äºè®¡ç®—å·®å¼‚ï¼‰
    previous_span: Option<Span>,
}

impl DeltaEncoder {
    pub fn new() -> Self {
        Self {
            previous_span: None,
        }
    }
    
    /// ç¼–ç Spanä¸ºå¢é‡æ•°æ®
    pub fn encode(&mut self, span: &Span) -> EncodedSpan {
        if let Some(prev) = &self.previous_span {
            // è®¡ç®—ä¸å‰ä¸€ä¸ªSpançš„å·®å¼‚
            let delta = self.compute_delta(prev, span);
            self.previous_span = Some(span.clone());
            
            EncodedSpan::Delta {
                base_index: 0, // ç®€åŒ–ï¼šæ€»æ˜¯ç›¸å¯¹äºå‰ä¸€ä¸ª
                delta,
            }
        } else {
            // ç¬¬ä¸€ä¸ªSpanï¼Œå®Œæ•´ç¼–ç 
            self.previous_span = Some(span.clone());
            EncodedSpan::Full(span.clone())
        }
    }
    
    /// è®¡ç®—ä¸¤ä¸ªSpanä¹‹é—´çš„å·®å¼‚
    fn compute_delta(&self, prev: &Span, curr: &Span) -> SpanDelta {
        let mut delta = SpanDelta::default();
        
        // åç§°å·®å¼‚
        if prev.name != curr.name {
            delta.name = Some(curr.name.clone());
        }
        
        // æ—¶é—´æˆ³å·®å¼‚ï¼ˆä½¿ç”¨å¢é‡ç¼–ç ï¼‰
        delta.start_time_delta = (curr.start_time_unix_nano as i64) 
            - (prev.start_time_unix_nano as i64);
        delta.end_time_delta = (curr.end_time_unix_nano as i64) 
            - (prev.end_time_unix_nano as i64);
        
        // å±æ€§å·®å¼‚
        delta.attributes = self.compute_attribute_delta(
            &prev.attributes,
            &curr.attributes,
        );
        
        // Kindå·®å¼‚
        if prev.kind != curr.kind {
            delta.kind = Some(curr.kind);
        }
        
        delta
    }
    
    /// è®¡ç®—å±æ€§å·®å¼‚
    fn compute_attribute_delta(
        &self,
        prev_attrs: &[KeyValue],
        curr_attrs: &[KeyValue],
    ) -> AttributeDelta {
        // ç®€åŒ–å®ç°ï¼šåªæ ‡è®°æ–°å¢ã€åˆ é™¤å’Œä¿®æ”¹çš„å±æ€§
        let mut added = Vec::new();
        let mut removed = Vec::new();
        let mut modified = Vec::new();
        
        // TODO: å®ç°å®Œæ•´çš„å±æ€§å·®å¼‚è®¡ç®—
        
        AttributeDelta {
            added,
            removed,
            modified,
        }
    }
}

/// ç¼–ç åçš„Span
#[derive(Debug, Clone)]
pub enum EncodedSpan {
    /// å®Œæ•´Span
    Full(Span),
    
    /// å¢é‡Spanï¼ˆç›¸å¯¹äºbase_indexï¼‰
    Delta {
        base_index: usize,
        delta: SpanDelta,
    },
}

/// Spanå¢é‡æ•°æ®
#[derive(Debug, Clone, Default)]
pub struct SpanDelta {
    pub name: Option<String>,
    pub start_time_delta: i64,
    pub end_time_delta: i64,
    pub attributes: AttributeDelta,
    pub kind: Option<i32>,
}

/// å±æ€§å¢é‡
#[derive(Debug, Clone, Default)]
pub struct AttributeDelta {
    pub added: Vec<KeyValue>,
    pub removed: Vec<String>,
    pub modified: Vec<KeyValue>,
}
```

### 4. å‹ç¼©å™¨ä¸»ä½“

```rust
// src/compression/tracezip/compressor.rs

use super::*;

/// Tracezipå‹ç¼©å™¨
pub struct TraceCompressor {
    config: TracezipConfig,
    deduplicator: SpanDeduplicator,
    delta_encoder: DeltaEncoder,
    string_table: StringTable,
    stats: CompressionStats,
}

impl TraceCompressor {
    pub fn new(config: TracezipConfig) -> Self {
        Self {
            config,
            deduplicator: SpanDeduplicator::new(),
            delta_encoder: DeltaEncoder::new(),
            string_table: StringTable::new(),
            stats: CompressionStats::default(),
        }
    }
    
    /// å‹ç¼©ä¸€æ‰¹trace
    pub fn compress(&mut self, traces: Vec<Trace>) -> Result<CompressedTraces> {
        let start_time = std::time::Instant::now();
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦å‹ç¼©
        let total_spans: usize = traces.iter()
            .flat_map(|t| &t.resource_spans)
            .flat_map(|rs| &rs.scope_spans)
            .map(|ss| ss.spans.len())
            .sum();
        
        if !self.config.enabled || total_spans < self.config.min_batch_size {
            // ä¸å‹ç¼©ï¼Œç›´æ¥è¿”å›
            return Ok(CompressedTraces::Uncompressed(traces));
        }
        
        // æ”¶é›†æ‰€æœ‰Span
        let mut all_spans = Vec::new();
        for trace in &traces {
            for resource_span in &trace.resource_spans {
                for scope_span in &resource_span.scope_spans {
                    all_spans.extend(scope_span.spans.iter().cloned());
                }
            }
        }
        
        // Step 1: Spanå»é‡
        let deduped = if self.config.enable_dedup {
            self.deduplicator.deduplicate(&all_spans)
        } else {
            // ä¸å»é‡ï¼Œæ‰€æœ‰Spanéƒ½æ˜¯å”¯ä¸€çš„
            DeduplicatedSpans {
                unique_spans: all_spans.iter().enumerate()
                    .map(|(i, s)| (SpanId(i as u32), s.clone()))
                    .collect(),
                span_refs: (0..all_spans.len())
                    .map(|i| SpanRef {
                        original_index: i,
                        referenced_id: SpanId(i as u32),
                    })
                    .collect(),
            }
        };
        
        // Step 2: å¢é‡ç¼–ç 
        let encoded_spans: Vec<EncodedSpan> = if self.config.enable_delta_encoding {
            deduped.unique_spans.iter()
                .map(|(_, span)| self.delta_encoder.encode(span))
                .collect()
        } else {
            deduped.unique_spans.iter()
                .map(|(_, span)| EncodedSpan::Full(span.clone()))
                .collect()
        };
        
        // Step 3: å­—ç¬¦ä¸²è¡¨ä¼˜åŒ–
        let (optimized_spans, string_table) = self.string_table.optimize(&encoded_spans);
        
        // Step 4: åºåˆ—åŒ–
        let compressed_data = self.serialize(CompressedData {
            spans: optimized_spans,
            span_refs: deduped.span_refs,
            string_table,
        })?;
        
        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        let elapsed = start_time.elapsed();
        self.stats.span_count += total_spans as u64;
        self.stats.deduped_spans += (total_spans - deduped.unique_spans.len()) as u64;
        self.stats.original_size += self.estimate_size(&traces);
        self.stats.compressed_size += compressed_data.len() as u64;
        self.stats.compression_time_us += elapsed.as_micros() as u64;
        self.stats.compression_ratio = self.stats.compressed_size as f64 
            / self.stats.original_size as f64;
        
        Ok(CompressedTraces::Compressed(compressed_data))
    }
    
    /// åºåˆ—åŒ–å‹ç¼©æ•°æ®
    fn serialize(&self, data: CompressedData) -> Result<Vec<u8>> {
        // ä½¿ç”¨Protocol Buffersåºåˆ—åŒ–
        // TODO: å®ç°å®Œæ•´çš„åºåˆ—åŒ–é€»è¾‘
        Ok(Vec::new())
    }
    
    /// ä¼°ç®—åŸå§‹æ•°æ®å¤§å°
    fn estimate_size(&self, traces: &[Trace]) -> u64 {
        // ç®€åŒ–ï¼šä½¿ç”¨åºåˆ—åŒ–åçš„å¤§å°
        // TODO: å®ç°æ›´å‡†ç¡®çš„ä¼°ç®—
        0
    }
    
    /// è·å–å‹ç¼©ç»Ÿè®¡ä¿¡æ¯
    pub fn stats(&self) -> &CompressionStats {
        &self.stats
    }
    
    /// é‡ç½®ç»Ÿè®¡ä¿¡æ¯
    pub fn reset_stats(&mut self) {
        self.stats = CompressionStats::default();
    }
}

/// å‹ç¼©åçš„traces
pub enum CompressedTraces {
    /// æœªå‹ç¼©ï¼ˆå°æ‰¹é‡ï¼‰
    Uncompressed(Vec<Trace>),
    
    /// å·²å‹ç¼©
    Compressed(Vec<u8>),
}

/// å‹ç¼©æ•°æ®ç»“æ„
struct CompressedData {
    spans: Vec<EncodedSpan>,
    span_refs: Vec<SpanRef>,
    string_table: StringTable,
}
```

### 5. é›†æˆåˆ°å¯¼å‡ºå™¨

```rust
// src/exporter/otlp.rs (ä¿®æ”¹)

use crate::compression::tracezip::{TraceCompressor, TracezipConfig};

pub struct OtlpExporter {
    // ... ç°æœ‰å­—æ®µ
    
    /// Tracezipå‹ç¼©å™¨ï¼ˆå¯é€‰ï¼‰
    compressor: Option<TraceCompressor>,
}

impl OtlpExporter {
    pub fn new(config: OtlpExporterConfig) -> Self {
        let compressor = if config.enable_tracezip {
            Some(TraceCompressor::new(config.tracezip_config))
        } else {
            None
        };
        
        Self {
            // ... ç°æœ‰åˆå§‹åŒ–
            compressor,
        }
    }
    
    pub async fn export_traces(&mut self, traces: Vec<Trace>) -> Result<()> {
        // å¦‚æœå¯ç”¨äº†å‹ç¼©ï¼Œå…ˆå‹ç¼©
        let payload = if let Some(compressor) = &mut self.compressor {
            match compressor.compress(traces)? {
                CompressedTraces::Compressed(data) => {
                    // è®¾ç½®å‹ç¼©æ ‡è®°
                    self.set_compression_header("tracezip");
                    data
                }
                CompressedTraces::Uncompressed(traces) => {
                    // ä½¿ç”¨æ ‡å‡†åºåˆ—åŒ–
                    self.serialize_traces(traces)?
                }
            }
        } else {
            // æœªå¯ç”¨å‹ç¼©
            self.serialize_traces(traces)?
        };
        
        // å‘é€æ•°æ®
        self.send(payload).await?;
        
        // è®°å½•å‹ç¼©ç»Ÿè®¡
        if let Some(compressor) = &self.compressor {
            let stats = compressor.stats();
            debug!("Tracezip stats: {:?}", stats);
            
            // å¯¼å‡ºå‹ç¼©æŒ‡æ ‡
            self.metrics.record_compression_ratio(stats.compression_ratio);
            self.metrics.record_compression_time(stats.compression_time_us);
        }
        
        Ok(())
    }
}
```

---

## ğŸ“Š æ€§èƒ½æµ‹è¯•

### æµ‹è¯•åœºæ™¯

```rust
// benchmarks/tracezip_benchmarks.rs

use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};
use otlp::compression::tracezip::*;

fn bench_compression(c: &mut Criterion) {
    let mut group = c.benchmark_group("tracezip_compression");
    
    // ä¸åŒæ‰¹é‡å¤§å°
    for size in [10, 100, 1000, 10000] {
        let spans = generate_test_spans(size);
        
        group.bench_with_input(
            BenchmarkId::new("compress", size),
            &spans,
            |b, spans| {
                let mut compressor = TraceCompressor::new(TracezipConfig::default());
                b.iter(|| {
                    compressor.compress(black_box(spans.clone()))
                });
            },
        );
    }
    
    group.finish();
}

fn bench_deduplication(c: &mut Criterion) {
    let mut group = c.benchmark_group("span_deduplication");
    
    // ä¸åŒé‡å¤ç‡
    for dup_rate in [0.0, 0.25, 0.5, 0.75] {
        let spans = generate_spans_with_duplication(1000, dup_rate);
        
        group.bench_with_input(
            BenchmarkId::new("dedup", (dup_rate * 100.0) as i32),
            &spans,
            |b, spans| {
                let mut dedup = SpanDeduplicator::new();
                b.iter(|| {
                    dedup.deduplicate(black_box(spans))
                });
            },
        );
    }
    
    group.finish();
}

criterion_group!(benches, bench_compression, bench_deduplication);
criterion_main!(benches);
```

### æ€§èƒ½ç›®æ ‡

```yaml
å‹ç¼©æ€§èƒ½:
  å°æ‰¹é‡(10 spans):
    - å‹ç¼©æ—¶é—´: <1ms
    - å‹ç¼©ç‡: 20-30%
  
  ä¸­æ‰¹é‡(100 spans):
    - å‹ç¼©æ—¶é—´: <5ms
    - å‹ç¼©ç‡: 40-50%
  
  å¤§æ‰¹é‡(1000 spans):
    - å‹ç¼©æ—¶é—´: <10ms
    - å‹ç¼©ç‡: 50-60%

èµ„æºæ¶ˆè€—:
  CPUå¼€é”€: <5% (ç›¸å¯¹äºæœªå‹ç¼©)
  å†…å­˜å¼€é”€: <10% (ç›¸å¯¹äºæœªå‹ç¼©)
  
ååé‡:
  æœ€å°: 10,000 spans/s
  ç›®æ ‡: 50,000 spans/s
```

---

## âœ… éªŒæ”¶æ ‡å‡†

```yaml
åŠŸèƒ½å®Œæ•´æ€§:
  âœ… Spanå»é‡å®ç°
  âœ… å¢é‡ç¼–ç å®ç°
  âœ… å­—ç¬¦ä¸²è¡¨ä¼˜åŒ–
  âœ… æ‰¹é‡å¤„ç†æ”¯æŒ
  âœ… é€æ˜å‹ç¼©/è§£å‹
  âœ… é…ç½®é€‰é¡¹å®Œæ•´
  âœ… å‘åå…¼å®¹æ€§

æ€§èƒ½è¾¾æ ‡:
  âœ… ä¼ è¾“é‡å‡å°‘ â‰¥50%
  âœ… CPUå¼€é”€ <5%
  âœ… å†…å­˜å¼€é”€ <10%
  âœ… å‹ç¼©å»¶è¿Ÿ <10ms

è´¨é‡è¦æ±‚:
  âœ… å•å…ƒæµ‹è¯•è¦†ç›–ç‡ >80%
  âœ… é›†æˆæµ‹è¯•å®Œæ•´
  âœ… æ€§èƒ½åŸºå‡†æµ‹è¯•
  âœ… æ–‡æ¡£å®Œæ•´æ¸…æ™°
  âœ… ç¤ºä¾‹ä»£ç ä¸°å¯Œ

å…¼å®¹æ€§:
  âœ… OTLPå®Œå…¨å…¼å®¹
  âœ… å‘åå…¼å®¹
  âœ… ä¼˜é›…é™çº§
  âœ… ç‰ˆæœ¬æ£€æµ‹
```

---

## ğŸ“š å‚è€ƒèµ„æ–™

- [Tracezip: A Trace Archive Format for Efficient Compression and Retrieval](https://research.google/pubs/pub49484/)
- [OTLP Compression Extensions](https://github.com/open-telemetry/opentelemetry-proto)
- [Jaeger Compression Implementation](https://github.com/jaegertracing/jaeger)

---

**åˆ›å»ºæ—¥æœŸ**: 2025å¹´10æœˆ23æ—¥  
**é¢„è®¡å®Œæˆ**: 2025å¹´12æœˆ31æ—¥  
**è´Ÿè´£äºº**: å¾…åˆ†é…  

ğŸš€ **è®©æˆ‘ä»¬æ„å»ºé«˜æ•ˆçš„å‹ç¼©ç³»ç»Ÿï¼**
