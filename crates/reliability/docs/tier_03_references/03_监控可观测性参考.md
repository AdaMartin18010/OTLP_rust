# 监控与可观测性完整参考

**最后更新**: 2025-10-24  
**适用版本**: Rust 1.90+  
**难度**: ⭐⭐⭐⭐

---

## 📋 目录

- [监控与可观测性完整参考](#监控与可观测性完整参考)
  - [📋 目录](#-目录)
  - [1. 三大支柱概述](#1-三大支柱概述)
    - [1.1 日志 (Logging)](#11-日志-logging)
    - [1.2 指标 (Metrics)](#12-指标-metrics)
    - [1.3 追踪 (Tracing)](#13-追踪-tracing)
  - [2. 日志框架 (log/tracing)](#2-日志框架-logtracing)
    - [2.1 log crate 基础](#21-log-crate-基础)
    - [2.2 env\_logger 配置](#22-env_logger-配置)
    - [2.3 tracing 框架](#23-tracing-框架)
    - [2.4 结构化日志](#24-结构化日志)
  - [3. 指标收集 (metrics)](#3-指标收集-metrics)
    - [3.1 metrics crate](#31-metrics-crate)
    - [3.2 Prometheus 集成](#32-prometheus-集成)
    - [3.3 指标类型](#33-指标类型)
  - [4. 分布式追踪 (OpenTelemetry)](#4-分布式追踪-opentelemetry)
    - [4.1 基本配置](#41-基本配置)
    - [4.2 Span 管理](#42-span-管理)
    - [4.3 上下文传播](#43-上下文传播)
  - [5. 日志最佳实践](#5-日志最佳实践)
    - [5.1 日志级别使用](#51-日志级别使用)
    - [5.2 结构化日志](#52-结构化日志)
    - [5.3 敏感信息处理](#53-敏感信息处理)
  - [6. 指标最佳实践](#6-指标最佳实践)
    - [6.1 命名约定](#61-命名约定)
    - [6.2 标签使用](#62-标签使用)
    - [6.3 性能考量](#63-性能考量)
  - [7. 追踪最佳实践](#7-追踪最佳实践)
    - [7.1 Span 设计](#71-span-设计)
    - [7.2 采样策略](#72-采样策略)
    - [7.3 异步追踪](#73-异步追踪)
  - [8. 生产环境集成](#8-生产环境集成)
    - [8.1 完整示例](#81-完整示例)
    - [8.2 健康检查](#82-健康检查)
  - [9. 故障排查](#9-故障排查)
    - [9.1 常见问题](#91-常见问题)
  - [10. API 速查表](#10-api-速查表)
    - [10.1 日志宏](#101-日志宏)
    - [10.2 指标API](#102-指标api)
    - [10.3 追踪API](#103-追踪api)

---

## 🎯 三大支柱概述

### 1.1 日志 (Logging)

**定义**: 记录离散事件，包含时间戳和上下文信息。

**用途**:

- 错误调试
- 审计追踪
- 业务分析

**示例**:

```text
2025-10-24T10:30:45Z INFO User logged in: user_id=123
2025-10-24T10:30:46Z ERROR Database connection failed: timeout
```

---

### 1.2 指标 (Metrics)

**定义**: 可聚合的数值数据，用于监控系统状态。

**用途**:

- 性能监控
- 容量规划
- 告警触发

**示例**:

```text
http_requests_total{method="GET", status="200"} 1524
http_request_duration_seconds_bucket{le="0.1"} 234
```

---

### 1.3 追踪 (Tracing)

**定义**: 跟踪请求在分布式系统中的执行路径。

**用途**:

- 性能分析
- 依赖关系
- 瓶颈定位

**示例**:

```text
Trace ID: abc123
├─ Span: HTTP Request (100ms)
│  ├─ Span: Auth Check (10ms)
│  ├─ Span: Database Query (60ms)
│  └─ Span: Response Marshal (30ms)
```

---

## 📝 日志框架 (log/tracing)

### 2.1 log crate 基础

**Cargo.toml**:

```toml
[dependencies]
log = "0.4"
env_logger = "0.11"
```

**基本使用**:

```rust
use log::{trace, debug, info, warn, error};

fn main() {
    env_logger::init();
    
    trace!("Trace message");
    debug!("Debug message");
    info!("Info message");
    warn!("Warning message");
    error!("Error message");
}

// 运行: RUST_LOG=info cargo run
```

**带参数的日志**:

```rust
let user_id = 42;
let duration = 1.23;

info!("User {} logged in", user_id);
debug!("Request completed in {:.2}ms", duration);
error!("Failed to connect to {}:{}", host, port);

// 结构化参数
info!(target: "auth", "Login attempt: user_id={}", user_id);
```

---

### 2.2 env_logger 配置

**环境变量配置**:

```bash
# 全局级别
RUST_LOG=info cargo run

# 模块级别
RUST_LOG=myapp=debug,hyper=info cargo run

# 多个模块
RUST_LOG=myapp::auth=debug,myapp::db=info cargo run

# 复杂过滤
RUST_LOG=warn,myapp=debug cargo run
```

**程序化配置**:

```rust
use env_logger::Builder;
use log::LevelFilter;

fn init_logger() {
    Builder::new()
        .filter_level(LevelFilter::Info)
        .filter_module("myapp::auth", LevelFilter::Debug)
        .filter_module("hyper", LevelFilter::Warn)
        .format_timestamp_millis()
        .init();
}
```

---

### 2.3 tracing 框架

**Cargo.toml**:

```toml
[dependencies]
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
```

**基本使用**:

```rust
use tracing::{trace, debug, info, warn, error, instrument};

fn main() {
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::INFO)
        .init();
    
    info!("Starting application");
    process_request(42);
}

#[instrument]
fn process_request(user_id: i32) {
    info!("Processing request");
    let result = perform_task();
    info!(result = ?result, "Task completed");
}

// 输出:
// INFO starting application
// INFO process_request{user_id=42}: processing request
// INFO process_request{user_id=42}: task completed result=Ok(())
```

**Span 和 Event**:

```rust
use tracing::{span, Level};

fn handle_request() {
    let span = span!(Level::INFO, "request", method = "GET", path = "/api/users");
    let _enter = span.enter();
    
    // 事件自动关联到当前 span
    info!("Handling request");
    
    let user = fetch_user(42);
    info!(user_id = user.id, "User fetched");
}

// 简化写法
#[instrument(fields(request_id = %uuid::Uuid::new_v4()))]
async fn handle_request_async() {
    info!("Request started");
    // ...
}
```

---

### 2.4 结构化日志

**使用 serde_json**:

```rust
use serde_json::json;
use tracing::info;

let event = json!({
    "event": "user_login",
    "user_id": 42,
    "ip": "192.168.1.1",
    "timestamp": chrono::Utc::now(),
});

info!(event = %event, "User event");

// JSON 格式订阅器
use tracing_subscriber::fmt::format::FmtSpan;

tracing_subscriber::fmt()
    .json()
    .with_span_events(FmtSpan::CLOSE)
    .init();
```

---

## 💡 指标收集 (metrics)

### 3.1 metrics crate

**Cargo.toml**:

```toml
[dependencies]
metrics = "0.21"
metrics-exporter-prometheus = "0.13"
```

**基本使用**:

```rust
use metrics::{counter, gauge, histogram};

fn handle_request() {
    // 计数器：累加
    counter!("http_requests_total", "method" => "GET", "status" => "200").increment(1);
    
    // 仪表盘：设置值
    gauge!("active_connections").set(42.0);
    
    // 直方图：记录分布
    histogram!("http_request_duration_seconds").record(0.123);
}
```

**初始化**:

```rust
use metrics_exporter_prometheus::PrometheusBuilder;

fn main() {
    // 设置 Prometheus exporter
    PrometheusBuilder::new()
        .install()
        .expect("failed to install Prometheus recorder");
    
    // 现在可以使用 metrics 宏
    counter!("app_started").increment(1);
}
```

---

### 3.2 Prometheus 集成

**完整 HTTP 服务器**:

```rust
use axum::{routing::get, Router};
use metrics_exporter_prometheus::PrometheusHandle;

#[tokio::main]
async fn main() {
    // 创建 Prometheus exporter
    let recorder_handle = PrometheusBuilder::new()
        .install_recorder()
        .unwrap();
    
    // 创建 metrics 端点
    let app = Router::new()
        .route("/metrics", get(move || async move {
            recorder_handle.render()
        }))
        .route("/api/users", get(handle_users));
    
    // 启动服务器
    axum::Server::bind(&"0.0.0.0:9090".parse().unwrap())
        .serve(app.into_make_service())
        .await
        .unwrap();
}

async fn handle_users() -> &'static str {
    counter!("api_requests_total", "endpoint" => "/api/users").increment(1);
    let start = std::time::Instant::now();
    
    // 处理请求
    
    histogram!("api_request_duration_seconds", "endpoint" => "/api/users")
        .record(start.elapsed().as_secs_f64());
    
    "Users"
}
```

---

### 3.3 指标类型

**计数器 (Counter)**:

```rust
// 只增不减
counter!("requests_total").increment(1);
counter!("bytes_sent").increment(1024);

// 带标签
counter!("http_requests", 
    "method" => "GET",
    "status" => "200"
).increment(1);
```

**仪表盘 (Gauge)**:

```rust
// 可增可减
gauge!("active_connections").increment(1.0);
gauge!("active_connections").decrement(1.0);
gauge!("active_connections").set(42.0);

// 温度、CPU使用率等
gauge!("cpu_usage_percent").set(75.5);
gauge!("memory_used_bytes").set(1_073_741_824.0);
```

**直方图 (Histogram)**:

```rust
// 记录值的分布
histogram!("http_request_duration_seconds").record(0.123);
histogram!("db_query_duration_seconds").record(0.045);

// 自动生成 bucket、sum、count
// http_request_duration_seconds_bucket{le="0.1"} 234
// http_request_duration_seconds_sum 125.4
// http_request_duration_seconds_count 1000
```

---

## 🔧 分布式追踪 (OpenTelemetry)

### 4.1 基本配置

**Cargo.toml**:

```toml
[dependencies]
opentelemetry = "0.20"
opentelemetry-jaeger = "0.19"
tracing-opentelemetry = "0.21"
tracing-subscriber = "0.3"
```

**初始化**:

```rust
use opentelemetry::global;
use opentelemetry_jaeger::new_agent_pipeline;
use tracing_subscriber::{layer::SubscriberExt, Registry};

fn init_tracer() {
    // 配置 Jaeger exporter
    let tracer = new_agent_pipeline()
        .with_service_name("my-service")
        .with_endpoint("localhost:6831")
        .install_batch(opentelemetry::runtime::Tokio)
        .expect("Failed to install OpenTelemetry tracer");
    
    // 创建 tracing layer
    let telemetry = tracing_opentelemetry::layer().with_tracer(tracer);
    
    // 组合订阅器
    let subscriber = Registry::default()
        .with(telemetry)
        .with(tracing_subscriber::fmt::layer());
    
    tracing::subscriber::set_global_default(subscriber)
        .expect("Failed to set subscriber");
}
```

---

### 4.2 Span 管理

**手动 Span**:

```rust
use tracing::{span, Level};

fn process() {
    let span = span!(Level::INFO, "process", user_id = 42);
    let _enter = span.enter();
    
    // 所有日志和 span 自动关联
    info!("Processing started");
    
    // 嵌套 span
    {
        let child_span = span!(Level::DEBUG, "database_query");
        let _enter = child_span.enter();
        
        info!("Querying database");
    }
    
    info!("Processing completed");
}
```

**自动 Span (instrument)**:

```rust
use tracing::instrument;

#[instrument(skip(password), fields(user_id = user.id))]
async fn authenticate(user: &User, password: &str) -> Result<Token, AuthError> {
    info!("Authenticating user");
    
    let hash = hash_password(password).await?;
    verify_hash(&user.password_hash, &hash)?;
    
    info!("Authentication successful");
    Ok(generate_token(user))
}
```

---

### 4.3 上下文传播

**HTTP 头部传播**:

```rust
use opentelemetry::global;
use opentelemetry::propagation::TextMapPropagator;

async fn handle_request(req: Request) -> Response {
    // 提取上下文
    let propagator = global::get_text_map_propagator(|propagator| {
        propagator.extract(&req.headers())
    });
    
    // 在当前上下文中处理请求
    let span = span!(Level::INFO, "handle_request");
    let _enter = span.enter();
    
    // 调用下游服务
    let mut downstream_req = Request::new();
    
    // 注入上下文
    global::get_text_map_propagator(|propagator| {
        propagator.inject_context(&tracing::Span::current().context(), &mut downstream_req.headers_mut())
    });
    
    client.send(downstream_req).await
}
```

---

## 📊 日志最佳实践

### 5.1 日志级别使用

```rust
// TRACE: 非常详细，仅用于诊断特定问题
trace!("Entering function with args: {:?}", args);

// DEBUG: 开发调试信息
debug!("Cache hit for key: {}", key);

// INFO: 重要的业务事件
info!("User {} logged in successfully", user_id);

// WARN: 警告，不影响功能但需注意
warn!("Retry attempt {}/3 failed", retry_count);

// ERROR: 错误，需要关注和修复
error!("Database connection failed: {}", err);
```

---

### 5.2 结构化日志

```rust
// ❌ 不好：难以解析
info!("User 42 logged in from 192.168.1.1");

// ✅ 好：结构化
info!(
    user_id = 42,
    ip = "192.168.1.1",
    "User logged in"
);

// 使用 tracing fields
#[instrument(fields(
    user_id = user.id,
    username = %user.name,
    request_id = %uuid::Uuid::new_v4()
))]
async fn process_user(user: &User) {
    info!("Processing user");
}
```

---

### 5.3 敏感信息处理

```rust
use tracing::info;

// ❌ 不要记录敏感信息
// error!("Login failed: password={}", password);

// ✅ 使用占位符
info!("Login failed: user={}, password=***", username);

// ✅ 使用 skip 跳过敏感字段
#[instrument(skip(password, api_key))]
fn authenticate(username: &str, password: &str, api_key: &str) {
    // ...
}

// ✅ 自定义 Debug 实现
#[derive(Debug)]
struct User {
    id: u32,
    username: String,
    #[debug(skip)]  // 或使用自定义格式化
    password_hash: String,
}
```

---

## 🚀 指标最佳实践

### 6.1 命名约定

```rust
// ✅ 好的命名
counter!("http_requests_total");          // 使用 _total 后缀
gauge!("active_connections");             // 描述性名称
histogram!("http_request_duration_seconds"); // 使用标准单位后缀

// ❌ 不好的命名
counter!("requests");                     // 不够具体
gauge!("conn");                          // 缩写不清晰
histogram!("latency");                   // 缺少单位
```

---

### 6.2 标签使用

```rust
// ✅ 好的标签：基数可控
counter!("http_requests_total",
    "method" => "GET",           // 有限值: GET, POST等
    "status" => "200",           // 有限值: 200, 404等
    "endpoint" => "/api/users"   // 控制数量的端点
).increment(1);

// ❌ 不好的标签：基数过高
counter!("http_requests_total",
    "user_id" => user_id,        // 可能有数百万用户
    "request_id" => request_id   // 每个请求都不同
).increment(1);
```

---

### 6.3 性能考量

```rust
// ✅ 缓存指标句柄
use metrics::{Counter, register_counter};

struct Metrics {
    requests_total: Counter,
}

impl Metrics {
    fn new() -> Self {
        Self {
            requests_total: register_counter!("requests_total"),
        }
    }
}

// 使用缓存的句柄
fn handle_request(metrics: &Metrics) {
    metrics.requests_total.increment(1);  // 快速
}

// ❌ 每次都查找
fn handle_request_slow() {
    counter!("requests_total").increment(1);  // 稍慢
}
```

---

## 🔍 追踪最佳实践

### 7.1 Span 设计

```rust
// ✅ 好的 span 设计
#[instrument(name = "authenticate_user", skip(password))]
async fn authenticate(username: &str, password: &str) -> Result<User> {
    // 子操作也创建 span
    let user = fetch_user(username).await?;
    verify_password(&user, password).await?;
    Ok(user)
}

#[instrument(name = "db.query", fields(db.statement = query))]
async fn fetch_user(username: &str) -> Result<User> {
    // ...
}

// Span 层次:
// authenticate_user
// └─ db.query
```

---

### 7.2 采样策略

```rust
use opentelemetry::sdk::trace::{Sampler, SamplerResult};

// 固定采样率
let sampler = Sampler::TraceIdRatioBased(0.1); // 10%

// 自定义采样
struct CustomSampler;

impl Sampler for CustomSampler {
    fn should_sample(&self, context: &SamplingContext) -> SamplerResult {
        // 总是采样错误请求
        if context.attributes().contains_key("error") {
            return SamplerResult::RecordAndSample;
        }
        
        // 其他请求按比例采样
        if rand::random::<f64>() < 0.1 {
            SamplerResult::RecordAndSample
        } else {
            SamplerResult::Drop
        }
    }
}
```

---

### 7.3 异步追踪

```rust
use tracing::Instrument;

async fn process_async() {
    // ✅ 使用 instrument 确保上下文传播
    let span = span!(Level::INFO, "process");
    
    async move {
        info!("Step 1");
        tokio::time::sleep(Duration::from_millis(100)).await;
        info!("Step 2");
    }
    .instrument(span)
    .await;
}

// 或使用 #[instrument]
#[instrument]
async fn process_auto() {
    info!("Step 1");
    tokio::time::sleep(Duration::from_millis(100)).await;
    info!("Step 2");
}
```

---

## 💻 生产环境集成

### 8.1 完整示例

```rust
use tracing::info;
use metrics::{counter, histogram};
use opentelemetry::global;

#[tokio::main]
async fn main() {
    // 初始化观测性组件
    init_observability();
    
    info!("Application started");
    counter!("app_starts_total").increment(1);
    
    // 启动服务
    let app = create_app();
    
    // 优雅关闭
    tokio::select! {
        _ = axum::Server::bind(&"0.0.0.0:8080".parse().unwrap())
            .serve(app.into_make_service()) => {}
        _ = tokio::signal::ctrl_c() => {
            info!("Shutting down");
            global::shutdown_tracer_provider();
        }
    }
}

fn init_observability() {
    // 日志
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::INFO)
        .json()
        .init();
    
    // 指标
    let _ = metrics_exporter_prometheus::PrometheusBuilder::new()
        .install();
    
    // 追踪
    let tracer = opentelemetry_jaeger::new_agent_pipeline()
        .with_service_name("my-service")
        .install_batch(opentelemetry::runtime::Tokio)
        .unwrap();
    
    tracing::subscriber::set_global_default(
        tracing_subscriber::Registry::default()
            .with(tracing_opentelemetry::layer().with_tracer(tracer))
    ).unwrap();
}
```

---

### 8.2 健康检查

```rust
use axum::{Json, response::IntoResponse};
use serde_json::json;

async fn health_check() -> impl IntoResponse {
    let health = json!({
        "status": "healthy",
        "timestamp": chrono::Utc::now(),
        "checks": {
            "database": check_database().await,
            "cache": check_cache().await,
        }
    });
    
    Json(health)
}

async fn readiness_check() -> impl IntoResponse {
    // 检查所有依赖是否就绪
    if is_ready().await {
        (axum::http::StatusCode::OK, "Ready")
    } else {
        (axum::http::StatusCode::SERVICE_UNAVAILABLE, "Not ready")
    }
}
```

---

## 📚 故障排查

### 9.1 常见问题

**问题 1**: 日志级别不生效

```bash
# 确保设置了环境变量
RUST_LOG=debug cargo run

# 或在代码中设置
env_logger::Builder::new()
    .filter_level(log::LevelFilter::Debug)
    .init();
```

**问题 2**: 指标未导出

```rust
// 确保安装了 exporter
let _handle = PrometheusBuilder::new()
    .install_recorder()
    .expect("Failed to install Prometheus recorder");

// 确保有 /metrics 端点
app.route("/metrics", get(|| async { recorder_handle.render() }))
```

**问题 3**: Span 上下文丢失

```rust
// ✅ 确保在异步代码中传播上下文
async fn work() {
    async_operation()
        .instrument(span!(Level::INFO, "operation"))
        .await;
}
```

---

## ✅ API 速查表

### 10.1 日志宏

| 宏 | 级别 | 用途 |
|----|------|------|
| `trace!()` | TRACE | 详细诊断 |
| `debug!()` | DEBUG | 调试信息 |
| `info!()` | INFO | 业务事件 |
| `warn!()` | WARN | 警告 |
| `error!()` | ERROR | 错误 |

---

### 10.2 指标API

| 函数 | 类型 | 说明 |
|------|------|------|
| `counter!()` | Counter | 只增计数器 |
| `gauge!()` | Gauge | 可增可减仪表盘 |
| `histogram!()` | Histogram | 值分布直方图 |

---

### 10.3 追踪API

| 宏/函数 | 说明 |
|---------|------|
| `span!()` | 创建 span |
| `#[instrument]` | 自动 span |
| `.instrument()` | 异步 span 传播 |

---

**相关文档**:

- [测试框架完整参考](./01_测试框架完整参考.md)
- [错误处理完整参考](./02_错误处理完整参考.md)
- [故障恢复机制参考](./04_故障恢复机制参考.md)
- [Tier 2 监控实践](../tier_02_guides/)

---

**最后更新**: 2025-10-24  
**贡献者**: Rust Documentation Team
