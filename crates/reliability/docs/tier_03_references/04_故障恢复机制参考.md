# 故障恢复机制完整参考

**最后更新**: 2025-10-24  
**适用版本**: Rust 1.90+  
**难度**: ⭐⭐⭐⭐

---

## 📋 目录

- [故障恢复机制完整参考](#故障恢复机制完整参考)
  - [📋 目录](#-目录)
  - [1. 重试策略](#1-重试策略)
    - [1.1 固定延迟重试](#11-固定延迟重试)
    - [1.2 指数退避](#12-指数退避)
    - [1.3 抖动 (Jitter)](#13-抖动-jitter)
  - [2. 断路器模式 (Circuit Breaker)](#2-断路器模式-circuit-breaker)
    - [2.1 状态机](#21-状态机)
    - [2.2 基本实现](#22-基本实现)
    - [2.3 高级配置](#23-高级配置)
  - [3. 超时控制](#3-超时控制)
    - [3.1 tokio 超时](#31-tokio-超时)
    - [3.2 分层超时](#32-分层超时)
    - [3.3 超时传播](#33-超时传播)
  - [4. 限流算法](#4-限流算法)
    - [4.1 令牌桶 (Token Bucket)](#41-令牌桶-token-bucket)
    - [4.2 漏桶 (Leaky Bucket)](#42-漏桶-leaky-bucket)
    - [4.3 固定窗口计数](#43-固定窗口计数)
    - [4.4 滑动窗口日志](#44-滑动窗口日志)
  - [5. 降级策略](#5-降级策略)
    - [5.1 特性降级](#51-特性降级)
    - [5.2 缓存降级](#52-缓存降级)
    - [5.3 默认值降级](#53-默认值降级)
  - [6. 舱壁隔离 (Bulkhead)](#6-舱壁隔离-bulkhead)
    - [6.1 资源池隔离](#61-资源池隔离)
    - [6.2 线程池隔离](#62-线程池隔离)
  - [7. 优雅关机](#7-优雅关机)
    - [7.1 信号处理](#71-信号处理)
    - [7.2 资源清理](#72-资源清理)
    - [7.3 请求排空](#73-请求排空)
  - [8. 健康检查](#8-健康检查)
    - [8.1 活性检查 (Liveness)](#81-活性检查-liveness)
    - [8.2 就绪检查 (Readiness)](#82-就绪检查-readiness)
  - [9. 组合模式](#9-组合模式)
    - [9.1 重试 + 断路器](#91-重试--断路器)
    - [9.2 超时 + 重试 + 断路器](#92-超时--重试--断路器)
  - [10. 最佳实践](#10-最佳实践)
    - [10.1 策略选择](#101-策略选择)
    - [10.2 参数调优](#102-参数调优)
    - [10.3 监控指标](#103-监控指标)
  - [11. API 速查表](#11-api-速查表)
    - [11.1 重试库对比](#111-重试库对比)
    - [11.2 配置参数](#112-配置参数)

---

## 🎯 重试策略

### 1.1 固定延迟重试

**基本实现**:

```rust
use std::time::Duration;

async fn retry_fixed<F, T, E>(
    mut operation: F,
    max_retries: usize,
    delay: Duration,
) -> Result<T, E>
where
    F: FnMut() -> Result<T, E>,
{
    let mut attempts = 0;
    
    loop {
        match operation() {
            Ok(result) => return Ok(result),
            Err(e) if attempts < max_retries => {
                attempts += 1;
                tokio::time::sleep(delay).await;
            }
            Err(e) => return Err(e),
        }
    }
}

// 使用
let result = retry_fixed(
    || fetch_data(),
    3,
    Duration::from_secs(1)
).await?;
```

---

### 1.2 指数退避

**算法**: `delay = base_delay * 2^attempt`

```rust
async fn retry_exponential<F, T, E>(
    mut operation: F,
    max_retries: usize,
    base_delay: Duration,
) -> Result<T, E>
where
    F: FnMut() -> Result<T, E>,
{
    let mut attempts = 0;
    
    loop {
        match operation() {
            Ok(result) => return Ok(result),
            Err(e) if attempts < max_retries => {
                let delay = base_delay * 2_u32.pow(attempts as u32);
                tokio::time::sleep(delay).await;
                attempts += 1;
            }
            Err(e) => return Err(e),
        }
    }
}

// 使用
let result = retry_exponential(
    || fetch_data(),
    5,
    Duration::from_millis(100)
).await?;

// 延迟序列: 100ms, 200ms, 400ms, 800ms, 1600ms
```

---

### 1.3 抖动 (Jitter)

**目的**: 避免"惊群效应"，分散重试时间。

```rust
use rand::Rng;

fn exponential_backoff_with_jitter(
    attempt: u32,
    base_delay: Duration,
    max_delay: Duration,
) -> Duration {
    let exponential = base_delay * 2_u32.pow(attempt);
    let capped = exponential.min(max_delay);
    
    // Full jitter: 0 到 capped 之间随机
    let jitter = rand::thread_rng().gen_range(0..=capped.as_millis()) as u64;
    Duration::from_millis(jitter)
}

async fn retry_with_jitter<F, T, E>(
    mut operation: F,
    max_retries: usize,
) -> Result<T, E>
where
    F: FnMut() -> Result<T, E>,
{
    for attempt in 0..max_retries {
        match operation() {
            Ok(result) => return Ok(result),
            Err(e) if attempt < max_retries - 1 => {
                let delay = exponential_backoff_with_jitter(
                    attempt as u32,
                    Duration::from_millis(100),
                    Duration::from_secs(10),
                );
                tokio::time::sleep(delay).await;
            }
            Err(e) => return Err(e),
        }
    }
    
    unreachable!()
}
```

---

## 📝 断路器模式 (Circuit Breaker)

### 2.1 状态机

```text
    [Closed] ──failure threshold──> [Open]
        ↑                              │
        │                              │ timeout
        │                              ↓
    [Half-Open] <──────────────── [Open]
        │
        success threshold
        │
        ↓
    [Closed]
```

**状态说明**:

- **Closed**: 正常运行，请求通过
- **Open**: 快速失败，直接拒绝请求
- **Half-Open**: 尝试恢复，允许部分请求

---

### 2.2 基本实现

```rust
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};

#[derive(Debug, Clone, PartialEq)]
enum CircuitState {
    Closed,
    Open,
    HalfOpen,
}

struct CircuitBreaker {
    state: Arc<Mutex<State>>,
    failure_threshold: usize,
    success_threshold: usize,
    timeout: Duration,
}

struct State {
    state: CircuitState,
    failure_count: usize,
    success_count: usize,
    last_failure_time: Option<Instant>,
}

impl CircuitBreaker {
    pub fn new(
        failure_threshold: usize,
        success_threshold: usize,
        timeout: Duration,
    ) -> Self {
        Self {
            state: Arc::new(Mutex::new(State {
                state: CircuitState::Closed,
                failure_count: 0,
                success_count: 0,
                last_failure_time: None,
            })),
            failure_threshold,
            success_threshold,
            timeout,
        }
    }
    
    pub async fn call<F, T, E>(&self, operation: F) -> Result<T, CircuitBreakerError<E>>
    where
        F: FnOnce() -> Result<T, E>,
    {
        // 检查是否可以执行
        {
            let mut state = self.state.lock().unwrap();
            
            match state.state {
                CircuitState::Open => {
                    // 检查是否超时，可以尝试恢复
                    if let Some(last_failure) = state.last_failure_time {
                        if last_failure.elapsed() > self.timeout {
                            state.state = CircuitState::HalfOpen;
                            state.success_count = 0;
                        } else {
                            return Err(CircuitBreakerError::Open);
                        }
                    }
                }
                _ => {}
            }
        }
        
        // 执行操作
        match operation() {
            Ok(result) => {
                self.on_success();
                Ok(result)
            }
            Err(e) => {
                self.on_failure();
                Err(CircuitBreakerError::Operation(e))
            }
        }
    }
    
    fn on_success(&self) {
        let mut state = self.state.lock().unwrap();
        
        match state.state {
            CircuitState::HalfOpen => {
                state.success_count += 1;
                if state.success_count >= self.success_threshold {
                    state.state = CircuitState::Closed;
                    state.failure_count = 0;
                    state.success_count = 0;
                }
            }
            CircuitState::Closed => {
                state.failure_count = 0;
            }
            _ => {}
        }
    }
    
    fn on_failure(&self) {
        let mut state = self.state.lock().unwrap();
        
        match state.state {
            CircuitState::Closed => {
                state.failure_count += 1;
                if state.failure_count >= self.failure_threshold {
                    state.state = CircuitState::Open;
                    state.last_failure_time = Some(Instant::now());
                }
            }
            CircuitState::HalfOpen => {
                state.state = CircuitState::Open;
                state.last_failure_time = Some(Instant::now());
            }
            _ => {}
        }
    }
}

#[derive(Debug)]
enum CircuitBreakerError<E> {
    Open,
    Operation(E),
}

// 使用
let breaker = CircuitBreaker::new(5, 2, Duration::from_secs(60));

match breaker.call(|| fetch_data()).await {
    Ok(data) => println!("Success: {:?}", data),
    Err(CircuitBreakerError::Open) => println!("Circuit breaker is open"),
    Err(CircuitBreakerError::Operation(e)) => println!("Operation failed: {:?}", e),
}
```

---

### 2.3 高级配置

```rust
struct CircuitBreakerConfig {
    failure_threshold: usize,      // 失败阈值
    success_threshold: usize,      // 成功阈值
    timeout: Duration,             // Open 状态超时
    half_open_max_calls: usize,    // Half-Open 最大调用数
    error_rate_threshold: f64,     // 错误率阈值 (0.0-1.0)
    min_requests: usize,           // 最小请求数（计算错误率）
}

impl Default for CircuitBreakerConfig {
    fn default() -> Self {
        Self {
            failure_threshold: 5,
            success_threshold: 2,
            timeout: Duration::from_secs(60),
            half_open_max_calls: 3,
            error_rate_threshold: 0.5,
            min_requests: 10,
        }
    }
}
```

---

## 💡 超时控制

### 3.1 tokio 超时

```rust
use tokio::time::{timeout, Duration};

// 基本超时
async fn with_timeout() -> Result<String, TimeoutError> {
    timeout(Duration::from_secs(5), fetch_data())
        .await
        .map_err(|_| TimeoutError)?
}

// 多个操作的超时
async fn multiple_timeouts() -> Result<(), Box<dyn std::error::Error>> {
    // 单个操作超时
    let data1 = timeout(Duration::from_secs(2), fetch_data1()).await??;
    
    // 另一个操作超时
    let data2 = timeout(Duration::from_secs(3), fetch_data2()).await??;
    
    // 总超时
    timeout(
        Duration::from_secs(10),
        process(data1, data2)
    ).await??;
    
    Ok(())
}
```

---

### 3.2 分层超时

```rust
struct TimeoutConfig {
    database: Duration,    // 数据库查询超时
    cache: Duration,       // 缓存操作超时
    api: Duration,         // API 调用超时
    total: Duration,       // 总超时
}

async fn process_with_layered_timeout(
    config: &TimeoutConfig
) -> Result<Response, Error> {
    // 总超时
    timeout(config.total, async {
        // 缓存查询超时
        let cached = timeout(config.cache, check_cache()).await.ok().flatten();
        
        if let Some(data) = cached {
            return Ok(data);
        }
        
        // 数据库查询超时
        let db_data = timeout(config.database, query_database())
            .await
            .map_err(|_| Error::DatabaseTimeout)??;
        
        // API 调用超时
        let api_data = timeout(config.api, call_api())
            .await
            .map_err(|_| Error::ApiTimeout)??;
        
        Ok(combine(db_data, api_data))
    }).await
    .map_err(|_| Error::TotalTimeout)?
}
```

---

### 3.3 超时传播

```rust
use tokio::time::{Instant, timeout_at};

async fn parent_operation(deadline: Instant) -> Result<(), Error> {
    // 传播截止时间给子操作
    let result1 = timeout_at(deadline, child_operation1()).await?;
    
    // 计算剩余时间
    let remaining = deadline.saturating_duration_since(Instant::now());
    
    if remaining.is_zero() {
        return Err(Error::Timeout);
    }
    
    let result2 = timeout_at(deadline, child_operation2()).await?;
    
    Ok(())
}

// 使用
let deadline = Instant::now() + Duration::from_secs(10);
parent_operation(deadline).await?;
```

---

## 🔧 限流算法

### 4.1 令牌桶 (Token Bucket)

**算法**: 固定速率生成令牌，请求消耗令牌。

```rust
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};

struct TokenBucket {
    capacity: usize,           // 桶容量
    tokens: Arc<Mutex<f64>>,   // 当前令牌数
    rate: f64,                 // 令牌生成速率（个/秒）
    last_update: Arc<Mutex<Instant>>,
}

impl TokenBucket {
    pub fn new(capacity: usize, rate: f64) -> Self {
        Self {
            capacity,
            tokens: Arc::new(Mutex::new(capacity as f64)),
            rate,
            last_update: Arc::new(Mutex::new(Instant::now())),
        }
    }
    
    pub fn acquire(&self, tokens: usize) -> bool {
        self.refill();
        
        let mut current_tokens = self.tokens.lock().unwrap();
        
        if *current_tokens >= tokens as f64 {
            *current_tokens -= tokens as f64;
            true
        } else {
            false
        }
    }
    
    fn refill(&self) {
        let now = Instant::now();
        let mut last_update = self.last_update.lock().unwrap();
        let elapsed = now.duration_since(*last_update).as_secs_f64();
        
        if elapsed > 0.0 {
            let mut tokens = self.tokens.lock().unwrap();
            *tokens = (*tokens + elapsed * self.rate).min(self.capacity as f64);
            *last_update = now;
        }
    }
    
    pub async fn wait_for(&self, tokens: usize) {
        loop {
            if self.acquire(tokens) {
                return;
            }
            tokio::time::sleep(Duration::from_millis(10)).await;
        }
    }
}

// 使用
let limiter = TokenBucket::new(100, 10.0);  // 容量100，速率10/秒

if limiter.acquire(1) {
    // 处理请求
} else {
    // 拒绝请求
}

// 或等待令牌
limiter.wait_for(1).await;
// 继续处理
```

---

### 4.2 漏桶 (Leaky Bucket)

**算法**: 固定速率流出请求。

```rust
use std::collections::VecDeque;

struct LeakyBucket {
    capacity: usize,
    rate: Duration,  // 流出间隔
    queue: Arc<Mutex<VecDeque<Instant>>>,
}

impl LeakyBucket {
    pub fn new(capacity: usize, rate: Duration) -> Self {
        Self {
            capacity,
            rate,
            queue: Arc::new(Mutex::new(VecDeque::new())),
        }
    }
    
    pub fn try_acquire(&self) -> bool {
        self.leak();
        
        let mut queue = self.queue.lock().unwrap();
        
        if queue.len() < self.capacity {
            queue.push_back(Instant::now());
            true
        } else {
            false
        }
    }
    
    fn leak(&self) {
        let now = Instant::now();
        let mut queue = self.queue.lock().unwrap();
        
        while let Some(first) = queue.front() {
            if now.duration_since(*first) >= self.rate {
                queue.pop_front();
            } else {
                break;
            }
        }
    }
}
```

---

### 4.3 固定窗口计数

```rust
use std::collections::HashMap;
use std::time::{SystemTime, UNIX_EPOCH};

struct FixedWindowCounter {
    limit: usize,
    window_size: Duration,
    windows: Arc<Mutex<HashMap<u64, usize>>>,
}

impl FixedWindowCounter {
    pub fn new(limit: usize, window_size: Duration) -> Self {
        Self {
            limit,
            window_size,
            windows: Arc::new(Mutex::new(HashMap::new())),
        }
    }
    
    pub fn try_acquire(&self) -> bool {
        let now = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();
        
        let window = now / self.window_size.as_secs();
        
        let mut windows = self.windows.lock().unwrap();
        
        // 清理旧窗口
        windows.retain(|&k, _| k >= window);
        
        let count = windows.entry(window).or_insert(0);
        
        if *count < self.limit {
            *count += 1;
            true
        } else {
            false
        }
    }
}
```

---

### 4.4 滑动窗口日志

```rust
use std::collections::VecDeque;

struct SlidingWindowLog {
    limit: usize,
    window_size: Duration,
    log: Arc<Mutex<VecDeque<Instant>>>,
}

impl SlidingWindowLog {
    pub fn new(limit: usize, window_size: Duration) -> Self {
        Self {
            limit,
            window_size,
            log: Arc::new(Mutex::new(VecDeque::new())),
        }
    }
    
    pub fn try_acquire(&self) -> bool {
        let now = Instant::now();
        let mut log = self.log.lock().unwrap();
        
        // 清理窗口外的记录
        while let Some(first) = log.front() {
            if now.duration_since(*first) > self.window_size {
                log.pop_front();
            } else {
                break;
            }
        }
        
        if log.len() < self.limit {
            log.push_back(now);
            true
        } else {
            false
        }
    }
}
```

---

## 📊 降级策略

### 5.1 特性降级

```rust
async fn get_user_profile(user_id: i32) -> Result<UserProfile, Error> {
    // 尝试完整功能
    match get_full_profile(user_id).await {
        Ok(profile) => Ok(profile),
        Err(_) => {
            // 降级：返回基本信息
            get_basic_profile(user_id).await
        }
    }
}

async fn search_products(query: &str) -> Result<Vec<Product>, Error> {
    // 尝试高级搜索（包含推荐）
    match advanced_search(query).await {
        Ok(results) => Ok(results),
        Err(_) => {
            // 降级：基本搜索（无推荐）
            basic_search(query).await
        }
    }
}
```

---

### 5.2 缓存降级

```rust
async fn get_data(id: i32) -> Result<Data, Error> {
    // 1. 尝试主数据源
    match fetch_from_primary(id).await {
        Ok(data) => {
            // 更新缓存
            let _ = update_cache(id, &data).await;
            return Ok(data);
        }
        Err(_) => {}
    }
    
    // 2. 尝试从缓存读取
    if let Ok(cached) = get_from_cache(id).await {
        return Ok(cached);
    }
    
    // 3. 尝试备份数据源
    if let Ok(data) = fetch_from_backup(id).await {
        return Ok(data);
    }
    
    // 4. 返回默认值
    Ok(Data::default())
}
```

---

### 5.3 默认值降级

```rust
async fn get_recommendations(user_id: i32) -> Vec<Product> {
    // 尝试个性化推荐
    if let Ok(personalized) = get_personalized_recommendations(user_id).await {
        return personalized;
    }
    
    // 降级：热门推荐
    if let Ok(popular) = get_popular_products().await {
        return popular;
    }
    
    // 最终降级：静态默认列表
    get_default_products()
}
```

---

## 🚀 舱壁隔离 (Bulkhead)

### 6.1 资源池隔离

```rust
use tokio::sync::Semaphore;

struct ResourcePool {
    semaphore: Arc<Semaphore>,
}

impl ResourcePool {
    pub fn new(capacity: usize) -> Self {
        Self {
            semaphore: Arc::new(Semaphore::new(capacity)),
        }
    }
    
    pub async fn acquire<F, T>(&self, operation: F) -> Result<T, Error>
    where
        F: FnOnce() -> T,
    {
        let _permit = self.semaphore.acquire().await.map_err(|_| Error::PoolExhausted)?;
        Ok(operation())
    }
}

// 为不同服务创建独立资源池
struct ServicePools {
    database_pool: ResourcePool,
    cache_pool: ResourcePool,
    external_api_pool: ResourcePool,
}

impl ServicePools {
    pub fn new() -> Self {
        Self {
            database_pool: ResourcePool::new(50),
            cache_pool: ResourcePool::new(100),
            external_api_pool: ResourcePool::new(20),
        }
    }
}

// 使用
async fn handle_request(pools: &ServicePools) -> Result<Response, Error> {
    // 数据库查询使用独立池
    let db_result = pools.database_pool
        .acquire(|| query_database())
        .await?;
    
    // 外部 API 调用使用独立池
    let api_result = pools.external_api_pool
        .acquire(|| call_external_api())
        .await?;
    
    Ok(combine(db_result, api_result))
}
```

---

### 6.2 线程池隔离

```rust
use tokio::runtime::{Builder, Runtime};

struct IsolatedExecutors {
    cpu_intensive: Runtime,
    io_intensive: Runtime,
    default: Runtime,
}

impl IsolatedExecutors {
    pub fn new() -> Self {
        Self {
            // CPU 密集型：线程数 = CPU 核心数
            cpu_intensive: Builder::new_multi_thread()
                .worker_threads(num_cpus::get())
                .thread_name("cpu-pool")
                .build()
                .unwrap(),
            
            // I/O 密集型：更多线程
            io_intensive: Builder::new_multi_thread()
                .worker_threads(num_cpus::get() * 2)
                .thread_name("io-pool")
                .build()
                .unwrap(),
            
            // 默认
            default: Runtime::new().unwrap(),
        }
    }
    
    pub fn spawn_cpu_task<F>(&self, task: F)
    where
        F: Future<Output = ()> + Send + 'static,
    {
        self.cpu_intensive.spawn(task);
    }
    
    pub fn spawn_io_task<F>(&self, task: F)
    where
        F: Future<Output = ()> + Send + 'static,
    {
        self.io_intensive.spawn(task);
    }
}
```

---

## 🔍 优雅关机

### 7.1 信号处理

```rust
use tokio::signal;

async fn shutdown_signal() {
    let ctrl_c = async {
        signal::ctrl_c()
            .await
            .expect("failed to install Ctrl+C handler");
    };
    
    #[cfg(unix)]
    let terminate = async {
        signal::unix::signal(signal::unix::SignalKind::terminate())
            .expect("failed to install signal handler")
            .recv()
            .await;
    };
    
    #[cfg(not(unix))]
    let terminate = std::future::pending::<()>();
    
    tokio::select! {
        _ = ctrl_c => {},
        _ = terminate => {},
    }
    
    println!("Shutting down gracefully");
}
```

---

### 7.2 资源清理

```rust
struct Application {
    database: DatabasePool,
    cache: Cache,
    background_tasks: JoinSet<()>,
}

impl Application {
    pub async fn run(mut self) {
        tokio::select! {
            _ = self.serve() => {},
            _ = shutdown_signal() => {
                println!("Shutdown signal received");
            }
        }
        
        // 优雅关机
        self.shutdown().await;
    }
    
    async fn shutdown(mut self) {
        println!("Stopping background tasks...");
        self.background_tasks.shutdown().await;
        
        println!("Closing database connections...");
        self.database.close().await;
        
        println!("Flushing cache...");
        self.cache.flush().await;
        
        println!("Shutdown complete");
    }
}
```

---

### 7.3 请求排空

```rust
use tokio::sync::watch;

struct Server {
    shutdown_tx: watch::Sender<bool>,
}

impl Server {
    pub async fn run(self) {
        let (shutdown_tx, mut shutdown_rx) = watch::channel(false);
        
        // 启动服务器
        let server = axum::Server::bind(&"0.0.0.0:8080".parse().unwrap())
            .serve(app.into_make_service())
            .with_graceful_shutdown(async move {
                shutdown_rx.changed().await.ok();
            });
        
        tokio::select! {
            _ = server => {},
            _ = shutdown_signal() => {
                println!("Initiating graceful shutdown");
                // 通知所有处理器停止接受新请求
                shutdown_tx.send(true).ok();
                
                // 等待现有请求完成（最多30秒）
                tokio::time::sleep(Duration::from_secs(30)).await;
            }
        }
    }
}
```

---

## 💻 健康检查

### 8.1 活性检查 (Liveness)

```rust
async fn liveness_check() -> impl IntoResponse {
    // 检查应用是否活着
    // 简单检查，不依赖外部服务
    (StatusCode::OK, "OK")
}
```

---

### 8.2 就绪检查 (Readiness)

```rust
async fn readiness_check(state: Arc<AppState>) -> impl IntoResponse {
    // 检查所有依赖是否就绪
    let mut checks = HashMap::new();
    
    // 数据库检查
    checks.insert("database", check_database(&state.db).await);
    
    // 缓存检查
    checks.insert("cache", check_cache(&state.cache).await);
    
    // 外部服务检查
    checks.insert("external_api", check_external_api().await);
    
    let all_healthy = checks.values().all(|&v| v);
    
    let status = if all_healthy {
        StatusCode::OK
    } else {
        StatusCode::SERVICE_UNAVAILABLE
    };
    
    (status, Json(json!({
        "status": if all_healthy { "ready" } else { "not ready" },
        "checks": checks,
    })))
}

async fn check_database(pool: &DatabasePool) -> bool {
    pool.acquire().await.is_ok()
}

async fn check_cache(cache: &Cache) -> bool {
    cache.ping().await.is_ok()
}
```

---

## 📚 组合模式

### 9.1 重试 + 断路器

```rust
async fn resilient_call<F, T, E>(
    breaker: &CircuitBreaker,
    operation: F,
) -> Result<T, Error>
where
    F: Fn() -> Result<T, E>,
{
    retry_exponential(
        || {
            breaker.call(&operation)
        },
        3,
        Duration::from_millis(100)
    ).await
}
```

---

### 9.2 超时 + 重试 + 断路器

```rust
async fn fully_resilient_call<F, Fut, T>(
    breaker: &CircuitBreaker,
    mut operation: F,
) -> Result<T, Error>
where
    F: FnMut() -> Fut,
    Fut: Future<Output = Result<T, Error>>,
{
    retry_with_jitter(
        || async {
            breaker.call(|| async {
                timeout(Duration::from_secs(5), operation())
                    .await
                    .map_err(|_| Error::Timeout)?
            }).await
        },
        3
    ).await
}
```

---

## ✅ 最佳实践

### 10.1 策略选择

| 场景 | 推荐策略 |
|------|---------|
| 瞬时网络故障 | 重试 (指数退避 + 抖动) |
| 下游服务不稳定 | 断路器 |
| 防止雪崩 | 断路器 + 舱壁 |
| API 限流 | 令牌桶 / 漏桶 |
| 服务降级 | 缓存 + 默认值 |

---

### 10.2 参数调优

**重试参数**:

- 最大重试次数: 3-5 次
- 基础延迟: 100-500ms
- 最大延迟: 10-30s

**断路器参数**:

- 失败阈值: 5-10 次
- 超时时间: 60s
- 半开最大调用: 3-5 次

**超时参数**:

- 数据库查询: 2-5s
- HTTP 请求: 10-30s
- 总超时: 操作总和 + 缓冲

---

### 10.3 监控指标

```rust
use metrics::{counter, histogram, gauge};

// 重试指标
counter!("retry_attempts_total", "operation" => "fetch_data").increment(1);
histogram!("retry_delay_seconds").record(delay.as_secs_f64());

// 断路器指标
gauge!("circuit_breaker_state", "service" => "api").set(state_value);
counter!("circuit_breaker_state_changes", "service" => "api").increment(1);

// 超时指标
counter!("timeout_total", "operation" => "query").increment(1);
histogram!("operation_duration_seconds", "operation" => "query")
    .record(duration.as_secs_f64());

// 限流指标
counter!("rate_limit_hits_total").increment(1);
gauge!("rate_limit_available_tokens").set(tokens);
```

---

## 🌟 API 速查表

### 11.1 重试库对比

| 库 | 特点 | 用途 |
|----|------|------|
| `again` | 简单重试 | 基本场景 |
| `retry` | 可配置策略 | 通用场景 |
| `tower::retry` | 服务中间件 | 微服务 |

---

### 11.2 配置参数

| 参数 | 典型值 | 说明 |
|------|--------|------|
| `max_retries` | 3-5 | 最大重试次数 |
| `base_delay` | 100ms | 初始延迟 |
| `max_delay` | 10s | 最大延迟 |
| `timeout` | 5s | 单次超时 |
| `circuit_breaker_threshold` | 5 | 断路器阈值 |

---

**相关文档**:

- [测试框架完整参考](./01_测试框架完整参考.md)
- [错误处理完整参考](./02_错误处理完整参考.md)
- [监控可观测性参考](./03_监控可观测性参考.md)
- [Tier 2 故障恢复实践](../tier_02_guides/)

---

**最后更新**: 2025-10-24  
**贡献者**: Rust Documentation Team
