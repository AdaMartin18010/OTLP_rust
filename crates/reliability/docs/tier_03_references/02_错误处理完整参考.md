# 错误处理完整参考

**最后更新**: 2025-10-24  
**适用版本**: Rust 1.90+  
**难度**: ⭐⭐⭐

---

## 📋 目录

- [错误处理完整参考](#错误处理完整参考)
  - [📋 目录](#-目录)
  - [1. Result 类型详解](#1-result-类型详解)
    - [1.1 基本定义](#11-基本定义)
    - [1.2 Result 方法](#12-result-方法)
    - [1.3 组合器模式](#13-组合器模式)
  - [2. Error Trait 完整 API](#2-error-trait-完整-api)
    - [2.1 Error Trait 定义](#21-error-trait-定义)
    - [2.2 标准错误类型](#22-标准错误类型)
    - [2.3 实现 Error Trait](#23-实现-error-trait)
  - [3. 错误传播机制](#3-错误传播机制)
    - [3.1 ? 操作符](#31--操作符)
    - [3.2 From/Into 转换](#32-frominto-转换)
    - [3.3 自动类型转换](#33-自动类型转换)
  - [4. 自定义错误类型](#4-自定义错误类型)
    - [4.1 简单错误枚举](#41-简单错误枚举)
    - [4.2 使用 thiserror](#42-使用-thiserror)
    - [4.3 错误上下文](#43-错误上下文)
  - [5. anyhow 错误处理](#5-anyhow-错误处理)
    - [5.1 基本使用](#51-基本使用)
    - [5.2 添加上下文](#52-添加上下文)
    - [5.3 错误链](#53-错误链)
  - [6. Panic 处理策略](#6-panic-处理策略)
    - [6.1 Panic 机制](#61-panic-机制)
    - [6.2 捕获 Panic](#62-捕获-panic)
    - [6.3 Panic Hook](#63-panic-hook)
  - [7. 错误处理模式](#7-错误处理模式)
    - [7.1 多层错误传播](#71-多层错误传播)
    - [7.2 错误转换](#72-错误转换)
    - [7.3 错误恢复](#73-错误恢复)
  - [8. 最佳实践](#8-最佳实践)
    - [8.1 库 vs 应用](#81-库-vs-应用)
    - [8.2 错误信息设计](#82-错误信息设计)
    - [8.3 性能考量](#83-性能考量)
  - [9. 常见错误模式](#9-常见错误模式)
    - [9.1 I/O 错误](#91-io-错误)
    - [9.2 解析错误](#92-解析错误)
    - [9.3 验证错误](#93-验证错误)
  - [10. 调试与故障排查](#10-调试与故障排查)
    - [10.1 错误信息追踪](#101-错误信息追踪)
    - [10.2 Backtrace](#102-backtrace)
  - [11. API 速查表](#11-api-速查表)
    - [11.1 Result 方法](#111-result-方法)
    - [11.2 Error Trait 方法](#112-error-trait-方法)

---

## 🎯 Result 类型详解

### 1.1 基本定义

```rust
pub enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

**基本使用**:

```rust
fn divide(a: i32, b: i32) -> Result<i32, String> {
    if b == 0 {
        Err("Division by zero".to_string())
    } else {
        Ok(a / b)
    }
}

// 使用
match divide(10, 2) {
    Ok(result) => println!("Result: {}", result),
    Err(e) => eprintln!("Error: {}", e),
}
```

---

### 1.2 Result 方法

**检查方法**:

```rust
let result: Result<i32, &str> = Ok(42);

// 检查是否成功
assert!(result.is_ok());
assert!(!result.is_err());

// 检查并获取引用
assert_eq!(result.as_ref(), Ok(&42));

// 转换为 Option
assert_eq!(result.ok(), Some(42));
assert_eq!(result.err(), None);
```

**转换方法**:

```rust
let result: Result<i32, &str> = Ok(42);

// map: 转换成功值
let doubled = result.map(|x| x * 2);
assert_eq!(doubled, Ok(84));

// map_err: 转换错误值
let result: Result<i32, &str> = Err("error");
let mapped = result.map_err(|e| format!("Error: {}", e));
assert_eq!(mapped, Err("Error: error".to_string()));

// and_then: 链式操作
let result = Ok(42)
    .and_then(|x| Ok(x * 2))
    .and_then(|x| Ok(x + 1));
assert_eq!(result, Ok(85));

// or_else: 错误恢复
let result: Result<i32, &str> = Err("error");
let recovered = result.or_else(|_| Ok(0));
assert_eq!(recovered, Ok(0));
```

**展开方法**:

```rust
// unwrap: 成功返回值，错误 panic
let value = Ok(42).unwrap();
// Err("error").unwrap(); // panic!

// unwrap_or: 提供默认值
let value = Err("error").unwrap_or(0);
assert_eq!(value, 0);

// unwrap_or_else: 计算默认值
let value = Err("error").unwrap_or_else(|_| 42);
assert_eq!(value, 42);

// unwrap_or_default: 使用类型默认值
let value: i32 = Err("error").unwrap_or_default();
assert_eq!(value, 0);

// expect: 带自定义消息的 unwrap
let value = Ok(42).expect("Should have a value");
```

---

### 1.3 组合器模式

```rust
// 多个 Result 组合
fn process() -> Result<i32, String> {
    let a = read_number()?;
    let b = read_number()?;
    let result = divide(a, b)?;
    Ok(result * 2)
}

// 使用 and 组合
let result = Ok(42).and(Ok(100));
assert_eq!(result, Ok(100));

// 使用 or 组合
let result: Result<i32, &str> = Err("error1").or(Err("error2"));
assert_eq!(result, Err("error2"));

// flatten: 展平嵌套 Result
let nested: Result<Result<i32, &str>, &str> = Ok(Ok(42));
let flattened = nested.flatten();
assert_eq!(flattened, Ok(42));
```

---

## 📝 Error Trait 完整 API

### 2.1 Error Trait 定义

```rust
pub trait Error: Debug + Display {
    // 获取错误源（可选）
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        None
    }
    
    // 获取类型 ID（不稳定）
    fn type_id(&self, _: private::Internal) -> TypeId where Self: 'static {
        TypeId::of::<Self>()
    }
    
    // 获取 backtrace（不稳定）
    fn provide<'a>(&'a self, request: &mut Request<'a>) {}
}
```

---

### 2.2 标准错误类型

**常见标准库错误**:

```rust
use std::io;
use std::num;
use std::str;
use std::fmt;

// I/O 错误
let err: io::Error = io::Error::new(io::ErrorKind::NotFound, "File not found");

// 解析错误
let err: num::ParseIntError = "abc".parse::<i32>().unwrap_err();

// UTF-8 错误
let err: str::Utf8Error = str::from_utf8(&[0xFF]).unwrap_err();

// 格式化错误
let err: fmt::Error = fmt::Error;
```

---

### 2.3 实现 Error Trait

```rust
use std::error::Error;
use std::fmt;

#[derive(Debug)]
struct MyError {
    message: String,
    source: Option<Box<dyn Error>>,
}

impl fmt::Display for MyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "MyError: {}", self.message)
    }
}

impl Error for MyError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        self.source.as_ref().map(|e| e.as_ref())
    }
}

// 使用
fn example() -> Result<(), MyError> {
    Err(MyError {
        message: "Something went wrong".to_string(),
        source: None,
    })
}
```

---

## 💡 错误传播机制

### 3.1 ? 操作符

```rust
// ? 操作符展开
fn read_file(path: &str) -> Result<String, std::io::Error> {
    let mut file = std::fs::File::open(path)?;  // 错误直接返回
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}

// 等价于
fn read_file_manual(path: &str) -> Result<String, std::io::Error> {
    let mut file = match std::fs::File::open(path) {
        Ok(file) => file,
        Err(e) => return Err(e),
    };
    
    let mut contents = String::new();
    match file.read_to_string(&mut contents) {
        Ok(_) => Ok(contents),
        Err(e) => Err(e),
    }
}
```

---

### 3.2 From/Into 转换

```rust
use std::io;
use std::num::ParseIntError;

#[derive(Debug)]
enum MyError {
    Io(io::Error),
    Parse(ParseIntError),
}

// 实现 From trait 启用 ? 自动转换
impl From<io::Error> for MyError {
    fn from(err: io::Error) -> Self {
        MyError::Io(err)
    }
}

impl From<ParseIntError> for MyError {
    fn from(err: ParseIntError) -> Self {
        MyError::Parse(err)
    }
}

// 使用
fn process() -> Result<i32, MyError> {
    let content = std::fs::read_to_string("file.txt")?;  // io::Error 自动转换
    let number = content.trim().parse()?;  // ParseIntError 自动转换
    Ok(number)
}
```

---

### 3.3 自动类型转换

```rust
// Box<dyn Error> 可接受任何错误
fn flexible_error() -> Result<(), Box<dyn std::error::Error>> {
    std::fs::read_to_string("file.txt")?;  // io::Error
    "123abc".parse::<i32>()?;  // ParseIntError
    Ok(())
}

// 使用 anyhow::Error 更灵活
use anyhow::Result;

fn anyhow_example() -> Result<()> {
    std::fs::read_to_string("file.txt")?;
    "123abc".parse::<i32>()?;
    Ok(())
}
```

---

## 🔧 自定义错误类型

### 4.1 简单错误枚举

```rust
use std::fmt;

#[derive(Debug)]
enum AppError {
    NotFound,
    InvalidInput(String),
    DatabaseError(String),
}

impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AppError::NotFound => write!(f, "Resource not found"),
            AppError::InvalidInput(msg) => write!(f, "Invalid input: {}", msg),
            AppError::DatabaseError(msg) => write!(f, "Database error: {}", msg),
        }
    }
}

impl std::error::Error for AppError {}
```

---

### 4.2 使用 thiserror

**Cargo.toml**:

```toml
[dependencies]
thiserror = "1.0"
```

**定义错误**:

```rust
use thiserror::Error;

#[derive(Error, Debug)]
enum DataStoreError {
    #[error("data store disconnected")]
    Disconnect(#[from] io::Error),
    
    #[error("the data for key `{0}` is not available")]
    Redaction(String),
    
    #[error("invalid header (expected {expected:?}, found {found:?})")]
    InvalidHeader {
        expected: String,
        found: String,
    },
    
    #[error("unknown data store error")]
    Unknown,
}

// 使用
fn example() -> Result<(), DataStoreError> {
    Err(DataStoreError::Redaction("secret_key".to_string()))
}
```

**透明错误传播**:

```rust
#[derive(Error, Debug)]
enum MyError {
    #[error(transparent)]
    IoError(#[from] std::io::Error),
    
    #[error(transparent)]
    Other(#[from] anyhow::Error),
}
```

---

### 4.3 错误上下文

```rust
use thiserror::Error;

#[derive(Error, Debug)]
enum ConfigError {
    #[error("failed to read config file: {path}")]
    ReadError {
        path: String,
        #[source]
        source: std::io::Error,
    },
    
    #[error("failed to parse config at line {line}")]
    ParseError {
        line: usize,
        #[source]
        source: toml::de::Error,
    },
}

// 使用
fn load_config(path: &str) -> Result<Config, ConfigError> {
    let content = std::fs::read_to_string(path)
        .map_err(|source| ConfigError::ReadError {
            path: path.to_string(),
            source,
        })?;
    
    let config = toml::from_str(&content)
        .map_err(|source| ConfigError::ParseError {
            line: 0,  // 实际应解析源
            source,
        })?;
    
    Ok(config)
}
```

---

## 📊 anyhow 错误处理

### 5.1 基本使用

**Cargo.toml**:

```toml
[dependencies]
anyhow = "1.0"
```

**简化错误处理**:

```rust
use anyhow::{Result, Context, bail, ensure, anyhow};

// 替代 Result<T, Box<dyn Error>>
fn process() -> Result<String> {
    let path = "config.toml";
    let content = std::fs::read_to_string(path)?;
    Ok(content)
}

// 抛出自定义错误
fn check_value(x: i32) -> Result<()> {
    if x < 0 {
        bail!("Value cannot be negative: {}", x);
    }
    Ok(())
}

// 断言风格
fn validate(x: i32) -> Result<()> {
    ensure!(x > 0, "Value must be positive");
    ensure!(x < 100, "Value must be less than 100");
    Ok(())
}

// 创建错误
fn create_error() -> Result<()> {
    Err(anyhow!("Something went wrong"))
}
```

---

### 5.2 添加上下文

```rust
use anyhow::{Context, Result};

fn load_config() -> Result<Config> {
    let path = "config.toml";
    
    let content = std::fs::read_to_string(path)
        .context("Failed to read config file")?;
    
    let config: Config = toml::from_str(&content)
        .with_context(|| format!("Failed to parse config from {}", path))?;
    
    Ok(config)
}

// 错误输出:
// Error: Failed to parse config from config.toml
// 
// Caused by:
//     TOML parse error at line 3, column 5
//     |
//   3 | value = "invalid
//     |         ^^^^^^^^
//     unexpected end of file
```

---

### 5.3 错误链

```rust
use anyhow::Result;

fn inner() -> Result<()> {
    Err(anyhow::anyhow!("Inner error"))
}

fn middle() -> Result<()> {
    inner().context("Middle layer")?;
    Ok(())
}

fn outer() -> Result<()> {
    middle().context("Outer layer")?;
    Ok(())
}

fn main() {
    if let Err(e) = outer() {
        eprintln!("Error: {:?}", e);
        
        // 遍历错误链
        for cause in e.chain() {
            eprintln!("  Caused by: {}", cause);
        }
    }
}

// 输出:
// Error: Outer layer
//   Caused by: Middle layer
//   Caused by: Inner error
```

---

## 🚀 Panic 处理策略

### 6.1 Panic 机制

```rust
// 触发 panic
fn will_panic() {
    panic!("Something went wrong!");
}

// 条件 panic
fn check_value(x: i32) {
    assert!(x > 0, "x must be positive, got {}", x);
    assert_eq!(x, 42, "x must be 42");
    assert_ne!(x, 0, "x cannot be 0");
}

// unreachable! 宏
fn process_status(status: Status) {
    match status {
        Status::Ok => println!("OK"),
        Status::Error => println!("Error"),
        // 如果确信不会到达
        _ => unreachable!("Unexpected status"),
    }
}

// unimplemented! 宏
fn future_feature() {
    unimplemented!("This will be implemented later");
}
```

---

### 6.2 捕获 Panic

```rust
use std::panic;

fn may_panic() {
    panic!("Oops!");
}

// 捕获 panic
fn safe_call() -> Result<(), String> {
    let result = panic::catch_unwind(|| {
        may_panic();
    });
    
    match result {
        Ok(_) => Ok(()),
        Err(e) => {
            if let Some(s) = e.downcast_ref::<&str>() {
                Err(format!("Panic: {}", s))
            } else {
                Err("Unknown panic".to_string())
            }
        }
    }
}

// 设置 panic 行为
panic::set_hook(Box::new(|panic_info| {
    eprintln!("Custom panic handler: {:?}", panic_info);
}));
```

---

### 6.3 Panic Hook

```rust
use std::panic;

fn setup_panic_handler() {
    let default_hook = panic::take_hook();
    
    panic::set_hook(Box::new(move |panic_info| {
        // 记录到日志
        log::error!("Panic occurred: {:?}", panic_info);
        
        // 发送到监控系统
        send_to_monitoring(panic_info);
        
        // 调用默认 hook
        default_hook(panic_info);
    }));
}

// 生产环境 panic 处理
fn production_panic_handler(info: &panic::PanicInfo) {
    let location = info.location().map(|l| {
        format!("{}:{}:{}", l.file(), l.line(), l.column())
    }).unwrap_or_else(|| "unknown".to_string());
    
    let message = if let Some(s) = info.payload().downcast_ref::<&str>() {
        s.to_string()
    } else if let Some(s) = info.payload().downcast_ref::<String>() {
        s.clone()
    } else {
        "Unknown panic message".to_string()
    };
    
    eprintln!("PANIC at {}: {}", location, message);
}
```

---

## 🔍 错误处理模式

### 7.1 多层错误传播

```rust
// Repository 层
mod repository {
    use thiserror::Error;
    
    #[derive(Error, Debug)]
    pub enum RepositoryError {
        #[error("database error")]
        Database(#[from] sqlx::Error),
        
        #[error("not found")]
        NotFound,
    }
    
    pub fn find_user(id: i32) -> Result<User, RepositoryError> {
        // ...
    }
}

// Service 层
mod service {
    use thiserror::Error;
    use super::repository::RepositoryError;
    
    #[derive(Error, Debug)]
    pub enum ServiceError {
        #[error("repository error")]
        Repository(#[from] RepositoryError),
        
        #[error("validation error: {0}")]
        Validation(String),
    }
    
    pub fn get_user(id: i32) -> Result<User, ServiceError> {
        let user = repository::find_user(id)?;
        
        if !user.is_active {
            return Err(ServiceError::Validation("User is inactive".to_string()));
        }
        
        Ok(user)
    }
}

// Controller 层
mod controller {
    use super::service::ServiceError;
    
    pub enum HttpError {
        NotFound,
        BadRequest(String),
        Internal(String),
    }
    
    impl From<ServiceError> for HttpError {
        fn from(err: ServiceError) -> Self {
            match err {
                ServiceError::Repository(RepositoryError::NotFound) => 
                    HttpError::NotFound,
                ServiceError::Validation(msg) => 
                    HttpError::BadRequest(msg),
                _ => HttpError::Internal(err.to_string()),
            }
        }
    }
}
```

---

### 7.2 错误转换

```rust
// 使用 ? 和 From trait
fn convert_example() -> Result<String, MyError> {
    let bytes = std::fs::read("file.txt")?;  // io::Error -> MyError
    let text = String::from_utf8(bytes)?;    // FromUtf8Error -> MyError
    Ok(text)
}

// 手动转换
fn manual_convert() -> Result<String, MyError> {
    let bytes = std::fs::read("file.txt")
        .map_err(|e| MyError::Io(e))?;
    
    let text = String::from_utf8(bytes)
        .map_err(|e| MyError::Utf8(e.utf8_error()))?;
    
    Ok(text)
}
```

---

### 7.3 错误恢复

```rust
// 提供默认值
fn with_default() -> String {
    std::fs::read_to_string("config.toml")
        .unwrap_or_else(|_| "default config".to_string())
}

// 重试机制
fn with_retry<F, T, E>(mut f: F, max_retries: usize) -> Result<T, E>
where
    F: FnMut() -> Result<T, E>,
{
    let mut attempts = 0;
    
    loop {
        match f() {
            Ok(val) => return Ok(val),
            Err(e) if attempts < max_retries => {
                attempts += 1;
                std::thread::sleep(std::time::Duration::from_millis(100 * attempts as u64));
            }
            Err(e) => return Err(e),
        }
    }
}

// 降级处理
fn with_fallback() -> Result<Data, MyError> {
    // 尝试主数据源
    if let Ok(data) = fetch_from_primary() {
        return Ok(data);
    }
    
    // 尝试备份数据源
    if let Ok(data) = fetch_from_backup() {
        return Ok(data);
    }
    
    // 使用缓存
    if let Ok(data) = fetch_from_cache() {
        return Ok(data);
    }
    
    Err(MyError::AllSourcesFailed)
}
```

---

## 💻 最佳实践

### 8.1 库 vs 应用

**库开发**:

```rust
// ✅ 提供具体的错误类型
#[derive(Error, Debug)]
pub enum LibraryError {
    #[error("invalid input: {0}")]
    InvalidInput(String),
    
    #[error("operation failed")]
    OperationFailed,
}

// ✅ 不使用 panic（除了不可恢复错误）
pub fn process(input: &str) -> Result<Output, LibraryError> {
    // ...
}

// ❌ 不要在库中使用 unwrap/expect
// let x = some_operation().unwrap(); // 坏实践
```

**应用开发**:

```rust
// ✅ 可以使用 anyhow 简化
use anyhow::Result;

fn main() -> Result<()> {
    let config = load_config()?;
    let data = fetch_data()?;
    process(config, data)?;
    Ok(())
}

// ✅ main 函数可以返回 Result
// 失败时会打印错误并返回非零退出码

// ✅ 可以适度使用 expect
let value = env::var("REQUIRED_VAR")
    .expect("REQUIRED_VAR must be set");
```

---

### 8.2 错误信息设计

```rust
// ❌ 不好：信息不足
Err("Failed")

// ✅ 好：提供上下文
Err(format!("Failed to parse config at line {}: {}", line, details))

// ❌ 不好：过于技术化
Err("ENOENT: no such file or directory")

// ✅ 好：用户友好
Err(format!("Configuration file not found at: {}", path))

// ✅ 最佳：结构化错误
#[derive(Error, Debug)]
#[error("Failed to load configuration from {path}")]
struct ConfigLoadError {
    path: String,
    #[source]
    source: std::io::Error,
}
```

---

### 8.3 性能考量

```rust
// Result 是零成本抽象
// ✅ 不比手动错误处理慢
fn with_result() -> Result<i32, String> {
    if condition {
        Ok(42)
    } else {
        Err("error".to_string())
    }
}

// ⚠️ 避免在热路径创建错误对象
fn hot_path() -> Result<i32, String> {
    // ❌ 每次都创建 String
    if x < 0 {
        return Err(format!("Negative value: {}", x));
    }
    
    // ✅ 使用静态字符串
    if x < 0 {
        return Err("Negative value");
    }
    
    Ok(x)
}

// ✅ 使用 error 枚举（无堆分配）
#[derive(Error, Debug)]
enum FastError {
    #[error("negative value")]
    Negative,
    
    #[error("too large")]
    TooLarge,
}
```

---

## 📚 常见错误模式

### 9.1 I/O 错误

```rust
use std::io::{self, Read, Write};
use std::fs::File;

fn read_file_safe(path: &str) -> io::Result<String> {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}

// 带上下文的 I/O 错误
fn read_with_context(path: &str) -> anyhow::Result<String> {
    let contents = std::fs::read_to_string(path)
        .with_context(|| format!("Failed to read file: {}", path))?;
    Ok(contents)
}
```

---

### 9.2 解析错误

```rust
use std::num::ParseIntError;

fn parse_config(text: &str) -> Result<Config, ConfigError> {
    let lines: Vec<&str> = text.lines().collect();
    
    let port = lines.get(0)
        .ok_or(ConfigError::MissingField("port"))?
        .parse::<u16>()
        .map_err(|e| ConfigError::InvalidPort(e))?;
    
    let timeout = lines.get(1)
        .ok_or(ConfigError::MissingField("timeout"))?
        .parse::<u64>()
        .map_err(|e| ConfigError::InvalidTimeout(e))?;
    
    Ok(Config { port, timeout })
}
```

---

### 9.3 验证错误

```rust
#[derive(Error, Debug)]
enum ValidationError {
    #[error("field {field} is required")]
    Required { field: String },
    
    #[error("field {field} must be between {min} and {max}")]
    OutOfRange { field: String, min: i32, max: i32 },
    
    #[error("field {field} has invalid format")]
    InvalidFormat { field: String },
}

fn validate_user(user: &User) -> Result<(), ValidationError> {
    if user.name.is_empty() {
        return Err(ValidationError::Required {
            field: "name".to_string(),
        });
    }
    
    if user.age < 0 || user.age > 150 {
        return Err(ValidationError::OutOfRange {
            field: "age".to_string(),
            min: 0,
            max: 150,
        });
    }
    
    Ok(())
}
```

---

## ✅ 调试与故障排查

### 10.1 错误信息追踪

```rust
use anyhow::Context;

fn trace_error_chain() {
    match dangerous_operation() {
        Ok(_) => println!("Success"),
        Err(e) => {
            eprintln!("Error: {}", e);
            
            // 打印完整错误链
            for (i, cause) in e.chain().enumerate() {
                eprintln!("  {}: {}", i, cause);
            }
            
            // Debug 格式（包含 backtrace）
            eprintln!("\nDebug: {:?}", e);
        }
    }
}
```

---

### 10.2 Backtrace

```rust
use std::backtrace::Backtrace;

#[derive(Debug)]
struct DetailedError {
    message: String,
    backtrace: Backtrace,
}

impl DetailedError {
    fn new(message: impl Into<String>) -> Self {
        Self {
            message: message.into(),
            backtrace: Backtrace::capture(),
        }
    }
}

// 启用 backtrace
// RUST_BACKTRACE=1 cargo run

// anyhow 自动支持 backtrace
use anyhow::Result;

fn with_backtrace() -> Result<()> {
    Err(anyhow::anyhow!("Error with backtrace"))
}
```

---

## 🌟 API 速查表

### 11.1 Result 方法

| 方法 | 签名 | 说明 |
|------|------|------|
| `is_ok()` | `&self -> bool` | 检查是否成功 |
| `is_err()` | `&self -> bool` | 检查是否失败 |
| `ok()` | `self -> Option<T>` | 转换为 Option |
| `err()` | `self -> Option<E>` | 获取错误为 Option |
| `map()` | `self, F -> Result<U, E>` | 转换成功值 |
| `map_err()` | `self, F -> Result<T, F>` | 转换错误值 |
| `and_then()` | `self, F -> Result<U, E>` | 链式操作 |
| `or_else()` | `self, F -> Result<T, F>` | 错误恢复 |
| `unwrap()` | `self -> T` | 展开或 panic |
| `unwrap_or()` | `self, T -> T` | 展开或默认值 |
| `expect()` | `self, &str -> T` | 展开或带消息 panic |

---

### 11.2 Error Trait 方法

| 方法 | 签名 | 说明 |
|------|------|------|
| `source()` | `&self -> Option<&dyn Error>` | 获取底层错误 |
| `to_string()` | `&self -> String` | Display 实现 |
| `type_id()` | `&self -> TypeId` | 类型 ID（不稳定） |

---

**相关文档**:

- [测试框架完整参考](./01_测试框架完整参考.md)
- [监控可观测性参考](./03_监控可观测性参考.md)
- [Tier 2 错误处理实践](../tier_02_guides/)
- [Tier 4 高级错误处理](../tier_04_advanced/)

---

**最后更新**: 2025-10-24  
**贡献者**: Rust Documentation Team
