apiVersion: apps/v1
kind: Deployment
metadata:
  name: otlp-server
  namespace: otlp-system
  labels:
    app: otlp-server
    version: v1.0.0
    component: telemetry
spec:
  replicas: 3
  selector:
    matchLabels:
      app: otlp-server
  template:
    metadata:
      labels:
        app: otlp-server
        version: v1.0.0
        component: telemetry
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
        prometheus.io/path: "/metrics"
    spec:
      serviceAccountName: otlp-server
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        runAsGroup: 1000
        fsGroup: 1000
      containers:
      - name: otlp-server
        image: otlp/otlp-server:latest
        imagePullPolicy: Always
        ports:
        - name: grpc
          containerPort: 4317
          protocol: TCP
        - name: http
          containerPort: 4318
          protocol: TCP
        - name: metrics
          containerPort: 8080
          protocol: TCP
        - name: health
          containerPort: 8081
          protocol: TCP
        env:
        - name: RUST_LOG
          value: "info"
        - name: OTLP_ENDPOINT
          value: "0.0.0.0:4317"
        - name: OTLP_HTTP_ENDPOINT
          value: "0.0.0.0:4318"
        - name: METRICS_ENDPOINT
          value: "0.0.0.0:8080"
        - name: HEALTH_ENDPOINT
          value: "0.0.0.0:8081"
        - name: MAX_CONNECTIONS
          value: "1000"
        - name: MAX_BATCH_SIZE
          value: "1000"
        - name: BATCH_TIMEOUT_MS
          value: "100"
        - name: CIRCUIT_BREAKER_FAILURE_THRESHOLD
          value: "10"
        - name: CIRCUIT_BREAKER_RECOVERY_TIMEOUT_MS
          value: "5000"
        - name: MEMORY_POOL_MAX_SIZE
          value: "100"
        - name: CONNECTION_POOL_MAX_SIZE
          value: "100"
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8081
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /ready
            port: 8081
          initialDelaySeconds: 5
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
        startupProbe:
          httpGet:
            path: /startup
            port: 8081
          initialDelaySeconds: 10
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 10
        volumeMounts:
        - name: config
          mountPath: /etc/otlp
          readOnly: true
        - name: tmp
          mountPath: /tmp
        - name: logs
          mountPath: /var/log/otlp
      volumes:
      - name: config
        configMap:
          name: otlp-config
      - name: tmp
        emptyDir: {}
      - name: logs
        emptyDir: {}
      nodeSelector:
        kubernetes.io/os: linux
      tolerations:
      - key: "node-role.kubernetes.io/master"
        operator: "Exists"
        effect: "NoSchedule"
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app
                  operator: In
                  values:
                  - otlp-server
              topologyKey: kubernetes.io/hostname
---
apiVersion: v1
kind: Service
metadata:
  name: otlp-server
  namespace: otlp-system
  labels:
    app: otlp-server
    component: telemetry
  annotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "8080"
    prometheus.io/path: "/metrics"
spec:
  type: ClusterIP
  ports:
  - name: grpc
    port: 4317
    targetPort: 4317
    protocol: TCP
  - name: http
    port: 4318
    targetPort: 4318
    protocol: TCP
  - name: metrics
    port: 8080
    targetPort: 8080
    protocol: TCP
  - name: health
    port: 8081
    targetPort: 8081
    protocol: TCP
  selector:
    app: otlp-server
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: otlp-server
  namespace: otlp-system
  labels:
    app: otlp-server
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: otlp-server
  namespace: otlp-system
rules:
- apiGroups: [""]
  resources: ["configmaps", "secrets"]
  verbs: ["get", "list", "watch"]
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list", "watch"]
- apiGroups: [""]
  resources: ["services"]
  verbs: ["get", "list", "watch"]
- apiGroups: [""]
  resources: ["endpoints"]
  verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: otlp-server
  namespace: otlp-system
subjects:
- kind: ServiceAccount
  name: otlp-server
  namespace: otlp-system
roleRef:
  kind: Role
  name: otlp-server
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: otlp-config
  namespace: otlp-system
  labels:
    app: otlp-server
data:
  config.yaml: |
    server:
      grpc:
        endpoint: "0.0.0.0:4317"
        max_connections: 1000
        keep_alive_time: 30s
        keep_alive_timeout: 5s
        keep_alive_permit_without_stream: true
      http:
        endpoint: "0.0.0.0:4318"
        max_connections: 1000
        read_timeout: 30s
        write_timeout: 30s
        idle_timeout: 120s
      metrics:
        endpoint: "0.0.0.0:8080"
        path: "/metrics"
      health:
        endpoint: "0.0.0.0:8081"
        path: "/health"
    
    performance:
      circuit_breaker:
        failure_threshold: 10
        recovery_timeout: 5s
        half_open_max_calls: 5
        sliding_window_size: 60s
        minimum_calls: 10
      memory_pool:
        max_size: 100
        initial_size: 10
        object_ttl: 300s
        cleanup_interval: 60s
      batch_processor:
        max_batch_size: 1000
        min_batch_size: 10
        batch_timeout: 100ms
        max_wait_time: 5s
        concurrency: 4
        enable_compression: true
        memory_limit: 100MB
      connection_pool:
        max_connections: 100
        min_connections: 5
        connection_timeout: 30s
        idle_timeout: 300s
        max_lifetime: 3600s
        health_check_interval: 60s
    
    resilience:
      retry:
        max_attempts: 3
        initial_delay: 100ms
        max_delay: 5s
        multiplier: 2.0
        jitter: true
      timeout:
        request_timeout: 30s
        connection_timeout: 10s
        read_timeout: 30s
        write_timeout: 30s
      graceful_degradation:
        enabled: true
        fallback_enabled: true
        cache_enabled: true
        cache_ttl: 300s
    
    monitoring:
      metrics:
        enabled: true
        interval: 10s
        retention: 24h
      logging:
        level: "info"
        format: "json"
        output: "stdout"
      tracing:
        enabled: true
        sampling_rate: 0.1
        jaeger_endpoint: "http://jaeger-collector:14268/api/traces"
    
    storage:
      type: "memory"
      max_size: "1GB"
      cleanup_interval: "1h"
      compression: true
