# OpenTelemetry Protocol (OTLP) ç»Ÿä¸€è§„èŒƒè¯¦è§£

## ğŸ“Š OTLPè§„èŒƒæ¦‚è§ˆ

**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ27æ—¥  
**æ–‡æ¡£ç‰ˆæœ¬**: 2.0.0  
**ç»´æŠ¤è€…**: OpenTelemetry 2025 æ ‡å‡†å›¢é˜Ÿ  
**çŠ¶æ€**: ç»Ÿä¸€æ•´åˆç‰ˆæœ¬  
**æ•´åˆæ¥æº**: åˆå¹¶äº†å¤šä¸ªé‡å¤çš„è§„èŒƒæ–‡æ¡£

> æƒå¨æ¥æºä¸å®ç°å¯¹é½
>
> - æƒå¨å®šä¹‰å…¥å£ï¼šæœ¬æ–‡ä»¶ï¼ˆç»Ÿä¸€è§„èŒƒè¯¦è§£ï¼‰
> - ä»£ç æ˜ å°„ï¼ˆSpec â†” Codeï¼‰ï¼šå‚è§ `docs/OTLP_2025_COMPREHENSIVE_DOCUMENTATION_INDEX.md` çš„â€œè§„èŒƒ-å®ç°å¯¹é½çŸ©é˜µâ€ç« èŠ‚
> - æºç è·³è½¬ï¼š`otlp/src/data.rs`ã€`otlp/src/transport.rs`ã€`otlp/src/protobuf.rs`ã€`otlp/src/exporter.rs`ã€`otlp/src/processor.rs`ã€`otlp/src/config.rs`

## ğŸ¯ OTLPè§„èŒƒç›®æ ‡

### ä¸»è¦ç›®æ ‡

1. **åè®®æ ‡å‡†åŒ–**: å»ºç«‹ç»Ÿä¸€çš„é¥æµ‹æ•°æ®åè®®
2. **æ•°æ®æ¨¡å‹**: å®šä¹‰æ ‡å‡†çš„æ•°æ®æ¨¡å‹
3. **ä¼ è¾“åè®®**: æ”¯æŒå¤šç§ä¼ è¾“åè®®
4. **äº’æ“ä½œæ€§**: ç¡®ä¿ç³»ç»Ÿé—´äº’æ“ä½œæ€§
5. **ç‰ˆæœ¬å…¼å®¹**: ä¿è¯å‘åå…¼å®¹æ€§

### æˆåŠŸæ ‡å‡†

- **åè®®å®Œæ•´æ€§**: 100%å®Œæ•´
- **æ•°æ®æ¨¡å‹**: æ ‡å‡†åŒ–
- **ä¼ è¾“æ”¯æŒ**: å¤šåè®®æ”¯æŒ
- **äº’æ“ä½œæ€§**: å®Œå…¨äº’æ“ä½œ
- **å…¼å®¹æ€§**: å‘åå…¼å®¹ä¿è¯

## ğŸ—ï¸ OTLPåè®®æ¶æ„

### åè®®å±‚æ¬¡

```text
åº”ç”¨å±‚
â”œâ”€â”€ é¥æµ‹æ•°æ® (Traces, Metrics, Logs)
â”œâ”€â”€ èµ„æºä¿¡æ¯ (Resource)
â””â”€â”€ å±æ€§ä¿¡æ¯ (Attributes)

åè®®å±‚
â”œâ”€â”€ OTLPåè®®å®šä¹‰
â”œâ”€â”€ æ•°æ®åºåˆ—åŒ–
â””â”€â”€ æ¶ˆæ¯æ ¼å¼

ä¼ è¾“å±‚
â”œâ”€â”€ gRPCä¼ è¾“
â”œâ”€â”€ HTTPä¼ è¾“
â””â”€â”€ å…¶ä»–ä¼ è¾“åè®®

ç½‘ç»œå±‚
â”œâ”€â”€ TCP/IP
â”œâ”€â”€ TLS/SSL
â””â”€â”€ å…¶ä»–ç½‘ç»œåè®®
```

### æ ¸å¿ƒç‰¹æ€§

```text
OTLP åè®®ç‰¹æ€§
â”œâ”€â”€ æ ‡å‡†åŒ–æ•°æ®æ ¼å¼
â”‚   â”œâ”€â”€ Protocol Buffers å®šä¹‰
â”‚   â”œâ”€â”€ è·¨è¯­è¨€æ”¯æŒ
â”‚   â”œâ”€â”€ ç‰ˆæœ¬åŒ–å…¼å®¹
â”‚   â””â”€â”€ å‘åå…¼å®¹ä¿è¯
â”œâ”€â”€ å¤šä¼ è¾“åè®®æ”¯æŒ
â”‚   â”œâ”€â”€ gRPC ä¼ è¾“
â”‚   â”œâ”€â”€ HTTP/1.1 ä¼ è¾“
â”‚   â”œâ”€â”€ HTTP/2 ä¼ è¾“
â”‚   â””â”€â”€ è‡ªå®šä¹‰ä¼ è¾“åè®®
â”œâ”€â”€ æ•°æ®ç±»å‹æ”¯æŒ
â”‚   â”œâ”€â”€ è¿½è¸ªæ•°æ® (Traces)
â”‚   â”œâ”€â”€ æŒ‡æ ‡æ•°æ® (Metrics)
â”‚   â””â”€â”€ æ—¥å¿—æ•°æ® (Logs)
â””â”€â”€ é«˜çº§ç‰¹æ€§
    â”œâ”€â”€ å‹ç¼©æ”¯æŒ
    â”œâ”€â”€ é‡è¯•æœºåˆ¶
    â”œâ”€â”€ æµæ§åˆ¶
    â””â”€â”€ å®‰å…¨è®¤è¯
```

## ğŸ“‹ æ•°æ®æ¨¡å‹è¯¦è§£

### 1. è¿½è¸ªæ•°æ® (Traces)

#### åŸºæœ¬ç»“æ„

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TraceData {
    /// è¿½è¸ªID - å…¨å±€å”¯ä¸€æ ‡è¯†
    pub trace_id: String,
    /// è·¨åº¦ID - æ“ä½œå”¯ä¸€æ ‡è¯†
    pub span_id: String,
    /// çˆ¶è·¨åº¦ID - ç”¨äºæ„å»ºè°ƒç”¨é“¾
    pub parent_span_id: Option<String>,
    /// æ“ä½œåç§°
    pub name: String,
    /// è·¨åº¦ç±»å‹
    pub span_kind: SpanKind,
    /// å¼€å§‹æ—¶é—´
    pub start_time: u64,
    /// ç»“æŸæ—¶é—´
    pub end_time: u64,
    /// çŠ¶æ€ä¿¡æ¯
    pub status: SpanStatus,
    /// å±æ€§é›†åˆ
    pub attributes: HashMap<String, AttributeValue>,
    /// äº‹ä»¶åˆ—è¡¨
    pub events: Vec<SpanEvent>,
    /// é“¾æ¥åˆ—è¡¨
    pub links: Vec<SpanLink>,
}
```

#### è·¨åº¦ç±»å‹

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SpanKind {
    /// å†…éƒ¨è·¨åº¦ - æœåŠ¡å†…éƒ¨æ“ä½œ
    Internal,
    /// æœåŠ¡å™¨è·¨åº¦ - æ¥æ”¶è¯·æ±‚
    Server,
    /// å®¢æˆ·ç«¯è·¨åº¦ - å‘é€è¯·æ±‚
    Client,
    /// ç”Ÿäº§è€…è·¨åº¦ - æ¶ˆæ¯ç”Ÿäº§
    Producer,
    /// æ¶ˆè´¹è€…è·¨åº¦ - æ¶ˆæ¯æ¶ˆè´¹
    Consumer,
}
```

### 2. æŒ‡æ ‡æ•°æ® (Metrics)

#### åŸºæœ¬ç»“æ„2

```rust
#[derive(Debug, Clone)]
pub struct MetricData {
    /// æŒ‡æ ‡åç§°
    pub name: String,
    /// æŒ‡æ ‡æè¿°
    pub description: String,
    /// æŒ‡æ ‡å•ä½
    pub unit: String,
    /// æŒ‡æ ‡ç±»å‹
    pub metric_type: MetricType,
    /// æ•°æ®ç‚¹é›†åˆ
    pub data_points: Vec<DataPoint>,
}
```

#### æŒ‡æ ‡ç±»å‹2

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum MetricType {
    /// è®¡æ•°å™¨ - å•è°ƒé€’å¢çš„æ•°å€¼
    Counter,
    /// ä»ªè¡¨ - å¯å¢å¯å‡çš„æ•°å€¼
    Gauge,
    /// ç›´æ–¹å›¾ - æ•°å€¼åˆ†å¸ƒç»Ÿè®¡
    Histogram,
    /// æ‘˜è¦ - åˆ†ä½æ•°ç»Ÿè®¡
    Summary,
}
```

### 3. æ—¥å¿—æ•°æ® (Logs)

#### åŸºæœ¬ç»“æ„3

```rust
#[derive(Debug, Clone)]
pub struct LogData {
    /// æ—¶é—´æˆ³
    pub timestamp: u64,
    /// ä¸¥é‡ç¨‹åº¦
    pub severity: LogSeverity,
    /// ä¸¥é‡ç¨‹åº¦æ–‡æœ¬
    pub severity_text: String,
    /// æ—¥å¿—æ¶ˆæ¯
    pub message: String,
    /// å±æ€§é›†åˆ
    pub attributes: HashMap<String, AttributeValue>,
    /// èµ„æºå±æ€§
    pub resource_attributes: HashMap<String, AttributeValue>,
    /// å…³è”çš„è¿½è¸ªID
    pub trace_id: Option<String>,
    /// å…³è”çš„è·¨åº¦ID
    pub span_id: Option<String>,
}
```

## ğŸŒ ä¼ è¾“åè®®è¯¦è§£

### 1. gRPCä¼ è¾“

#### é…ç½®ç¤ºä¾‹

```rust
pub struct GrpcTransport {
    config: OtlpConfig,
    client: Option<tonic::transport::Channel>,
    compression_utils: CompressionUtils,
}

impl GrpcTransport {
    pub fn new(config: OtlpConfig) -> Self {
        Self {
            config,
            client: None,
            compression_utils: CompressionUtils::new(),
        }
    }
    
    pub async fn initialize(&mut self) -> Result<()> {
        let endpoint = self.config.endpoint.clone();
        let channel = tonic::transport::Channel::from_shared(endpoint)?
            .connect()
            .await?;
        
        self.client = Some(channel);
        Ok(())
    }
}
```

#### æ€§èƒ½ç‰¹æ€§

- **é»˜è®¤ç«¯å£**: 4317
- **å‹ç¼©æ”¯æŒ**: gzipé»˜è®¤
- **æµæ§åˆ¶**: å†…ç½®back-pressure
- **æ€§èƒ½åŸºå‡†**: 200k spans/s

### 2. HTTPä¼ è¾“

#### é…ç½®ç¤ºä¾‹2

```rust
pub struct HttpTransport {
    config: OtlpConfig,
    client: reqwest::Client,
    compression_utils: CompressionUtils,
}

impl HttpTransport {
    pub fn new(config: OtlpConfig) -> Self {
        let client = reqwest::Client::builder()
            .timeout(config.timeout)
            .build()
            .expect("Failed to create HTTP client");
        
        Self {
            config,
            client,
            compression_utils: CompressionUtils::new(),
        }
    }
}
```

#### æ€§èƒ½ç‰¹æ€§2

- **é»˜è®¤ç«¯å£**: 4318
- **æ ¼å¼æ”¯æŒ**: Protobuf over HTTP
- **é˜²ç«å¢™å‹å¥½**: å¤ç”¨80/443ç«¯å£
- **æ€§èƒ½åŸºå‡†**: 60k spans/s

## âš™ï¸ é…ç½®ç®¡ç†

### åŸºç¡€é…ç½®

```rust
#[derive(Debug, Clone)]
pub struct OtlpConfig {
    /// æœåŠ¡ç«¯ç‚¹
    pub endpoint: String,
    /// ä¼ è¾“åè®®
    pub protocol: TransportProtocol,
    /// è¿æ¥è¶…æ—¶
    pub timeout: Duration,
    /// é‡è¯•æ¬¡æ•°
    pub retry_count: usize,
    /// æ‰¹å¤„ç†é…ç½®
    pub batch_config: BatchConfig,
    /// å‹ç¼©ç®—æ³•
    pub compression: CompressionAlgorithm,
    /// è®¤è¯é…ç½®
    pub auth: Option<AuthConfig>,
    /// TLSé…ç½®
    pub tls: TlsConfig,
    /// é‡‡æ ·é…ç½®
    pub sampling: SamplingConfig,
}
```

### ç¯å¢ƒç‰¹å®šé…ç½®

```rust
impl OtlpConfig {
    /// å¼€å‘ç¯å¢ƒé…ç½®
    pub fn for_development() -> Self {
        Self {
            endpoint: "http://localhost:4317".to_string(),
            protocol: TransportProtocol::Grpc,
            timeout: Duration::from_secs(5),
            retry_count: 3,
            batch_config: BatchConfig::default(),
            compression: CompressionAlgorithm::Gzip,
            auth: None,
            tls: TlsConfig::disabled(),
            sampling: SamplingConfig::ratio(1.0),
        }
    }
    
    /// ç”Ÿäº§ç¯å¢ƒé…ç½®
    pub fn for_production() -> Self {
        Self {
            endpoint: "https://otlp-collector.company.com".to_string(),
            protocol: TransportProtocol::Grpc,
            timeout: Duration::from_secs(30),
            retry_count: 5,
            batch_config: BatchConfig::high_throughput(),
            compression: CompressionAlgorithm::Zstd,
            auth: Some(AuthConfig::with_api_key("production-key")),
            tls: TlsConfig::enabled(),
            sampling: SamplingConfig::adaptive(0.01),
        }
    }
}
```

## ğŸ”§ é«˜çº§ç‰¹æ€§

### 1. å‹ç¼©æ”¯æŒ

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CompressionAlgorithm {
    /// æ— å‹ç¼©
    None,
    /// Gzipå‹ç¼© - é€šç”¨å‹ç¼©ç®—æ³•
    Gzip,
    /// Brotliå‹ç¼© - é«˜æ•ˆå‹ç¼©ç®—æ³•
    Brotli,
    /// Zstdå‹ç¼© - å¿«é€Ÿå‹ç¼©ç®—æ³•
    Zstd,
}
```

### 2. é‡è¯•æœºåˆ¶

```rust
pub struct RetryConfig {
    /// æœ€å¤§é‡è¯•æ¬¡æ•°
    pub max_retries: usize,
    /// åˆå§‹é€€é¿æ—¶é—´
    pub initial_backoff: Duration,
    /// æœ€å¤§é€€é¿æ—¶é—´
    pub max_backoff: Duration,
    /// é€€é¿ä¹˜æ•°
    pub backoff_multiplier: f64,
    /// æŠ–åŠ¨å› å­
    pub jitter_factor: f64,
}
```

### 3. é‡‡æ ·æ§åˆ¶

```rust
pub struct SamplingConfig {
    /// é‡‡æ ·æ¯”ä¾‹
    pub ratio: f64,
    /// é‡‡æ ·ç­–ç•¥
    pub strategy: SamplingStrategy,
    /// åŠ¨æ€è°ƒæ•´
    pub adaptive: bool,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SamplingStrategy {
    /// å›ºå®šæ¯”ä¾‹é‡‡æ ·
    Fixed,
    /// è‡ªé€‚åº”é‡‡æ ·
    Adaptive,
    /// åŸºäºè§„åˆ™çš„é‡‡æ ·
    RuleBased,
}
```

## ğŸš€ ä½¿ç”¨ç¤ºä¾‹

### åŸºç¡€ä½¿ç”¨

```rust
use otlp::{OtlpClient, OtlpConfig};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // åˆ›å»ºé…ç½®
    let config = OtlpConfig::for_development()
        .with_endpoint("http://localhost:4317")
        .with_service("my-service", "1.0.0");
    
    // åˆ›å»ºå®¢æˆ·ç«¯
    let client = OtlpClient::new(config).await?;
    client.initialize().await?;
    
    // å‘é€è¿½è¸ªæ•°æ®
    let result = client.send_trace("example-operation").await?
        .with_attribute("service.name", "my-service")
        .with_attribute("operation.type", "database")
        .finish()
        .await?;
    
    println!("å‘é€æˆåŠŸ: {} æ¡", result.success_count);
    
    client.shutdown().await?;
    Ok(())
}
```

### é«˜çº§é…ç½®

```rust
// é«˜ååé‡é…ç½®
let config = OtlpConfig::for_production()
    .with_endpoint("https://api.honeycomb.io:443")
    .with_protocol(TransportProtocol::Grpc)
    .with_compression(CompressionAlgorithm::Zstd)
    .with_sampling_ratio(0.1)
    .with_batch_config(BatchConfig {
        max_export_batch_size: 1000,
        export_timeout: Duration::from_millis(5000),
        max_queue_size: 10000,
        scheduled_delay: Duration::from_millis(1000),
    })
    .with_auth(AuthConfig::with_api_key("your-api-key"))
    .with_tls(TlsConfig::enabled());
```

### æ‰¹é‡å¤„ç†

```rust
// æ‰¹é‡å‘é€æ•°æ®
async fn send_batch_data(client: &OtlpClient) -> Result<()> {
    let mut batch = Vec::new();
    
    for i in 0..1000 {
        let data = TelemetryData::trace(format!("operation-{}", i))
            .with_attribute("batch_id", "batch-001")
            .with_attribute("index", i.to_string());
        batch.push(data);
    }
    
    let result = client.send_batch(batch).await?;
    println!("æ‰¹é‡å‘é€æˆåŠŸ: {} æ¡", result.success_count);
    
    Ok(())
}
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–

### 1. æ‰¹å¤„ç†ä¼˜åŒ–

```rust
pub struct BatchConfig {
    /// æœ€å¤§æ‰¹å¤„ç†å¤§å°
    pub max_export_batch_size: usize,
    /// å¯¼å‡ºè¶…æ—¶æ—¶é—´
    pub export_timeout: Duration,
    /// æœ€å¤§é˜Ÿåˆ—å¤§å°
    pub max_queue_size: usize,
    /// è°ƒåº¦å»¶è¿Ÿ
    pub scheduled_delay: Duration,
}

impl BatchConfig {
    /// ä½å»¶è¿Ÿé…ç½®
    pub fn low_latency() -> Self {
        Self {
            max_export_batch_size: 10,
            export_timeout: Duration::from_millis(10),
            max_queue_size: 100,
            scheduled_delay: Duration::from_millis(1),
        }
    }
    
    /// é«˜ååé‡é…ç½®
    pub fn high_throughput() -> Self {
        Self {
            max_export_batch_size: 10000,
            export_timeout: Duration::from_secs(10),
            max_queue_size: 100000,
            scheduled_delay: Duration::from_secs(1),
        }
    }
}
```

### 2. è¿æ¥æ± ä¼˜åŒ–

```rust
pub struct ConnectionPool {
    /// æœ€å¤§è¿æ¥æ•°
    pub max_connections: usize,
    /// è¿æ¥è¶…æ—¶
    pub connection_timeout: Duration,
    /// ç©ºé—²è¶…æ—¶
    pub idle_timeout: Duration,
    /// å¥åº·æ£€æŸ¥é—´éš”
    pub health_check_interval: Duration,
}
```

## ğŸ” æ•…éšœæ’æŸ¥

### å¸¸è§é—®é¢˜

| é—®é¢˜ | åŸå›  | è§£å†³æ–¹æ¡ˆ |
|------|------|----------|
| è¿æ¥è¶…æ—¶ | ç½‘ç»œé—®é¢˜æˆ–æœåŠ¡ä¸å¯ç”¨ | æ£€æŸ¥ç½‘ç»œè¿æ¥å’ŒæœåŠ¡çŠ¶æ€ |
| è®¤è¯å¤±è´¥ | APIå¯†é’¥é”™è¯¯æˆ–è¿‡æœŸ | éªŒè¯APIå¯†é’¥å’Œæƒé™ |
| æ•°æ®ä¸¢å¤± | æ‰¹å¤„ç†é…ç½®ä¸å½“ | è°ƒæ•´æ‰¹å¤„ç†å‚æ•° |
| æ€§èƒ½é—®é¢˜ | é‡‡æ ·ç‡è¿‡é«˜æˆ–æ‰¹å¤„ç†è¿‡å° | ä¼˜åŒ–é‡‡æ ·å’Œæ‰¹å¤„ç†é…ç½® |

### è°ƒè¯•æŠ€å·§

1. **å¯ç”¨è°ƒè¯•æ—¥å¿—**: è®¾ç½®æ—¥å¿—çº§åˆ«ä¸ºDEBUG
2. **ç›‘æ§æŒ‡æ ‡**: ä½¿ç”¨å†…ç½®æŒ‡æ ‡ç›‘æ§æ€§èƒ½
3. **å¥åº·æ£€æŸ¥**: å®šæœŸæ£€æŸ¥æœåŠ¡å¥åº·çŠ¶æ€
4. **é”™è¯¯é‡è¯•**: é…ç½®é€‚å½“çš„é‡è¯•ç­–ç•¥

## ğŸ“š å‚è€ƒèµ„æ–™

- [OpenTelemetryå®˜æ–¹æ–‡æ¡£](https://opentelemetry.io/docs/)
- [OTLPåè®®è§„èŒƒ](https://github.com/open-telemetry/opentelemetry-proto)
- [CNCFé¡¹ç›®](https://www.cncf.io/projects/)
- [Rustå®˜æ–¹æ–‡æ¡£](https://doc.rust-lang.org/)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v2.0.0  
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ27æ—¥  
**ç»´æŠ¤è€…**: OpenTelemetry 2025 æ ‡å‡†å›¢é˜Ÿ  
**æ•´åˆçŠ¶æ€**: å·²å®Œæˆé‡å¤å†…å®¹åˆå¹¶
