# OpenTelemetry Protocol (OTLP) 统一规范详解

**版本**: 2.1.0  
**创建时间**: 2025年1月27日  
**最后更新**: 2025年10月27日  
**Rust 版本**: 1.90.0  
**状态**: 🟢 活跃维护

> **简介**: OTLP 协议的完整技术规范说明，包含协议架构、数据模型、传输机制和实施指南。本文档整合了多个重复规范文档，提供统一权威的 OTLP 规范参考。

> **权威来源与实现对齐**:  
> - 权威定义入口：本文件（统一规范详解）
> - 代码映射：参见 `OTLP_2025_COMPREHENSIVE_DOCUMENTATION_INDEX.md` 的"规范-实现对齐矩阵"章节
> - 源码跳转：`otlp/src/data.rs`, `otlp/src/transport.rs`, `otlp/src/protobuf.rs`, `otlp/src/exporter.rs`

---

## 📋 目录

- [OpenTelemetry Protocol (OTLP) 统一规范详解](#opentelemetry-protocol-otlp-统一规范详解)
  - [📋 目录](#-目录)
  - [1. OTLP 规范概览](#1-otlp-规范概览)
    - [1.1 规范目标](#11-规范目标)
    - [1.2 成功标准](#12-成功标准)
    - [1.3 适用范围](#13-适用范围)
  - [2. OTLP 协议架构](#2-otlp-协议架构)
    - [2.1 协议层次](#21-协议层次)
    - [2.2 核心特性](#22-核心特性)
    - [2.3 架构原则](#23-架构原则)
  - [3. 数据模型规范](#3-数据模型规范)
    - [3.1 追踪数据（Traces）](#31-追踪数据traces)
    - [3.2 指标数据（Metrics）](#32-指标数据metrics)
    - [3.3 日志数据（Logs）](#33-日志数据logs)
    - [3.4 资源模型（Resource）](#34-资源模型resource)
    - [3.5 属性系统（Attributes）](#35-属性系统attributes)
  - [4. 传输协议规范](#4-传输协议规范)
    - [4.1 gRPC 传输](#41-grpc-传输)
    - [4.2 HTTP/1.1 传输](#42-http11-传输)
    - [4.3 HTTP/2 传输](#43-http2-传输)
    - [4.4 压缩和编码](#44-压缩和编码)
  - [5. Protocol Buffers 定义](#5-protocol-buffers-定义)
    - [5.1 消息结构](#51-消息结构)
    - [5.2 字段定义](#52-字段定义)
    - [5.3 版本兼容性](#53-版本兼容性)
  - [6. 安全性规范](#6-安全性规范)
    - [6.1 传输层安全（TLS）](#61-传输层安全tls)
    - [6.2 身份认证](#62-身份认证)
    - [6.3 授权机制](#63-授权机制)
  - [7. 性能优化](#7-性能优化)
    - [7.1 批处理策略](#71-批处理策略)
    - [7.2 压缩算法](#72-压缩算法)
    - [7.3 连接管理](#73-连接管理)
  - [8. 错误处理](#8-错误处理)
    - [8.1 错误代码](#81-错误代码)
    - [8.2 重试策略](#82-重试策略)
    - [8.3 熔断机制](#83-熔断机制)
  - [9. 实施指南](#9-实施指南)
    - [9.1 客户端实现](#91-客户端实现)
    - [9.2 服务端实现](#92-服务端实现)
    - [9.3 测试验证](#93-测试验证)
  - [10. 版本兼容性](#10-版本兼容性)
    - [10.1 协议版本](#101-协议版本)
    - [10.2 向后兼容](#102-向后兼容)
    - [10.3 升级路径](#103-升级路径)
  - [附录 A: 完整示例](#附录-a-完整示例)
  - [附录 B: 参考资料](#附录-b-参考资料)

---

## 📖 OTLP 规范概览

### 1.1 规范目标

OTLP（OpenTelemetry Protocol）规范的主要目标：

1. **协议标准化**: 建立统一的遥测数据协议
   - 定义标准的数据交换格式
   - 确保跨语言、跨平台互操作性
   - 提供清晰的协议演进路径

2. **数据模型统一**: 定义标准的数据模型
   - Traces（追踪）、Metrics（指标）、Logs（日志）三大支柱
   - 统一的资源和属性模型
   - 可扩展的数据结构

3. **传输协议支持**: 支持多种传输协议
   - gRPC 作为首选协议（高性能）
   - HTTP/1.1 和 HTTP/2 支持（广泛兼容）
   - 自定义传输协议扩展

4. **互操作性保证**: 确保系统间互操作性
   - 明确的协议规范
   - 完整的测试套件
   - 参考实现

5. **版本兼容性**: 保证向后兼容性
   - 语义化版本控制
   - 渐进式特性添加
   - 废弃特性的过渡期

### 1.2 成功标准

| 指标 | 目标 | 当前状态 |
|------|------|---------|
| **协议完整性** | 100% | ✅ 完整 |
| **数据模型** | 标准化 | ✅ 已标准化 |
| **传输支持** | 多协议 | ✅ gRPC + HTTP |
| **互操作性** | 完全互操作 | ✅ 已验证 |
| **兼容性** | 向后兼容 | ✅ 保证兼容 |

### 1.3 适用范围

本规范适用于：

- **客户端库**: 各编程语言的 OTLP 客户端实现
- **服务端**: OTLP Collector 和后端服务
- **网关**: 协议转换和代理服务
- **工具**: 开发、测试和监控工具

---

## 📝 OTLP 协议架构

### 2.1 协议层次

OTLP 协议采用分层架构设计：

```text
┌─────────────────────────────────────────────────────────┐
│                      应用层                               │
│  ┌───────────┐  ┌───────────┐  ┌───────────┐            │
│  │  Traces   │  │  Metrics  │  │   Logs    │            │
│  └───────────┘  └───────────┘  └───────────┘            │
│  ┌───────────────────────────────────────┐              │
│  │        Resource & Attributes          │              │
│  └───────────────────────────────────────┘              │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│                      协议层                               │
│  ┌───────────────────────────────────────┐              │
│  │      OTLP 协议定义 (Protobuf)         │              │
│  ├───────────────────────────────────────┤              │
│  │      数据序列化与反序列化              │              │
│  └───────────────────────────────────────┘              │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│                      传输层                               │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐              │
│  │  gRPC    │  │ HTTP/1.1 │  │ HTTP/2   │              │
│  └──────────┘  └──────────┘  └──────────┘              │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│                      网络层                               │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐              │
│  │  TCP/IP  │  │ TLS/SSL  │  │  HTTP/3  │              │
│  └──────────┘  └──────────┘  └──────────┘              │
└─────────────────────────────────────────────────────────┘
```

### 2.2 核心特性

#### 2.2.1 标准化数据格式

- **Protocol Buffers 定义**: 跨语言的二进制序列化格式
- **跨语言支持**: 所有主流编程语言
- **版本化兼容**: 语义化版本控制
- **向后兼容保证**: 旧版本客户端可与新版本服务端通信

#### 2.2.2 多传输协议支持

| 传输协议 | 特性 | 适用场景 |
|---------|------|---------|
| **gRPC** | 高性能、双向流、多路复用 | 生产环境首选 |
| **HTTP/1.1** | 广泛支持、简单易用 | 兼容性要求高 |
| **HTTP/2** | 多路复用、服务器推送 | 现代化部署 |

#### 2.2.3 数据类型支持

- **Traces**: 分布式追踪数据（Span 模型）
- **Metrics**: 性能指标数据（Counter、Gauge、Histogram 等）
- **Logs**: 结构化日志数据（LogRecord 模型）

#### 2.2.4 高级特性

- **压缩支持**: gzip、snappy、zstd
- **批处理**: 批量发送减少网络开销
- **重试机制**: 智能重试保证可靠性
- **熔断器**: 防止级联故障
- **背压控制**: 流量控制机制

### 2.3 架构原则

1. **性能优先**: 高吞吐量、低延迟
2. **可靠性**: 数据不丢失、错误可恢复
3. **可扩展性**: 易于添加新特性
4. **互操作性**: 跨语言、跨平台兼容
5. **简洁性**: 易于理解和实现

---

## 🔍 数据模型规范

### 3.1 追踪数据（Traces）

#### 3.1.1 Span 模型

```protobuf
message Span {
  bytes trace_id = 1;              // 追踪 ID (16 bytes)
  bytes span_id = 2;               // Span ID (8 bytes)
  string trace_state = 3;          // 追踪状态
  bytes parent_span_id = 4;        // 父 Span ID
  string name = 5;                 // Span 名称
  SpanKind kind = 6;               // Span 类型
  fixed64 start_time_unix_nano = 7;// 开始时间（纳秒）
  fixed64 end_time_unix_nano = 8;  // 结束时间（纳秒）
  repeated KeyValue attributes = 9;// 属性列表
  uint32 dropped_attributes_count = 10;
  repeated Event events = 11;      // 事件列表
  uint32 dropped_events_count = 12;
  repeated Link links = 13;        // 链接列表
  uint32 dropped_links_count = 14;
  Status status = 15;              // 状态信息
}
```

#### 3.1.2 Span 类型

```rust
pub enum SpanKind {
    Unspecified = 0,  // 未指定
    Internal = 1,     // 内部操作
    Server = 2,       // 服务端接收
    Client = 3,       // 客户端调用
    Producer = 4,     // 消息生产者
    Consumer = 5,     // 消息消费者
}
```

#### 3.1.3 使用示例

```rust
use otlp::trace::{Span, SpanKind};

// 创建 Span
let span = Span::builder("my_operation")
    .with_kind(SpanKind::Server)
    .with_attribute("http.method", "GET")
    .with_attribute("http.url", "/api/users")
    .start();

// ... 执行操作 ...

span.end();
```

### 3.2 指标数据（Metrics）

#### 3.2.1 指标类型

```text
Metrics 类型
├── Gauge（瞬时值）
│   └── 示例：CPU 使用率、内存使用量
├── Counter（累加计数器）
│   └── 示例：请求总数、错误总数
├── Histogram（直方图）
│   └── 示例：请求延迟分布
└── Summary（摘要）
    └── 示例：请求延迟的百分位数
```

#### 3.2.2 Metric 数据结构

```protobuf
message Metric {
  string name = 1;                  // 指标名称
  string description = 2;           // 指标描述
  string unit = 3;                  // 单位
  oneof data {
    Gauge gauge = 4;
    Sum sum = 5;
    Histogram histogram = 6;
    ExponentialHistogram exponential_histogram = 7;
    Summary summary = 8;
  }
}
```

#### 3.2.3 使用示例

```rust
use otlp::metrics::{Counter, Histogram};

// 计数器
let counter = Counter::new("http_requests_total")
    .with_description("Total HTTP requests")
    .with_unit("1");

counter.add(1, &[("method", "GET"), ("status", "200")]);

// 直方图
let histogram = Histogram::new("http_request_duration_seconds")
    .with_description("HTTP request duration")
    .with_unit("s");

histogram.record(0.042, &[("method", "GET")]);
```

### 3.3 日志数据（Logs）

#### 3.3.1 LogRecord 结构

```protobuf
message LogRecord {
  fixed64 time_unix_nano = 1;       // 时间戳（纳秒）
  fixed64 observed_time_unix_nano = 2;
  SeverityNumber severity_number = 3;// 严重级别（数值）
  string severity_text = 4;          // 严重级别（文本）
  AnyValue body = 5;                 // 日志主体
  repeated KeyValue attributes = 6;  // 属性
  uint32 dropped_attributes_count = 7;
  uint32 flags = 8;                  // 标志位
  bytes trace_id = 9;                // 关联的 Trace ID
  bytes span_id = 10;                // 关联的 Span ID
}
```

#### 3.3.2 严重级别

```rust
pub enum SeverityNumber {
    Unspecified = 0,
    Trace = 1,    // TRACE (1-4)
    Debug = 5,    // DEBUG (5-8)
    Info = 9,     // INFO (9-12)
    Warn = 13,    // WARN (13-16)
    Error = 17,   // ERROR (17-20)
    Fatal = 21,   // FATAL (21-24)
}
```

### 3.4 资源模型（Resource）

#### 3.4.1 Resource 定义

```protobuf
message Resource {
  repeated KeyValue attributes = 1;  // 资源属性
  uint32 dropped_attributes_count = 2;
}
```

#### 3.4.2 标准资源属性

```yaml
# 服务信息
service.name: "my-service"
service.version: "1.0.0"
service.instance.id: "instance-1"

# 部署环境
deployment.environment: "production"
cloud.provider: "aws"
cloud.region: "us-west-2"

# 主机信息
host.name: "server-01"
host.arch: "amd64"
os.type: "linux"
```

### 3.5 属性系统（Attributes）

#### 3.5.1 KeyValue 定义

```protobuf
message KeyValue {
  string key = 1;
  AnyValue value = 2;
}

message AnyValue {
  oneof value {
    string string_value = 1;
    bool bool_value = 2;
    int64 int_value = 3;
    double double_value = 4;
    ArrayValue array_value = 5;
    KeyValueList kvlist_value = 6;
    bytes bytes_value = 7;
    }
}
```

---

## 🔧 传输协议规范

### 4.1 gRPC 传输

#### 4.1.1 服务定义

```protobuf
service TraceService {
  rpc Export(ExportTraceServiceRequest) returns (ExportTraceServiceResponse) {}
}

service MetricsService {
  rpc Export(ExportMetricsServiceRequest) returns (ExportMetricsServiceResponse) {}
}

service LogsService {
  rpc Export(ExportLogsServiceRequest) returns (ExportLogsServiceResponse) {}
}
```

#### 4.1.2 端点配置

```yaml
# gRPC 端点
endpoint: "https://otlp.example.com:4317"

# 安全配置
tls:
  enabled: true
  cert_file: "/path/to/cert.pem"
  key_file: "/path/to/key.pem"
  ca_file: "/path/to/ca.pem"

# 认证
headers:
  authorization: "Bearer ${API_KEY}"
```

### 4.2 HTTP/1.1 传输

#### 4.2.1 HTTP 端点

```text
POST /v1/traces HTTP/1.1
POST /v1/metrics HTTP/1.1
POST /v1/logs HTTP/1.1
```

#### 4.2.2 HTTP 头部

```http
Content-Type: application/x-protobuf
Content-Encoding: gzip
Authorization: Bearer <token>
```

#### 4.2.3 响应状态码

| 状态码 | 说明 | 处理建议 |
|-------|------|---------|
| 200 | 成功 | 继续 |
| 400 | 请求错误 | 检查数据格式 |
| 401 | 未授权 | 检查认证信息 |
| 429 | 限流 | 指数退避重试 |
| 500 | 服务器错误 | 重试 |
| 503 | 服务不可用 | 重试 |

### 4.3 HTTP/2 传输

HTTP/2 传输支持：
- ✅ 多路复用
- ✅ 服务器推送
- ✅ 头部压缩
- ✅ 二进制帧

### 4.4 压缩和编码

#### 4.4.1 支持的压缩算法

```text
压缩算法
├── gzip (推荐)
│   └── 压缩率: 约 70-80%
├── snappy
│   └── 速度快，压缩率中等
└── zstd (最佳)
    └── 压缩率和速度平衡
```

#### 4.4.2 配置示例

```rust
use otlp::exporter::Compression;

let exporter = OtlpExporter::builder()
    .with_compression(Compression::Gzip)
    .with_endpoint("https://otlp.example.com:4317")
    .build()?;
```

---

## 📊 Protocol Buffers 定义

### 5.1 消息结构

完整的 Protocol Buffers 定义参见：
- [opentelemetry-proto GitHub](https://github.com/open-telemetry/opentelemetry-proto)

### 5.2 字段定义

所有字段遵循 Protocol Buffers 规范：
- 字段编号1-15使用1字节编码
- 字段编号16-2047使用2字节编码
- 保留字段用于未来扩展

### 5.3 版本兼容性

- ✅ 向后兼容：新字段使用新编号
- ✅ 废弃字段：标记为 `deprecated`
- ✅ 保留字段：使用 `reserved` 关键字

---

## 🌟 安全性规范

### 6.1 传输层安全（TLS）

#### 6.1.1 TLS 配置

```yaml
tls:
  enabled: true
  min_version: "1.2"
  max_version: "1.3"
  cipher_suites:
    - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
    - TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
```

#### 6.1.2 证书验证

- ✅ 验证服务器证书
- ✅ 验证证书链
- ✅ 检查证书有效期
- ✅ 验证主机名

### 6.2 身份认证

#### 6.2.1 支持的认证方式

```text
认证方式
├── API Key（简单）
│   └── Header: Authorization: Bearer <key>
├── mTLS（双向认证）
│   └── 客户端和服务器双向证书验证
├── OAuth 2.0（标准）
│   └── Token 刷新机制
└── 自定义认证
    └── 扩展头部
```

### 6.3 授权机制

- RBAC（基于角色的访问控制）
- ABAC（基于属性的访问控制）
- 自定义策略

---

## 🔬 性能优化

### 7.1 批处理策略

```rust
let batch_config = BatchConfig {
    max_queue_size: 2048,
    scheduled_delay_millis: 5000,
    max_export_batch_size: 512,
    max_export_timeout_millis: 30000,
};
```

### 7.2 压缩算法

| 算法 | 压缩率 | 速度 | 推荐场景 |
|------|--------|------|---------|
| **gzip** | 高 | 中等 | 通用场景 |
| **snappy** | 中等 | 快 | 低延迟要求 |
| **zstd** | 很高 | 快 | 高吞吐量 |

### 7.3 连接管理

- **连接池**: 复用连接减少开销
- **Keep-Alive**: 保持长连接
- **超时控制**: 合理设置超时时间

---

## 💻 错误处理

### 8.1 错误代码

| 错误代码 | 说明 | 处理方式 |
|---------|------|---------|
| `INVALID_ARGUMENT` | 无效参数 | 检查请求数据 |
| `DEADLINE_EXCEEDED` | 超时 | 重试 |
| `NOT_FOUND` | 资源不存在 | 检查配置 |
| `RESOURCE_EXHAUSTED` | 资源耗尽 | 限流、重试 |
| `UNAVAILABLE` | 服务不可用 | 重试、降级 |

### 8.2 重试策略

```rust
let retry_config = RetryConfig {
    max_attempts: 5,
    initial_backoff: Duration::from_millis(100),
    max_backoff: Duration::from_secs(30),
    backoff_multiplier: 2.0,
    jitter: true,
};
```

### 8.3 熔断机制

```rust
let circuit_breaker = CircuitBreaker::new()
    .with_failure_threshold(10)
    .with_success_threshold(2)
    .with_timeout(Duration::from_secs(60));
```

---

## 📚 实施指南

### 9.1 客户端实现

#### 9.1.1 基本实现步骤

1. **配置客户端**
```rust
let client = OtlpClient::builder()
    .with_endpoint("https://otlp.example.com:4317")
    .with_compression(Compression::Gzip)
    .with_timeout(Duration::from_secs(30))
    .build()?;
```

2. **发送数据**
```rust
// 发送追踪数据
client.export_traces(traces).await?;

// 发送指标数据
client.export_metrics(metrics).await?;

// 发送日志数据
client.export_logs(logs).await?;
```

### 9.2 服务端实现

#### 9.2.1 gRPC 服务实现

```rust
#[tonic::async_trait]
impl TraceService for MyTraceService {
    async fn export(
        &self,
        request: Request<ExportTraceServiceRequest>,
    ) -> Result<Response<ExportTraceServiceResponse>, Status> {
        // 处理追踪数据
        let traces = request.into_inner();
        self.process_traces(traces).await?;
        
        Ok(Response::new(ExportTraceServiceResponse {
            partial_success: None,
        }))
    }
}
```

### 9.3 测试验证

#### 9.3.1 测试清单

- [ ] 单元测试：各组件功能
- [ ] 集成测试：端到端流程
- [ ] 性能测试：吞吐量和延迟
- [ ] 压力测试：高负载场景
- [ ] 兼容性测试：多版本互操作

---

## ✅ 版本兼容性

### 10.1 协议版本

当前版本：**v1.3.0**

### 10.2 向后兼容

- ✅ v1.x.x 系列保证向后兼容
- ✅ 新字段添加不破坏旧版本
- ✅ 废弃字段保留至少一个主版本

### 10.3 升级路径

```text
升级路径
v1.0.0 → v1.1.0 → v1.2.0 → v1.3.0 (当前)
  ↓
v2.0.0 (未来，可能存在破坏性变更)
```

---

## 附录 A: 完整示例

### 完整的 OTLP 客户端示例

```rust
use otlp::{OtlpClient, OtlpConfig, Compression};
use std::time::Duration;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 1. 配置客户端
    let config = OtlpConfig::builder()
        .with_endpoint("https://otlp.example.com:4317")
        .with_compression(Compression::Gzip)
        .with_timeout(Duration::from_secs(30))
        .with_header("authorization", "Bearer YOUR_API_KEY")
        .with_tls_config(TlsConfig {
            enabled: true,
            cert_file: Some("/path/to/cert.pem"),
            ..Default::default()
        })
        .build()?;
    
    // 2. 创建客户端
    let client = OtlpClient::new(config).await?;
    
    // 3. 发送追踪数据
    let span = Span::builder("http_request")
        .with_kind(SpanKind::Server)
        .with_attribute("http.method", "GET")
        .with_attribute("http.url", "/api/users")
        .start();
    
    // 执行操作...
    span.end();
    
    client.export_traces(vec![span]).await?;
    
    // 4. 发送指标数据
    let counter = Counter::new("http_requests_total")
        .with_description("Total HTTP requests");
    counter.add(1, &[("method", "GET"), ("status", "200")]);
    
    client.export_metrics(vec![counter.into()]).await?;
    
    // 5. 发送日志数据
    let log = LogRecord::builder()
        .with_severity(SeverityNumber::Info)
        .with_body("Request processed successfully")
        .with_attribute("request_id", "12345")
        .build();
    
    client.export_logs(vec![log]).await?;
    
    println!("✅ All data exported successfully!");
    Ok(())
}
```

---

## 附录 B: 参考资料

### 官方文档

- [OpenTelemetry 官网](https://opentelemetry.io/)
- [OTLP 规范](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/protocol/otlp.md)
- [Protocol Buffers 定义](https://github.com/open-telemetry/opentelemetry-proto)

### 相关文档

- [快速开始指南](../01_快速开始/README.md)
- [核心概念](../02_核心概念/README.md)
- [架构设计](../04_架构设计/README.md)
- [API 参考](../API_REFERENCE.md)

### 社区资源

- [OpenTelemetry GitHub](https://github.com/open-telemetry)
- [CNCF OpenTelemetry](https://www.cncf.io/projects/opentelemetry/)

---

**文档版本**: 2.1.0  
**整合来源**: 合并了多个重复的规范文档  
**维护者**: OpenTelemetry 2025 标准团队  
**最后更新**: 2025年10月27日  
**Rust 版本**: 1.90.0

---

**本文档是 OTLP 协议的权威规范参考，所有实现应遵循此规范。** 📋✅
