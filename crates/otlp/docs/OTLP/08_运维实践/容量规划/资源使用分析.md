# èµ„æºä½¿ç”¨åˆ†æ

## ç›®å½•

- [èµ„æºä½¿ç”¨åˆ†æ](#èµ„æºä½¿ç”¨åˆ†æ)
  - [ç›®å½•](#ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
  - [èµ„æºä½¿ç”¨ç›‘æ§](#èµ„æºä½¿ç”¨ç›‘æ§)
    - [Prometheus æŒ‡æ ‡](#prometheus-æŒ‡æ ‡)
    - [Rust å®ç°ï¼šèµ„æºç›‘æ§](#rust-å®ç°èµ„æºç›‘æ§)
  - [ä½¿ç”¨è¶‹åŠ¿åˆ†æ](#ä½¿ç”¨è¶‹åŠ¿åˆ†æ)
    - [æ—¶é—´åºåˆ—åˆ†æ](#æ—¶é—´åºåˆ—åˆ†æ)
  - [èµ„æºåˆ©ç”¨ç‡ä¼˜åŒ–](#èµ„æºåˆ©ç”¨ç‡ä¼˜åŒ–)
    - [ä¼˜åŒ–å»ºè®®ç”Ÿæˆ](#ä¼˜åŒ–å»ºè®®ç”Ÿæˆ)
  - [è¯¦ç»†èµ„æºç›‘æ§å®ç°](#è¯¦ç»†èµ„æºç›‘æ§å®ç°)
    - [å¤šç»´åº¦èµ„æºç›‘æ§å™¨](#å¤šç»´åº¦èµ„æºç›‘æ§å™¨)
  - [é«˜çº§è¶‹åŠ¿åˆ†æ](#é«˜çº§è¶‹åŠ¿åˆ†æ)
    - [å¤šç»´åº¦è¶‹åŠ¿åˆ†æå™¨](#å¤šç»´åº¦è¶‹åŠ¿åˆ†æå™¨)
  - [æ™ºèƒ½ä¼˜åŒ–å»ºè®®ç³»ç»Ÿ](#æ™ºèƒ½ä¼˜åŒ–å»ºè®®ç³»ç»Ÿ)
    - [é«˜çº§ä¼˜åŒ–é¡¾é—®](#é«˜çº§ä¼˜åŒ–é¡¾é—®)
  - [å®æˆ˜æ¡ˆä¾‹](#å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹1ï¼šå†…å­˜æ³„æ¼æ£€æµ‹](#æ¡ˆä¾‹1å†…å­˜æ³„æ¼æ£€æµ‹)
    - [æ¡ˆä¾‹2ï¼šCPU çªå¢åˆ†æ](#æ¡ˆä¾‹2cpu-çªå¢åˆ†æ)

## æ¦‚è¿°

èµ„æºä½¿ç”¨åˆ†æå¸®åŠ©äº†è§£ç³»ç»Ÿèµ„æºæ¶ˆè€—æƒ…å†µï¼Œä¸ºä¼˜åŒ–å’Œæ‰©å®¹æä¾›ä¾æ®ã€‚

## èµ„æºä½¿ç”¨ç›‘æ§

### Prometheus æŒ‡æ ‡

```yaml
# CPU ä½¿ç”¨ç‡
- process_cpu_seconds_total
- node_cpu_seconds_total

# å†…å­˜ä½¿ç”¨
- process_resident_memory_bytes
- node_memory_MemAvailable_bytes

# ç£ç›˜ä½¿ç”¨
- node_filesystem_avail_bytes
- node_disk_io_time_seconds_total

# ç½‘ç»œä½¿ç”¨
- node_network_receive_bytes_total
- node_network_transmit_bytes_total
```

### Rust å®ç°ï¼šèµ„æºç›‘æ§

```rust
use sysinfo::{System, SystemExt, ProcessExt};

pub struct ResourceMonitor {
    system: System,
}

impl ResourceMonitor {
    pub fn new() -> Self {
        Self {
            system: System::new_all(),
        }
    }

    pub fn collect_metrics(&mut self) -> ResourceMetrics {
        self.system.refresh_all();

        ResourceMetrics {
            cpu_usage: self.system.global_cpu_info().cpu_usage(),
            memory_used: self.system.used_memory(),
            memory_total: self.system.total_memory(),
            disk_usage: self.get_disk_usage(),
        }
    }

    fn get_disk_usage(&self) -> f64 {
        // å®ç°ç£ç›˜ä½¿ç”¨ç‡è®¡ç®—
        0.0
    }
}

pub struct ResourceMetrics {
    pub cpu_usage: f32,
    pub memory_used: u64,
    pub memory_total: u64,
    pub disk_usage: f64,
}
```

## ä½¿ç”¨è¶‹åŠ¿åˆ†æ

### æ—¶é—´åºåˆ—åˆ†æ

```rust
pub struct TrendAnalyzer {
    data_points: Vec<(u64, f64)>, // (timestamp, value)
}

impl TrendAnalyzer {
    pub fn analyze_trend(&self) -> TrendResult {
        if self.data_points.len() < 2 {
            return TrendResult::Insufficient;
        }

        let slope = self.calculate_slope();

        if slope > 0.1 {
            TrendResult::Increasing
        } else if slope < -0.1 {
            TrendResult::Decreasing
        } else {
            TrendResult::Stable
        }
    }

    fn calculate_slope(&self) -> f64 {
        // çº¿æ€§å›å½’è®¡ç®—æ–œç‡
        let n = self.data_points.len() as f64;
        let sum_x: f64 = self.data_points.iter().map(|(t, _)| *t as f64).sum();
        let sum_y: f64 = self.data_points.iter().map(|(_, v)| v).sum();
        let sum_xy: f64 = self.data_points.iter().map(|(t, v)| (*t as f64) * v).sum();
        let sum_x2: f64 = self.data_points.iter().map(|(t, _)| (*t as f64).powi(2)).sum();

        (n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x * sum_x)
    }
}

pub enum TrendResult {
    Increasing,
    Decreasing,
    Stable,
    Insufficient,
}
```

## èµ„æºåˆ©ç”¨ç‡ä¼˜åŒ–

### ä¼˜åŒ–å»ºè®®ç”Ÿæˆ

```rust
pub struct OptimizationAdvisor {
    metrics: ResourceMetrics,
}

impl OptimizationAdvisor {
    pub fn generate_recommendations(&self) -> Vec<Recommendation> {
        let mut recommendations = Vec::new();

        // CPU ä¼˜åŒ–å»ºè®®
        if self.metrics.cpu_usage > 80.0 {
            recommendations.push(Recommendation {
                resource: "CPU".to_string(),
                severity: Severity::High,
                suggestion: "è€ƒè™‘å¢åŠ  CPU æ ¸å¿ƒæ•°æˆ–ä¼˜åŒ–è®¡ç®—å¯†é›†å‹ä»»åŠ¡".to_string(),
            });
        }

        // å†…å­˜ä¼˜åŒ–å»ºè®®
        let memory_usage_percent = (self.metrics.memory_used as f64 / self.metrics.memory_total as f64) * 100.0;
        if memory_usage_percent > 85.0 {
            recommendations.push(Recommendation {
                resource: "Memory".to_string(),
                severity: Severity::High,
                suggestion: "å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜ï¼Œå»ºè®®å¢åŠ å†…å­˜æˆ–ä¼˜åŒ–å†…å­˜ä½¿ç”¨".to_string(),
            });
        }

        recommendations
    }
}

pub struct Recommendation {
    pub resource: String,
    pub severity: Severity,
    pub suggestion: String,
}

pub enum Severity {
    Low,
    Medium,
    High,
    Critical,
}
```

## è¯¦ç»†èµ„æºç›‘æ§å®ç°

### å¤šç»´åº¦èµ„æºç›‘æ§å™¨

```rust
use sysinfo::{System, SystemExt, ProcessExt, DiskExt, NetworkExt};
use std::collections::HashMap;
use std::time::{Duration, Instant};

/// å®Œæ•´çš„èµ„æºç›‘æ§å™¨
pub struct ComprehensiveResourceMonitor {
    system: System,
    start_time: Instant,
    history: ResourceHistory,
}

impl ComprehensiveResourceMonitor {
    pub fn new() -> Self {
        Self {
            system: System::new_all(),
            start_time: Instant::now(),
            history: ResourceHistory::new(),
        }
    }

    /// æ”¶é›†æ‰€æœ‰èµ„æºæŒ‡æ ‡
    pub fn collect_all_metrics(&mut self) -> AllResourceMetrics {
        self.system.refresh_all();
        
        let metrics = AllResourceMetrics {
            cpu: self.collect_cpu_metrics(),
            memory: self.collect_memory_metrics(),
            disk: self.collect_disk_metrics(),
            network: self.collect_network_metrics(),
            process: self.collect_process_metrics(),
            timestamp: Instant::now().duration_since(self.start_time).as_secs(),
        };
        
        // è®°å½•å†å²
        self.history.add(metrics.clone());
        
        metrics
    }

    fn collect_cpu_metrics(&self) -> CpuMetrics {
        let global_cpu = self.system.global_cpu_info();
        let per_cpu: Vec<f32> = self.system.cpus().iter()
            .map(|cpu| cpu.cpu_usage())
            .collect();
        
        CpuMetrics {
            global_usage: global_cpu.cpu_usage(),
            per_core_usage: per_cpu.clone(),
            core_count: per_cpu.len(),
            load_average_1m: self.system.load_average().one,
            load_average_5m: self.system.load_average().five,
            load_average_15m: self.system.load_average().fifteen,
        }
    }

    fn collect_memory_metrics(&self) -> MemoryMetrics {
        let used = self.system.used_memory();
        let total = self.system.total_memory();
        let available = self.system.available_memory();
        let swap_used = self.system.used_swap();
        let swap_total = self.system.total_swap();
        
        MemoryMetrics {
            used_bytes: used,
            total_bytes: total,
            available_bytes: available,
            usage_percent: (used as f64 / total as f64) * 100.0,
            swap_used_bytes: swap_used,
            swap_total_bytes: swap_total,
            swap_usage_percent: if swap_total > 0 {
                (swap_used as f64 / swap_total as f64) * 100.0
            } else {
                0.0
            },
        }
    }

    fn collect_disk_metrics(&self) -> Vec<DiskMetrics> {
        self.system.disks().iter().map(|disk| {
            let total = disk.total_space();
            let available = disk.available_space();
            let used = total - available;
            
            DiskMetrics {
                mount_point: disk.mount_point().to_string_lossy().to_string(),
                total_bytes: total,
                used_bytes: used,
                available_bytes: available,
                usage_percent: (used as f64 / total as f64) * 100.0,
                file_system: disk.file_system().to_string_lossy().to_string(),
            }
        }).collect()
    }

    fn collect_network_metrics(&self) -> NetworkMetrics {
        let networks = self.system.networks();
        let mut total_received = 0u64;
        let mut total_transmitted = 0u64;
        
        for (_name, network) in networks {
            total_received += network.received();
            total_transmitted += network.transmitted();
        }
        
        NetworkMetrics {
            total_received_bytes: total_received,
            total_transmitted_bytes: total_transmitted,
            interface_count: networks.len(),
        }
    }

    fn collect_process_metrics(&self) -> ProcessMetrics {
        let current_pid = std::process::id();
        
        if let Some(process) = self.system.process(sysinfo::Pid::from_u32(current_pid)) {
            ProcessMetrics {
                pid: current_pid,
                cpu_usage: process.cpu_usage(),
                memory_bytes: process.memory(),
                virtual_memory_bytes: process.virtual_memory(),
                disk_read_bytes: process.disk_usage().read_bytes,
                disk_write_bytes: process.disk_usage().written_bytes,
            }
        } else {
            ProcessMetrics::default()
        }
    }

    /// è·å–èµ„æºä½¿ç”¨å†å²
    pub fn get_history(&self, duration: Duration) -> Vec<AllResourceMetrics> {
        self.history.get_recent(duration)
    }
}

#[derive(Debug, Clone)]
pub struct AllResourceMetrics {
    pub cpu: CpuMetrics,
    pub memory: MemoryMetrics,
    pub disk: Vec<DiskMetrics>,
    pub network: NetworkMetrics,
    pub process: ProcessMetrics,
    pub timestamp: u64,
}

#[derive(Debug, Clone)]
pub struct CpuMetrics {
    pub global_usage: f32,
    pub per_core_usage: Vec<f32>,
    pub core_count: usize,
    pub load_average_1m: f64,
    pub load_average_5m: f64,
    pub load_average_15m: f64,
}

#[derive(Debug, Clone)]
pub struct MemoryMetrics {
    pub used_bytes: u64,
    pub total_bytes: u64,
    pub available_bytes: u64,
    pub usage_percent: f64,
    pub swap_used_bytes: u64,
    pub swap_total_bytes: u64,
    pub swap_usage_percent: f64,
}

#[derive(Debug, Clone)]
pub struct DiskMetrics {
    pub mount_point: String,
    pub total_bytes: u64,
    pub used_bytes: u64,
    pub available_bytes: u64,
    pub usage_percent: f64,
    pub file_system: String,
}

#[derive(Debug, Clone)]
pub struct NetworkMetrics {
    pub total_received_bytes: u64,
    pub total_transmitted_bytes: u64,
    pub interface_count: usize,
}

#[derive(Debug, Clone, Default)]
pub struct ProcessMetrics {
    pub pid: u32,
    pub cpu_usage: f32,
    pub memory_bytes: u64,
    pub virtual_memory_bytes: u64,
    pub disk_read_bytes: u64,
    pub disk_write_bytes: u64,
}

/// èµ„æºä½¿ç”¨å†å²è®°å½•
struct ResourceHistory {
    metrics: Vec<AllResourceMetrics>,
    max_size: usize,
}

impl ResourceHistory {
    fn new() -> Self {
        Self {
            metrics: Vec::new(),
            max_size: 1000, // ä¿ç•™æœ€è¿‘ 1000 ä¸ªæ•°æ®ç‚¹
        }
    }

    fn add(&mut self, metrics: AllResourceMetrics) {
        self.metrics.push(metrics);
        if self.metrics.len() > self.max_size {
            self.metrics.remove(0);
        }
    }

    fn get_recent(&self, duration: Duration) -> Vec<AllResourceMetrics> {
        let cutoff_time = self.metrics.last()
            .map(|m| m.timestamp.saturating_sub(duration.as_secs()))
            .unwrap_or(0);
        
        self.metrics.iter()
            .filter(|m| m.timestamp >= cutoff_time)
            .cloned()
            .collect()
    }
}
```

## é«˜çº§è¶‹åŠ¿åˆ†æ

### å¤šç»´åº¦è¶‹åŠ¿åˆ†æå™¨

```rust
use statrs::statistics::Statistics;

/// é«˜çº§è¶‹åŠ¿åˆ†æå™¨
pub struct AdvancedTrendAnalyzer {
    history: Vec<AllResourceMetrics>,
}

impl AdvancedTrendAnalyzer {
    pub fn new(history: Vec<AllResourceMetrics>) -> Self {
        Self { history }
    }

    /// åˆ†ææ‰€æœ‰èµ„æºè¶‹åŠ¿
    pub fn analyze_all_trends(&self) -> TrendAnalysisReport {
        TrendAnalysisReport {
            cpu_trend: self.analyze_cpu_trend(),
            memory_trend: self.analyze_memory_trend(),
            disk_trend: self.analyze_disk_trend(),
            network_trend: self.analyze_network_trend(),
            predictions: self.generate_predictions(),
        }
    }

    fn analyze_cpu_trend(&self) -> ResourceTrend {
        let data: Vec<f64> = self.history.iter()
            .map(|m| m.cpu.global_usage as f64)
            .collect();
        
        self.calculate_trend(&data, "CPU")
    }

    fn analyze_memory_trend(&self) -> ResourceTrend {
        let data: Vec<f64> = self.history.iter()
            .map(|m| m.memory.usage_percent)
            .collect();
        
        self.calculate_trend(&data, "Memory")
    }

    fn analyze_disk_trend(&self) -> ResourceTrend {
        let data: Vec<f64> = self.history.iter()
            .filter_map(|m| m.disk.first())
            .map(|d| d.usage_percent)
            .collect();
        
        self.calculate_trend(&data, "Disk")
    }

    fn analyze_network_trend(&self) -> ResourceTrend {
        let data: Vec<f64> = self.history.iter()
            .map(|m| m.network.total_transmitted_bytes as f64)
            .collect();
        
        self.calculate_trend(&data, "Network")
    }

    fn calculate_trend(&self, data: &[f64], resource_name: &str) -> ResourceTrend {
        if data.len() < 2 {
            return ResourceTrend {
                resource: resource_name.to_string(),
                direction: TrendDirection::Insufficient,
                slope: 0.0,
                confidence: 0.0,
                mean: 0.0,
                std_dev: 0.0,
                min: 0.0,
                max: 0.0,
            };
        }

        let mean = data.mean();
        let std_dev = data.std_dev();
        let min = data.iter().cloned().fold(f64::INFINITY, f64::min);
        let max = data.iter().cloned().fold(f64::NEG_INFINITY, f64::max);

        // çº¿æ€§å›å½’è®¡ç®—æ–œç‡
        let n = data.len() as f64;
        let x: Vec<f64> = (0..data.len()).map(|i| i as f64).collect();
        let sum_x: f64 = x.iter().sum();
        let sum_y: f64 = data.iter().sum();
        let sum_xy: f64 = x.iter().zip(data.iter()).map(|(xi, yi)| xi * yi).sum();
        let sum_x2: f64 = x.iter().map(|xi| xi * xi).sum();

        let slope = (n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x * sum_x);

        // è®¡ç®— RÂ² (å†³å®šç³»æ•°) ä½œä¸ºç½®ä¿¡åº¦
        let y_pred: Vec<f64> = x.iter().map(|xi| mean + slope * (xi - sum_x / n)).collect();
        let ss_res: f64 = data.iter().zip(y_pred.iter())
            .map(|(yi, yp)| (yi - yp).powi(2))
            .sum();
        let ss_tot: f64 = data.iter()
            .map(|yi| (yi - mean).powi(2))
            .sum();
        let r_squared = 1.0 - (ss_res / ss_tot);

        let direction = if slope > 0.01 {
            TrendDirection::Increasing
        } else if slope < -0.01 {
            TrendDirection::Decreasing
        } else {
            TrendDirection::Stable
        };

        ResourceTrend {
            resource: resource_name.to_string(),
            direction,
            slope,
            confidence: r_squared,
            mean,
            std_dev,
            min,
            max,
        }
    }

    /// ç”Ÿæˆæœªæ¥é¢„æµ‹
    fn generate_predictions(&self) -> Vec<ResourcePrediction> {
        let mut predictions = Vec::new();

        // CPU é¢„æµ‹
        let cpu_data: Vec<f64> = self.history.iter()
            .map(|m| m.cpu.global_usage as f64)
            .collect();
        predictions.push(self.predict_resource("CPU", &cpu_data, 3600)); // 1å°æ—¶å

        // å†…å­˜é¢„æµ‹
        let memory_data: Vec<f64> = self.history.iter()
            .map(|m| m.memory.usage_percent)
            .collect();
        predictions.push(self.predict_resource("Memory", &memory_data, 3600));

        predictions
    }

    fn predict_resource(&self, name: &str, data: &[f64], seconds_ahead: u64) -> ResourcePrediction {
        if data.len() < 2 {
            return ResourcePrediction {
                resource: name.to_string(),
                current_value: 0.0,
                predicted_value: 0.0,
                time_ahead_seconds: seconds_ahead,
                confidence: 0.0,
            };
        }

        let trend = self.calculate_trend(data, name);
        let current_value = data.last().copied().unwrap_or(0.0);
        
        // ç®€å•çº¿æ€§é¢„æµ‹
        let time_points = data.len() as f64;
        let predicted_value = current_value + trend.slope * (seconds_ahead as f64 / time_points);

        ResourcePrediction {
            resource: name.to_string(),
            current_value,
            predicted_value: predicted_value.max(0.0).min(100.0), // é™åˆ¶åœ¨ 0-100%
            time_ahead_seconds: seconds_ahead,
            confidence: trend.confidence,
        }
    }
}

#[derive(Debug)]
pub struct TrendAnalysisReport {
    pub cpu_trend: ResourceTrend,
    pub memory_trend: ResourceTrend,
    pub disk_trend: ResourceTrend,
    pub network_trend: ResourceTrend,
    pub predictions: Vec<ResourcePrediction>,
}

#[derive(Debug)]
pub struct ResourceTrend {
    pub resource: String,
    pub direction: TrendDirection,
    pub slope: f64,
    pub confidence: f64,
    pub mean: f64,
    pub std_dev: f64,
    pub min: f64,
    pub max: f64,
}

#[derive(Debug)]
pub enum TrendDirection {
    Increasing,
    Decreasing,
    Stable,
    Insufficient,
}

#[derive(Debug)]
pub struct ResourcePrediction {
    pub resource: String,
    pub current_value: f64,
    pub predicted_value: f64,
    pub time_ahead_seconds: u64,
    pub confidence: f64,
}
```

## æ™ºèƒ½ä¼˜åŒ–å»ºè®®ç³»ç»Ÿ

### é«˜çº§ä¼˜åŒ–é¡¾é—®

```rust
/// æ™ºèƒ½ä¼˜åŒ–é¡¾é—®
pub struct IntelligentOptimizationAdvisor {
    current_metrics: AllResourceMetrics,
    trend_report: TrendAnalysisReport,
    thresholds: ResourceThresholds,
}

#[derive(Debug, Clone)]
pub struct ResourceThresholds {
    pub cpu_warning: f64,
    pub cpu_critical: f64,
    pub memory_warning: f64,
    pub memory_critical: f64,
    pub disk_warning: f64,
    pub disk_critical: f64,
}

impl Default for ResourceThresholds {
    fn default() -> Self {
        Self {
            cpu_warning: 70.0,
            cpu_critical: 85.0,
            memory_warning: 75.0,
            memory_critical: 90.0,
            disk_warning: 80.0,
            disk_critical: 95.0,
        }
    }
}

impl IntelligentOptimizationAdvisor {
    pub fn new(
        current_metrics: AllResourceMetrics,
        trend_report: TrendAnalysisReport,
    ) -> Self {
        Self {
            current_metrics,
            trend_report,
            thresholds: ResourceThresholds::default(),
        }
    }

    /// ç”Ÿæˆå…¨é¢çš„ä¼˜åŒ–å»ºè®®
    pub fn generate_comprehensive_recommendations(&self) -> Vec<DetailedRecommendation> {
        let mut recommendations = Vec::new();

        // CPU å»ºè®®
        recommendations.extend(self.analyze_cpu());
        
        // å†…å­˜å»ºè®®
        recommendations.extend(self.analyze_memory());
        
        // ç£ç›˜å»ºè®®
        recommendations.extend(self.analyze_disk());
        
        // ç½‘ç»œå»ºè®®
        recommendations.extend(self.analyze_network());
        
        // åŸºäºè¶‹åŠ¿çš„é¢„æµ‹æ€§å»ºè®®
        recommendations.extend(self.generate_predictive_recommendations());

        // æŒ‰ä¸¥é‡ç¨‹åº¦æ’åº
        recommendations.sort_by(|a, b| b.severity.cmp(&a.severity));

        recommendations
    }

    fn analyze_cpu(&self) -> Vec<DetailedRecommendation> {
        let mut recommendations = Vec::new();
        let cpu_usage = self.current_metrics.cpu.global_usage as f64;

        if cpu_usage > self.thresholds.cpu_critical {
            recommendations.push(DetailedRecommendation {
                resource: "CPU".to_string(),
                severity: Severity::Critical,
                current_value: cpu_usage,
                threshold: self.thresholds.cpu_critical,
                issue: format!("CPU ä½¿ç”¨ç‡è¾¾åˆ° {:.1}%ï¼Œè¶…è¿‡ä¸´ç•Œé˜ˆå€¼", cpu_usage),
                suggestions: vec![
                    "ç«‹å³æ£€æŸ¥æ˜¯å¦æœ‰å¼‚å¸¸è¿›ç¨‹å ç”¨ CPU".to_string(),
                    "è€ƒè™‘æ°´å¹³æ‰©å±•å¢åŠ å®ä¾‹æ•°".to_string(),
                    "ä¼˜åŒ–è®¡ç®—å¯†é›†å‹ä»»åŠ¡".to_string(),
                    "å¯ç”¨ CPU é™æµä¿æŠ¤".to_string(),
                ],
                estimated_impact: "é«˜ - å¯èƒ½å½±å“æœåŠ¡å“åº”æ—¶é—´".to_string(),
                action_priority: ActionPriority::Immediate,
            });
        } else if cpu_usage > self.thresholds.cpu_warning {
            recommendations.push(DetailedRecommendation {
                resource: "CPU".to_string(),
                severity: Severity::Warning,
                current_value: cpu_usage,
                threshold: self.thresholds.cpu_warning,
                issue: format!("CPU ä½¿ç”¨ç‡ {:.1}% æ¥è¿‘è­¦å‘Šé˜ˆå€¼", cpu_usage),
                suggestions: vec![
                    "ç›‘æ§ CPU ä½¿ç”¨è¶‹åŠ¿".to_string(),
                    "æ£€æŸ¥æ˜¯å¦æœ‰ä¼˜åŒ–ç©ºé—´".to_string(),
                    "å‡†å¤‡æ‰©å®¹è®¡åˆ’".to_string(),
                ],
                estimated_impact: "ä¸­ - éœ€è¦å…³æ³¨".to_string(),
                action_priority: ActionPriority::High,
            });
        }

        // è´Ÿè½½å¹³å‡å€¼åˆ†æ
        let load_avg = self.current_metrics.cpu.load_average_5m;
        let core_count = self.current_metrics.cpu.core_count as f64;
        if load_avg > core_count * 0.8 {
            recommendations.push(DetailedRecommendation {
                resource: "CPU Load".to_string(),
                severity: Severity::Warning,
                current_value: load_avg,
                threshold: core_count * 0.8,
                issue: format!("5åˆ†é’Ÿè´Ÿè½½å¹³å‡å€¼ {:.2} è¾ƒé«˜ï¼ˆæ ¸å¿ƒæ•°ï¼š{}ï¼‰", load_avg, core_count),
                suggestions: vec![
                    "æ£€æŸ¥æ˜¯å¦æœ‰é•¿æ—¶é—´è¿è¡Œçš„ä»»åŠ¡".to_string(),
                    "è€ƒè™‘ä»»åŠ¡è°ƒåº¦ä¼˜åŒ–".to_string(),
                ],
                estimated_impact: "ä¸­".to_string(),
                action_priority: ActionPriority::Medium,
            });
        }

        recommendations
    }

    fn analyze_memory(&self) -> Vec<DetailedRecommendation> {
        let mut recommendations = Vec::new();
        let memory_usage = self.current_metrics.memory.usage_percent;

        if memory_usage > self.thresholds.memory_critical {
            recommendations.push(DetailedRecommendation {
                resource: "Memory".to_string(),
                severity: Severity::Critical,
                current_value: memory_usage,
                threshold: self.thresholds.memory_critical,
                issue: format!("å†…å­˜ä½¿ç”¨ç‡ {:.1}% è¾¾åˆ°ä¸´ç•Œæ°´å¹³", memory_usage),
                suggestions: vec![
                    "ç«‹å³æ£€æŸ¥å†…å­˜æ³„æ¼".to_string(),
                    "é‡å¯é«˜å†…å­˜å ç”¨æœåŠ¡".to_string(),
                    "å¢åŠ ç‰©ç†å†…å­˜".to_string(),
                    "å¯ç”¨å†…å­˜é™åˆ¶å’Œ OOM ä¿æŠ¤".to_string(),
                ],
                estimated_impact: "ä¸¥é‡ - å¯èƒ½å¯¼è‡´ OOM".to_string(),
                action_priority: ActionPriority::Immediate,
            });
        } else if memory_usage > self.thresholds.memory_warning {
            recommendations.push(DetailedRecommendation {
                resource: "Memory".to_string(),
                severity: Severity::Warning,
                current_value: memory_usage,
                threshold: self.thresholds.memory_warning,
                issue: format!("å†…å­˜ä½¿ç”¨ç‡ {:.1}% åé«˜", memory_usage),
                suggestions: vec![
                    "åˆ†æå†…å­˜ä½¿ç”¨æ¨¡å¼".to_string(),
                    "ä¼˜åŒ–ç¼“å­˜ç­–ç•¥".to_string(),
                    "è€ƒè™‘å‚ç›´æ‰©å±•".to_string(),
                ],
                estimated_impact: "ä¸­".to_string(),
                action_priority: ActionPriority::High,
            });
        }

        // Swap ä½¿ç”¨åˆ†æ
        if self.current_metrics.memory.swap_usage_percent > 10.0 {
            recommendations.push(DetailedRecommendation {
                resource: "Swap".to_string(),
                severity: Severity::Warning,
                current_value: self.current_metrics.memory.swap_usage_percent,
                threshold: 10.0,
                issue: format!("Swap ä½¿ç”¨ç‡ {:.1}%ï¼Œå¯èƒ½å½±å“æ€§èƒ½", 
                    self.current_metrics.memory.swap_usage_percent),
                suggestions: vec![
                    "å¢åŠ ç‰©ç†å†…å­˜".to_string(),
                    "å‡å°‘å†…å­˜å ç”¨".to_string(),
                    "è°ƒæ•´ swappiness å‚æ•°".to_string(),
                ],
                estimated_impact: "ä¸­ - æ€§èƒ½ä¸‹é™".to_string(),
                action_priority: ActionPriority::Medium,
            });
        }

        recommendations
    }

    fn analyze_disk(&self) -> Vec<DetailedRecommendation> {
        let mut recommendations = Vec::new();

        for disk in &self.current_metrics.disk {
            if disk.usage_percent > self.thresholds.disk_critical {
                recommendations.push(DetailedRecommendation {
                    resource: format!("Disk ({})", disk.mount_point),
                    severity: Severity::Critical,
                    current_value: disk.usage_percent,
                    threshold: self.thresholds.disk_critical,
                    issue: format!("ç£ç›˜ {} ä½¿ç”¨ç‡ {:.1}% è¾¾åˆ°ä¸´ç•Œæ°´å¹³", 
                        disk.mount_point, disk.usage_percent),
                    suggestions: vec![
                        "ç«‹å³æ¸…ç†ä¸å¿…è¦çš„æ–‡ä»¶".to_string(),
                        "å½’æ¡£æ—§æ•°æ®".to_string(),
                        "æ‰©å±•ç£ç›˜ç©ºé—´".to_string(),
                        "å¯ç”¨æ—¥å¿—è½®è½¬".to_string(),
                    ],
                    estimated_impact: "ä¸¥é‡ - å¯èƒ½å¯¼è‡´æœåŠ¡ä¸­æ–­".to_string(),
                    action_priority: ActionPriority::Immediate,
                });
            } else if disk.usage_percent > self.thresholds.disk_warning {
                recommendations.push(DetailedRecommendation {
                    resource: format!("Disk ({})", disk.mount_point),
                    severity: Severity::Warning,
                    current_value: disk.usage_percent,
                    threshold: self.thresholds.disk_warning,
                    issue: format!("ç£ç›˜ {} ä½¿ç”¨ç‡ {:.1}% åé«˜", 
                        disk.mount_point, disk.usage_percent),
                    suggestions: vec![
                        "è®¡åˆ’ç£ç›˜æ¸…ç†".to_string(),
                        "å®¡æŸ¥æ•°æ®ä¿ç•™ç­–ç•¥".to_string(),
                        "è€ƒè™‘æ•°æ®å‹ç¼©".to_string(),
                    ],
                    estimated_impact: "ä¸­".to_string(),
                    action_priority: ActionPriority::High,
                });
            }
        }

        recommendations
    }

    fn analyze_network(&self) -> Vec<DetailedRecommendation> {
        let mut recommendations = Vec::new();

        // ç½‘ç»œæµé‡åˆ†æï¼ˆéœ€è¦å†å²æ•°æ®å¯¹æ¯”ï¼‰
        // è¿™é‡Œç®€åŒ–å¤„ç†
        let total_traffic = self.current_metrics.network.total_received_bytes 
            + self.current_metrics.network.total_transmitted_bytes;

        if total_traffic > 1_000_000_000_000 { // 1TB
            recommendations.push(DetailedRecommendation {
                resource: "Network".to_string(),
                severity: Severity::Info,
                current_value: total_traffic as f64,
                threshold: 1_000_000_000_000.0,
                issue: "ç½‘ç»œæµé‡è¾ƒå¤§".to_string(),
                suggestions: vec![
                    "æ£€æŸ¥æ˜¯å¦æœ‰å¼‚å¸¸æµé‡".to_string(),
                    "è€ƒè™‘å¯ç”¨æ•°æ®å‹ç¼©".to_string(),
                    "ä¼˜åŒ–ç½‘ç»œä¼ è¾“".to_string(),
                ],
                estimated_impact: "ä½".to_string(),
                action_priority: ActionPriority::Low,
            });
        }

        recommendations
    }

    fn generate_predictive_recommendations(&self) -> Vec<DetailedRecommendation> {
        let mut recommendations = Vec::new();

        // åŸºäºè¶‹åŠ¿é¢„æµ‹çš„å»ºè®®
        for prediction in &self.trend_report.predictions {
            if prediction.confidence > 0.7 && prediction.predicted_value > 85.0 {
                recommendations.push(DetailedRecommendation {
                    resource: format!("{} (é¢„æµ‹)", prediction.resource),
                    severity: Severity::Info,
                    current_value: prediction.current_value,
                    threshold: 85.0,
                    issue: format!(
                        "{} é¢„è®¡åœ¨ {} åˆ†é’Ÿåè¾¾åˆ° {:.1}%",
                        prediction.resource,
                        prediction.time_ahead_seconds / 60,
                        prediction.predicted_value
                    ),
                    suggestions: vec![
                        "æå‰å‡†å¤‡æ‰©å®¹".to_string(),
                        "ä¼˜åŒ–èµ„æºä½¿ç”¨".to_string(),
                        "ç›‘æ§è¶‹åŠ¿å˜åŒ–".to_string(),
                    ],
                    estimated_impact: "é¢„é˜²æ€§".to_string(),
                    action_priority: ActionPriority::Medium,
                });
            }
        }

        recommendations
    }
}

#[derive(Debug)]
pub struct DetailedRecommendation {
    pub resource: String,
    pub severity: Severity,
    pub current_value: f64,
    pub threshold: f64,
    pub issue: String,
    pub suggestions: Vec<String>,
    pub estimated_impact: String,
    pub action_priority: ActionPriority,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum Severity {
    Info = 0,
    Low = 1,
    Warning = 2,
    High = 3,
    Critical = 4,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum ActionPriority {
    Low = 0,
    Medium = 1,
    High = 2,
    Immediate = 3,
}
```

## å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹1ï¼šå†…å­˜æ³„æ¼æ£€æµ‹

**åœºæ™¯**ï¼šç”Ÿäº§ç¯å¢ƒå†…å­˜ä½¿ç”¨ç‡æŒç»­å¢é•¿

**ç›‘æ§æ•°æ®**ï¼š

```text
æ—¶é—´      å†…å­˜ä½¿ç”¨ç‡    è¶‹åŠ¿
10:00    45%          -
11:00    52%          â†‘ +7%
12:00    59%          â†‘ +7%
13:00    67%          â†‘ +8%
14:00    75%          â†‘ +8%
```

**è¶‹åŠ¿åˆ†æç»“æœ**ï¼š

```rust
ResourceTrend {
    resource: "Memory",
    direction: TrendDirection::Increasing,
    slope: 7.5,  // æ¯å°æ—¶å¢é•¿ 7.5%
    confidence: 0.95,  // 95% ç½®ä¿¡åº¦
    mean: 59.6,
    std_dev: 10.2,
}
```

**é¢„æµ‹**ï¼š

```rust
ResourcePrediction {
    resource: "Memory",
    current_value: 75.0,
    predicted_value: 90.0,  // 2å°æ—¶å
    time_ahead_seconds: 7200,
    confidence: 0.95,
}
```

**ä¼˜åŒ–å»ºè®®**ï¼š

```text
ğŸ”´ ä¸¥é‡æ€§ï¼šCritical
ğŸ“Š å½“å‰å€¼ï¼š75%
âš ï¸  é—®é¢˜ï¼šå†…å­˜ä½¿ç”¨ç‡æŒç»­å¢é•¿ï¼Œé¢„è®¡2å°æ—¶åè¾¾åˆ°90%
ğŸ’¡ å»ºè®®ï¼š
  1. ç«‹å³æ£€æŸ¥å†…å­˜æ³„æ¼ï¼ˆä½¿ç”¨ heaptrack æˆ– valgrindï¼‰
  2. åˆ†æè¿›ç¨‹å†…å­˜å ç”¨ï¼ˆps aux --sort=-%memï¼‰
  3. æ£€æŸ¥æ˜¯å¦æœ‰æœªé‡Šæ”¾çš„èµ„æº
  4. è€ƒè™‘é‡å¯æœåŠ¡é‡Šæ”¾å†…å­˜
  5. å‡†å¤‡æ‰©å®¹è®¡åˆ’
```

**å®é™…å¤„ç†**ï¼š

1. ä½¿ç”¨ `heaptrack` å‘ç° Span ç¼“å­˜æœªæ­£ç¡®æ¸…ç†
2. ä¿®å¤ä»£ç ï¼Œæ·»åŠ å®šæœŸæ¸…ç†é€»è¾‘
3. é‡å¯æœåŠ¡ï¼Œå†…å­˜ä½¿ç”¨ç‡é™è‡³ 40%
4. æŒç»­ç›‘æ§ï¼Œç¡®è®¤é—®é¢˜è§£å†³

### æ¡ˆä¾‹2ï¼šCPU çªå¢åˆ†æ

**åœºæ™¯**ï¼šCPU ä½¿ç”¨ç‡çªç„¶ä» 30% è·³å‡åˆ° 85%

**ç›‘æ§æ•°æ®**ï¼š

```text
14:55    30%    æ­£å¸¸
14:56    32%    æ­£å¸¸
14:57    85%    âš ï¸ çªå¢
14:58    87%    æŒç»­é«˜ä½
14:59    86%    æŒç»­é«˜ä½
```

**å˜åŒ–ç‚¹æ£€æµ‹ç»“æœ**ï¼š

```rust
ChangePoint {
    index: 157,  // 14:57
    direction: ChangeDirection::Increase,
    magnitude: 4.2,  // æ˜¾è‘—å˜åŒ–
}
```

**ä¼˜åŒ–å»ºè®®**ï¼š

```text
ğŸ”´ ä¸¥é‡æ€§ï¼šCritical
ğŸ“Š å½“å‰å€¼ï¼š85%
âš ï¸  é—®é¢˜ï¼šCPU ä½¿ç”¨ç‡çªå¢ï¼Œä» 30% è·³è‡³ 85%
ğŸ’¡ å»ºè®®ï¼š
  1. æ£€æŸ¥æœ€è¿‘çš„ä»£ç éƒ¨ç½²æˆ–é…ç½®å˜æ›´
  2. æŸ¥çœ‹è¿›ç¨‹ CPU å ç”¨ï¼ˆtop -cï¼‰
  3. æ£€æŸ¥æ˜¯å¦æœ‰æ­»å¾ªç¯æˆ–æ— é™é€’å½’
  4. æŸ¥çœ‹ç³»ç»Ÿæ—¥å¿—
  5. è€ƒè™‘å›æ»šæœ€è¿‘çš„å˜æ›´
```

**æ ¹å› åˆ†æ**ï¼š

- 14:57 éƒ¨ç½²äº†æ–°ç‰ˆæœ¬
- æ–°ç‰ˆæœ¬å¼•å…¥äº†ä½æ•ˆçš„å¾ªç¯é€»è¾‘
- æ¯ä¸ªè¯·æ±‚è§¦å‘ O(nÂ²) å¤æ‚åº¦çš„æ“ä½œ

**è§£å†³æ–¹æ¡ˆ**ï¼š

1. ç«‹å³å›æ»šåˆ°ä¸Šä¸€ä¸ªç‰ˆæœ¬
2. CPU ä½¿ç”¨ç‡æ¢å¤åˆ° 32%
3. ä¿®å¤ä»£ç ï¼Œä¼˜åŒ–ä¸º O(n) å¤æ‚åº¦
4. é‡æ–°éƒ¨ç½²å¹¶éªŒè¯

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [å®¹é‡é¢„æµ‹æ¨¡å‹](./å®¹é‡é¢„æµ‹æ¨¡å‹.md)
- [æ‰©å®¹å†³ç­–](./æ‰©å®¹å†³ç­–.md)
- [æ€§èƒ½å›å½’æ£€æµ‹](../æ€§èƒ½è°ƒä¼˜/æ€§èƒ½å›å½’æ£€æµ‹.md)
