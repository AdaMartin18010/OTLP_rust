# OTLP 诊断工具集

## 目录

- [OTLP 诊断工具集](#otlp-诊断工具集)
  - [目录](#目录)
  - [概述](#概述)
  - [系统级诊断工具](#系统级诊断工具)
    - [性能分析工具](#性能分析工具)
    - [网络诊断工具](#网络诊断工具)
    - [资源监控工具](#资源监控工具)
  - [OTLP 专用工具](#otlp-专用工具)
    - [Trace 分析工具](#trace-分析工具)
    - [配置验证工具](#配置验证工具)
    - [健康检查工具](#健康检查工具)
  - [自动化诊断脚本](#自动化诊断脚本)
    - [快速健康检查脚本](#快速健康检查脚本)
    - [性能分析脚本](#性能分析脚本)
    - [日志分析脚本](#日志分析脚本)
  - [监控集成](#监控集成)
    - [Prometheus 集成](#prometheus-集成)
    - [Grafana 仪表板](#grafana-仪表板)
  - [故障注入工具](#故障注入工具)
    - [混沌工程工具](#混沌工程工具)
  - [参考资源](#参考资源)

## 概述

本文档汇总了 OTLP 系统诊断和故障排查所需的各类工具，包括系统级工具、OTLP 专用工具和自动化脚本。

**工具分类**：

- **系统级工具**：通用的系统诊断工具
- **OTLP 专用工具**：针对 OTLP 的特定工具
- **自动化脚本**：快速诊断和问题定位脚本
- **监控集成**：与监控系统的集成
- **故障注入工具**：用于测试系统韧性

## 系统级诊断工具

### 性能分析工具

**1. perf - Linux 性能分析器**:

```bash
# 安装
sudo apt-get install linux-tools-common linux-tools-generic

# 记录性能数据
perf record -F 99 -p $(pgrep otlp) -g -- sleep 30

# 查看报告
perf report

# 生成火焰图
perf script | stackcollapse-perf.pl | flamegraph.pl > flamegraph.svg
```

**2. strace - 系统调用追踪**:

```bash
# 追踪系统调用
strace -p $(pgrep otlp) -f -e trace=network

# 统计系统调用
strace -c -p $(pgrep otlp)

# 追踪文件操作
strace -e trace=open,read,write -p $(pgrep otlp)
```

**3. ltrace - 库函数调用追踪**:

```bash
# 追踪库函数调用
ltrace -p $(pgrep otlp)

# 统计调用次数
ltrace -c -p $(pgrep otlp)
```

**4. valgrind - 内存分析**:

```bash
# 内存泄漏检测
valgrind --leak-check=full --show-leak-kinds=all ./otlp-collector

# 性能分析
valgrind --tool=callgrind ./otlp-collector
kcachegrind callgrind.out.*
```

### 网络诊断工具

**1. tcpdump - 网络抓包**:

```bash
# 抓取 OTLP gRPC 流量
tcpdump -i any port 4317 -w otlp-grpc.pcap

# 抓取 OTLP HTTP 流量
tcpdump -i any port 4318 -w otlp-http.pcap

# 实时查看
tcpdump -i any port 4317 -A
```

**2. wireshark - 网络协议分析**:

```bash
# 启动 wireshark
wireshark otlp-grpc.pcap

# 过滤 gRPC 流量
# 过滤器: tcp.port == 4317 && http2
```

**3. netstat / ss - 网络连接状态**:

```bash
# 查看监听端口
netstat -tlnp | grep otlp
ss -tlnp | grep otlp

# 查看连接数
ss -s

# 查看连接详情
ss -antp | grep otlp
```

**4. iperf - 网络带宽测试**:

```bash
# 服务端
iperf -s

# 客户端
iperf -c <server-ip> -t 60 -i 1
```

### 资源监控工具

**1. top / htop - 进程监控**:

```bash
# 查看进程资源使用
top -p $(pgrep otlp)

# 更友好的界面
htop -p $(pgrep otlp)
```

**2. iostat - I/O 统计**:

```bash
# 查看磁盘 I/O
iostat -x 1

# 查看特定设备
iostat -x /dev/sda 1
```

**3. vmstat - 虚拟内存统计**:

```bash
# 查看系统资源
vmstat 1

# 详细内存信息
vmstat -s
```

**4. sar - 系统活动报告**:

```bash
# CPU 使用率
sar -u 1 10

# 内存使用率
sar -r 1 10

# 网络统计
sar -n DEV 1 10
```

## OTLP 专用工具

### Trace 分析工具

**1. Trace 验证器**:

```rust
use std::collections::{HashMap, HashSet};

/// Trace 验证器
pub struct TraceValidator {
    spans: HashMap<Vec<u8>, Span>,
}

impl TraceValidator {
    pub fn new() -> Self {
        Self {
            spans: HashMap::new(),
        }
    }

    /// 添加 Span
    pub fn add_span(&mut self, span: Span) {
        self.spans.insert(span.span_id.clone(), span);
    }

    /// 验证 Trace
    pub fn validate(&self) -> ValidationResult {
        let mut result = ValidationResult::default();

        // 检查 1: 所有 Span 的 TraceID 一致
        let trace_ids: HashSet<_> = self.spans.values()
            .map(|s| &s.trace_id)
            .collect();
        if trace_ids.len() > 1 {
            result.errors.push("Multiple TraceIDs found".to_string());
        }

        // 检查 2: 父子关系完整
        for span in self.spans.values() {
            if let Some(parent_id) = &span.parent_span_id {
                if !self.spans.contains_key(parent_id) {
                    result.warnings.push(format!(
                        "Missing parent span: {}",
                        hex::encode(parent_id)
                    ));
                }
            }
        }

        // 检查 3: 时间戳合理性
        for span in self.spans.values() {
            if span.end_time_unix_nano < span.start_time_unix_nano {
                result.errors.push(format!(
                    "Invalid timestamps for span: {}",
                    hex::encode(&span.span_id)
                ));
            }

            // 检查父子时间关系
            if let Some(parent_id) = &span.parent_span_id {
                if let Some(parent) = self.spans.get(parent_id) {
                    if span.start_time_unix_nano < parent.start_time_unix_nano {
                        result.warnings.push(format!(
                            "Child span starts before parent: {}",
                            hex::encode(&span.span_id)
                        ));
                    }
                }
            }
        }

        // 检查 4: 循环依赖
        if let Some(cycle) = self.detect_cycle() {
            result.errors.push(format!(
                "Cycle detected: {}",
                cycle.iter()
                    .map(|id| hex::encode(id))
                    .collect::<Vec<_>>()
                    .join(" -> ")
            ));
        }

        result
    }

    /// 检测循环依赖
    fn detect_cycle(&self) -> Option<Vec<Vec<u8>>> {
        let mut visited = HashSet::new();
        let mut rec_stack = HashSet::new();
        let mut path = Vec::new();

        for span_id in self.spans.keys() {
            if !visited.contains(span_id) {
                if let Some(cycle) = self.dfs_cycle(
                    span_id,
                    &mut visited,
                    &mut rec_stack,
                    &mut path,
                ) {
                    return Some(cycle);
                }
            }
        }

        None
    }

    fn dfs_cycle(
        &self,
        span_id: &Vec<u8>,
        visited: &mut HashSet<Vec<u8>>,
        rec_stack: &mut HashSet<Vec<u8>>,
        path: &mut Vec<Vec<u8>>,
    ) -> Option<Vec<Vec<u8>>> {
        visited.insert(span_id.clone());
        rec_stack.insert(span_id.clone());
        path.push(span_id.clone());

        if let Some(span) = self.spans.get(span_id) {
            if let Some(parent_id) = &span.parent_span_id {
                if rec_stack.contains(parent_id) {
                    // 找到循环
                    let cycle_start = path.iter().position(|id| id == parent_id).unwrap();
                    return Some(path[cycle_start..].to_vec());
                }

                if !visited.contains(parent_id) {
                    if let Some(cycle) = self.dfs_cycle(parent_id, visited, rec_stack, path) {
                        return Some(cycle);
                    }
                }
            }
        }

        rec_stack.remove(span_id);
        path.pop();
        None
    }
}

#[derive(Debug, Clone)]
pub struct Span {
    pub trace_id: Vec<u8>,
    pub span_id: Vec<u8>,
    pub parent_span_id: Option<Vec<u8>>,
    pub start_time_unix_nano: u64,
    pub end_time_unix_nano: u64,
}

#[derive(Debug, Default)]
pub struct ValidationResult {
    pub errors: Vec<String>,
    pub warnings: Vec<String>,
}

impl ValidationResult {
    pub fn is_valid(&self) -> bool {
        self.errors.is_empty()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_validate_valid_trace() {
        let mut validator = TraceValidator::new();

        let parent = Span {
            trace_id: vec![1; 16],
            span_id: vec![1; 8],
            parent_span_id: None,
            start_time_unix_nano: 1000,
            end_time_unix_nano: 2000,
        };

        let child = Span {
            trace_id: vec![1; 16],
            span_id: vec![2; 8],
            parent_span_id: Some(vec![1; 8]),
            start_time_unix_nano: 1100,
            end_time_unix_nano: 1900,
        };

        validator.add_span(parent);
        validator.add_span(child);

        let result = validator.validate();
        assert!(result.is_valid());
    }

    #[test]
    fn test_validate_invalid_timestamps() {
        let mut validator = TraceValidator::new();

        let span = Span {
            trace_id: vec![1; 16],
            span_id: vec![1; 8],
            parent_span_id: None,
            start_time_unix_nano: 2000,
            end_time_unix_nano: 1000,  // 结束时间早于开始时间
        };

        validator.add_span(span);

        let result = validator.validate();
        assert!(!result.is_valid());
        assert!(!result.errors.is_empty());
    }
}
```

### 配置验证工具

**配置验证脚本**:

```bash
#!/bin/bash
# validate-config.sh - OTLP 配置验证脚本

CONFIG_FILE="${1:-/etc/otlp/config.yaml}"

echo "验证配置文件: $CONFIG_FILE"

# 检查文件是否存在
if [ ! -f "$CONFIG_FILE" ]; then
    echo "错误: 配置文件不存在"
    exit 1
fi

# 检查 YAML 语法
if ! yamllint "$CONFIG_FILE" 2>/dev/null; then
    echo "错误: YAML 语法错误"
    exit 1
fi

# 检查必需字段
required_fields=("receivers" "processors" "exporters" "service")
for field in "${required_fields[@]}"; do
    if ! grep -q "^$field:" "$CONFIG_FILE"; then
        echo "错误: 缺少必需字段: $field"
        exit 1
    fi
done

# 检查端口冲突
ports=$(grep -oP 'endpoint:.*:(\d+)' "$CONFIG_FILE" | grep -oP '\d+$' | sort | uniq -d)
if [ -n "$ports" ]; then
    echo "警告: 检测到端口冲突: $ports"
fi

# 检查文件路径
paths=$(grep -oP '(directory|path):.*' "$CONFIG_FILE" | awk '{print $2}')
for path in $paths; do
    if [ ! -e "$path" ]; then
        echo "警告: 路径不存在: $path"
    fi
done

echo "配置验证完成"
```

### 健康检查工具

**健康检查脚本**:

```bash
#!/bin/bash
# health-check.sh - OTLP 健康检查脚本

GRPC_ENDPOINT="${1:-localhost:4317}"
HTTP_ENDPOINT="${2:-localhost:4318}"

echo "=== OTLP 健康检查 ==="
echo

# 检查进程
echo "1. 检查进程状态"
if pgrep -x otlp-collector > /dev/null; then
    echo "   ✓ 进程运行中"
    PID=$(pgrep -x otlp-collector)
    echo "   PID: $PID"
else
    echo "   ✗ 进程未运行"
    exit 1
fi

# 检查端口
echo
echo "2. 检查端口监听"
if netstat -tlnp 2>/dev/null | grep -q ":4317"; then
    echo "   ✓ gRPC 端口 (4317) 监听中"
else
    echo "   ✗ gRPC 端口 (4317) 未监听"
fi

if netstat -tlnp 2>/dev/null | grep -q ":4318"; then
    echo "   ✓ HTTP 端口 (4318) 监听中"
else
    echo "   ✗ HTTP 端口 (4318) 未监听"
fi

# 检查资源使用
echo
echo "3. 检查资源使用"
CPU=$(ps -p $PID -o %cpu --no-headers | tr -d ' ')
MEM=$(ps -p $PID -o %mem --no-headers | tr -d ' ')
echo "   CPU: ${CPU}%"
echo "   内存: ${MEM}%"

# 检查文件描述符
FD_COUNT=$(lsof -p $PID 2>/dev/null | wc -l)
FD_LIMIT=$(cat /proc/$PID/limits | grep "open files" | awk '{print $4}')
echo "   文件描述符: $FD_COUNT / $FD_LIMIT"

# 检查健康端点
echo
echo "4. 检查健康端点"
if curl -s -f "http://${HTTP_ENDPOINT}/health" > /dev/null 2>&1; then
    echo "   ✓ 健康检查通过"
else
    echo "   ✗ 健康检查失败"
fi

# 检查指标端点
echo
echo "5. 检查指标端点"
if curl -s "http://localhost:8888/metrics" | grep -q "otlp"; then
    echo "   ✓ 指标端点正常"
    
    # 显示关键指标
    echo
    echo "   关键指标:"
    curl -s "http://localhost:8888/metrics" | grep -E "(otlp_receiver_accepted|otlp_receiver_refused|otlp_exporter_sent)" | head -5
else
    echo "   ✗ 指标端点异常"
fi

echo
echo "=== 健康检查完成 ==="
```

## 自动化诊断脚本

### 快速健康检查脚本

见上文 [健康检查工具](#健康检查工具)。

### 性能分析脚本

```bash
#!/bin/bash
# performance-analysis.sh - OTLP 性能分析脚本

DURATION="${1:-60}"  # 分析时长（秒）
OUTPUT_DIR="${2:-./perf-analysis}"

mkdir -p "$OUTPUT_DIR"

echo "开始性能分析 (时长: ${DURATION}秒)"
echo "输出目录: $OUTPUT_DIR"

PID=$(pgrep -x otlp-collector)
if [ -z "$PID" ]; then
    echo "错误: 找不到 otlp-collector 进程"
    exit 1
fi

# 1. CPU 性能分析
echo "1. 收集 CPU 性能数据..."
perf record -F 99 -p $PID -g -o "$OUTPUT_DIR/perf.data" -- sleep $DURATION

# 生成报告
perf report -i "$OUTPUT_DIR/perf.data" > "$OUTPUT_DIR/perf-report.txt"

# 生成火焰图
if command -v stackcollapse-perf.pl > /dev/null; then
    perf script -i "$OUTPUT_DIR/perf.data" | \
        stackcollapse-perf.pl | \
        flamegraph.pl > "$OUTPUT_DIR/flamegraph.svg"
    echo "   火焰图: $OUTPUT_DIR/flamegraph.svg"
fi

# 2. 内存分析
echo "2. 收集内存使用数据..."
for i in $(seq 1 $DURATION); do
    ps -p $PID -o rss,vsz,pmem --no-headers >> "$OUTPUT_DIR/memory.log"
    sleep 1
done

# 3. I/O 分析
echo "3. 收集 I/O 数据..."
pidstat -d -p $PID 1 $DURATION > "$OUTPUT_DIR/io.log"

# 4. 网络分析
echo "4. 收集网络数据..."
ss -antp | grep $PID > "$OUTPUT_DIR/network-before.log"
sleep $DURATION
ss -antp | grep $PID > "$OUTPUT_DIR/network-after.log"

# 5. 系统调用分析
echo "5. 收集系统调用数据..."
strace -c -p $PID -o "$OUTPUT_DIR/syscalls.log" sleep $DURATION 2>&1

echo
echo "性能分析完成!"
echo "结果保存在: $OUTPUT_DIR"
```

### 日志分析脚本

```bash
#!/bin/bash
# log-analysis.sh - OTLP 日志分析脚本

LOG_FILE="${1:-/var/log/otlp/collector.log}"
TIME_RANGE="${2:-1h}"  # 分析时间范围

echo "=== OTLP 日志分析 ==="
echo "日志文件: $LOG_FILE"
echo "时间范围: $TIME_RANGE"
echo

# 1. 错误统计
echo "1. 错误统计"
echo "   错误总数:"
journalctl -u otlp-collector --since "$TIME_RANGE ago" | grep -c "ERROR"

echo "   错误类型分布:"
journalctl -u otlp-collector --since "$TIME_RANGE ago" | \
    grep "ERROR" | \
    awk '{print $NF}' | \
    sort | uniq -c | sort -rn | head -10

# 2. 警告统计
echo
echo "2. 警告统计"
echo "   警告总数:"
journalctl -u otlp-collector --since "$TIME_RANGE ago" | grep -c "WARN"

# 3. 性能指标
echo
echo "3. 性能指标"
echo "   平均延迟:"
journalctl -u otlp-collector --since "$TIME_RANGE ago" | \
    grep -oP 'latency=\K[0-9.]+' | \
    awk '{sum+=$1; count++} END {if(count>0) print sum/count "ms"}'

# 4. 请求统计
echo
echo "4. 请求统计"
echo "   总请求数:"
journalctl -u otlp-collector --since "$TIME_RANGE ago" | grep -c "request"

echo "   成功请求:"
journalctl -u otlp-collector --since "$TIME_RANGE ago" | grep -c "status=200"

echo "   失败请求:"
journalctl -u otlp-collector --since "$TIME_RANGE ago" | grep -c "status=5"

# 5. 热点分析
echo
echo "5. 热点分析 (最频繁的日志)"
journalctl -u otlp-collector --since "$TIME_RANGE ago" | \
    awk '{$1=$2=$3=""; print $0}' | \
    sort | uniq -c | sort -rn | head -10

echo
echo "=== 分析完成 ==="
```

## 监控集成

### Prometheus 集成

**Prometheus 配置**:

```yaml
# prometheus.yml
scrape_configs:
  - job_name: 'otlp-collector'
    static_configs:
      - targets: ['localhost:8888']
    scrape_interval: 15s
    scrape_timeout: 10s
```

**告警规则**:

```yaml
# otlp-alerts.yml
groups:
  - name: otlp_alerts
    interval: 30s
    rules:
      # 高丢弃率告警
      - alert: HighSpanDropRate
        expr: rate(otlp_receiver_dropped_spans_total[5m]) > 10
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High span drop rate"
          description: "Span drop rate is {{ $value }} spans/sec"

      # 高错误率告警
      - alert: HighErrorRate
        expr: rate(otlp_exporter_send_failed_spans_total[5m]) > 5
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "High export error rate"
          description: "Export error rate is {{ $value }} errors/sec"

      # 队列满告警
      - alert: QueueFull
        expr: otlp_exporter_queue_size / otlp_exporter_queue_capacity > 0.9
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "Export queue nearly full"
          description: "Queue utilization is {{ $value | humanizePercentage }}"

      # 高延迟告警
      - alert: HighLatency
        expr: histogram_quantile(0.99, rate(otlp_receiver_request_duration_seconds_bucket[5m])) > 1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High request latency"
          description: "P99 latency is {{ $value }}s"
```

### Grafana 仪表板

**仪表板 JSON 片段**:

```json
{
  "dashboard": {
    "title": "OTLP Collector Monitoring",
    "panels": [
      {
        "title": "Request Rate",
        "targets": [
          {
            "expr": "rate(otlp_receiver_accepted_spans_total[5m])",
            "legendFormat": "Accepted"
          },
          {
            "expr": "rate(otlp_receiver_refused_spans_total[5m])",
            "legendFormat": "Refused"
          }
        ]
      },
      {
        "title": "Export Success Rate",
        "targets": [
          {
            "expr": "rate(otlp_exporter_sent_spans_total[5m]) / (rate(otlp_exporter_sent_spans_total[5m]) + rate(otlp_exporter_send_failed_spans_total[5m]))",
            "legendFormat": "Success Rate"
          }
        ]
      },
      {
        "title": "Queue Size",
        "targets": [
          {
            "expr": "otlp_exporter_queue_size",
            "legendFormat": "Current Size"
          },
          {
            "expr": "otlp_exporter_queue_capacity",
            "legendFormat": "Capacity"
          }
        ]
      }
    ]
  }
}
```

## 故障注入工具

### 混沌工程工具

**网络延迟注入**:

```bash
#!/bin/bash
# inject-latency.sh - 注入网络延迟

INTERFACE="${1:-eth0}"
DELAY="${2:-100ms}"
JITTER="${3:-10ms}"

echo "在接口 $INTERFACE 上注入延迟: $DELAY ± $JITTER"

# 添加延迟
tc qdisc add dev $INTERFACE root netem delay $DELAY $JITTER

echo "延迟已注入"
echo "恢复命令: tc qdisc del dev $INTERFACE root"
```

**网络丢包注入**:

```bash
#!/bin/bash
# inject-packet-loss.sh - 注入网络丢包

INTERFACE="${1:-eth0}"
LOSS_RATE="${2:-5%}"

echo "在接口 $INTERFACE 上注入丢包率: $LOSS_RATE"

# 添加丢包
tc qdisc add dev $INTERFACE root netem loss $LOSS_RATE

echo "丢包已注入"
echo "恢复命令: tc qdisc del dev $INTERFACE root"
```

**CPU 压力测试**:

```bash
#!/bin/bash
# cpu-stress.sh - CPU 压力测试

CORES="${1:-2}"
DURATION="${2:-60}"

echo "启动 CPU 压力测试"
echo "核心数: $CORES"
echo "时长: ${DURATION}秒"

stress-ng --cpu $CORES --timeout ${DURATION}s --metrics-brief
```

## 参考资源

**官方文档**：

- OpenTelemetry Collector: <https://opentelemetry.io/docs/collector/>
- OTLP Specification: <https://opentelemetry.io/docs/specs/otlp/>

**工具文档**：

- perf: <https://perf.wiki.kernel.org/>
- Brendan Gregg's Tools: <https://www.brendangregg.com/linuxperf.html>
- Prometheus: <https://prometheus.io/docs/>
- Grafana: <https://grafana.com/docs/>

**书籍**：

- "Systems Performance" by Brendan Gregg
- "BPF Performance Tools" by Brendan Gregg

---

*本工具集持续更新，欢迎贡献新的工具和脚本。*
