# OTLP è¿ç»´å®æˆ˜æ¡ˆä¾‹åº“

## ç›®å½•

- [OTLP è¿ç»´å®æˆ˜æ¡ˆä¾‹åº“](#otlp-è¿ç»´å®æˆ˜æ¡ˆä¾‹åº“)
  - [ç›®å½•](#ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
  - [ğŸ“Š æ¡ˆä¾‹åˆ†ç±»ä½“ç³»](#-æ¡ˆä¾‹åˆ†ç±»ä½“ç³»)
  - [ğŸ”¥ æ€§èƒ½ä¼˜åŒ–æ¡ˆä¾‹](#-æ€§èƒ½ä¼˜åŒ–æ¡ˆä¾‹)
    - [æ¡ˆä¾‹1ï¼šé«˜å»¶è¿Ÿé—®é¢˜æ’æŸ¥ä¸ä¼˜åŒ–](#æ¡ˆä¾‹1é«˜å»¶è¿Ÿé—®é¢˜æ’æŸ¥ä¸ä¼˜åŒ–)
      - [ğŸ“‹ æ¡ˆä¾‹èƒŒæ™¯](#-æ¡ˆä¾‹èƒŒæ™¯)
      - [ğŸ” é—®é¢˜ç°è±¡](#-é—®é¢˜ç°è±¡)
      - [ğŸ“Š åˆ†æè¿‡ç¨‹](#-åˆ†æè¿‡ç¨‹)
      - [ğŸ’¡ æ ¹å› å®šä½](#-æ ¹å› å®šä½)
      - [âœ… è§£å†³æ–¹æ¡ˆ](#-è§£å†³æ–¹æ¡ˆ)
      - [ğŸ“ˆ ä¼˜åŒ–æ•ˆæœ](#-ä¼˜åŒ–æ•ˆæœ)
      - [ğŸ“ ç»éªŒæ•™è®­](#-ç»éªŒæ•™è®­)
    - [æ¡ˆä¾‹2ï¼šå†…å­˜æ³„æ¼æ£€æµ‹ä¸ä¿®å¤](#æ¡ˆä¾‹2å†…å­˜æ³„æ¼æ£€æµ‹ä¸ä¿®å¤)
      - [ğŸ“‹ æ¡ˆä¾‹èƒŒæ™¯2](#-æ¡ˆä¾‹èƒŒæ™¯2)
      - [ğŸ” é—®é¢˜ç°è±¡2](#-é—®é¢˜ç°è±¡2)
      - [ğŸ“Š åˆ†æè¿‡ç¨‹2](#-åˆ†æè¿‡ç¨‹2)
      - [ğŸ’¡ æ ¹å› å®šä½2](#-æ ¹å› å®šä½2)
      - [âœ… è§£å†³æ–¹æ¡ˆ2](#-è§£å†³æ–¹æ¡ˆ2)
      - [ğŸ“ˆ ä¼˜åŒ–æ•ˆæœ2](#-ä¼˜åŒ–æ•ˆæœ2)
      - [ğŸ“ ç»éªŒæ•™è®­2](#-ç»éªŒæ•™è®­2)
    - [æ¡ˆä¾‹3ï¼šCPUçƒ­ç‚¹ä¼˜åŒ–](#æ¡ˆä¾‹3cpuçƒ­ç‚¹ä¼˜åŒ–)
      - [ğŸ“‹ æ¡ˆä¾‹èƒŒæ™¯3](#-æ¡ˆä¾‹èƒŒæ™¯3)
      - [ğŸ” é—®é¢˜ç°è±¡3](#-é—®é¢˜ç°è±¡3)
      - [ğŸ“Š åˆ†æè¿‡ç¨‹3](#-åˆ†æè¿‡ç¨‹3)
      - [ğŸ’¡ æ ¹å› å®šä½3](#-æ ¹å› å®šä½3)
      - [âœ… è§£å†³æ–¹æ¡ˆ3](#-è§£å†³æ–¹æ¡ˆ3)
      - [ğŸ“ˆ ä¼˜åŒ–æ•ˆæœ3](#-ä¼˜åŒ–æ•ˆæœ3)
      - [ğŸ“ ç»éªŒæ•™è®­3](#-ç»éªŒæ•™è®­3)
  - [ğŸ’° æˆæœ¬ä¼˜åŒ–æ¡ˆä¾‹](#-æˆæœ¬ä¼˜åŒ–æ¡ˆä¾‹)
    - [æ¡ˆä¾‹4ï¼šæ™ºèƒ½é‡‡æ ·é™ä½80%æˆæœ¬](#æ¡ˆä¾‹4æ™ºèƒ½é‡‡æ ·é™ä½80æˆæœ¬)
      - [ğŸ“‹ æ¡ˆä¾‹èƒŒæ™¯4](#-æ¡ˆä¾‹èƒŒæ™¯4)
      - [ğŸ” å½“å‰çŠ¶å†µ4](#-å½“å‰çŠ¶å†µ4)
      - [ğŸ“Š æˆæœ¬åˆ†æ4](#-æˆæœ¬åˆ†æ4)
      - [ğŸ’¡ ä¼˜åŒ–ç­–ç•¥4](#-ä¼˜åŒ–ç­–ç•¥4)
      - [ğŸ“ˆ ä¼˜åŒ–æ•ˆæœ4](#-ä¼˜åŒ–æ•ˆæœ4)
      - [ğŸ“ ç»éªŒæ•™è®­4](#-ç»éªŒæ•™è®­4)
    - [æ¡ˆä¾‹5ï¼šå­˜å‚¨åˆ†å±‚èŠ‚çœ93%å­˜å‚¨æˆæœ¬](#æ¡ˆä¾‹5å­˜å‚¨åˆ†å±‚èŠ‚çœ93å­˜å‚¨æˆæœ¬)
      - [ğŸ“‹ æ¡ˆä¾‹èƒŒæ™¯5](#-æ¡ˆä¾‹èƒŒæ™¯5)
      - [ğŸ’¡ è§£å†³æ–¹æ¡ˆ5](#-è§£å†³æ–¹æ¡ˆ5)
      - [ğŸ“ˆ ä¼˜åŒ–æ•ˆæœ5](#-ä¼˜åŒ–æ•ˆæœ5)
    - [æ¡ˆä¾‹6ï¼šæ‰¹å¤„ç†ä¼˜åŒ–æå‡ååé‡](#æ¡ˆä¾‹6æ‰¹å¤„ç†ä¼˜åŒ–æå‡ååé‡)
      - [ğŸ“‹ æ¡ˆä¾‹èƒŒæ™¯6](#-æ¡ˆä¾‹èƒŒæ™¯6)
      - [ğŸ’¡ ä¼˜åŒ–æ–¹æ¡ˆ6](#-ä¼˜åŒ–æ–¹æ¡ˆ6)
      - [ğŸ“ˆ ä¼˜åŒ–æ•ˆæœ6](#-ä¼˜åŒ–æ•ˆæœ6)
  - [ğŸš¨ æ•…éšœæ’æŸ¥æ¡ˆä¾‹](#-æ•…éšœæ’æŸ¥æ¡ˆä¾‹)
    - [æ¡ˆä¾‹7ï¼šæœåŠ¡é›ªå´©äº‹æ•…å¤„ç†](#æ¡ˆä¾‹7æœåŠ¡é›ªå´©äº‹æ•…å¤„ç†)
      - [ğŸ“‹ æ¡ˆä¾‹èƒŒæ™¯7](#-æ¡ˆä¾‹èƒŒæ™¯7)
      - [ğŸ”¥ äº‹æ•…æ—¶é—´çº¿7](#-äº‹æ•…æ—¶é—´çº¿7)
      - [ğŸ” æ ¹å› åˆ†æ](#-æ ¹å› åˆ†æ)
      - [âœ… æ”¹è¿›æªæ–½](#-æ”¹è¿›æªæ–½)
      - [ğŸ“ˆ æ”¹è¿›æ•ˆæœ](#-æ”¹è¿›æ•ˆæœ)
  - [ğŸ¯ æœ€ä½³å®è·µæ€»ç»“](#-æœ€ä½³å®è·µæ€»ç»“)
    - [é€šç”¨åŸåˆ™](#é€šç”¨åŸåˆ™)
    - [å·¥å…·ç®±](#å·¥å…·ç®±)
    - [æ£€æŸ¥æ¸…å•](#æ£€æŸ¥æ¸…å•)

## æ¦‚è¿°

æœ¬æ¡ˆä¾‹åº“æ”¶é›†äº†çœŸå®ç”Ÿäº§ç¯å¢ƒä¸­çš„ OTLP è¿ç»´æ¡ˆä¾‹ï¼Œæ¶µç›–æ€§èƒ½ä¼˜åŒ–ã€æˆæœ¬æ§åˆ¶ã€æ•…éšœæ’æŸ¥ã€æ‰©å®¹å†³ç­–ã€ç›‘æ§å‘Šè­¦ç­‰å„ä¸ªæ–¹é¢ã€‚æ¯ä¸ªæ¡ˆä¾‹éƒ½åŒ…å«é—®é¢˜èƒŒæ™¯ã€åˆ†æè¿‡ç¨‹ã€è§£å†³æ–¹æ¡ˆå’Œæ•ˆæœè¯„ä¼°ã€‚

## ğŸ“Š æ¡ˆä¾‹åˆ†ç±»ä½“ç³»

```mermaid
mindmap
  root((OTLPå®æˆ˜æ¡ˆä¾‹åº“))
    æ€§èƒ½ä¼˜åŒ–
      å»¶è¿Ÿä¼˜åŒ–
      ååé‡æå‡
      èµ„æºåˆ©ç”¨ç‡
    æˆæœ¬ä¼˜åŒ–
      é‡‡æ ·ç­–ç•¥
      å­˜å‚¨åˆ†å±‚
      èµ„æºå³é…
    æ•…éšœæ’æŸ¥
      æœåŠ¡æ•…éšœ
      æ•°æ®é—®é¢˜
      ç½‘ç»œé—®é¢˜
    æ‰©å®¹å†³ç­–
      è‡ªåŠ¨æ‰©å®¹
      é¢„æµ‹æ‰©å®¹
      æ™ºèƒ½ç¼©å®¹
    ç›‘æ§å‘Šè­¦
      SLOç®¡ç†
      å‘Šè­¦ä¼˜åŒ–
      æ ¹å› åˆ†æ
```

---

## ğŸ”¥ æ€§èƒ½ä¼˜åŒ–æ¡ˆä¾‹

### æ¡ˆä¾‹1ï¼šé«˜å»¶è¿Ÿé—®é¢˜æ’æŸ¥ä¸ä¼˜åŒ–

#### ğŸ“‹ æ¡ˆä¾‹èƒŒæ™¯

**å…¬å¸**ï¼šæŸç”µå•†å¹³å°  
**é—®é¢˜**ï¼šOTLP Collector P99 å»¶è¿Ÿä» 50ms é£™å‡è‡³ 500ms  
**å½±å“**ï¼šå½±å“ 10+ å¾®æœåŠ¡çš„è¿½è¸ªæ•°æ®ä¸ŠæŠ¥  
**æ—¶é—´**ï¼š2024å¹´11æœˆ

#### ğŸ” é—®é¢˜ç°è±¡

```bash
# Prometheus æŸ¥è¯¢æ˜¾ç¤ºå»¶è¿Ÿæ¿€å¢
otlp_request_duration_seconds{quantile="0.99"} > 0.5

# é”™è¯¯ç‡ä¹Ÿåœ¨ä¸Šå‡
rate(otlp_errors_total[5m]) > 100
```

#### ğŸ“Š åˆ†æè¿‡ç¨‹

**1. å»¶è¿Ÿåˆ†è§£åˆ†æ**:

```rust
// ä½¿ç”¨å»¶è¿Ÿåˆ†è§£å·¥å…·
use otlp_tools::LatencyBreakdown;

let breakdown = LatencyBreakdown::analyze(&trace_id);
println!("{:#?}", breakdown);

// è¾“å‡ºï¼š
// LatencyBreakdown {
//     total: 520ms,
//     network: 10ms,
//     queue_wait: 380ms,  // âš ï¸ ç“¶é¢ˆï¼
//     processing: 100ms,
//     serialization: 20ms,
//     export: 10ms,
// }
```

**2. é˜Ÿåˆ—æ·±åº¦ç›‘æ§**:

```bash
# æŸ¥çœ‹é˜Ÿåˆ—ç§¯å‹
curl http://localhost:8888/metrics | grep queue_size
otlp_queue_size{type="spans"} 50000  # âš ï¸ é˜Ÿåˆ—å·²æ»¡ï¼
```

**3. CPU Profiling**:

```bash
# ä½¿ç”¨ perf åˆ†æ CPU çƒ­ç‚¹
perf record -F 99 -p $(pgrep otlp-collector) -g -- sleep 60
perf report --stdio

# å‘ç°ï¼š
# 45% - protobuf åºåˆ—åŒ–
# 30% - æ‰¹å¤„ç†é€»è¾‘
# 15% - ç½‘ç»œ I/O
```

#### ğŸ’¡ æ ¹å› å®šä½

1. **é˜Ÿåˆ—å®¹é‡ä¸è¶³**ï¼šé»˜è®¤é˜Ÿåˆ—å¤§å° 10,000ï¼Œé«˜å³°æœŸè¯·æ±‚é‡è¾¾åˆ° 50,000/s
2. **æ‰¹å¤„ç†æ•ˆç‡ä½**ï¼šæ¯æ‰¹åªå¤„ç† 100 ä¸ª Spanï¼Œæ‰¹æ¬¡è¿‡å°
3. **åºåˆ—åŒ–å¼€é”€å¤§**ï¼šä½¿ç”¨äº†éä¼˜åŒ–çš„ protobuf åºåˆ—åŒ–

#### âœ… è§£å†³æ–¹æ¡ˆ

**æ–¹æ¡ˆ1ï¼šæ‰©å¤§é˜Ÿåˆ—å®¹é‡**:

```yaml
# otel-collector-config.yaml
processors:
  batch:
    timeout: 1s
    send_batch_size: 5000  # ä» 100 å¢åŠ åˆ° 5000
    send_batch_max_size: 10000
  
  queued_retry:
    num_workers: 16
    queue_size: 100000  # ä» 10000 å¢åŠ åˆ° 100000
    retry_on_failure:
      enabled: true
      initial_interval: 5s
      max_interval: 30s
```

**æ–¹æ¡ˆ2ï¼šä¼˜åŒ–æ‰¹å¤„ç†**:

```rust
// ä½¿ç”¨æ›´é«˜æ•ˆçš„æ‰¹å¤„ç†å™¨
pub struct OptimizedBatcher {
    batch_size: usize,
    timeout: Duration,
    buffer: Vec<Span>,
}

impl OptimizedBatcher {
    pub fn new(batch_size: usize, timeout: Duration) -> Self {
        Self {
            batch_size,
            timeout,
            buffer: Vec::with_capacity(batch_size),
        }
    }
    
    pub async fn add_span(&mut self, span: Span) -> Option<Vec<Span>> {
        self.buffer.push(span);
        
        if self.buffer.len() >= self.batch_size {
            Some(std::mem::replace(
                &mut self.buffer,
                Vec::with_capacity(self.batch_size)
            ))
        } else {
            None
        }
    }
}
```

**æ–¹æ¡ˆ3ï¼šå¯ç”¨é›¶æ‹·è´åºåˆ—åŒ–**:

```rust
// ä½¿ç”¨ prost çš„é›¶æ‹·è´ç‰¹æ€§
use prost::Message;
use bytes::BytesMut;

pub fn serialize_zero_copy(spans: &[Span]) -> BytesMut {
    let mut buf = BytesMut::with_capacity(spans.encoded_len());
    spans.encode(&mut buf).unwrap();
    buf
}
```

#### ğŸ“ˆ ä¼˜åŒ–æ•ˆæœ

| æŒ‡æ ‡ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æ”¹å–„ |
|------|--------|--------|------|
| **P99 å»¶è¿Ÿ** | 500ms | 45ms | **-91%** â¬‡ï¸ |
| **P50 å»¶è¿Ÿ** | 80ms | 15ms | **-81%** â¬‡ï¸ |
| **ååé‡** | 10,000/s | 50,000/s | **+400%** â¬†ï¸ |
| **CPU ä½¿ç”¨ç‡** | 85% | 45% | **-47%** â¬‡ï¸ |
| **é”™è¯¯ç‡** | 5% | 0.1% | **-98%** â¬‡ï¸ |

#### ğŸ“ ç»éªŒæ•™è®­

1. **é˜Ÿåˆ—å®¹é‡è¦é¢„ç•™å……è¶³**ï¼šè‡³å°‘æ˜¯å³°å€¼æµé‡çš„ 2-3 å€
2. **æ‰¹å¤„ç†å¤§å°è¦åˆç†**ï¼šå¤ªå°å¯¼è‡´å¼€é”€å¤§ï¼Œå¤ªå¤§å¯¼è‡´å»¶è¿Ÿé«˜
3. **åºåˆ—åŒ–æ€§èƒ½å¾ˆå…³é”®**ï¼šä½¿ç”¨é›¶æ‹·è´å’Œé¢„åˆ†é…å†…å­˜
4. **ç›‘æ§è¦å…¨é¢**ï¼šå»¶è¿Ÿåˆ†è§£ã€é˜Ÿåˆ—æ·±åº¦ã€CPU Profiling

---

### æ¡ˆä¾‹2ï¼šå†…å­˜æ³„æ¼æ£€æµ‹ä¸ä¿®å¤

#### ğŸ“‹ æ¡ˆä¾‹èƒŒæ™¯2

**å…¬å¸**ï¼šæŸé‡‘èç§‘æŠ€å…¬å¸  
**é—®é¢˜**ï¼šOTLP Collector å†…å­˜æŒç»­å¢é•¿ï¼Œ24å°æ—¶å OOM  
**å½±å“**ï¼šæœåŠ¡æ¯å¤©é‡å¯ 1-2 æ¬¡ï¼Œæ•°æ®ä¸¢å¤±  
**æ—¶é—´**ï¼š2024å¹´10æœˆ

#### ğŸ” é—®é¢˜ç°è±¡2

```bash
# å†…å­˜ä½¿ç”¨æŒç»­å¢é•¿
watch -n 1 'ps aux | grep otlp-collector'
# å†…å­˜ä» 500MB å¢é•¿åˆ° 8GBï¼ˆ24å°æ—¶ï¼‰

# Prometheus ç›‘æ§
rate(process_resident_memory_bytes[1h]) > 0  # æŒç»­å¢é•¿
```

#### ğŸ“Š åˆ†æè¿‡ç¨‹2

**1. å†…å­˜ Profiling**:

```bash
# ä½¿ç”¨ Rust çš„ jemalloc profiling
export MALLOC_CONF="prof:true,prof_leak:true,lg_prof_sample:0"
cargo build --release
./target/release/otlp-collector

# ç”Ÿæˆ heap profile
jeprof --show_bytes --pdf otlp-collector jeprof.*.heap > memory_leak.pdf
```

**2. ä»£ç å®¡æŸ¥å‘ç°é—®é¢˜**:

```rust
// âŒ é—®é¢˜ä»£ç ï¼šSpan ç¼“å­˜æ²¡æœ‰æ¸…ç†
pub struct SpanCache {
    cache: HashMap<String, Vec<Span>>,  // æ°¸è¿œä¸æ¸…ç†ï¼
}

impl SpanCache {
    pub fn add(&mut self, trace_id: String, span: Span) {
        self.cache.entry(trace_id)
            .or_insert_with(Vec::new)
            .push(span);
        // âš ï¸ æ²¡æœ‰æ¸…ç†é€»è¾‘ï¼
    }
}
```

**3. å†…å­˜å¢é•¿è¶‹åŠ¿åˆ†æ**:

```rust
use sysinfo::{System, SystemExt};

pub struct MemoryMonitor {
    system: System,
    samples: Vec<(Instant, u64)>,
}

impl MemoryMonitor {
    pub fn analyze_trend(&self) -> MemoryTrend {
        // çº¿æ€§å›å½’åˆ†æ
        let (slope, _) = linear_regression(&self.samples);
        
        if slope > 1_000_000 {  // æ¯ç§’å¢é•¿ > 1MB
            MemoryTrend::Leak
        } else {
            MemoryTrend::Normal
        }
    }
}
```

#### ğŸ’¡ æ ¹å› å®šä½2

1. **Span ç¼“å­˜æ— é™å¢é•¿**ï¼šæ²¡æœ‰ TTL å’Œå®¹é‡é™åˆ¶
2. **Arc å¼•ç”¨å¾ªç¯**ï¼šSpan ä¹‹é—´çš„å¼•ç”¨æ²¡æœ‰æ­£ç¡®é‡Šæ”¾
3. **å¼‚æ­¥ä»»åŠ¡æ³„æ¼**ï¼šæŸäº› tokio ä»»åŠ¡æ²¡æœ‰æ­£ç¡®å–æ¶ˆ

#### âœ… è§£å†³æ–¹æ¡ˆ2

**æ–¹æ¡ˆ1ï¼šæ·»åŠ  LRU ç¼“å­˜**:

```rust
use lru::LruCache;
use std::num::NonZeroUsize;

pub struct SpanCache {
    cache: LruCache<String, Vec<Span>>,
    ttl: Duration,
    last_cleanup: Instant,
}

impl SpanCache {
    pub fn new(capacity: usize, ttl: Duration) -> Self {
        Self {
            cache: LruCache::new(NonZeroUsize::new(capacity).unwrap()),
            ttl,
            last_cleanup: Instant::now(),
        }
    }
    
    pub fn add(&mut self, trace_id: String, span: Span) {
        self.cache.get_or_insert(trace_id, || Vec::new()).push(span);
        
        // å®šæœŸæ¸…ç†è¿‡æœŸæ•°æ®
        if self.last_cleanup.elapsed() > Duration::from_secs(60) {
            self.cleanup_expired();
            self.last_cleanup = Instant::now();
        }
    }
    
    fn cleanup_expired(&mut self) {
        // LRU ä¼šè‡ªåŠ¨æ·˜æ±°æœ€æ—§çš„æ•°æ®
        self.cache.resize(NonZeroUsize::new(self.cache.cap().get()).unwrap());
    }
}
```

**æ–¹æ¡ˆ2ï¼šä½¿ç”¨ Weak å¼•ç”¨æ‰“ç ´å¾ªç¯**:

```rust
use std::sync::{Arc, Weak};

pub struct Span {
    pub span_id: String,
    pub parent: Option<Weak<Span>>,  // ä½¿ç”¨ Weak é¿å…å¾ªç¯å¼•ç”¨
    pub children: Vec<Arc<Span>>,
}
```

**æ–¹æ¡ˆ3ï¼šæ­£ç¡®ç®¡ç†å¼‚æ­¥ä»»åŠ¡**:

```rust
use tokio::task::JoinHandle;

pub struct TaskManager {
    tasks: Vec<JoinHandle<()>>,
}

impl TaskManager {
    pub fn spawn<F>(&mut self, future: F)
    where
        F: Future<Output = ()> + Send + 'static,
    {
        let handle = tokio::spawn(future);
        self.tasks.push(handle);
    }
    
    pub async fn shutdown(&mut self) {
        for task in self.tasks.drain(..) {
            task.abort();  // å–æ¶ˆä»»åŠ¡
            let _ = task.await;
        }
    }
}

impl Drop for TaskManager {
    fn drop(&mut self) {
        // ç¡®ä¿ä»»åŠ¡è¢«å–æ¶ˆ
        for task in &self.tasks {
            task.abort();
        }
    }
}
```

#### ğŸ“ˆ ä¼˜åŒ–æ•ˆæœ2

| æŒ‡æ ‡ | ä¿®å¤å‰ | ä¿®å¤å | æ”¹å–„ |
|------|--------|--------|------|
| **24h å†…å­˜å¢é•¿** | 500MB â†’ 8GB | 500MB â†’ 600MB | **-93%** â¬‡ï¸ |
| **OOM æ¬¡æ•°** | 1-2æ¬¡/å¤© | 0æ¬¡ | **-100%** â¬‡ï¸ |
| **æ•°æ®ä¸¢å¤±ç‡** | 5% | 0% | **-100%** â¬‡ï¸ |
| **æœåŠ¡å¯ç”¨æ€§** | 95% | 99.9% | **+5%** â¬†ï¸ |

#### ğŸ“ ç»éªŒæ•™è®­2

1. **ç¼“å­˜å¿…é¡»æœ‰å®¹é‡é™åˆ¶**ï¼šä½¿ç”¨ LRU æˆ– TTL
2. **æ³¨æ„å¼•ç”¨å¾ªç¯**ï¼šä½¿ç”¨ Weak å¼•ç”¨
3. **å¼‚æ­¥ä»»åŠ¡è¦ç®¡ç†ç”Ÿå‘½å‘¨æœŸ**ï¼šç¡®ä¿æ­£ç¡®å–æ¶ˆ
4. **å®šæœŸè¿›è¡Œå†…å­˜ Profiling**ï¼šåŠæ—©å‘ç°æ³„æ¼

---

### æ¡ˆä¾‹3ï¼šCPUçƒ­ç‚¹ä¼˜åŒ–

#### ğŸ“‹ æ¡ˆä¾‹èƒŒæ™¯3

**å…¬å¸**ï¼šæŸ SaaS å¹³å°  
**é—®é¢˜**ï¼šOTLP Collector CPU ä½¿ç”¨ç‡æŒç»­ 90%+  
**å½±å“**ï¼šå»¶è¿Ÿå¢åŠ ï¼Œååé‡ä¸‹é™  
**æ—¶é—´**ï¼š2024å¹´12æœˆ

#### ğŸ” é—®é¢˜ç°è±¡3

```bash
# CPU ä½¿ç”¨ç‡æŒç»­é«˜ä½
top -p $(pgrep otlp-collector)
# CPU: 95%

# çº¿ç¨‹æ•°å¼‚å¸¸å¤š
ps -eLf | grep otlp-collector | wc -l
# 500+ çº¿ç¨‹
```

#### ğŸ“Š åˆ†æè¿‡ç¨‹3

**1. CPU Profiling**:

```bash
# ä½¿ç”¨ perf åˆ†æ
sudo perf record -F 99 -p $(pgrep otlp-collector) -g -- sleep 60
sudo perf report --stdio > perf_report.txt

# ç«ç„°å›¾ç”Ÿæˆ
git clone https://github.com/brendangregg/FlameGraph
sudo perf script | ./FlameGraph/stackcollapse-perf.pl | ./FlameGraph/flamegraph.pl > flamegraph.svg
```

**å‘ç°çƒ­ç‚¹**ï¼š

- 40% - JSON åºåˆ—åŒ–/ååºåˆ—åŒ–
- 25% - æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…
- 20% - å­—ç¬¦ä¸²æ‹·è´
- 15% - å…¶ä»–

**2. ä»£ç çƒ­ç‚¹åˆ†æ**:

```rust
// âŒ é—®é¢˜ä»£ç ï¼šé¢‘ç¹çš„ JSON åºåˆ—åŒ–
for span in spans {
    let json = serde_json::to_string(&span)?;  // æ¯æ¬¡éƒ½åºåˆ—åŒ–ï¼
    process_json(&json);
}

// âŒ é—®é¢˜ä»£ç ï¼šä½æ•ˆçš„æ­£åˆ™è¡¨è¾¾å¼
for attribute in &span.attributes {
    let re = Regex::new(r"^http_.*").unwrap();  // æ¯æ¬¡éƒ½ç¼–è¯‘ï¼
    if re.is_match(&attribute.key) {
        // ...
    }
}
```

#### ğŸ’¡ æ ¹å› å®šä½3

1. **è¿‡åº¦åºåˆ—åŒ–**ï¼šä¸å¿…è¦çš„ JSON åºåˆ—åŒ–
2. **æ­£åˆ™è¡¨è¾¾å¼æœªç¼“å­˜**ï¼šæ¯æ¬¡éƒ½é‡æ–°ç¼–è¯‘
3. **å­—ç¬¦ä¸²é¢‘ç¹æ‹·è´**ï¼šä½¿ç”¨ `String` è€Œé `&str`
4. **çº¿ç¨‹æ± é…ç½®ä¸å½“**ï¼šçº¿ç¨‹æ•°è¿‡å¤šå¯¼è‡´ä¸Šä¸‹æ–‡åˆ‡æ¢

#### âœ… è§£å†³æ–¹æ¡ˆ3

**æ–¹æ¡ˆ1ï¼šå‡å°‘åºåˆ—åŒ–**:

```rust
// âœ… ä¼˜åŒ–åï¼šç›´æ¥å¤„ç†ç»“æ„ä½“
for span in spans {
    process_span(&span);  // ç›´æ¥å¤„ç†ï¼Œä¸åºåˆ—åŒ–
}

// åªåœ¨å¿…è¦æ—¶åºåˆ—åŒ–
if need_export {
    let json = serde_json::to_string(&span)?;
    export_json(&json);
}
```

**æ–¹æ¡ˆ2ï¼šç¼“å­˜æ­£åˆ™è¡¨è¾¾å¼**:

```rust
use once_cell::sync::Lazy;
use regex::Regex;

static HTTP_PATTERN: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r"^http_.*").unwrap()
});

// ä½¿ç”¨ç¼“å­˜çš„æ­£åˆ™è¡¨è¾¾å¼
for attribute in &span.attributes {
    if HTTP_PATTERN.is_match(&attribute.key) {
        // ...
    }
}
```

**æ–¹æ¡ˆ3ï¼šå‡å°‘å­—ç¬¦ä¸²æ‹·è´**:

```rust
// âŒ ä¹‹å‰ï¼šé¢‘ç¹æ‹·è´
pub fn process_attribute(key: String, value: String) {
    // ...
}

// âœ… ä¼˜åŒ–åï¼šä½¿ç”¨å¼•ç”¨
pub fn process_attribute(key: &str, value: &str) {
    // ...
}

// ä½¿ç”¨ Cow å¤„ç†å¯èƒ½éœ€è¦ä¿®æ”¹çš„æƒ…å†µ
use std::borrow::Cow;

pub fn process_attribute(key: Cow<str>, value: Cow<str>) {
    // åªåœ¨éœ€è¦æ—¶æ‰æ‹·è´
}
```

**æ–¹æ¡ˆ4ï¼šä¼˜åŒ–çº¿ç¨‹æ± **:

```rust
use tokio::runtime::Builder;

// âŒ ä¹‹å‰ï¼šé»˜è®¤é…ç½®ï¼ˆçº¿ç¨‹æ•° = CPU æ ¸å¿ƒæ•° * 2ï¼‰
let runtime = tokio::runtime::Runtime::new()?;

// âœ… ä¼˜åŒ–åï¼šç²¾ç¡®æ§åˆ¶çº¿ç¨‹æ•°
let runtime = Builder::new_multi_thread()
    .worker_threads(8)  // å›ºå®š 8 ä¸ªå·¥ä½œçº¿ç¨‹
    .thread_name("otlp-worker")
    .thread_stack_size(2 * 1024 * 1024)  // 2MB æ ˆ
    .build()?;
```

#### ğŸ“ˆ ä¼˜åŒ–æ•ˆæœ3

| æŒ‡æ ‡ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æ”¹å–„ |
|------|--------|--------|------|
| **CPU ä½¿ç”¨ç‡** | 95% | 35% | **-63%** â¬‡ï¸ |
| **ååé‡** | 20,000/s | 60,000/s | **+200%** â¬†ï¸ |
| **P99 å»¶è¿Ÿ** | 200ms | 50ms | **-75%** â¬‡ï¸ |
| **çº¿ç¨‹æ•°** | 500+ | 8 | **-98%** â¬‡ï¸ |

#### ğŸ“ ç»éªŒæ•™è®­3

1. **é¿å…è¿‡åº¦åºåˆ—åŒ–**ï¼šåªåœ¨å¿…è¦æ—¶åºåˆ—åŒ–
2. **ç¼“å­˜æ­£åˆ™è¡¨è¾¾å¼**ï¼šä½¿ç”¨ `once_cell` æˆ– `lazy_static`
3. **ä¼˜å…ˆä½¿ç”¨å¼•ç”¨**ï¼šå‡å°‘ä¸å¿…è¦çš„æ‹·è´
4. **åˆç†é…ç½®çº¿ç¨‹æ± **ï¼šçº¿ç¨‹ä¸æ˜¯è¶Šå¤šè¶Šå¥½

---

## ğŸ’° æˆæœ¬ä¼˜åŒ–æ¡ˆä¾‹

### æ¡ˆä¾‹4ï¼šæ™ºèƒ½é‡‡æ ·é™ä½80%æˆæœ¬

#### ğŸ“‹ æ¡ˆä¾‹èƒŒæ™¯4

**å…¬å¸**ï¼šæŸåœ¨çº¿æ•™è‚²å¹³å°  
**é—®é¢˜**ï¼šOTLP æˆæœ¬æ¯æœˆ $50,000ï¼Œè¶…å‡ºé¢„ç®—  
**ç›®æ ‡**ï¼šé™ä½æˆæœ¬è‡³ $10,000/æœˆ  
**æ—¶é—´**ï¼š2024å¹´9æœˆ

#### ğŸ” å½“å‰çŠ¶å†µ4

```bash
# å½“å‰æ•°æ®é‡
Spans/day: 10 billion
Storage: 500 TB/month
Cost: $50,000/month
```

#### ğŸ“Š æˆæœ¬åˆ†æ4

```rust
use otlp_tools::CostCalculator;

let calculator = CostCalculator::new();
let breakdown = calculator.analyze();

println!("{:#?}", breakdown);
// CostBreakdown {
//     compute: $15,000 (30%)
//     storage: $25,000 (50%)  // âš ï¸ æœ€å¤§å¼€é”€
//     network: $8,000 (16%)
//     license: $2,000 (4%)
// }
```

#### ğŸ’¡ ä¼˜åŒ–ç­–ç•¥4

**ç­–ç•¥1ï¼šå¤šçº§é‡‡æ ·**:

```rust
pub struct MultiTierSampler {
    tiers: Vec<SamplingTier>,
}

#[derive(Debug)]
pub struct SamplingTier {
    pub name: String,
    pub condition: SamplingCondition,
    pub rate: f64,
}

#[derive(Debug)]
pub enum SamplingCondition {
    Error,
    HighLatency(Duration),
    ImportantEndpoint(Vec<String>),
    Default,
}

impl MultiTierSampler {
    pub fn new() -> Self {
        Self {
            tiers: vec![
                SamplingTier {
                    name: "errors".to_string(),
                    condition: SamplingCondition::Error,
                    rate: 1.0,  // 100% é‡‡æ ·é”™è¯¯
                },
                SamplingTier {
                    name: "slow_requests".to_string(),
                    condition: SamplingCondition::HighLatency(Duration::from_millis(500)),
                    rate: 1.0,  // 100% é‡‡æ ·æ…¢è¯·æ±‚
                },
                SamplingTier {
                    name: "important_apis".to_string(),
                    condition: SamplingCondition::ImportantEndpoint(vec![
                        "/api/payment".to_string(),
                        "/api/checkout".to_string(),
                    ]),
                    rate: 0.5,  // 50% é‡‡æ ·é‡è¦ API
                },
                SamplingTier {
                    name: "default".to_string(),
                    condition: SamplingCondition::Default,
                    rate: 0.01,  // 1% é‡‡æ ·å…¶ä»–è¯·æ±‚
                },
            ],
        }
    }
    
    pub fn should_sample(&self, span: &Span) -> bool {
        for tier in &self.tiers {
            if self.matches_condition(span, &tier.condition) {
                return rand::random::<f64>() < tier.rate;
            }
        }
        false
    }
    
    fn matches_condition(&self, span: &Span, condition: &SamplingCondition) -> bool {
        match condition {
            SamplingCondition::Error => span.status.is_error(),
            SamplingCondition::HighLatency(threshold) => {
                span.duration() > *threshold
            }
            SamplingCondition::ImportantEndpoint(endpoints) => {
                endpoints.iter().any(|ep| span.name.contains(ep))
            }
            SamplingCondition::Default => true,
        }
    }
}
```

**ç­–ç•¥2ï¼šOTLP Collector é…ç½®**:

```yaml
# otel-collector-config.yaml
processors:
  probabilistic_sampler:
    hash_seed: 22
    sampling_percentage: 1  # é»˜è®¤ 1%
  
  tail_sampling:
    decision_wait: 10s
    num_traces: 100000
    expected_new_traces_per_sec: 10000
    policies:
      # 100% é‡‡æ ·é”™è¯¯
      - name: errors
        type: status_code
        status_code:
          status_codes: [ERROR]
      
      # 100% é‡‡æ ·æ…¢è¯·æ±‚
      - name: slow_requests
        type: latency
        latency:
          threshold_ms: 500
      
      # 50% é‡‡æ ·é‡è¦ API
      - name: important_apis
        type: string_attribute
        string_attribute:
          key: http.route
          values: [/api/payment, /api/checkout]
          enabled_regex_matching: true
        probabilistic:
          sampling_percentage: 50
      
      # 1% é‡‡æ ·å…¶ä»–
      - name: default
        type: probabilistic
        probabilistic:
          sampling_percentage: 1
```

#### ğŸ“ˆ ä¼˜åŒ–æ•ˆæœ4

**æ•°æ®é‡å˜åŒ–**ï¼š

| ç±»åˆ« | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | é‡‡æ ·ç‡ |
|------|--------|--------|--------|
| **é”™è¯¯è¯·æ±‚** | 100M/å¤© | 100M/å¤© | 100% |
| **æ…¢è¯·æ±‚** | 200M/å¤© | 200M/å¤© | 100% |
| **é‡è¦ API** | 500M/å¤© | 250M/å¤© | 50% |
| **æ™®é€šè¯·æ±‚** | 9.2B/å¤© | 92M/å¤© | 1% |
| **æ€»è®¡** | 10B/å¤© | 642M/å¤© | **-94%** â¬‡ï¸ |

**æˆæœ¬å˜åŒ–**ï¼š

| é¡¹ç›® | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | èŠ‚çœ |
|------|--------|--------|------|
| **è®¡ç®—æˆæœ¬** | $15,000 | $3,000 | $12,000 |
| **å­˜å‚¨æˆæœ¬** | $25,000 | $5,000 | $20,000 |
| **ç½‘ç»œæˆæœ¬** | $8,000 | $1,600 | $6,400 |
| **è®¸å¯æˆæœ¬** | $2,000 | $2,000 | $0 |
| **æ€»æˆæœ¬** | **$50,000** | **$11,600** | **$38,400 (-77%)** |

#### ğŸ“ ç»éªŒæ•™è®­4

1. **åˆ†å±‚é‡‡æ ·å¾ˆå…³é”®**ï¼šä¸åŒç±»å‹çš„è¯·æ±‚é‡‡ç”¨ä¸åŒé‡‡æ ·ç‡
2. **ä¿ç•™é‡è¦æ•°æ®**ï¼šé”™è¯¯å’Œæ…¢è¯·æ±‚å¿…é¡» 100% é‡‡æ ·
3. **æˆæœ¬èŠ‚çœæ˜¾è‘—**ï¼šé‡‡æ ·å¯ä»¥é™ä½ 70-90% æˆæœ¬
4. **ä¸å½±å“é—®é¢˜æ’æŸ¥**ï¼šå…³é”®é—®é¢˜ä¾ç„¶å¯ä»¥è¿½è¸ª

---

### æ¡ˆä¾‹5ï¼šå­˜å‚¨åˆ†å±‚èŠ‚çœ93%å­˜å‚¨æˆæœ¬

#### ğŸ“‹ æ¡ˆä¾‹èƒŒæ™¯5

**å…¬å¸**ï¼šæŸç‰©æµå…¬å¸  
**é—®é¢˜**ï¼šçƒ­å­˜å‚¨æˆæœ¬é«˜è¾¾ $30,000/æœˆ  
**ç›®æ ‡**ï¼šé€šè¿‡å­˜å‚¨åˆ†å±‚é™ä½æˆæœ¬  
**æ—¶é—´**ï¼š2024å¹´11æœˆ

#### ğŸ’¡ è§£å†³æ–¹æ¡ˆ5

**å­˜å‚¨åˆ†å±‚ç­–ç•¥**ï¼š

```yaml
# å­˜å‚¨åˆ†å±‚é…ç½®
storage_tiers:
  hot:
    retention: 7 days
    storage_class: SSD
    cost_per_gb: $0.30
  
  warm:
    retention: 30 days
    storage_class: HDD
    cost_per_gb: $0.10
  
  cold:
    retention: 365 days
    storage_class: S3 Glacier
    cost_per_gb: $0.004
```

**è‡ªåŠ¨åŒ–åˆ†å±‚è„šæœ¬**ï¼š

```bash
#!/bin/bash
# tier_storage.sh

# 7å¤©å‰çš„æ•°æ®ç§»åˆ°æ¸©å­˜å‚¨
find /data/hot -type f -mtime +7 -exec mv {} /data/warm/ \;

# 30å¤©å‰çš„æ•°æ®ç§»åˆ°å†·å­˜å‚¨
find /data/warm -type f -mtime +30 -exec aws s3 cp {} s3://traces-cold/ \;

# åˆ é™¤æœ¬åœ°å‰¯æœ¬
find /data/warm -type f -mtime +30 -delete
```

#### ğŸ“ˆ ä¼˜åŒ–æ•ˆæœ5

| å­˜å‚¨å±‚ | æ•°æ®é‡ | æˆæœ¬/æœˆ | å æ¯” |
|--------|--------|---------|------|
| **çƒ­å­˜å‚¨ (7å¤©)** | 70 TB | $2,100 | 7% |
| **æ¸©å­˜å‚¨ (30å¤©)** | 300 TB | $3,000 | 10% |
| **å†·å­˜å‚¨ (365å¤©)** | 3.6 PB | $1,440 | 83% |
| **æ€»è®¡** | 3.97 PB | **$6,540** | 100% |

**æˆæœ¬èŠ‚çœ**ï¼š$30,000 â†’ $6,540 = **èŠ‚çœ $23,460 (-78%)**

---

### æ¡ˆä¾‹6ï¼šæ‰¹å¤„ç†ä¼˜åŒ–æå‡ååé‡

#### ğŸ“‹ æ¡ˆä¾‹èƒŒæ™¯6

**å…¬å¸**ï¼šæŸæ¸¸æˆå…¬å¸  
**é—®é¢˜**ï¼šOTLP ååé‡ä¸è¶³ï¼Œé«˜å³°æœŸä¸¢æ•°æ®  
**ç›®æ ‡**ï¼šæå‡ååé‡è‡³ 100,000 spans/s  
**æ—¶é—´**ï¼š2024å¹´10æœˆ

#### ğŸ’¡ ä¼˜åŒ–æ–¹æ¡ˆ6

**åŠ¨æ€æ‰¹å¤„ç†**ï¼š

```rust
pub struct AdaptiveBatcher {
    min_batch_size: usize,
    max_batch_size: usize,
    current_batch_size: usize,
    timeout: Duration,
}

impl AdaptiveBatcher {
    pub fn adjust_batch_size(&mut self, metrics: &SystemMetrics) {
        if metrics.queue_depth > 10000 {
            // é˜Ÿåˆ—ç§¯å‹ï¼Œå¢å¤§æ‰¹æ¬¡
            self.current_batch_size = (self.current_batch_size * 2)
                .min(self.max_batch_size);
        } else if metrics.queue_depth < 1000 {
            // é˜Ÿåˆ—ç©ºé—²ï¼Œå‡å°æ‰¹æ¬¡ï¼ˆé™ä½å»¶è¿Ÿï¼‰
            self.current_batch_size = (self.current_batch_size / 2)
                .max(self.min_batch_size);
        }
    }
}
```

#### ğŸ“ˆ ä¼˜åŒ–æ•ˆæœ6

| æŒ‡æ ‡ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æ”¹å–„ |
|------|--------|--------|------|
| **ååé‡** | 30,000/s | 120,000/s | **+300%** â¬†ï¸ |
| **P99 å»¶è¿Ÿ** | 150ms | 80ms | **-47%** â¬‡ï¸ |
| **æ•°æ®ä¸¢å¤±ç‡** | 8% | 0.1% | **-99%** â¬‡ï¸ |

---

## ğŸš¨ æ•…éšœæ’æŸ¥æ¡ˆä¾‹

### æ¡ˆä¾‹7ï¼šæœåŠ¡é›ªå´©äº‹æ•…å¤„ç†

#### ğŸ“‹ æ¡ˆä¾‹èƒŒæ™¯7

**å…¬å¸**ï¼šæŸç¤¾äº¤åª’ä½“å¹³å°  
**äº‹æ•…**ï¼šOTLP Collector æ•…éšœå¯¼è‡´ 20+ æœåŠ¡é›ªå´©  
**å½±å“**ï¼šå…¨ç«™ä¸å¯ç”¨ 45 åˆ†é’Ÿ  
**æ—¶é—´**ï¼š2024å¹´12æœˆ15æ—¥ 14:30

#### ğŸ”¥ äº‹æ•…æ—¶é—´çº¿7

```mermaid
gantt
    title æœåŠ¡é›ªå´©äº‹æ•…æ—¶é—´çº¿
    dateFormat HH:mm
    
    section æ•…éšœå‘ç”Ÿ
    OTLP Collector OOM     :crit, 14:30, 5m
    æœåŠ¡å¼€å§‹è¶…æ—¶           :crit, 14:32, 3m
    
    section å½±å“æ‰©æ•£
    æœåŠ¡Aé™çº§              :crit, 14:35, 10m
    æœåŠ¡B/C/Dè¿é”æ•…éšœ      :crit, 14:38, 15m
    å…¨ç«™ä¸å¯ç”¨             :crit, 14:40, 35m
    
    section åº”æ€¥å¤„ç†
    å¯åŠ¨æˆ˜äº‰å®¤             :active, 14:35, 5m
    å®šä½æ ¹å›                :active, 14:40, 10m
    é‡å¯Collector          :active, 14:50, 5m
    æœåŠ¡é€æ­¥æ¢å¤           :active, 14:55, 15m
    
    section æ¢å¤éªŒè¯
    ç›‘æ§æŒ‡æ ‡æ¢å¤           :done, 15:10, 5m
    å…¨ç«™æ¢å¤æ­£å¸¸           :done, 15:15, 0m
```

#### ğŸ” æ ¹å› åˆ†æ

**ç›´æ¥åŸå› **ï¼š

- OTLP Collector å†…å­˜æ³„æ¼å¯¼è‡´ OOM
- æœåŠ¡ SDK é‡è¯•æœºåˆ¶å¯¼è‡´é›ªå´©

**æ·±å±‚åŸå› **ï¼š

- ç¼ºå°‘ç†”æ–­æœºåˆ¶
- ç›‘æ§å‘Šè­¦ä¸åŠæ—¶
- æ²¡æœ‰é™çº§é¢„æ¡ˆ

#### âœ… æ”¹è¿›æªæ–½

**1. æ·»åŠ ç†”æ–­å™¨**:

```rust
use std::sync::atomic::{AtomicU64, Ordering};
use std::time::{Duration, Instant};

pub struct CircuitBreaker {
    failure_count: AtomicU64,
    failure_threshold: u64,
    timeout: Duration,
    last_failure_time: Mutex<Option<Instant>>,
    state: Mutex<CircuitState>,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum CircuitState {
    Closed,      // æ­£å¸¸çŠ¶æ€
    Open,        // ç†”æ–­çŠ¶æ€
    HalfOpen,    // åŠå¼€çŠ¶æ€ï¼ˆå°è¯•æ¢å¤ï¼‰
}

impl CircuitBreaker {
    pub fn new(failure_threshold: u64, timeout: Duration) -> Self {
        Self {
            failure_count: AtomicU64::new(0),
            failure_threshold,
            timeout,
            last_failure_time: Mutex::new(None),
            state: Mutex::new(CircuitState::Closed),
        }
    }
    
    pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError<E>>
    where
        F: Future<Output = Result<T, E>>,
    {
        // æ£€æŸ¥ç†”æ–­å™¨çŠ¶æ€
        let state = *self.state.lock().unwrap();
        
        match state {
            CircuitState::Open => {
                // æ£€æŸ¥æ˜¯å¦å¯ä»¥å°è¯•æ¢å¤
                if self.should_attempt_reset() {
                    *self.state.lock().unwrap() = CircuitState::HalfOpen;
                } else {
                    return Err(CircuitBreakerError::Open);
                }
            }
            CircuitState::HalfOpen | CircuitState::Closed => {}
        }
        
        // æ‰§è¡Œè°ƒç”¨
        match f.await {
            Ok(result) => {
                self.on_success();
                Ok(result)
            }
            Err(e) => {
                self.on_failure();
                Err(CircuitBreakerError::CallFailed(e))
            }
        }
    }
    
    fn on_success(&self) {
        self.failure_count.store(0, Ordering::SeqCst);
        *self.state.lock().unwrap() = CircuitState::Closed;
    }
    
    fn on_failure(&self) {
        let failures = self.failure_count.fetch_add(1, Ordering::SeqCst) + 1;
        *self.last_failure_time.lock().unwrap() = Some(Instant::now());
        
        if failures >= self.failure_threshold {
            *self.state.lock().unwrap() = CircuitState::Open;
        }
    }
    
    fn should_attempt_reset(&self) -> bool {
        if let Some(last_failure) = *self.last_failure_time.lock().unwrap() {
            last_failure.elapsed() > self.timeout
        } else {
            false
        }
    }
}
```

**2. ä¼˜åŒ–é‡è¯•ç­–ç•¥**:

```rust
// SDK é…ç½®
OpenTelemetryConfig {
    retry: RetryConfig {
        max_retries: 3,
        initial_backoff: Duration::from_millis(100),
        max_backoff: Duration::from_secs(5),
        timeout: Duration::from_secs(10),
        // âš ï¸ å…³é”®ï¼šå¯ç”¨ç†”æ–­
        circuit_breaker: Some(CircuitBreakerConfig {
            failure_threshold: 5,
            timeout: Duration::from_secs(30),
        }),
    },
}
```

#### ğŸ“ˆ æ”¹è¿›æ•ˆæœ

- **MTTR**ï¼šä» 45 åˆ†é’Ÿé™ä½åˆ° 5 åˆ†é’Ÿ
- **æ•…éšœéš”ç¦»**ï¼šå•ä¸ªæœåŠ¡æ•…éšœä¸å†æ‰©æ•£
- **å¯ç”¨æ€§**ï¼šä» 99.5% æå‡åˆ° 99.95%

---

## ğŸ¯ æœ€ä½³å®è·µæ€»ç»“

### é€šç”¨åŸåˆ™

1. **ç›‘æ§å…ˆè¡Œ**ï¼šå®Œå–„çš„ç›‘æ§æ˜¯ä¸€åˆ‡çš„åŸºç¡€
2. **æ¸è¿›å¼ä¼˜åŒ–**ï¼šå°æ­¥å¿«è·‘ï¼ŒæŒç»­æ”¹è¿›
3. **æ•°æ®é©±åŠ¨**ï¼šç”¨æ•°æ®è¯´è¯ï¼Œé¿å…ä¸»è§‚è‡†æ–­
4. **è‡ªåŠ¨åŒ–ä¼˜å…ˆ**ï¼šèƒ½è‡ªåŠ¨åŒ–çš„ç»ä¸æ‰‹åŠ¨
5. **æˆæœ¬æ„è¯†**ï¼šæ—¶åˆ»å…³æ³¨æˆæœ¬æ•ˆç›Šæ¯”

### å·¥å…·ç®±

```bash
# æ€§èƒ½åˆ†æ
- perf: CPU profiling
- flamegraph: ç«ç„°å›¾
- criterion: Rust benchmark
- jemalloc: å†…å­˜ profiling

# ç›‘æ§å·¥å…·
- Prometheus: æŒ‡æ ‡ç›‘æ§
- Grafana: å¯è§†åŒ–
- Jaeger/Tempo: è¿½è¸ªæŸ¥çœ‹
- Loki: æ—¥å¿—èšåˆ

# å‹æµ‹å·¥å…·
- wrk: HTTP å‹æµ‹
- k6: ç°ä»£åŒ–å‹æµ‹
- ghz: gRPC å‹æµ‹
```

### æ£€æŸ¥æ¸…å•

**ä¸Šçº¿å‰æ£€æŸ¥**ï¼š

- [ ] æ€§èƒ½åŸºå‡†æµ‹è¯•å®Œæˆ
- [ ] ç›‘æ§å‘Šè­¦é…ç½®å®Œæˆ
- [ ] å®¹é‡è§„åˆ’è¯„ä¼°å®Œæˆ
- [ ] é™çº§é¢„æ¡ˆå‡†å¤‡å®Œæˆ
- [ ] å›æ»šæ–¹æ¡ˆéªŒè¯å®Œæˆ

**æ—¥å¸¸è¿ç»´æ£€æŸ¥**ï¼š

- [ ] æ¯æ—¥æŸ¥çœ‹ç›‘æ§å¤§ç›˜
- [ ] æ¯å‘¨åˆ†ææˆæœ¬æŠ¥å‘Š
- [ ] æ¯æœˆè¿›è¡Œæ€§èƒ½å›å½’æµ‹è¯•
- [ ] æ¯å­£åº¦è¿›è¡Œå®¹é‡è¯„ä¼°
- [ ] æ¯åŠå¹´è¿›è¡Œæ¶æ„å®¡æŸ¥

---

**æ¡ˆä¾‹åº“æŒç»­æ›´æ–°ä¸­...**

å¦‚éœ€æ·»åŠ æ‚¨çš„æ¡ˆä¾‹æˆ–æœ‰ä»»ä½•é—®é¢˜ï¼Œè¯·è”ç³» OTLP å›¢é˜Ÿã€‚
