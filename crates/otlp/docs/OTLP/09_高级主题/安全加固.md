# 安全加固

## 目录

- [概述](#概述)
- [认证与授权](#认证与授权)
- [数据加密](#数据加密)
- [安全审计](#安全审计)
- [漏洞管理](#漏洞管理)

## 概述

安全加固确保 OTLP 系统抵御各种安全威胁，保护敏感数据。

## 认证与授权

### mTLS 双向认证

```rust
use rustls::{ServerConfig, ClientConfig};
use std::sync::Arc;

pub struct MtlsConfig {
    server_config: Arc<ServerConfig>,
    client_config: Arc<ClientConfig>,
}

impl MtlsConfig {
    pub fn new(
        ca_cert: &[u8],
        server_cert: &[u8],
        server_key: &[u8],
        client_cert: &[u8],
        client_key: &[u8],
    ) -> Result<Self, TlsError> {
        // 配置服务端
        let server_config = Self::build_server_config(ca_cert, server_cert, server_key)?;
        
        // 配置客户端
        let client_config = Self::build_client_config(ca_cert, client_cert, client_key)?;

        Ok(Self {
            server_config: Arc::new(server_config),
            client_config: Arc::new(client_config),
        })
    }

    fn build_server_config(
        ca_cert: &[u8],
        server_cert: &[u8],
        server_key: &[u8],
    ) -> Result<ServerConfig, TlsError> {
        // 实际 TLS 配置
        Ok(ServerConfig::builder().build())
    }

    fn build_client_config(
        ca_cert: &[u8],
        client_cert: &[u8],
        client_key: &[u8],
    ) -> Result<ClientConfig, TlsError> {
        // 实际 TLS 配置
        Ok(ClientConfig::builder().build())
    }
}

#[derive(Debug)]
pub enum TlsError {
    InvalidCertificate,
    InvalidKey,
}
```

### API 密钥管理

```rust
use sha2::{Sha256, Digest};
use std::collections::HashMap;

pub struct ApiKeyManager {
    keys: HashMap<String, ApiKey>,
}

pub struct ApiKey {
    pub key_id: String,
    pub key_hash: Vec<u8>,
    pub permissions: Vec<Permission>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub expires_at: Option<chrono::DateTime<chrono::Utc>>,
}

pub enum Permission {
    ReadSpans,
    WriteSpans,
    Admin,
}

impl ApiKeyManager {
    pub fn new() -> Self {
        Self {
            keys: HashMap::new(),
        }
    }

    pub fn create_key(&mut self, permissions: Vec<Permission>) -> (String, String) {
        let key_id = uuid::Uuid::new_v4().to_string();
        let api_key = Self::generate_secure_key();
        let key_hash = Self::hash_key(&api_key);

        let key = ApiKey {
            key_id: key_id.clone(),
            key_hash,
            permissions,
            created_at: chrono::Utc::now(),
            expires_at: None,
        };

        self.keys.insert(key_id.clone(), key);

        (key_id, api_key)
    }

    pub fn validate_key(&self, api_key: &str) -> Option<&ApiKey> {
        let key_hash = Self::hash_key(api_key);

        self.keys.values().find(|k| k.key_hash == key_hash)
    }

    fn generate_secure_key() -> String {
        use rand::Rng;
        let random_bytes: Vec<u8> = (0..32).map(|_| rand::thread_rng().gen()).collect();
        base64::encode(&random_bytes)
    }

    fn hash_key(key: &str) -> Vec<u8> {
        let mut hasher = Sha256::new();
        hasher.update(key.as_bytes());
        hasher.finalize().to_vec()
    }

    pub fn revoke_key(&mut self, key_id: &str) -> bool {
        self.keys.remove(key_id).is_some()
    }
}
```

### RBAC 权限控制

```rust
pub struct RbacManager {
    roles: HashMap<String, Role>,
    user_roles: HashMap<String, Vec<String>>,
}

pub struct Role {
    pub name: String,
    pub permissions: Vec<Permission>,
}

impl RbacManager {
    pub fn new() -> Self {
        Self {
            roles: HashMap::new(),
            user_roles: HashMap::new(),
        }
    }

    pub fn create_role(&mut self, name: String, permissions: Vec<Permission>) {
        self.roles.insert(name.clone(), Role { name, permissions });
    }

    pub fn assign_role(&mut self, user_id: String, role_name: String) {
        self.user_roles.entry(user_id).or_insert_with(Vec::new).push(role_name);
    }

    pub fn check_permission(&self, user_id: &str, required_permission: &Permission) -> bool {
        if let Some(roles) = self.user_roles.get(user_id) {
            for role_name in roles {
                if let Some(role) = self.roles.get(role_name) {
                    if role.permissions.iter().any(|p| std::mem::discriminant(p) == std::mem::discriminant(required_permission)) {
                        return true;
                    }
                }
            }
        }
        false
    }
}
```

## 数据加密

### 传输加密

```rust
pub struct EncryptionManager {
    cipher_suite: CipherSuite,
}

pub enum CipherSuite {
    Aes256Gcm,
    ChaCha20Poly1305,
}

impl EncryptionManager {
    pub fn encrypt(&self, data: &[u8], key: &[u8]) -> Result<Vec<u8>, EncryptionError> {
        match self.cipher_suite {
            CipherSuite::Aes256Gcm => self.encrypt_aes_gcm(data, key),
            CipherSuite::ChaCha20Poly1305 => self.encrypt_chacha(data, key),
        }
    }

    pub fn decrypt(&self, encrypted: &[u8], key: &[u8]) -> Result<Vec<u8>, EncryptionError> {
        match self.cipher_suite {
            CipherSuite::Aes256Gcm => self.decrypt_aes_gcm(encrypted, key),
            CipherSuite::ChaCha20Poly1305 => self.decrypt_chacha(encrypted, key),
        }
    }

    fn encrypt_aes_gcm(&self, data: &[u8], key: &[u8]) -> Result<Vec<u8>, EncryptionError> {
        // 实际 AES-GCM 加密
        Ok(data.to_vec())
    }

    fn decrypt_aes_gcm(&self, encrypted: &[u8], key: &[u8]) -> Result<Vec<u8>, EncryptionError> {
        // 实际 AES-GCM 解密
        Ok(encrypted.to_vec())
    }

    fn encrypt_chacha(&self, data: &[u8], key: &[u8]) -> Result<Vec<u8>, EncryptionError> {
        // 实际 ChaCha20-Poly1305 加密
        Ok(data.to_vec())
    }

    fn decrypt_chacha(&self, encrypted: &[u8], key: &[u8]) -> Result<Vec<u8>, EncryptionError> {
        // 实际 ChaCha20-Poly1305 解密
        Ok(encrypted.to_vec())
    }
}

#[derive(Debug)]
pub enum EncryptionError {
    InvalidKey,
    EncryptionFailed,
    DecryptionFailed,
}
```

### 静态数据加密

```rust
pub struct DataAtRestEncryption {
    key_rotation_interval: Duration,
    current_key_version: u32,
}

impl DataAtRestEncryption {
    pub fn encrypt_span(&self, span: &Span) -> EncryptedSpan {
        // 加密 Span 数据
        EncryptedSpan {
            encrypted_data: vec![],
            key_version: self.current_key_version,
        }
    }

    pub fn decrypt_span(&self, encrypted: &EncryptedSpan) -> Result<Span, EncryptionError> {
        // 解密 Span 数据
        Ok(Span {
            trace_id: vec![],
            span_id: vec![],
        })
    }

    pub async fn rotate_keys(&mut self) {
        self.current_key_version += 1;
        // 实际密钥轮换逻辑
    }
}

pub struct EncryptedSpan {
    pub encrypted_data: Vec<u8>,
    pub key_version: u32,
}

pub struct Span {
    pub trace_id: Vec<u8>,
    pub span_id: Vec<u8>,
}

use tokio::time::Duration;
```

## 安全审计

### 审计日志

```rust
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct AuditLog {
    pub timestamp: chrono::DateTime<chrono::Utc>,
    pub user_id: String,
    pub action: AuditAction,
    pub resource: String,
    pub result: AuditResult,
    pub ip_address: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum AuditAction {
    Login,
    Logout,
    CreateApiKey,
    RevokeApiKey,
    ReadSpan,
    WriteSpan,
    ModifyConfig,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum AuditResult {
    Success,
    Failure { reason: String },
}

pub struct AuditLogger {
    logs: Vec<AuditLog>,
}

impl AuditLogger {
    pub fn new() -> Self {
        Self { logs: Vec::new() }
    }

    pub fn log(&mut self, log: AuditLog) {
        println!("AUDIT: {:?}", log);
        self.logs.push(log);
    }

    pub fn query_logs(&self, user_id: Option<&str>, action: Option<&AuditAction>) -> Vec<&AuditLog> {
        self.logs.iter()
            .filter(|log| {
                user_id.map_or(true, |uid| log.user_id == uid) &&
                action.map_or(true, |act| std::mem::discriminant(&log.action) == std::mem::discriminant(act))
            })
            .collect()
    }
}
```

## 漏洞管理

### 依赖扫描

```bash
#!/bin/bash
# 依赖漏洞扫描

echo "=== Rust 依赖扫描 ==="
cargo audit

echo "=== Docker 镜像扫描 ==="
trivy image otlp-collector:latest

echo "=== Kubernetes 配置扫描 ==="
kubesec scan k8s/deployment.yaml
```

### 安全配置检查

```rust
pub struct SecurityConfigChecker;

impl SecurityConfigChecker {
    pub fn check_configuration(&self, config: &SystemConfig) -> Vec<SecurityIssue> {
        let mut issues = Vec::new();

        // 检查 TLS 配置
        if !config.tls_enabled {
            issues.push(SecurityIssue {
                severity: Severity::High,
                description: "TLS is not enabled".to_string(),
                recommendation: "Enable TLS for all connections".to_string(),
            });
        }

        // 检查认证配置
        if config.api_keys.is_empty() {
            issues.push(SecurityIssue {
                severity: Severity::Critical,
                description: "No API keys configured".to_string(),
                recommendation: "Configure API key authentication".to_string(),
            });
        }

        // 检查密码强度
        if config.admin_password.len() < 12 {
            issues.push(SecurityIssue {
                severity: Severity::Medium,
                description: "Weak admin password".to_string(),
                recommendation: "Use a password with at least 12 characters".to_string(),
            });
        }

        issues
    }
}

pub struct SystemConfig {
    pub tls_enabled: bool,
    pub api_keys: Vec<String>,
    pub admin_password: String,
}

pub struct SecurityIssue {
    pub severity: Severity,
    pub description: String,
    pub recommendation: String,
}

pub enum Severity {
    Low,
    Medium,
    High,
    Critical,
}
```

### 安全基线

```yaml
# 安全基线配置
security_baseline:
  authentication:
    - mtls_enabled: true
    - api_key_required: true
    - password_min_length: 12
    
  encryption:
    - tls_version: "1.3"
    - cipher_suites:
        - TLS_AES_256_GCM_SHA384
        - TLS_CHACHA20_POLY1305_SHA256
    - data_at_rest_encryption: true
    
  network:
    - firewall_enabled: true
    - rate_limiting: true
    - ddos_protection: true
    
  audit:
    - audit_logging: true
    - log_retention_days: 90
    - log_encryption: true
```

---

**相关文档**：

- [认证与授权](../06_安全/认证授权.md)
- [数据加密](../06_安全/数据加密.md)
