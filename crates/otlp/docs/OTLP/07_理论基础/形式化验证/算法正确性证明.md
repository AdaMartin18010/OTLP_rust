# OTLP 算法正确性证明

## 目录

- [OTLP 算法正确性证明](#otlp-算法正确性证明)
  - [目录](#目录)
  - [概述](#概述)
  - [循环调用检测算法](#循环调用检测算法)
    - [算法描述](#算法描述)
    - [正确性证明](#正确性证明)
    - [复杂度分析](#复杂度分析)
  - [Span 完整性检测算法](#span-完整性检测算法)
    - [算法描述1](#算法描述1)
    - [正确性证明1](#正确性证明1)
  - [采样算法](#采样算法)
    - [概率采样](#概率采样)
    - [自适应采样](#自适应采样)
    - [正确性证明2](#正确性证明2)
  - [批处理算法](#批处理算法)
    - [算法描述3](#算法描述3)
    - [正确性证明3](#正确性证明3)
  - [重试算法](#重试算法)
    - [指数退避算法](#指数退避算法)
    - [正确性证明4](#正确性证明4)
  - [聚合算法](#聚合算法)
    - [时间窗口聚合](#时间窗口聚合)
    - [正确性证明5](#正确性证明5)
  - [参考文献](#参考文献)

## 概述

本文档提供 OTLP 系统中关键算法的形式化正确性证明，确保算法在理论上是正确的。

## 循环调用检测算法

### 算法描述

**问题**：给定一个调用图 \( G = (V, E) \)，检测是否存在循环调用。

**算法**：使用 Tarjan 强连通分量算法。

```rust
use std::collections::{HashMap, HashSet};

/// Tarjan 算法检测循环调用
pub struct CycleDetector {
    /// 调用图：service -> 依赖的 services
    graph: HashMap<String, Vec<String>>,
    /// DFS 访问顺序
    index: usize,
    /// 节点索引
    indices: HashMap<String, usize>,
    /// 节点 lowlink
    lowlinks: HashMap<String, usize>,
    /// DFS 栈
    stack: Vec<String>,
    /// 栈中的节点
    on_stack: HashSet<String>,
    /// 强连通分量
    sccs: Vec<Vec<String>>,
}

impl CycleDetector {
    pub fn new(graph: HashMap<String, Vec<String>>) -> Self {
        Self {
            graph,
            index: 0,
            indices: HashMap::new(),
            lowlinks: HashMap::new(),
            stack: Vec::new(),
            on_stack: HashSet::new(),
            sccs: Vec::new(),
        }
    }

    /// 检测循环
    pub fn detect_cycles(&mut self) -> Vec<Vec<String>> {
        let nodes: Vec<_> = self.graph.keys().cloned().collect();
        
        for node in nodes {
            if !self.indices.contains_key(&node) {
                self.strongconnect(node);
            }
        }

        // 返回大小 > 1 的强连通分量（循环）
        self.sccs
            .iter()
            .filter(|scc| scc.len() > 1)
            .cloned()
            .collect()
    }

    fn strongconnect(&mut self, v: String) {
        // 设置节点索引
        self.indices.insert(v.clone(), self.index);
        self.lowlinks.insert(v.clone(), self.index);
        self.index += 1;
        
        self.stack.push(v.clone());
        self.on_stack.insert(v.clone());

        // 遍历邻居
        if let Some(neighbors) = self.graph.get(&v).cloned() {
            for w in neighbors {
                if !self.indices.contains_key(&w) {
                    // 未访问过
                    self.strongconnect(w.clone());
                    let v_lowlink = self.lowlinks[&v];
                    let w_lowlink = self.lowlinks[&w];
                    self.lowlinks.insert(v.clone(), v_lowlink.min(w_lowlink));
                } else if self.on_stack.contains(&w) {
                    // 在栈中
                    let v_lowlink = self.lowlinks[&v];
                    let w_index = self.indices[&w];
                    self.lowlinks.insert(v.clone(), v_lowlink.min(w_index));
                }
            }
        }

        // 如果 v 是 SCC 的根
        if self.lowlinks[&v] == self.indices[&v] {
            let mut scc = Vec::new();
            loop {
                let w = self.stack.pop().unwrap();
                self.on_stack.remove(&w);
                scc.push(w.clone());
                if w == v {
                    break;
                }
            }
            self.sccs.push(scc);
        }
    }
}
```

### 正确性证明

**定理 1**：Tarjan 算法正确地找到所有强连通分量。

**证明**：

**引理 1**：如果 \( v \) 和 \( w \) 在同一个 SCC 中，则它们有相同的 lowlink 值。

**证明**：

- 设 \( v \) 和 \( w \) 在同一个 SCC \( S \) 中
- 不失一般性，假设 \( v \) 先被访问
- 因为 \( v \) 和 \( w \) 在同一个 SCC 中，存在路径 \( v \rightsquigarrow w \) 和 \( w \rightsquigarrow v \)
- 当访问 \( w \) 时，\( v \) 仍在栈中（因为 \( v \rightsquigarrow w \)）
- 因此 \( \text{lowlink}[w] = \min(\text{lowlink}[w], \text{index}[v]) = \text{index}[v] \)
- 类似地，\( \text{lowlink}[v] = \text{index}[v] \)
- 因此它们有相同的 lowlink 值。∎

**引理 2**：如果 \( \text{lowlink}[v] = \text{index}[v] \)，则 \( v \) 是一个 SCC 的根。

**证明**：

- \( \text{lowlink}[v] = \text{index}[v] \) 意味着从 \( v \) 出发，不能到达索引更小的节点
- 因此 \( v \) 是其 SCC 中最先被访问的节点
- 即 \( v \) 是 SCC 的根。∎

**定理 1 的证明**：

结合引理 1 和引理 2，当 \( \text{lowlink}[v] = \text{index}[v] \) 时，栈中从 \( v \) 到栈顶的所有节点构成一个 SCC。∎

### 复杂度分析

**时间复杂度**：\( O(|V| + |E|) \)

**证明**：

- 每个节点被访问一次：\( O(|V|) \)
- 每条边被检查一次：\( O(|E|) \)
- 总时间：\( O(|V| + |E|) \)

**空间复杂度**：\( O(|V|) \)

**证明**：

- 栈的最大深度：\( O(|V|) \)
- 哈希表：\( O(|V|) \)
- 总空间：\( O(|V|) \)

## Span 完整性检测算法

### 算法描述1

**问题**：给定一组 Span，检测 Trace 是否完整（所有引用的父 Span 都存在）。

**算法**：

```rust
use std::collections::{HashMap, HashSet};

/// Span 完整性检测器
pub struct SpanCompletenessDetector {
    /// Span ID -> Span
    spans: HashMap<Vec<u8>, Span>,
    /// 已知的 Span ID
    known_spans: HashSet<Vec<u8>>,
    /// 引用的父 Span ID
    referenced_parents: HashSet<Vec<u8>>,
}

impl SpanCompletenessDetector {
    pub fn new() -> Self {
        Self {
            spans: HashMap::new(),
            known_spans: HashSet::new(),
            referenced_parents: HashSet::new(),
        }
    }

    /// 添加 Span
    pub fn add_span(&mut self, span: Span) {
        let span_id = span.span_id.clone();
        self.known_spans.insert(span_id.clone());

        if let Some(parent_id) = &span.parent_span_id {
            self.referenced_parents.insert(parent_id.clone());
        }

        self.spans.insert(span_id, span);
    }

    /// 检查完整性
    pub fn is_complete(&self) -> bool {
        // 所有引用的父 Span 都存在
        self.referenced_parents.is_subset(&self.known_spans)
    }

    /// 获取缺失的 Span
    pub fn get_missing_spans(&self) -> Vec<Vec<u8>> {
        self.referenced_parents
            .difference(&self.known_spans)
            .cloned()
            .collect()
    }
}

#[derive(Clone)]
struct Span {
    span_id: Vec<u8>,
    parent_span_id: Option<Vec<u8>>,
}
```

### 正确性证明1

**定理 2**：算法正确地检测 Span 完整性。

**证明**：

**定义**：Trace 是完整的当且仅当：

\[
\forall s \in \text{Spans}: s.\text{parent\_span\_id} \neq \bot \Rightarrow \exists s' \in \text{Spans}: s'.\text{span\_id} = s.\text{parent\_span\_id}
\]

**算法正确性**：

算法维护两个集合：

- \( K = \) 已知的 Span ID
- \( R = \) 引用的父 Span ID

算法返回 `true` 当且仅当 \( R \subseteq K \)。

**充分性**：如果 \( R \subseteq K \)，则所有引用的父 Span 都存在，Trace 完整。

**必要性**：如果 Trace 完整，则所有引用的父 Span 都存在，因此 \( R \subseteq K \)。

综上，算法正确。∎

## 采样算法

### 概率采样

**算法**：以概率 \( p \) 采样每个 Trace。

```rust
use rand::Rng;

/// 概率采样器
pub struct ProbabilitySampler {
    probability: f64,
}

impl ProbabilitySampler {
    pub fn new(probability: f64) -> Self {
        assert!(0.0 <= probability && probability <= 1.0);
        Self { probability }
    }

    /// 决定是否采样
    pub fn should_sample(&self) -> bool {
        let mut rng = rand::thread_rng();
        rng.gen::<f64>() < self.probability
    }
}
```

### 自适应采样

**算法**：根据系统负载动态调整采样率。

```rust
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::Arc;

/// 自适应采样器
pub struct AdaptiveSampler {
    /// 目标采样率（spans/秒）
    target_rate: f64,
    /// 当前采样概率
    probability: Arc<AtomicU64>,
    /// 最近一秒的 Span 数
    recent_spans: Arc<AtomicU64>,
}

impl AdaptiveSampler {
    pub fn new(target_rate: f64) -> Self {
        Self {
            target_rate,
            probability: Arc::new(AtomicU64::new(f64::to_bits(1.0))),
            recent_spans: Arc::new(AtomicU64::new(0)),
        }
    }

    /// 决定是否采样
    pub fn should_sample(&self) -> bool {
        let count = self.recent_spans.fetch_add(1, Ordering::Relaxed);
        let prob = f64::from_bits(self.probability.load(Ordering::Relaxed));

        let mut rng = rand::thread_rng();
        let sample = rng.gen::<f64>() < prob;

        // 每 1000 个 Span 调整一次概率
        if count % 1000 == 0 {
            self.adjust_probability(count);
        }

        sample
    }

    /// 调整采样概率
    fn adjust_probability(&self, count: u64) {
        let current_rate = count as f64; // 简化：假设 1 秒
        let prob = f64::from_bits(self.probability.load(Ordering::Relaxed));

        // 新概率 = 旧概率 * (目标速率 / 当前速率)
        let new_prob = (prob * self.target_rate / current_rate).clamp(0.0, 1.0);

        self.probability
            .store(f64::to_bits(new_prob), Ordering::Relaxed);
        self.recent_spans.store(0, Ordering::Relaxed);
    }
}
```

### 正确性证明2

**定理 3**：概率采样器的采样率收敛到目标采样率。

**证明**：

设：

- \( p_n \) = 第 \( n \) 次调整后的采样概率
- \( r_n \) = 第 \( n \) 个时间窗口的实际速率
- \( r^* \) = 目标速率

调整公式：

\[
p_{n+1} = p_n \cdot \frac{r^*}{r_n}
\]

期望速率：

\[
\mathbb{E}[r_n] = \text{总速率} \cdot p_n
\]

代入调整公式：

\[
p_{n+1} = p_n \cdot \frac{r^*}{\text{总速率} \cdot p_n} = \frac{r^*}{\text{总速率}}
\]

因此，采样概率收敛到 \( \frac{r^*}{\text{总速率}} \)，使得采样率收敛到 \( r^* \)。∎

## 批处理算法

### 算法描述3

**问题**：将 Span 分批发送，满足以下约束：

- 批次大小 \( \leq \) MaxBatchSize
- 批次年龄 \( \leq \) MaxBatchAge

**算法**：

```rust
use std::time::{Duration, Instant};

/// 批处理器
pub struct Batcher {
    /// 当前批次
    batch: Vec<Span>,
    /// 批次开始时间
    batch_start: Option<Instant>,
    /// 最大批次大小
    max_batch_size: usize,
    /// 最大批次年龄
    max_batch_age: Duration,
}

impl Batcher {
    pub fn new(max_batch_size: usize, max_batch_age: Duration) -> Self {
        Self {
            batch: Vec::new(),
            batch_start: None,
            max_batch_size,
            max_batch_age,
        }
    }

    /// 添加 Span
    pub fn add(&mut self, span: Span) -> Option<Vec<Span>> {
        // 初始化批次开始时间
        if self.batch_start.is_none() {
            self.batch_start = Some(Instant::now());
        }

        self.batch.push(span);

        // 检查是否需要刷新
        if self.should_flush() {
            self.flush()
        } else {
            None
        }
    }

    /// 检查是否应该刷新
    fn should_flush(&self) -> bool {
        // 批次大小达到上限
        if self.batch.len() >= self.max_batch_size {
            return true;
        }

        // 批次年龄达到上限
        if let Some(start) = self.batch_start {
            if start.elapsed() >= self.max_batch_age {
                return true;
            }
        }

        false
    }

    /// 刷新批次
    fn flush(&mut self) -> Option<Vec<Span>> {
        if self.batch.is_empty() {
            return None;
        }

        let batch = std::mem::take(&mut self.batch);
        self.batch_start = None;
        Some(batch)
    }
}
```

### 正确性证明3

**定理 4**：批处理算法满足约束条件。

**证明**：

**约束 1**：批次大小 \( \leq \) MaxBatchSize

当 `batch.len() >= max_batch_size` 时，`should_flush()` 返回 `true`，触发刷新。因此批次大小不会超过 MaxBatchSize。

**约束 2**：批次年龄 \( \leq \) MaxBatchAge

当 `batch_start.elapsed() >= max_batch_age` 时，`should_flush()` 返回 `true`，触发刷新。因此批次年龄不会超过 MaxBatchAge。

综上，算法满足约束条件。∎

## 重试算法

### 指数退避算法

**算法**：使用指数退避策略重试失败的请求。

```rust
use std::time::Duration;
use rand::Rng;

/// 指数退避重试器
pub struct ExponentialBackoff {
    /// 初始退避时间
    initial_backoff: Duration,
    /// 最大退避时间
    max_backoff: Duration,
    /// 退避倍数
    multiplier: f64,
    /// 当前重试次数
    retries: usize,
    /// 最大重试次数
    max_retries: usize,
}

impl ExponentialBackoff {
    pub fn new(
        initial_backoff: Duration,
        max_backoff: Duration,
        multiplier: f64,
        max_retries: usize,
    ) -> Self {
        Self {
            initial_backoff,
            max_backoff,
            multiplier,
            retries: 0,
            max_retries,
        }
    }

    /// 获取下一次重试的退避时间
    pub fn next_backoff(&mut self) -> Option<Duration> {
        if self.retries >= self.max_retries {
            return None;
        }

        let backoff = self.calculate_backoff();
        self.retries += 1;
        Some(backoff)
    }

    /// 计算退避时间
    fn calculate_backoff(&self) -> Duration {
        let base = self.initial_backoff.as_millis() as f64;
        let backoff = base * self.multiplier.powi(self.retries as i32);
        let backoff = backoff.min(self.max_backoff.as_millis() as f64);

        // 添加抖动（jitter）：± 25%
        let mut rng = rand::thread_rng();
        let jitter = rng.gen_range(0.75..=1.25);
        let backoff = (backoff * jitter) as u64;

        Duration::from_millis(backoff)
    }

    /// 重置重试计数
    pub fn reset(&mut self) {
        self.retries = 0;
    }
}
```

### 正确性证明4

**定理 5**：指数退避算法的退避时间有上界。

**证明**：

退避时间计算公式：

\[
t_n = \min(\text{initial} \times \text{multiplier}^n, \text{max})
\]

因为有 \( \min \) 操作，\( t_n \leq \text{max} \)。

因此退避时间有上界 \( \text{max} \)。∎

**定理 6**：指数退避算法最终会停止重试。

**证明**：

重试次数有上界 \( \text{max\_retries} \)。

当 \( n \geq \text{max\_retries} \) 时，`next_backoff()` 返回 `None`，停止重试。

因此算法最终会停止。∎

## 聚合算法

### 时间窗口聚合

**问题**：在滑动时间窗口内聚合指标。

**算法**：

```rust
use std::collections::VecDeque;
use std::time::{Duration, Instant};

/// 滑动窗口聚合器
pub struct SlidingWindowAggregator {
    /// 窗口大小
    window_size: Duration,
    /// 数据点：(时间戳, 值)
    data: VecDeque<(Instant, f64)>,
}

impl SlidingWindowAggregator {
    pub fn new(window_size: Duration) -> Self {
        Self {
            window_size,
            data: VecDeque::new(),
        }
    }

    /// 添加数据点
    pub fn add(&mut self, value: f64) {
        let now = Instant::now();
        self.data.push_back((now, value));
        self.evict_old_data(now);
    }

    /// 驱逐过期数据
    fn evict_old_data(&mut self, now: Instant) {
        while let Some((timestamp, _)) = self.data.front() {
            if now.duration_since(*timestamp) > self.window_size {
                self.data.pop_front();
            } else {
                break;
            }
        }
    }

    /// 计算平均值
    pub fn average(&self) -> f64 {
        if self.data.is_empty() {
            return 0.0;
        }

        let sum: f64 = self.data.iter().map(|(_, v)| v).sum();
        sum / self.data.len() as f64
    }

    /// 计算总和
    pub fn sum(&self) -> f64 {
        self.data.iter().map(|(_, v)| v).sum()
    }

    /// 计算最大值
    pub fn max(&self) -> Option<f64> {
        self.data.iter().map(|(_, v)| v).max_by(|a, b| a.partial_cmp(b).unwrap()).copied()
    }
}
```

### 正确性证明5

**定理 7**：滑动窗口聚合器只包含窗口内的数据。

**证明**：

**不变量**：\( \forall (t, v) \in \text{data}: \text{now} - t \leq \text{window\_size} \)

**归纳证明**：

**基础情况**：初始时 `data` 为空，不变量成立。

**归纳步骤**：假设不变量在添加数据点之前成立。

添加数据点 \( (t_{\text{now}}, v) \) 后：

- 新数据点满足：\( t_{\text{now}} - t_{\text{now}} = 0 \leq \text{window\_size} \)
- `evict_old_data()` 删除所有 \( t_{\text{now}} - t > \text{window\_size} \) 的数据点
- 因此不变量继续成立。

综上，不变量始终成立，算法正确。∎

## 参考文献

1. **Tarjan, R.** (1972). "Depth-First Search and Linear Graph Algorithms". *SIAM Journal on Computing*, 1(2), 146-160.

2. **Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C.** (2009). "Introduction to Algorithms" (3rd ed.). MIT Press.

3. **Vitter, J. S.** (1985). "Random Sampling with a Reservoir". *ACM Transactions on Mathematical Software*, 11(1), 37-57.

4. **AWS Architecture Blog** - "Exponential Backoff and Jitter": <https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/>

---

*本文档提供了 OTLP 系统中关键算法的形式化正确性证明，确保算法在理论上是正确和高效的。*
