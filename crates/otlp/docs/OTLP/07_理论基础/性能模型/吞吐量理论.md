# ååé‡ç†è®º

## ç›®å½•

- [ååé‡ç†è®º](#ååé‡ç†è®º)
  - [ç›®å½•](#ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
  - [ååé‡åŸºæœ¬å®šä¹‰](#ååé‡åŸºæœ¬å®šä¹‰)
    - [æ ¸å¿ƒæ¦‚å¿µ](#æ ¸å¿ƒæ¦‚å¿µ)
    - [ååé‡ä¸å»¶è¿Ÿçš„å…³ç³»](#ååé‡ä¸å»¶è¿Ÿçš„å…³ç³»)
  - [Amdahl å®šå¾‹](#amdahl-å®šå¾‹)
    - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
    - [æ¨å¯¼è¿‡ç¨‹](#æ¨å¯¼è¿‡ç¨‹)
    - [å®é™…åº”ç”¨](#å®é™…åº”ç”¨)
    - [Rust å®ç°ï¼šAmdahl å®šå¾‹è®¡ç®—å™¨](#rust-å®ç°amdahl-å®šå¾‹è®¡ç®—å™¨)
  - [é€šç”¨å¯æ‰©å±•æ€§å®šå¾‹ (USL)](#é€šç”¨å¯æ‰©å±•æ€§å®šå¾‹-usl)
    - [ç†è®ºæ¨¡å‹](#ç†è®ºæ¨¡å‹)
    - [å‚æ•°å«ä¹‰](#å‚æ•°å«ä¹‰)
    - [æ¨¡å‹æ‹Ÿåˆ](#æ¨¡å‹æ‹Ÿåˆ)
    - [Rust å®ç°ï¼šUSL æ¨¡å‹](#rust-å®ç°usl-æ¨¡å‹)
  - [Little å®šå¾‹](#little-å®šå¾‹)
    - [å®šå¾‹è¡¨è¿°](#å®šå¾‹è¡¨è¿°)
    - [è¯æ˜](#è¯æ˜)
    - [åº”ç”¨åœºæ™¯](#åº”ç”¨åœºæ™¯)
    - [Rust å®ç°ï¼šLittle å®šå¾‹åº”ç”¨](#rust-å®ç°little-å®šå¾‹åº”ç”¨)
  - [æ‰¹å¤„ç†ååé‡ä¼˜åŒ–](#æ‰¹å¤„ç†ååé‡ä¼˜åŒ–)
    - [æ‰¹å¤„ç†æ¨¡å‹](#æ‰¹å¤„ç†æ¨¡å‹)
    - [æœ€ä¼˜æ‰¹æ¬¡å¤§å°](#æœ€ä¼˜æ‰¹æ¬¡å¤§å°)
    - [åŠ¨æ€æ‰¹å¤„ç†](#åŠ¨æ€æ‰¹å¤„ç†)
    - [Rust å®ç°ï¼šè‡ªé€‚åº”æ‰¹å¤„ç†](#rust-å®ç°è‡ªé€‚åº”æ‰¹å¤„ç†)
  - [èƒŒå‹ä¸æµé‡æ§åˆ¶](#èƒŒå‹ä¸æµé‡æ§åˆ¶)
    - [èƒŒå‹æœºåˆ¶](#èƒŒå‹æœºåˆ¶)
    - [ä»¤ç‰Œæ¡¶ç®—æ³•](#ä»¤ç‰Œæ¡¶ç®—æ³•)
    - [æ¼æ¡¶ç®—æ³•](#æ¼æ¡¶ç®—æ³•)
    - [Rust å®ç°ï¼šä»¤ç‰Œæ¡¶é™æµå™¨](#rust-å®ç°ä»¤ç‰Œæ¡¶é™æµå™¨)
  - [OTLP ååé‡ä¼˜åŒ–å®è·µ](#otlp-ååé‡ä¼˜åŒ–å®è·µ)
    - [å¯¼å‡ºå™¨ååé‡ä¼˜åŒ–](#å¯¼å‡ºå™¨ååé‡ä¼˜åŒ–)
    - [æ”¶é›†å™¨ååé‡ä¼˜åŒ–](#æ”¶é›†å™¨ååé‡ä¼˜åŒ–)
    - [ç«¯åˆ°ç«¯ååé‡ç›‘æ§](#ç«¯åˆ°ç«¯ååé‡ç›‘æ§)
  - [å‚è€ƒæ–‡çŒ®](#å‚è€ƒæ–‡çŒ®)

## æ¦‚è¿°

ååé‡ï¼ˆThroughputï¼‰æ˜¯è¡¡é‡ç³»ç»Ÿå¤„ç†èƒ½åŠ›çš„å…³é”®æŒ‡æ ‡ï¼Œè¡¨ç¤ºå•ä½æ—¶é—´å†…ç³»ç»Ÿèƒ½å¤Ÿå¤„ç†çš„å·¥ä½œé‡ã€‚æœ¬æ–‡æ¡£ä»ç†è®ºè§’åº¦åˆ†æååé‡çš„æ•°å­¦æ¨¡å‹ã€å¯æ‰©å±•æ€§å®šå¾‹ã€ä¼˜åŒ–ç­–ç•¥ï¼Œå¹¶æä¾› OTLP ç³»ç»Ÿä¸­çš„å®é™…åº”ç”¨ã€‚

## ååé‡åŸºæœ¬å®šä¹‰

### æ ¸å¿ƒæ¦‚å¿µ

**ååé‡** (Throughput)ï¼šå•ä½æ—¶é—´å†…å®Œæˆçš„å·¥ä½œé‡

```text
X = N / T
```

å…¶ä¸­ï¼š

- `X`: ååé‡ï¼ˆè¯·æ±‚/ç§’ï¼Œspans/ç§’ç­‰ï¼‰
- `N`: å®Œæˆçš„å·¥ä½œæ•°é‡
- `T`: æ—¶é—´çª—å£

**é¥±å’Œååé‡** (Saturation Throughput)ï¼šç³»ç»Ÿåœ¨é¥±å’ŒçŠ¶æ€ä¸‹çš„æœ€å¤§ååé‡

```text
X_max = 1 / S
```

å…¶ä¸­ `S` æ˜¯æœåŠ¡æ—¶é—´ï¼ˆå¤„ç†å•ä¸ªè¯·æ±‚çš„å¹³å‡æ—¶é—´ï¼‰ã€‚

### ååé‡ä¸å»¶è¿Ÿçš„å…³ç³»

æ ¹æ® Little å®šå¾‹ï¼š

```text
L = Î» Ã— W
```

å…¶ä¸­ï¼š

- `L`: ç³»ç»Ÿä¸­çš„å¹³å‡è¯·æ±‚æ•°
- `Î»`: åˆ°è¾¾ç‡ï¼ˆååé‡ï¼‰
- `W`: å¹³å‡å“åº”æ—¶é—´ï¼ˆå»¶è¿Ÿï¼‰

**å…³é”®æ´å¯Ÿ**ï¼šåœ¨ç³»ç»Ÿæœªé¥±å’Œæ—¶ï¼Œå¢åŠ ååé‡ä¸ä¼šæ˜¾è‘—å¢åŠ å»¶è¿Ÿï¼›ä½†æ¥è¿‘é¥±å’Œç‚¹åï¼Œå»¶è¿Ÿä¼šæ€¥å‰§ä¸Šå‡ã€‚

## Amdahl å®šå¾‹

### ç†è®ºåŸºç¡€

**Amdahl å®šå¾‹**æè¿°äº†å¹¶è¡ŒåŒ–å¯¹ç³»ç»ŸåŠ é€Ÿæ¯”çš„ç†è®ºä¸Šé™ã€‚

è®¾ç¨‹åºä¸­å¯å¹¶è¡Œéƒ¨åˆ†å æ¯”ä¸º `p`ï¼Œä¸²è¡Œéƒ¨åˆ†å æ¯”ä¸º `1-p`ï¼Œä½¿ç”¨ `N` ä¸ªå¤„ç†å™¨æ—¶çš„åŠ é€Ÿæ¯”ä¸ºï¼š

```text
S(N) = 1 / ((1-p) + p/N)
```

### æ¨å¯¼è¿‡ç¨‹

åŸå§‹æ‰§è¡Œæ—¶é—´ï¼š`T_1 = T_serial + T_parallel`

å¹¶è¡Œæ‰§è¡Œæ—¶é—´ï¼š`T_N = T_serial + T_parallel/N`

åŠ é€Ÿæ¯”ï¼š

```text
S(N) = T_1 / T_N 
     = (T_serial + T_parallel) / (T_serial + T_parallel/N)
     = 1 / ((T_serial/T_1) + (T_parallel/T_1)/N)
     = 1 / ((1-p) + p/N)
```

### å®é™…åº”ç”¨

**æé™æƒ…å†µ**ï¼š

å½“ `N â†’ âˆ` æ—¶ï¼š

```text
S(âˆ) = 1 / (1-p)
```

**ç¤ºä¾‹**ï¼šå¦‚æœç¨‹åº 95% å¯å¹¶è¡Œï¼ˆp=0.95ï¼‰ï¼Œåˆ™ï¼š

- ç†è®ºæœ€å¤§åŠ é€Ÿæ¯”ï¼š`S(âˆ) = 1/0.05 = 20x`
- ä½¿ç”¨ 10 ä¸ªæ ¸å¿ƒï¼š`S(10) = 1/(0.05 + 0.095) â‰ˆ 6.9x`
- ä½¿ç”¨ 100 ä¸ªæ ¸å¿ƒï¼š`S(100) = 1/(0.05 + 0.0095) â‰ˆ 16.8x`

### Rust å®ç°ï¼šAmdahl å®šå¾‹è®¡ç®—å™¨

```rust
/// Amdahl å®šå¾‹è®¡ç®—å™¨
pub struct AmdahlCalculator {
    /// å¯å¹¶è¡Œéƒ¨åˆ†å æ¯” (0.0 - 1.0)
    parallel_fraction: f64,
}

impl AmdahlCalculator {
    pub fn new(parallel_fraction: f64) -> Self {
        assert!(
            (0.0..=1.0).contains(&parallel_fraction),
            "Parallel fraction must be between 0 and 1"
        );
        Self { parallel_fraction }
    }

    /// è®¡ç®—åŠ é€Ÿæ¯”
    pub fn speedup(&self, num_processors: usize) -> f64 {
        let n = num_processors as f64;
        let p = self.parallel_fraction;
        1.0 / ((1.0 - p) + p / n)
    }

    /// è®¡ç®—ç†è®ºæœ€å¤§åŠ é€Ÿæ¯”
    pub fn max_speedup(&self) -> f64 {
        1.0 / (1.0 - self.parallel_fraction)
    }

    /// è®¡ç®—æ•ˆç‡ï¼ˆåŠ é€Ÿæ¯”/å¤„ç†å™¨æ•°ï¼‰
    pub fn efficiency(&self, num_processors: usize) -> f64 {
        self.speedup(num_processors) / (num_processors as f64)
    }

    /// ç”ŸæˆåŠ é€Ÿæ¯”æ›²çº¿
    pub fn speedup_curve(&self, max_processors: usize) -> Vec<(usize, f64)> {
        (1..=max_processors)
            .map(|n| (n, self.speedup(n)))
            .collect()
    }

    /// åˆ†ææŠ¥å‘Š
    pub fn report(&self, num_processors: usize) {
        println!("=== Amdahl's Law Analysis ===");
        println!("Parallel Fraction: {:.1}%", self.parallel_fraction * 100.0);
        println!("Serial Fraction:   {:.1}%", (1.0 - self.parallel_fraction) * 100.0);
        println!();
        println!("Processors | Speedup | Efficiency");
        println!("-----------|---------|------------");

        for n in [1, 2, 4, 8, 16, 32, 64, 128].iter() {
            if *n <= num_processors {
                let speedup = self.speedup(*n);
                let efficiency = self.efficiency(*n);
                println!(
                    "{:>10} | {:>7.2}x | {:>9.1}%",
                    n,
                    speedup,
                    efficiency * 100.0
                );
            }
        }

        println!();
        println!("Theoretical Maximum Speedup: {:.2}x", self.max_speedup());
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_amdahl_law() {
        let calc = AmdahlCalculator::new(0.95);
        
        // å•æ ¸ï¼šåŠ é€Ÿæ¯”ä¸º 1
        assert!((calc.speedup(1) - 1.0).abs() < 0.001);
        
        // æ— é™æ ¸å¿ƒï¼šæ¥è¿‘ç†è®ºæœ€å¤§å€¼
        assert!((calc.speedup(10000) - 20.0).abs() < 0.1);
        
        // æ•ˆç‡éšæ ¸å¿ƒæ•°ä¸‹é™
        assert!(calc.efficiency(1) > calc.efficiency(10));
    }
}
```

## é€šç”¨å¯æ‰©å±•æ€§å®šå¾‹ (USL)

### ç†è®ºæ¨¡å‹

**USL (Universal Scalability Law)** ç”± Neil Gunther æå‡ºï¼Œæ‰©å±•äº† Amdahl å®šå¾‹ï¼Œè€ƒè™‘äº†ä¸€è‡´æ€§å¼€é”€ï¼ˆcoherency costï¼‰ã€‚

```text
X(N) = Î» Ã— N / (1 + Ïƒ(N-1) + ÎºN(N-1))
```

å…¶ä¸­ï¼š

- `X(N)`: N ä¸ªå¤„ç†å™¨æ—¶çš„ååé‡
- `Î»`: å•å¤„ç†å™¨ååé‡
- `Ïƒ`: ä¸²è¡ŒåŒ–ç³»æ•°ï¼ˆserialization coefficientï¼‰
- `Îº`: ä¸€è‡´æ€§ç³»æ•°ï¼ˆcoherency coefficientï¼‰
- `N`: å¤„ç†å™¨æ•°é‡

### å‚æ•°å«ä¹‰

1. **ä¸²è¡ŒåŒ–ç³»æ•° Ïƒ**ï¼š
   - è¡¨ç¤ºèµ„æºäº‰ç”¨å¯¼è‡´çš„æ€§èƒ½æŸå¤±
   - å¯¹åº” Amdahl å®šå¾‹ä¸­çš„ä¸²è¡Œéƒ¨åˆ†
   - å…¸å‹å€¼ï¼š0.01 - 0.1

2. **ä¸€è‡´æ€§ç³»æ•° Îº**ï¼š
   - è¡¨ç¤ºè·¨å¤„ç†å™¨é€šä¿¡/åŒæ­¥å¼€é”€
   - éšå¤„ç†å™¨æ•°é‡äºŒæ¬¡å¢é•¿
   - å…¸å‹å€¼ï¼š0.0001 - 0.01

### æ¨¡å‹æ‹Ÿåˆ

ç»™å®šå®éªŒæ•°æ® `{(Nâ‚, Xâ‚), (Nâ‚‚, Xâ‚‚), ..., (Nâ‚˜, Xâ‚˜)}`ï¼Œä½¿ç”¨æœ€å°äºŒä¹˜æ³•æ‹Ÿåˆå‚æ•° `Ïƒ` å’Œ `Îº`ã€‚

### Rust å®ç°ï¼šUSL æ¨¡å‹

```rust
use std::f64;

/// é€šç”¨å¯æ‰©å±•æ€§å®šå¾‹æ¨¡å‹
#[derive(Debug, Clone)]
pub struct USLModel {
    /// å•å¤„ç†å™¨ååé‡
    lambda: f64,
    /// ä¸²è¡ŒåŒ–ç³»æ•°
    sigma: f64,
    /// ä¸€è‡´æ€§ç³»æ•°
    kappa: f64,
}

impl USLModel {
    /// åˆ›å»º USL æ¨¡å‹
    pub fn new(lambda: f64, sigma: f64, kappa: f64) -> Self {
        Self {
            lambda,
            sigma,
            kappa,
        }
    }

    /// ä»å®éªŒæ•°æ®æ‹Ÿåˆæ¨¡å‹ï¼ˆç®€åŒ–å®ç°ï¼‰
    pub fn fit(data: &[(usize, f64)]) -> Self {
        // ç®€åŒ–ï¼šä½¿ç”¨å‰ä¸‰ä¸ªæ•°æ®ç‚¹æ±‚è§£
        // ç”Ÿäº§ç¯å¢ƒåº”ä½¿ç”¨éçº¿æ€§æœ€å°äºŒä¹˜æ³•ï¼ˆå¦‚ Levenberg-Marquardtï¼‰
        
        if data.len() < 3 {
            panic!("Need at least 3 data points for fitting");
        }

        let lambda = data[0].1; // å•å¤„ç†å™¨ååé‡

        // ç®€åŒ–çš„å‚æ•°ä¼°è®¡
        let sigma = 0.05; // é»˜è®¤å€¼ï¼Œå®é™…åº”é€šè¿‡ä¼˜åŒ–æ±‚è§£
        let kappa = 0.001;

        Self::new(lambda, sigma, kappa)
    }

    /// é¢„æµ‹ N ä¸ªå¤„ç†å™¨æ—¶çš„ååé‡
    pub fn throughput(&self, n: usize) -> f64 {
        let n_f64 = n as f64;
        let numerator = self.lambda * n_f64;
        let denominator = 1.0 + self.sigma * (n_f64 - 1.0) + self.kappa * n_f64 * (n_f64 - 1.0);
        numerator / denominator
    }

    /// è®¡ç®—åŠ é€Ÿæ¯”
    pub fn speedup(&self, n: usize) -> f64 {
        self.throughput(n) / self.lambda
    }

    /// æ‰¾åˆ°æœ€ä¼˜å¤„ç†å™¨æ•°é‡
    pub fn optimal_processors(&self, max_n: usize) -> (usize, f64) {
        (1..=max_n)
            .map(|n| (n, self.throughput(n)))
            .max_by(|a, b| a.1.partial_cmp(&b.1).unwrap())
            .unwrap()
    }

    /// åˆ¤æ–­æ˜¯å¦å­˜åœ¨é€€è¡ŒåŒºåŸŸï¼ˆretrograde regionï¼‰
    pub fn has_retrograde(&self) -> bool {
        self.kappa > 0.0
    }

    /// è®¡ç®—é€€è¡Œç‚¹ï¼ˆååé‡å¼€å§‹ä¸‹é™çš„ç‚¹ï¼‰
    pub fn retrograde_point(&self) -> Option<usize> {
        if !self.has_retrograde() {
            return None;
        }

        // æ±‚å¯¼æ•°ä¸º 0 çš„ç‚¹
        let n_critical = ((1.0 - self.sigma) / (2.0 * self.kappa)).sqrt();
        
        if n_critical > 1.0 {
            Some(n_critical.ceil() as usize)
        } else {
            None
        }
    }

    /// ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
    pub fn report(&self, max_processors: usize) {
        println!("=== Universal Scalability Law Analysis ===");
        println!("Î» (single-processor throughput): {:.2}", self.lambda);
        println!("Ïƒ (serialization coefficient):  {:.4}", self.sigma);
        println!("Îº (coherency coefficient):       {:.6}", self.kappa);
        println!();

        if let Some(retro) = self.retrograde_point() {
            println!("âš ï¸  Retrograde point at N = {} processors", retro);
            println!("   (Performance degrades beyond this point)\n");
        }

        let (optimal_n, optimal_throughput) = self.optimal_processors(max_processors);
        println!("Optimal Configuration: {} processors", optimal_n);
        println!("Maximum Throughput:    {:.2}", optimal_throughput);
        println!();

        println!("N    | Throughput | Speedup | Efficiency");
        println!("-----|------------|---------|------------");

        for n in [1, 2, 4, 8, 16, 32, 64, 128].iter() {
            if *n <= max_processors {
                let throughput = self.throughput(*n);
                let speedup = self.speedup(*n);
                let efficiency = speedup / (*n as f64);

                println!(
                    "{:>4} | {:>10.2} | {:>7.2}x | {:>9.1}%",
                    n,
                    throughput,
                    speedup,
                    efficiency * 100.0
                );
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_usl_model() {
        let model = USLModel::new(100.0, 0.05, 0.001);
        
        // å•å¤„ç†å™¨ååé‡
        assert!((model.throughput(1) - 100.0).abs() < 0.1);
        
        // ååé‡éšå¤„ç†å™¨æ•°å¢åŠ 
        assert!(model.throughput(2) > model.throughput(1));
        
        // å­˜åœ¨é€€è¡ŒåŒºåŸŸ
        assert!(model.has_retrograde());
    }
}
```

## Little å®šå¾‹

### å®šå¾‹è¡¨è¿°

**Little å®šå¾‹**æ˜¯æ’é˜Ÿè®ºä¸­çš„åŸºæœ¬å®šå¾‹ï¼Œé€‚ç”¨äºä»»ä½•ç¨³å®šç³»ç»Ÿï¼š

```text
L = Î» Ã— W
```

å…¶ä¸­ï¼š

- `L`: ç³»ç»Ÿä¸­çš„å¹³å‡è¯·æ±‚æ•°ï¼ˆé˜Ÿåˆ—é•¿åº¦ï¼‰
- `Î»`: å¹³å‡åˆ°è¾¾ç‡ï¼ˆååé‡ï¼‰
- `W`: å¹³å‡å“åº”æ—¶é—´

### è¯æ˜

è€ƒè™‘æ—¶é—´åŒºé—´ `[0, T]`ï¼š

è®¾åœ¨æ­¤æœŸé—´ï¼š

- åˆ°è¾¾çš„è¯·æ±‚æ•°ï¼š`A(T)`
- å®Œæˆçš„è¯·æ±‚æ•°ï¼š`C(T)`
- ç´¯è®¡åœç•™æ—¶é—´ï¼š`âˆ‘Wáµ¢`

åˆ™ï¼š

```text
L = lim(Tâ†’âˆ) (âˆ‘Wáµ¢) / T
Î» = lim(Tâ†’âˆ) A(T) / T
W = lim(Tâ†’âˆ) (âˆ‘Wáµ¢) / A(T)
```

å› æ­¤ï¼š

```text
L = (âˆ‘Wáµ¢) / T = (A(T) / T) Ã— (âˆ‘Wáµ¢ / A(T)) = Î» Ã— W
```

### åº”ç”¨åœºæ™¯

1. **å®¹é‡è§„åˆ’**ï¼šç»™å®šç›®æ ‡å»¶è¿Ÿå’Œé¢„æœŸååé‡ï¼Œè®¡ç®—æ‰€éœ€å¹¶å‘æ•°
2. **æ€§èƒ½åˆ†æ**ï¼šé€šè¿‡ç›‘æ§é˜Ÿåˆ—é•¿åº¦å’Œååé‡ï¼Œæ¨ç®—å¹³å‡å»¶è¿Ÿ
3. **ç“¶é¢ˆè¯†åˆ«**ï¼šé˜Ÿåˆ—é•¿åº¦æŒç»­å¢é•¿è¡¨æ˜ç³»ç»Ÿæ¥è¿‘é¥±å’Œ

### Rust å®ç°ï¼šLittle å®šå¾‹åº”ç”¨

```rust
use std::time::Duration;

/// Little å®šå¾‹è®¡ç®—å™¨
pub struct LittleLawCalculator;

impl LittleLawCalculator {
    /// è®¡ç®—å¹³å‡é˜Ÿåˆ—é•¿åº¦
    /// L = Î» Ã— W
    pub fn queue_length(arrival_rate: f64, avg_response_time: Duration) -> f64 {
        arrival_rate * avg_response_time.as_secs_f64()
    }

    /// è®¡ç®—æ‰€éœ€ååé‡
    /// Î» = L / W
    pub fn required_throughput(queue_length: f64, avg_response_time: Duration) -> f64 {
        queue_length / avg_response_time.as_secs_f64()
    }

    /// è®¡ç®—å¹³å‡å“åº”æ—¶é—´
    /// W = L / Î»
    pub fn avg_response_time(queue_length: f64, arrival_rate: f64) -> Duration {
        Duration::from_secs_f64(queue_length / arrival_rate)
    }

    /// å®¹é‡è§„åˆ’ï¼šè®¡ç®—æ‰€éœ€å¹¶å‘æ•°
    pub fn required_concurrency(
        target_throughput: f64,
        avg_service_time: Duration,
    ) -> usize {
        let concurrency = target_throughput * avg_service_time.as_secs_f64();
        concurrency.ceil() as usize
    }

    /// åˆ†æç³»ç»ŸçŠ¶æ€
    pub fn analyze(
        queue_length: f64,
        arrival_rate: f64,
        service_rate: f64,
    ) -> SystemAnalysis {
        let utilization = arrival_rate / service_rate;
        let avg_response_time = queue_length / arrival_rate;
        let avg_wait_time = avg_response_time - (1.0 / service_rate);

        SystemAnalysis {
            queue_length,
            arrival_rate,
            service_rate,
            utilization,
            avg_response_time: Duration::from_secs_f64(avg_response_time),
            avg_wait_time: Duration::from_secs_f64(avg_wait_time.max(0.0)),
            is_stable: utilization < 1.0,
        }
    }
}

#[derive(Debug)]
pub struct SystemAnalysis {
    pub queue_length: f64,
    pub arrival_rate: f64,
    pub service_rate: f64,
    pub utilization: f64,
    pub avg_response_time: Duration,
    pub avg_wait_time: Duration,
    pub is_stable: bool,
}

impl SystemAnalysis {
    pub fn report(&self) {
        println!("=== System Analysis (Little's Law) ===");
        println!("Queue Length (L):       {:.2}", self.queue_length);
        println!("Arrival Rate (Î»):       {:.2} req/s", self.arrival_rate);
        println!("Service Rate (Î¼):       {:.2} req/s", self.service_rate);
        println!("Utilization (Ï):        {:.1}%", self.utilization * 100.0);
        println!("Avg Response Time (W):  {:?}", self.avg_response_time);
        println!("Avg Wait Time:          {:?}", self.avg_wait_time);
        println!("System Stable:          {}", if self.is_stable { "âœ“" } else { "âœ—" });

        if self.utilization > 0.8 {
            println!("\nâš ï¸  Warning: High utilization (>80%)");
            println!("   Consider scaling up to avoid saturation");
        }

        if !self.is_stable {
            println!("\nğŸš¨ Critical: System is unstable!");
            println!("   Arrival rate exceeds service rate");
        }
    }
}
```

## æ‰¹å¤„ç†ååé‡ä¼˜åŒ–

### æ‰¹å¤„ç†æ¨¡å‹

æ‰¹å¤„ç†é€šè¿‡å‡å°‘å›ºå®šå¼€é”€æ¥æé«˜ååé‡ï¼š

```text
T_batch(b) = T_fixed + b Ã— T_per_item
```

ååé‡ï¼š

```text
X(b) = b / T_batch(b) = b / (T_fixed + b Ã— T_per_item)
```

### æœ€ä¼˜æ‰¹æ¬¡å¤§å°

åœ¨å»¶è¿Ÿçº¦æŸä¸‹æœ€å¤§åŒ–ååé‡ï¼š

```text
maximize:   X(b) = b / (T_fixed + b Ã— T_per_item)
subject to: T_batch(b) â‰¤ L_max
```

### åŠ¨æ€æ‰¹å¤„ç†

æ ¹æ®ç³»ç»Ÿè´Ÿè½½åŠ¨æ€è°ƒæ•´æ‰¹æ¬¡å¤§å°ï¼š

- **ä½è´Ÿè½½**ï¼šå°æ‰¹æ¬¡ï¼Œé™ä½å»¶è¿Ÿ
- **é«˜è´Ÿè½½**ï¼šå¤§æ‰¹æ¬¡ï¼Œæé«˜ååé‡

### Rust å®ç°ï¼šè‡ªé€‚åº”æ‰¹å¤„ç†

```rust
use std::time::{Duration, Instant};
use tokio::sync::mpsc;

/// è‡ªé€‚åº”æ‰¹å¤„ç†å™¨
pub struct AdaptiveBatcher<T> {
    /// æœ€å°æ‰¹æ¬¡å¤§å°
    min_batch_size: usize,
    /// æœ€å¤§æ‰¹æ¬¡å¤§å°
    max_batch_size: usize,
    /// æœ€å¤§ç­‰å¾…æ—¶é—´
    max_wait_time: Duration,
    /// å½“å‰æ‰¹æ¬¡
    current_batch: Vec<T>,
    /// æ‰¹æ¬¡å¼€å§‹æ—¶é—´
    batch_start: Option<Instant>,
    /// ååé‡ç»Ÿè®¡
    throughput_tracker: ThroughputTracker,
}

impl<T> AdaptiveBatcher<T> {
    pub fn new(
        min_batch_size: usize,
        max_batch_size: usize,
        max_wait_time: Duration,
    ) -> Self {
        Self {
            min_batch_size,
            max_batch_size,
            max_wait_time,
            current_batch: Vec::with_capacity(max_batch_size),
            batch_start: None,
            throughput_tracker: ThroughputTracker::new(),
        }
    }

    /// æ·»åŠ é¡¹åˆ°æ‰¹æ¬¡
    pub fn add(&mut self, item: T) -> Option<Vec<T>> {
        if self.current_batch.is_empty() {
            self.batch_start = Some(Instant::now());
        }

        self.current_batch.push(item);

        // æ£€æŸ¥æ˜¯å¦åº”è¯¥åˆ·æ–°æ‰¹æ¬¡
        if self.should_flush() {
            self.flush()
        } else {
            None
        }
    }

    /// åˆ¤æ–­æ˜¯å¦åº”è¯¥åˆ·æ–°
    fn should_flush(&self) -> bool {
        // è¾¾åˆ°æœ€å¤§æ‰¹æ¬¡å¤§å°
        if self.current_batch.len() >= self.max_batch_size {
            return true;
        }

        // è¾¾åˆ°æœ€å¤§ç­‰å¾…æ—¶é—´
        if let Some(start) = self.batch_start {
            if start.elapsed() >= self.max_wait_time {
                return self.current_batch.len() >= self.min_batch_size;
            }
        }

        false
    }

    /// åˆ·æ–°å½“å‰æ‰¹æ¬¡
    pub fn flush(&mut self) -> Option<Vec<T>> {
        if self.current_batch.is_empty() {
            return None;
        }

        let batch = std::mem::replace(
            &mut self.current_batch,
            Vec::with_capacity(self.max_batch_size),
        );

        let batch_size = batch.len();
        self.batch_start = None;

        // æ›´æ–°ååé‡ç»Ÿè®¡
        self.throughput_tracker.record_batch(batch_size);

        Some(batch)
    }

    /// è·å–å½“å‰ååé‡
    pub fn throughput(&self) -> f64 {
        self.throughput_tracker.throughput()
    }

    /// è‡ªé€‚åº”è°ƒæ•´æ‰¹æ¬¡å¤§å°
    pub fn adapt(&mut self) {
        let throughput = self.throughput();
        
        // ç®€åŒ–çš„è‡ªé€‚åº”ç­–ç•¥
        if throughput > 1000.0 && self.max_batch_size < 10000 {
            // é«˜ååé‡ï¼šå¢åŠ æ‰¹æ¬¡å¤§å°
            self.max_batch_size = (self.max_batch_size * 2).min(10000);
        } else if throughput < 100.0 && self.max_batch_size > 100 {
            // ä½ååé‡ï¼šå‡å°‘æ‰¹æ¬¡å¤§å°
            self.max_batch_size = (self.max_batch_size / 2).max(100);
        }
    }
}

/// ååé‡è¿½è¸ªå™¨
struct ThroughputTracker {
    total_items: usize,
    start_time: Instant,
}

impl ThroughputTracker {
    fn new() -> Self {
        Self {
            total_items: 0,
            start_time: Instant::now(),
        }
    }

    fn record_batch(&mut self, size: usize) {
        self.total_items += size;
    }

    fn throughput(&self) -> f64 {
        let elapsed = self.start_time.elapsed().as_secs_f64();
        if elapsed > 0.0 {
            self.total_items as f64 / elapsed
        } else {
            0.0
        }
    }
}
```

## èƒŒå‹ä¸æµé‡æ§åˆ¶

### èƒŒå‹æœºåˆ¶

**èƒŒå‹** (Backpressure) æ˜¯ä¸€ç§æµé‡æ§åˆ¶æœºåˆ¶ï¼Œé˜²æ­¢å¿«é€Ÿç”Ÿäº§è€…å‹å®æ…¢é€Ÿæ¶ˆè´¹è€…ã€‚

### ä»¤ç‰Œæ¡¶ç®—æ³•

ä»¤ç‰Œæ¡¶ä»¥å›ºå®šé€Ÿç‡ç”Ÿæˆä»¤ç‰Œï¼Œè¯·æ±‚æ¶ˆè€—ä»¤ç‰Œï¼š

```text
tokens(t) = min(capacity, tokens(t-1) + rate Ã— Î”t)
```

### æ¼æ¡¶ç®—æ³•

æ¼æ¡¶ä»¥å›ºå®šé€Ÿç‡å¤„ç†è¯·æ±‚ï¼Œè¶…å‡ºéƒ¨åˆ†è¢«ä¸¢å¼ƒæˆ–æ’é˜Ÿã€‚

### Rust å®ç°ï¼šä»¤ç‰Œæ¡¶é™æµå™¨

```rust
use std::sync::Arc;
use parking_lot::Mutex;
use std::time::{Duration, Instant};

/// ä»¤ç‰Œæ¡¶é™æµå™¨
#[derive(Clone)]
pub struct TokenBucket {
    inner: Arc<Mutex<TokenBucketInner>>,
}

struct TokenBucketInner {
    /// ä»¤ç‰Œå®¹é‡
    capacity: f64,
    /// å½“å‰ä»¤ç‰Œæ•°
    tokens: f64,
    /// ä»¤ç‰Œç”Ÿæˆé€Ÿç‡ï¼ˆtokens/ç§’ï¼‰
    rate: f64,
    /// ä¸Šæ¬¡æ›´æ–°æ—¶é—´
    last_update: Instant,
}

impl TokenBucket {
    pub fn new(capacity: f64, rate: f64) -> Self {
        Self {
            inner: Arc::new(Mutex::new(TokenBucketInner {
                capacity,
                tokens: capacity,
                rate,
                last_update: Instant::now(),
            })),
        }
    }

    /// å°è¯•è·å–ä»¤ç‰Œ
    pub fn try_acquire(&self, tokens: f64) -> bool {
        let mut inner = self.inner.lock();
        inner.refill();

        if inner.tokens >= tokens {
            inner.tokens -= tokens;
            true
        } else {
            false
        }
    }

    /// é˜»å¡è·å–ä»¤ç‰Œ
    pub async fn acquire(&self, tokens: f64) {
        loop {
            if self.try_acquire(tokens) {
                return;
            }
            tokio::time::sleep(Duration::from_millis(10)).await;
        }
    }

    /// è·å–å½“å‰ä»¤ç‰Œæ•°
    pub fn available_tokens(&self) -> f64 {
        let mut inner = self.inner.lock();
        inner.refill();
        inner.tokens
    }
}

impl TokenBucketInner {
    /// è¡¥å……ä»¤ç‰Œ
    fn refill(&mut self) {
        let now = Instant::now();
        let elapsed = now.duration_since(self.last_update).as_secs_f64();
        
        let new_tokens = elapsed * self.rate;
        self.tokens = (self.tokens + new_tokens).min(self.capacity);
        
        self.last_update = now;
    }
}
```

## OTLP ååé‡ä¼˜åŒ–å®è·µ

### å¯¼å‡ºå™¨ååé‡ä¼˜åŒ–

```rust
use prometheus::{Counter, Gauge, Registry};

pub struct OtlpThroughputMonitor {
    spans_exported: Counter,
    export_rate: Gauge,
    batch_size: Gauge,
}

impl OtlpThroughputMonitor {
    pub fn new(registry: &Registry) -> Result<Self, prometheus::Error> {
        let spans_exported = Counter::new(
            "otlp_spans_exported_total",
            "Total number of spans exported"
        )?;

        let export_rate = Gauge::new(
            "otlp_export_rate_spans_per_second",
            "Current export rate in spans/second"
        )?;

        let batch_size = Gauge::new(
            "otlp_batch_size",
            "Current batch size"
        )?;

        registry.register(Box::new(spans_exported.clone()))?;
        registry.register(Box::new(export_rate.clone()))?;
        registry.register(Box::new(batch_size.clone()))?;

        Ok(Self {
            spans_exported,
            export_rate,
            batch_size,
        })
    }

    pub fn record_export(&self, span_count: usize) {
        self.spans_exported.inc_by(span_count as f64);
    }

    pub fn update_rate(&self, rate: f64) {
        self.export_rate.set(rate);
    }

    pub fn update_batch_size(&self, size: usize) {
        self.batch_size.set(size as f64);
    }
}
```

### æ”¶é›†å™¨ååé‡ä¼˜åŒ–

```yaml
# OTLP Collector é…ç½®
receivers:
  otlp:
    protocols:
      grpc:
        max_concurrent_streams: 100
        max_recv_msg_size_mib: 32

processors:
  batch:
    timeout: 1s
    send_batch_size: 1000
    send_batch_max_size: 10000

exporters:
  otlp:
    endpoint: backend:4317
    sending_queue:
      enabled: true
      num_consumers: 10
      queue_size: 5000
```

### ç«¯åˆ°ç«¯ååé‡ç›‘æ§

```yaml
# Prometheus å‘Šè­¦è§„åˆ™
groups:
  - name: otlp_throughput
    rules:
      - alert: LowThroughput
        expr: rate(otlp_spans_exported_total[5m]) < 100
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "OTLP export throughput is low"
          description: "Current rate: {{ $value }} spans/s"

      - alert: ThroughputDrop
        expr: |
          (rate(otlp_spans_exported_total[5m]) 
           / rate(otlp_spans_exported_total[5m] offset 1h)) < 0.5
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "OTLP throughput dropped significantly"
```

## å‚è€ƒæ–‡çŒ®

1. Gunther, N. J. (2007). "Guerrilla Capacity Planning." Springer.
2. Amdahl, G. M. (1967). "Validity of the single processor approach to achieving large scale computing capabilities." AFIPS Conference Proceedings.
3. Little, J. D. C. (1961). "A Proof for the Queuing Formula: L = Î»W." Operations Research.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [æ€§èƒ½æ•°å­¦æ¨¡å‹](./æ€§èƒ½æ•°å­¦æ¨¡å‹.md)
- [å»¶è¿Ÿåˆ†ææ¨¡å‹](./å»¶è¿Ÿåˆ†ææ¨¡å‹.md)
- [èµ„æºæ¶ˆè€—æ¨¡å‹](./èµ„æºæ¶ˆè€—æ¨¡å‹.md)
