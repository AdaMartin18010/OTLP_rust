# 资源消耗模型

## 目录

- [资源消耗模型](#资源消耗模型)
  - [目录](#目录)
  - [概述](#概述)
  - [CPU 资源模型](#cpu-资源模型)
    - [CPU 利用率模型](#cpu-利用率模型)
    - [Rust 实现：CPU 监控](#rust-实现cpu-监控)
  - [内存资源模型](#内存资源模型)
    - [内存使用预测](#内存使用预测)
    - [Rust 实现：内存估算](#rust-实现内存估算)
  - [网络资源模型](#网络资源模型)
    - [网络带宽需求](#网络带宽需求)
    - [Rust 实现：带宽监控](#rust-实现带宽监控)
  - [存储资源模型](#存储资源模型)
    - [存储容量预测](#存储容量预测)
    - [Rust 实现：存储规划](#rust-实现存储规划)
  - [资源容量规划](#资源容量规划)
    - [容量规划模型](#容量规划模型)
    - [Rust 实现：容量规划器](#rust-实现容量规划器)
  - [OTLP 资源优化](#otlp-资源优化)
    - [优化策略](#优化策略)
    - [监控指标](#监控指标)
  - [参考文献](#参考文献)

## 概述

资源消耗模型用于量化分析系统对 CPU、内存、网络、存储等资源的使用情况，为容量规划和性能优化提供理论依据。

## CPU 资源模型

### CPU 利用率模型

**定义**：

```text
U_cpu = λ × S / N
```

其中：

- `U_cpu`: CPU 利用率
- `λ`: 请求到达率
- `S`: 平均服务时间
- `N`: CPU 核心数

### Rust 实现：CPU 监控

```rust
use std::time::{Duration, Instant};
use std::sync::Arc;
use std::sync::atomic::{AtomicU64, Ordering};

/// CPU 资源监控器
pub struct CpuMonitor {
    /// 总处理时间（微秒）
    total_processing_time: Arc<AtomicU64>,
    /// 请求计数
    request_count: Arc<AtomicU64>,
    /// 监控开始时间
    start_time: Instant,
}

impl CpuMonitor {
    pub fn new() -> Self {
        Self {
            total_processing_time: Arc::new(AtomicU64::new(0)),
            request_count: Arc::new(AtomicU64::new(0)),
            start_time: Instant::now(),
        }
    }

    pub fn record_processing(&self, duration: Duration) {
        self.total_processing_time.fetch_add(
            duration.as_micros() as u64,
            Ordering::Relaxed
        );
        self.request_count.fetch_add(1, Ordering::Relaxed);
    }

    pub fn cpu_utilization(&self, num_cores: usize) -> f64 {
        let elapsed = self.start_time.elapsed().as_micros() as u64;
        let total_time = self.total_processing_time.load(Ordering::Relaxed);
        
        if elapsed == 0 {
            return 0.0;
        }
        
        (total_time as f64) / (elapsed as f64 * num_cores as f64)
    }

    pub fn average_service_time(&self) -> Duration {
        let count = self.request_count.load(Ordering::Relaxed);
        if count == 0 {
            return Duration::ZERO;
        }
        
        let total = self.total_processing_time.load(Ordering::Relaxed);
        Duration::from_micros(total / count)
    }
}
```

## 内存资源模型

### 内存使用预测

**Span 内存占用**：

```text
M_span = M_base + M_attributes + M_events + M_links
```

**批处理内存**：

```text
M_batch = n × M_span × (1 + overhead)
```

### Rust 实现：内存估算

```rust
use std::mem::size_of;

/// 内存估算器
pub struct MemoryEstimator;

impl MemoryEstimator {
    /// 估算单个 Span 的内存占用（字节）
    pub fn estimate_span_size(
        num_attributes: usize,
        num_events: usize,
        num_links: usize,
        avg_string_len: usize,
    ) -> usize {
        // 基础结构大小
        let base_size = 128; // TraceID + SpanID + 时间戳等
        
        // 属性内存
        let attr_size = num_attributes * (32 + avg_string_len);
        
        // 事件内存
        let event_size = num_events * (64 + avg_string_len);
        
        // 链接内存
        let link_size = num_links * 48;
        
        base_size + attr_size + event_size + link_size
    }

    /// 估算批次内存占用
    pub fn estimate_batch_size(
        num_spans: usize,
        avg_span_size: usize,
        overhead_percent: f64,
    ) -> usize {
        let base_memory = num_spans * avg_span_size;
        (base_memory as f64 * (1.0 + overhead_percent / 100.0)) as usize
    }

    /// 计算最大批次大小（基于内存限制）
    pub fn max_batch_size(
        memory_limit_mb: usize,
        avg_span_size: usize,
    ) -> usize {
        let memory_limit_bytes = memory_limit_mb * 1024 * 1024;
        memory_limit_bytes / avg_span_size
    }
}
```

## 网络资源模型

### 网络带宽需求

**带宽计算**：

```text
BW_required = λ × S_payload × (1 + overhead)
```

其中：

- `λ`: Span 生成速率（spans/s）
- `S_payload`: 平均 Span 序列化大小
- `overhead`: 协议开销（HTTP/gRPC header 等）

### Rust 实现：带宽监控

```rust
use std::time::{Duration, Instant};
use std::sync::atomic::{AtomicU64, Ordering};

/// 网络带宽监控器
pub struct BandwidthMonitor {
    /// 发送字节数
    bytes_sent: AtomicU64,
    /// 接收字节数
    bytes_received: AtomicU64,
    /// 监控开始时间
    start_time: Instant,
}

impl BandwidthMonitor {
    pub fn new() -> Self {
        Self {
            bytes_sent: AtomicU64::new(0),
            bytes_received: AtomicU64::new(0),
            start_time: Instant::now(),
        }
    }

    pub fn record_sent(&self, bytes: u64) {
        self.bytes_sent.fetch_add(bytes, Ordering::Relaxed);
    }

    pub fn record_received(&self, bytes: u64) {
        self.bytes_received.fetch_add(bytes, Ordering::Relaxed);
    }

    /// 计算发送带宽（bytes/s）
    pub fn send_bandwidth(&self) -> f64 {
        let elapsed = self.start_time.elapsed().as_secs_f64();
        if elapsed == 0.0 {
            return 0.0;
        }
        self.bytes_sent.load(Ordering::Relaxed) as f64 / elapsed
    }

    /// 计算接收带宽（bytes/s）
    pub fn receive_bandwidth(&self) -> f64 {
        let elapsed = self.start_time.elapsed().as_secs_f64();
        if elapsed == 0.0 {
            return 0.0;
        }
        self.bytes_received.load(Ordering::Relaxed) as f64 / elapsed
    }

    /// 格式化带宽显示
    pub fn format_bandwidth(bytes_per_sec: f64) -> String {
        if bytes_per_sec < 1024.0 {
            format!("{:.2} B/s", bytes_per_sec)
        } else if bytes_per_sec < 1024.0 * 1024.0 {
            format!("{:.2} KB/s", bytes_per_sec / 1024.0)
        } else if bytes_per_sec < 1024.0 * 1024.0 * 1024.0 {
            format!("{:.2} MB/s", bytes_per_sec / (1024.0 * 1024.0))
        } else {
            format!("{:.2} GB/s", bytes_per_sec / (1024.0 * 1024.0 * 1024.0))
        }
    }
}
```

## 存储资源模型

### 存储容量预测

**每日存储增长**：

```text
Storage_daily = λ × S_span × 86400 × retention_days
```

### Rust 实现：存储规划

```rust
/// 存储容量规划器
pub struct StoragePlanner;

impl StoragePlanner {
    /// 计算每日存储需求（字节）
    pub fn daily_storage_requirement(
        spans_per_second: f64,
        avg_span_size_bytes: usize,
    ) -> u64 {
        let seconds_per_day = 86400.0;
        (spans_per_second * seconds_per_day * avg_span_size_bytes as f64) as u64
    }

    /// 计算总存储需求
    pub fn total_storage_requirement(
        spans_per_second: f64,
        avg_span_size_bytes: usize,
        retention_days: usize,
    ) -> u64 {
        let daily = Self::daily_storage_requirement(spans_per_second, avg_span_size_bytes);
        daily * retention_days as u64
    }

    /// 格式化存储大小
    pub fn format_storage(bytes: u64) -> String {
        const GB: u64 = 1024 * 1024 * 1024;
        const TB: u64 = 1024 * GB;
        const PB: u64 = 1024 * TB;

        if bytes < GB {
            format!("{:.2} MB", bytes as f64 / (1024.0 * 1024.0))
        } else if bytes < TB {
            format!("{:.2} GB", bytes as f64 / GB as f64)
        } else if bytes < PB {
            format!("{:.2} TB", bytes as f64 / TB as f64)
        } else {
            format!("{:.2} PB", bytes as f64 / PB as f64)
        }
    }
}
```

## 资源容量规划

### 容量规划模型

**目标**：确定满足性能目标所需的资源量

**约束条件**：

1. CPU 利用率 < 70%（留有余量）
2. 内存使用 < 80%
3. 网络带宽 < 60%
4. 存储增长可控

### Rust 实现：容量规划器

```rust
use std::collections::HashMap;

/// 资源容量规划器
pub struct CapacityPlanner {
    /// 目标 QPS
    target_qps: f64,
    /// 平均 Span 大小
    avg_span_size: usize,
    /// 保留天数
    retention_days: usize,
}

impl CapacityPlanner {
    pub fn new(target_qps: f64, avg_span_size: usize, retention_days: usize) -> Self {
        Self {
            target_qps,
            avg_span_size,
            retention_days,
        }
    }

    /// 计算所需资源
    pub fn calculate_requirements(&self) -> ResourceRequirements {
        // CPU 需求（假设每个 Span 处理需要 0.1ms）
        let cpu_time_per_span_ms = 0.1;
        let total_cpu_time_ms = self.target_qps * cpu_time_per_span_ms;
        let cpu_cores = (total_cpu_time_ms / 1000.0 / 0.7).ceil() as usize; // 70% 利用率

        // 内存需求（批处理缓冲）
        let batch_size = 1000;
        let num_batches = 10; // 并发批次
        let memory_mb = (batch_size * num_batches * self.avg_span_size) / (1024 * 1024);

        // 网络带宽需求
        let bandwidth_mbps = (self.target_qps * self.avg_span_size as f64 * 8.0) 
            / (1024.0 * 1024.0) / 0.6; // 60% 利用率

        // 存储需求
        let storage_gb = StoragePlanner::total_storage_requirement(
            self.target_qps,
            self.avg_span_size,
            self.retention_days,
        ) / (1024 * 1024 * 1024);

        ResourceRequirements {
            cpu_cores,
            memory_mb,
            bandwidth_mbps: bandwidth_mbps.ceil() as usize,
            storage_gb,
        }
    }
}

#[derive(Debug, Clone)]
pub struct ResourceRequirements {
    pub cpu_cores: usize,
    pub memory_mb: usize,
    pub bandwidth_mbps: usize,
    pub storage_gb: u64,
}

impl std::fmt::Display for ResourceRequirements {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "Resource Requirements:\n\
             - CPU Cores: {}\n\
             - Memory: {} MB\n\
             - Bandwidth: {} Mbps\n\
             - Storage: {} GB",
            self.cpu_cores, self.memory_mb, self.bandwidth_mbps, self.storage_gb
        )
    }
}
```

## OTLP 资源优化

### 优化策略

1. **压缩**：减少网络和存储开销
2. **采样**：降低整体资源消耗
3. **批处理**：提高 CPU 和网络效率
4. **异步处理**：避免阻塞，提高吞吐量

### 监控指标

```yaml
# Prometheus 监控指标
- otlp_cpu_usage_percent
- otlp_memory_usage_bytes
- otlp_network_bandwidth_bytes_per_sec
- otlp_storage_usage_bytes
```

## 参考文献

1. Gregg, B. (2020). "Systems Performance: Enterprise and the Cloud." Pearson.
2. Kleppmann, M. (2017). "Designing Data-Intensive Applications." O'Reilly Media.

---

**相关文档**：

- [性能数学模型](./性能数学模型.md)
- [延迟分析模型](./延迟分析模型.md)
- [吞吐量理论](./吞吐量理论.md)
