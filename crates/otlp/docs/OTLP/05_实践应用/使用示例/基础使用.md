# OTLP åŸºç¡€ä½¿ç”¨ç¤ºä¾‹

## ç›®å½•

- [OTLP åŸºç¡€ä½¿ç”¨ç¤ºä¾‹](#otlp-åŸºç¡€ä½¿ç”¨ç¤ºä¾‹)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“š æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸš€ å¿«é€Ÿå¼€å§‹](#-å¿«é€Ÿå¼€å§‹)
    - [åŸºç¡€é…ç½®](#åŸºç¡€é…ç½®)
  - [ğŸ“Š è¿½è¸ªæ•°æ®å‘é€](#-è¿½è¸ªæ•°æ®å‘é€)
    - [åŸºç¡€è¿½è¸ªç¤ºä¾‹](#åŸºç¡€è¿½è¸ªç¤ºä¾‹)
    - [åµŒå¥—è¿½è¸ªç¤ºä¾‹](#åµŒå¥—è¿½è¸ªç¤ºä¾‹)
    - [é”™è¯¯è¿½è¸ªç¤ºä¾‹](#é”™è¯¯è¿½è¸ªç¤ºä¾‹)
  - [ğŸ“ˆ æŒ‡æ ‡æ•°æ®å‘é€](#-æŒ‡æ ‡æ•°æ®å‘é€)
    - [è®¡æ•°å™¨æŒ‡æ ‡](#è®¡æ•°å™¨æŒ‡æ ‡)
    - [ä»ªè¡¨ç›˜æŒ‡æ ‡](#ä»ªè¡¨ç›˜æŒ‡æ ‡)
    - [ç›´æ–¹å›¾æŒ‡æ ‡](#ç›´æ–¹å›¾æŒ‡æ ‡)
  - [ğŸ“ æ—¥å¿—æ•°æ®å‘é€](#-æ—¥å¿—æ•°æ®å‘é€)
    - [åŸºç¡€æ—¥å¿—ç¤ºä¾‹](#åŸºç¡€æ—¥å¿—ç¤ºä¾‹)
    - [ç»“æ„åŒ–æ—¥å¿—ç¤ºä¾‹](#ç»“æ„åŒ–æ—¥å¿—ç¤ºä¾‹)
  - [ğŸ“¦ æ‰¹é‡æ•°æ®å‘é€](#-æ‰¹é‡æ•°æ®å‘é€)
    - [æ‰¹é‡è¿½è¸ªæ•°æ®](#æ‰¹é‡è¿½è¸ªæ•°æ®)
    - [æ··åˆæ•°æ®ç±»å‹æ‰¹é‡å‘é€](#æ··åˆæ•°æ®ç±»å‹æ‰¹é‡å‘é€)
  - [âš™ï¸ é«˜çº§é…ç½®ç¤ºä¾‹](#ï¸-é«˜çº§é…ç½®ç¤ºä¾‹)
    - [ç”Ÿäº§ç¯å¢ƒé…ç½®](#ç”Ÿäº§ç¯å¢ƒé…ç½®)
    - [å¼€å‘ç¯å¢ƒé…ç½®](#å¼€å‘ç¯å¢ƒé…ç½®)
  - [ğŸ”„ å¼‚æ­¥å¹¶å‘ç¤ºä¾‹](#-å¼‚æ­¥å¹¶å‘ç¤ºä¾‹)
    - [å¹¶å‘å‘é€è¿½è¸ªæ•°æ®](#å¹¶å‘å‘é€è¿½è¸ªæ•°æ®)
    - [å¼‚æ­¥æ‰¹å¤„ç†ç¤ºä¾‹](#å¼‚æ­¥æ‰¹å¤„ç†ç¤ºä¾‹)
  - [ğŸ›¡ï¸ é”™è¯¯å¤„ç†ç¤ºä¾‹](#ï¸-é”™è¯¯å¤„ç†ç¤ºä¾‹)
    - [åŸºç¡€é”™è¯¯å¤„ç†](#åŸºç¡€é”™è¯¯å¤„ç†)
    - [é‡è¯•æœºåˆ¶ç¤ºä¾‹](#é‡è¯•æœºåˆ¶ç¤ºä¾‹)
  - [ğŸ“Š æ€§èƒ½ç›‘æ§ç¤ºä¾‹](#-æ€§èƒ½ç›‘æ§ç¤ºä¾‹)
    - [è·å–å®¢æˆ·ç«¯æŒ‡æ ‡](#è·å–å®¢æˆ·ç«¯æŒ‡æ ‡)
    - [è‡ªå®šä¹‰æ€§èƒ½æŒ‡æ ‡](#è‡ªå®šä¹‰æ€§èƒ½æŒ‡æ ‡)
  - [ğŸ¯ å®Œæ•´åº”ç”¨ç¤ºä¾‹](#-å®Œæ•´åº”ç”¨ç¤ºä¾‹)
    - [WebæœåŠ¡é›†æˆç¤ºä¾‹](#webæœåŠ¡é›†æˆç¤ºä¾‹)
  - [ğŸ“š æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
    - [1. èµ„æºç®¡ç†](#1-èµ„æºç®¡ç†)
    - [2. é…ç½®ç®¡ç†](#2-é…ç½®ç®¡ç†)
    - [3. é”™è¯¯å¤„ç†ç­–ç•¥](#3-é”™è¯¯å¤„ç†ç­–ç•¥)
  - [ğŸš€ ä¸‹ä¸€æ­¥](#-ä¸‹ä¸€æ­¥)
    - [æ·±å…¥å­¦ä¹ ](#æ·±å…¥å­¦ä¹ )
    - [å®é™…åº”ç”¨](#å®é™…åº”ç”¨)
    - [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)

## ğŸ“š æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›äº†OTLP Rustå®ç°çš„åŸºç¡€ä½¿ç”¨ç¤ºä¾‹ï¼Œæ¶µç›–äº†è¿½è¸ªã€æŒ‡æ ‡ã€æ—¥å¿—çš„å‘é€ï¼Œä»¥åŠå¸¸è§çš„é…ç½®å’Œæœ€ä½³å®è·µã€‚

## ğŸš€ å¿«é€Ÿå¼€å§‹

### åŸºç¡€é…ç½®

```rust
use c21_otlp::{OtlpClient, OtlpConfig};
use c21_otlp::transport::TransportProtocol;
use std::time::Duration;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // åˆ›å»ºåŸºç¡€é…ç½®
    let config = OtlpConfig::default()
        .with_endpoint("http://localhost:4317")
        .with_protocol(TransportProtocol::Grpc)
        .with_service("example-service", "1.0.0")
        .with_timeout(Duration::from_secs(10));
    
    // åˆ›å»ºå®¢æˆ·ç«¯
    let client = OtlpClient::new(config).await?;
    client.initialize().await?;
    
    // ä½¿ç”¨å®¢æˆ·ç«¯...
    
    client.shutdown().await?;
    Ok(())
}
```

## ğŸ“Š è¿½è¸ªæ•°æ®å‘é€

### åŸºç¡€è¿½è¸ªç¤ºä¾‹

```rust
use c21_otlp::data::StatusCode;

async fn send_basic_trace(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    let result = client.send_trace("user-login").await?
        .with_attribute("service.name", "auth-service")
        .with_attribute("user.id", "12345")
        .with_attribute("operation.type", "authentication")
        .with_numeric_attribute("duration", 150.0)
        .with_status(StatusCode::Ok, Some("ç™»å½•æˆåŠŸ".to_string()))
        .finish()
        .await?;
    
    println!("è¿½è¸ªæ•°æ®å‘é€æˆåŠŸ: {} æ¡", result.success_count);
    Ok(())
}
```

### åµŒå¥—è¿½è¸ªç¤ºä¾‹

```rust
async fn send_nested_traces(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    // çˆ¶çº§è¿½è¸ª
    let parent_result = client.send_trace("process-order").await?
        .with_attribute("order.id", "ORD-001")
        .with_attribute("customer.id", "CUST-123")
        .finish()
        .await?;
    
    // å­çº§è¿½è¸ª - éªŒè¯æ”¯ä»˜
    let payment_result = client.send_trace("validate-payment").await?
        .with_attribute("order.id", "ORD-001")
        .with_attribute("payment.method", "credit-card")
        .with_attribute("payment.amount", 99.99)
        .finish()
        .await?;
    
    // å­çº§è¿½è¸ª - åº“å­˜æ£€æŸ¥
    let inventory_result = client.send_trace("check-inventory").await?
        .with_attribute("order.id", "ORD-001")
        .with_attribute("product.id", "PROD-456")
        .with_attribute("quantity", 2)
        .finish()
        .await?;
    
    println!("çˆ¶çº§è¿½è¸ª: {} æ¡", parent_result.success_count);
    println!("æ”¯ä»˜éªŒè¯: {} æ¡", payment_result.success_count);
    println!("åº“å­˜æ£€æŸ¥: {} æ¡", inventory_result.success_count);
    
    Ok(())
}
```

### é”™è¯¯è¿½è¸ªç¤ºä¾‹

```rust
use c21_otlp::data::StatusCode;

async fn send_error_trace(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    let result = client.send_trace("database-query").await?
        .with_attribute("service.name", "user-service")
        .with_attribute("db.operation", "SELECT")
        .with_attribute("db.table", "users")
        .with_attribute("error.message", "Connection timeout")
        .with_attribute("error.type", "DatabaseError")
        .with_numeric_attribute("duration", 5000.0)
        .with_status(StatusCode::Error, Some("æ•°æ®åº“è¿æ¥è¶…æ—¶".to_string()))
        .finish()
        .await?;
    
    println!("é”™è¯¯è¿½è¸ªå‘é€æˆåŠŸ: {} æ¡", result.success_count);
    Ok(())
}
```

## ğŸ“ˆ æŒ‡æ ‡æ•°æ®å‘é€

### è®¡æ•°å™¨æŒ‡æ ‡

```rust
async fn send_counter_metrics(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    // HTTPè¯·æ±‚è®¡æ•°å™¨
    let http_result = client.send_metric("http_requests_total", 1.0).await?
        .with_label("method", "GET")
        .with_label("endpoint", "/api/users")
        .with_label("status_code", "200")
        .with_description("HTTPè¯·æ±‚æ€»æ•°")
        .with_unit("count")
        .send()
        .await?;
    
    // ä¸šåŠ¡æ“ä½œè®¡æ•°å™¨
    let business_result = client.send_metric("orders_created_total", 1.0).await?
        .with_label("product_category", "electronics")
        .with_label("payment_method", "credit_card")
        .with_description("åˆ›å»ºçš„è®¢å•æ€»æ•°")
        .with_unit("count")
        .send()
        .await?;
    
    println!("HTTPæŒ‡æ ‡: {} æ¡", http_result.success_count);
    println!("ä¸šåŠ¡æŒ‡æ ‡: {} æ¡", business_result.success_count);
    
    Ok(())
}
```

### ä»ªè¡¨ç›˜æŒ‡æ ‡

```rust
async fn send_gauge_metrics(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    // å†…å­˜ä½¿ç”¨é‡
    let memory_result = client.send_metric("memory_usage_bytes", 1024.0 * 1024.0 * 512.0).await?
        .with_label("type", "heap")
        .with_description("å†…å­˜ä½¿ç”¨é‡")
        .with_unit("bytes")
        .send()
        .await?;
    
    // æ´»è·ƒè¿æ¥æ•°
    let connection_result = client.send_metric("active_connections", 42.0).await?
        .with_label("connection_type", "websocket")
        .with_description("æ´»è·ƒè¿æ¥æ•°")
        .with_unit("count")
        .send()
        .await?;
    
    println!("å†…å­˜æŒ‡æ ‡: {} æ¡", memory_result.success_count);
    println!("è¿æ¥æŒ‡æ ‡: {} æ¡", connection_result.success_count);
    
    Ok(())
}
```

### ç›´æ–¹å›¾æŒ‡æ ‡

```rust
async fn send_histogram_metrics(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    // è¯·æ±‚å»¶è¿Ÿåˆ†å¸ƒ
    let latency_result = client.send_metric("request_duration_seconds", 0.15).await?
        .with_label("endpoint", "/api/users")
        .with_label("method", "GET")
        .with_description("è¯·æ±‚å¤„ç†å»¶è¿Ÿ")
        .with_unit("seconds")
        .send()
        .await?;
    
    // å“åº”å¤§å°åˆ†å¸ƒ
    let size_result = client.send_metric("response_size_bytes", 2048.0).await?
        .with_label("content_type", "application/json")
        .with_description("å“åº”å¤§å°")
        .with_unit("bytes")
        .send()
        .await?;
    
    println!("å»¶è¿ŸæŒ‡æ ‡: {} æ¡", latency_result.success_count);
    println!("å¤§å°æŒ‡æ ‡: {} æ¡", size_result.success_count);
    
    Ok(())
}
```

## ğŸ“ æ—¥å¿—æ•°æ®å‘é€

### åŸºç¡€æ—¥å¿—ç¤ºä¾‹

```rust
use c21_otlp::data::LogSeverity;

async fn send_basic_logs(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    // ä¿¡æ¯æ—¥å¿—
    let info_result = client.send_log("ç”¨æˆ·ç™»å½•æˆåŠŸ", LogSeverity::Info).await?
        .with_attribute("user.id", "12345")
        .with_attribute("user.email", "user@example.com")
        .with_attribute("login.method", "password")
        .with_attribute("ip.address", "192.168.1.100")
        .send()
        .await?;
    
    // è­¦å‘Šæ—¥å¿—
    let warning_result = client.send_log("APIå“åº”æ—¶é—´è¿‡é•¿", LogSeverity::Warn).await?
        .with_attribute("endpoint", "/api/slow-endpoint")
        .with_attribute("response_time", 5000.0)
        .with_attribute("threshold", 3000.0)
        .send()
        .await?;
    
    // é”™è¯¯æ—¥å¿—
    let error_result = client.send_log("æ•°æ®åº“è¿æ¥å¤±è´¥", LogSeverity::Error).await?
        .with_attribute("database.host", "db.example.com")
        .with_attribute("database.port", 5432)
        .with_attribute("error.code", "CONNECTION_TIMEOUT")
        .with_attribute("retry_count", 3)
        .send()
        .await?;
    
    println!("ä¿¡æ¯æ—¥å¿—: {} æ¡", info_result.success_count);
    println!("è­¦å‘Šæ—¥å¿—: {} æ¡", warning_result.success_count);
    println!("é”™è¯¯æ—¥å¿—: {} æ¡", error_result.success_count);
    
    Ok(())
}
```

### ç»“æ„åŒ–æ—¥å¿—ç¤ºä¾‹

```rust
async fn send_structured_logs(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    // è®¢å•å¤„ç†æ—¥å¿—
    let order_result = client.send_log("è®¢å•å¤„ç†å®Œæˆ", LogSeverity::Info).await?
        .with_attribute("order.id", "ORD-12345")
        .with_attribute("order.amount", 299.99)
        .with_attribute("customer.id", "CUST-67890")
        .with_attribute("payment.method", "credit_card")
        .with_attribute("processing.time", 2.5)
        .with_attribute("items.count", 3)
        .with_trace_context("trace-abc123", "span-def456")
        .send()
        .await?;
    
    // ç³»ç»Ÿæ€§èƒ½æ—¥å¿—
    let performance_result = client.send_log("ç³»ç»Ÿæ€§èƒ½æŠ¥å‘Š", LogSeverity::Info).await?
        .with_attribute("cpu.usage", 45.2)
        .with_attribute("memory.usage", 68.5)
        .with_attribute("disk.usage", 32.1)
        .with_attribute("network.throughput", 1024.0)
        .with_attribute("active.users", 1250)
        .send()
        .await?;
    
    println!("è®¢å•æ—¥å¿—: {} æ¡", order_result.success_count);
    println!("æ€§èƒ½æ—¥å¿—: {} æ¡", performance_result.success_count);
    
    Ok(())
}
```

## ğŸ“¦ æ‰¹é‡æ•°æ®å‘é€

### æ‰¹é‡è¿½è¸ªæ•°æ®

```rust
use c21_otlp::TelemetryData;

async fn send_batch_traces(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    let mut batch_data = Vec::new();
    
    // åˆ›å»ºå¤šä¸ªè¿½è¸ªæ•°æ®
    for i in 0..10 {
        let trace_data = TelemetryData::trace(format!("batch-operation-{}", i))
            .with_attribute("batch.id", "BATCH-001")
            .with_attribute("operation.index", i.to_string())
            .with_attribute("operation.type", "batch_process")
            .with_attribute("batch.size", "10");
        
        batch_data.push(trace_data);
    }
    
    let result = client.send_batch(batch_data).await?;
    println!("æ‰¹é‡è¿½è¸ªå‘é€æˆåŠŸ: {} æ¡", result.success_count);
    
    Ok(())
}
```

### æ··åˆæ•°æ®ç±»å‹æ‰¹é‡å‘é€

```rust
async fn send_mixed_batch(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    let mut batch_data = Vec::new();
    
    // æ·»åŠ è¿½è¸ªæ•°æ®
    for i in 0..5 {
        let trace_data = TelemetryData::trace(format!("api-call-{}", i))
            .with_attribute("endpoint", "/api/data")
            .with_attribute("method", "GET")
            .with_attribute("request.id", format!("REQ-{}", i));
        
        batch_data.push(trace_data);
    }
    
    // æ·»åŠ æŒ‡æ ‡æ•°æ®
    for i in 0..3 {
        let metric_data = TelemetryData::metric("api_requests_total", 1.0)
            .with_label("endpoint", "/api/data")
            .with_label("status", "200");
        
        batch_data.push(metric_data);
    }
    
    // æ·»åŠ æ—¥å¿—æ•°æ®
    for i in 0..2 {
        let log_data = TelemetryData::log("APIè¯·æ±‚å¤„ç†", LogSeverity::Info)
            .with_attribute("request.id", format!("REQ-{}", i))
            .with_attribute("processing.time", 0.1 + i as f64 * 0.05);
        
        batch_data.push(log_data);
    }
    
    let result = client.send_batch(batch_data).await?;
    println!("æ··åˆæ‰¹é‡æ•°æ®å‘é€æˆåŠŸ: {} æ¡", result.success_count);
    
    Ok(())
}
```

## âš™ï¸ é«˜çº§é…ç½®ç¤ºä¾‹

### ç”Ÿäº§ç¯å¢ƒé…ç½®

```rust
async fn create_production_config() -> OtlpConfig {
    OtlpConfig::default()
        .with_endpoint("https://api.honeycomb.io:443")
        .with_protocol(TransportProtocol::Grpc)
        .with_compression(Compression::Gzip)
        .with_api_key("your-api-key")
        .with_bearer_token("your-bearer-token")
        .with_tls(true)
        .with_sampling_ratio(0.1) // 10%é‡‡æ ·ç‡
        .with_resource_attribute("service.name", "production-service")
        .with_resource_attribute("service.version", "2.1.0")
        .with_resource_attribute("deployment.environment", "production")
        .with_resource_attribute("deployment.region", "us-west-2")
        .with_batch_config(BatchConfig {
            max_export_batch_size: 512,
            export_timeout: Duration::from_millis(5000),
            max_queue_size: 2048,
            scheduled_delay: Duration::from_millis(5000),
        })
        .with_retry_config(RetryConfig {
            max_retries: 5,
            initial_retry_delay: Duration::from_millis(1000),
            max_retry_delay: Duration::from_secs(30),
            retry_delay_multiplier: 2.0,
            randomize_retry_delay: true,
        })
}
```

### å¼€å‘ç¯å¢ƒé…ç½®

```rust
async fn create_development_config() -> OtlpConfig {
    OtlpConfig::default()
        .with_endpoint("http://localhost:4317")
        .with_protocol(TransportProtocol::Grpc)
        .with_debug(true)
        .with_sampling_ratio(1.0) // 100%é‡‡æ ·ç‡ç”¨äºè°ƒè¯•
        .with_resource_attribute("service.name", "dev-service")
        .with_resource_attribute("service.version", "dev")
        .with_resource_attribute("deployment.environment", "development")
        .with_batch_config(BatchConfig {
            max_export_batch_size: 10, // å°æ‰¹é‡ç”¨äºå¿«é€Ÿè°ƒè¯•
            export_timeout: Duration::from_millis(1000),
            max_queue_size: 100,
            scheduled_delay: Duration::from_millis(1000),
        })
}
```

## ğŸ”„ å¼‚æ­¥å¹¶å‘ç¤ºä¾‹

### å¹¶å‘å‘é€è¿½è¸ªæ•°æ®

```rust
async fn send_concurrent_traces(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    let mut futures = Vec::new();
    
    // åˆ›å»ºå¤šä¸ªå¹¶å‘ä»»åŠ¡
    for i in 0..10 {
        let client_clone = client.clone();
        let future = tokio::spawn(async move {
            client_clone.send_trace(format!("concurrent-operation-{}", i)).await?
                .with_attribute("task.id", i.to_string())
                .with_attribute("concurrent", "true")
                .finish()
                .await
        });
        futures.push(future);
    }
    
    // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    let mut total_success = 0;
    for future in futures {
        let result = future.await??;
        total_success += result.success_count;
    }
    
    println!("å¹¶å‘å‘é€å®Œæˆï¼Œæ€»è®¡æˆåŠŸ: {} æ¡", total_success);
    Ok(())
}
```

### å¼‚æ­¥æ‰¹å¤„ç†ç¤ºä¾‹

```rust
async fn async_batch_processing(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    let (tx, mut rx) = tokio::sync::mpsc::channel(100);
    
    // ç”Ÿäº§è€…ä»»åŠ¡
    let producer = tokio::spawn(async move {
        for i in 0..100 {
            let data = TelemetryData::trace(format!("async-operation-{}", i))
                .with_attribute("batch.id", "ASYNC-BATCH")
                .with_attribute("operation.id", i.to_string());
            
            if tx.send(data).await.is_err() {
                break;
            }
            
            // æ¨¡æ‹Ÿå¼‚æ­¥æ•°æ®ç”Ÿæˆ
            tokio::time::sleep(Duration::from_millis(10)).await;
        }
    });
    
    // æ¶ˆè´¹è€…ä»»åŠ¡
    let consumer = tokio::spawn(async move {
        let mut batch = Vec::new();
        let batch_size = 20;
        
        while let Some(data) = rx.recv().await {
            batch.push(data);
            
            if batch.len() >= batch_size {
                let result = client.send_batch(batch).await?;
                println!("å¼‚æ­¥æ‰¹å¤„ç†å‘é€: {} æ¡", result.success_count);
                batch = Vec::new();
            }
        }
        
        // å‘é€å‰©ä½™æ•°æ®
        if !batch.is_empty() {
            let result = client.send_batch(batch).await?;
            println!("æœ€åæ‰¹æ¬¡å‘é€: {} æ¡", result.success_count);
        }
        
        Ok::<(), Box<dyn std::error::Error>>(())
    });
    
    // ç­‰å¾…ä»»åŠ¡å®Œæˆ
    tokio::try_join!(producer, consumer)?;
    
    Ok(())
}
```

## ğŸ›¡ï¸ é”™è¯¯å¤„ç†ç¤ºä¾‹

### åŸºç¡€é”™è¯¯å¤„ç†

```rust
async fn handle_basic_errors(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    match client.send_trace("error-prone-operation").await {
        Ok(mut builder) => {
            match builder
                .with_attribute("operation.type", "risky")
                .finish()
                .await
            {
                Ok(result) => println!("æ“ä½œæˆåŠŸ: {} æ¡", result.success_count),
                Err(e) => eprintln!("å‘é€å¤±è´¥: {}", e),
            }
        }
        Err(e) => eprintln!("åˆ›å»ºè¿½è¸ªå¤±è´¥: {}", e),
    }
    
    Ok(())
}
```

### é‡è¯•æœºåˆ¶ç¤ºä¾‹

```rust
async fn send_with_retry(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    let max_retries = 3;
    let mut retry_count = 0;
    
    loop {
        match client.send_trace("retry-operation").await?
            .with_attribute("retry.count", retry_count.to_string())
            .finish()
            .await
        {
            Ok(result) => {
                println!("å‘é€æˆåŠŸ: {} æ¡", result.success_count);
                break;
            }
            Err(e) => {
                retry_count += 1;
                if retry_count >= max_retries {
                    eprintln!("è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œæ”¾å¼ƒå‘é€: {}", e);
                    break;
                }
                
                eprintln!("å‘é€å¤±è´¥ï¼Œç¬¬{}æ¬¡é‡è¯•: {}", retry_count, e);
                tokio::time::sleep(Duration::from_millis(1000 * retry_count)).await;
            }
        }
    }
    
    Ok(())
}
```

## ğŸ“Š æ€§èƒ½ç›‘æ§ç¤ºä¾‹

### è·å–å®¢æˆ·ç«¯æŒ‡æ ‡

```rust
async fn monitor_client_metrics(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    let metrics = client.get_metrics().await;
    
    println!("=== å®¢æˆ·ç«¯æ€§èƒ½æŒ‡æ ‡ ===");
    println!("æ€»å‘é€æ•°æ®é‡: {}", metrics.total_data_sent);
    println!("æ€»æ¥æ”¶æ•°æ®é‡: {}", metrics.total_data_received);
    println!("è¿è¡Œæ—¶é—´: {:?}", metrics.uptime);
    println!("å¹³å‡å¯¼å‡ºå»¶è¿Ÿ: {:?}", metrics.exporter_metrics.average_export_latency);
    println!("å¯¼å‡ºæˆåŠŸç‡: {:.2}%", metrics.exporter_metrics.success_rate * 100.0);
    println!("å½“å‰é˜Ÿåˆ—å¤§å°: {}", metrics.processor_metrics.current_queue_size);
    println!("å¤„ç†çš„æ‰¹æ¬¡æ•°é‡: {}", metrics.processor_metrics.processed_batches);
    
    Ok(())
}
```

### è‡ªå®šä¹‰æ€§èƒ½æŒ‡æ ‡

```rust
async fn send_custom_performance_metrics(client: &OtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    let start_time = std::time::Instant::now();
    
    // æ‰§è¡Œä¸€äº›æ“ä½œ
    let result = client.send_trace("performance-test").await?
        .with_attribute("test.type", "performance")
        .finish()
        .await?;
    
    let duration = start_time.elapsed();
    
    // å‘é€æ€§èƒ½æŒ‡æ ‡
    let perf_result = client.send_metric("operation_duration_ms", duration.as_millis() as f64).await?
        .with_label("operation", "performance-test")
        .with_label("result", "success")
        .with_description("æ“ä½œæ‰§è¡Œæ—¶é—´")
        .with_unit("milliseconds")
        .send()
        .await?;
    
    println!("æ“ä½œè€—æ—¶: {:?}", duration);
    println!("è¿½è¸ªå‘é€: {} æ¡", result.success_count);
    println!("æ€§èƒ½æŒ‡æ ‡: {} æ¡", perf_result.success_count);
    
    Ok(())
}
```

## ğŸ¯ å®Œæ•´åº”ç”¨ç¤ºä¾‹

### WebæœåŠ¡é›†æˆç¤ºä¾‹

```rust
use warp::Filter;

async fn create_web_service() -> Result<(), Box<dyn std::error::Error>> {
    let config = OtlpConfig::default()
        .with_endpoint("http://localhost:4317")
        .with_service("web-service", "1.0.0");
    
    let client = OtlpClient::new(config).await?;
    client.initialize().await?;
    
    // åˆ›å»ºè·¯ç”±
    let routes = warp::path("api")
        .and(warp::path("users"))
        .and(warp::get())
        .and_then(move || {
            let client = client.clone();
            async move {
                // å‘é€è¿½è¸ªæ•°æ®
                let _ = client.send_trace("get-users").await?
                    .with_attribute("http.method", "GET")
                    .with_attribute("http.path", "/api/users")
                    .finish()
                    .await;
                
                // å‘é€æŒ‡æ ‡æ•°æ®
                let _ = client.send_metric("api_requests_total", 1.0).await?
                    .with_label("endpoint", "/api/users")
                    .with_label("method", "GET")
                    .send()
                    .await;
                
                Ok::<_, warp::Rejection>(warp::reply::json(&vec![
                    serde_json::json!({"id": 1, "name": "Alice"}),
                    serde_json::json!({"id": 2, "name": "Bob"}),
                ]))
            }
        });
    
    warp::serve(routes)
        .run(([127, 0, 0, 1], 3030))
        .await;
    
    client.shutdown().await?;
    Ok(())
}
```

## ğŸ“š æœ€ä½³å®è·µ

### 1. èµ„æºç®¡ç†

```rust
// ä½¿ç”¨RAIIæ¨¡å¼ç®¡ç†å®¢æˆ·ç«¯ç”Ÿå‘½å‘¨æœŸ
struct OtlpService {
    client: OtlpClient,
}

impl OtlpService {
    async fn new() -> Result<Self, Box<dyn std::error::Error>> {
        let config = OtlpConfig::default()
            .with_endpoint("http://localhost:4317")
            .with_service("managed-service", "1.0.0");
        
        let client = OtlpClient::new(config).await?;
        client.initialize().await?;
        
        Ok(Self { client })
    }
}

impl Drop for OtlpService {
    fn drop(&mut self) {
        // æ³¨æ„ï¼šè¿™é‡Œéœ€è¦å¼‚æ­¥æ¸…ç†ï¼Œå®é™…åº”ç”¨ä¸­å¯èƒ½éœ€è¦ä½¿ç”¨ä¸åŒçš„æ¨¡å¼
        println!("OTLPæœåŠ¡æ­£åœ¨å…³é—­...");
    }
}
```

### 2. é…ç½®ç®¡ç†

```rust
// ä½¿ç”¨ç¯å¢ƒå˜é‡è¿›è¡Œé…ç½®
fn load_config_from_env() -> OtlpConfig {
    let endpoint = std::env::var("OTLP_ENDPOINT")
        .unwrap_or_else(|_| "http://localhost:4317".to_string());
    
    let service_name = std::env::var("SERVICE_NAME")
        .unwrap_or_else(|_| "default-service".to_string());
    
    let service_version = std::env::var("SERVICE_VERSION")
        .unwrap_or_else(|_| "1.0.0".to_string());
    
    OtlpConfig::default()
        .with_endpoint(&endpoint)
        .with_service(&service_name, &service_version)
        .with_debug(std::env::var("DEBUG").is_ok())
}
```

### 3. é”™è¯¯å¤„ç†ç­–ç•¥

```rust
// ç»Ÿä¸€çš„é”™è¯¯å¤„ç†
async fn safe_send_trace(client: &OtlpClient, operation: &str) -> Result<u64, String> {
    match client.send_trace(operation).await {
        Ok(builder) => {
            match builder
                .with_attribute("operation", operation)
                .finish()
                .await
            {
                Ok(result) => Ok(result.success_count),
                Err(e) => Err(format!("å‘é€å¤±è´¥: {}", e)),
            }
        }
        Err(e) => Err(format!("åˆ›å»ºè¿½è¸ªå¤±è´¥: {}", e)),
    }
}
```

## ğŸš€ ä¸‹ä¸€æ­¥

### æ·±å…¥å­¦ä¹ 

1. **[é«˜çº§é…ç½®ç¤ºä¾‹](é«˜çº§é…ç½®.md)** - å­¦ä¹ æ›´å¤æ‚çš„é…ç½®é€‰é¡¹
2. **[æ‰¹é‡å¤„ç†ç¤ºä¾‹](æ‰¹é‡å¤„ç†.md)** - äº†è§£é«˜æ•ˆçš„æ‰¹é‡å¤„ç†
3. **[é”™è¯¯å¤„ç†ç¤ºä¾‹](é”™è¯¯å¤„ç†.md)** - æŒæ¡é”™è¯¯å¤„ç†æœ€ä½³å®è·µ

### å®é™…åº”ç”¨

1. **[Webåº”ç”¨é›†æˆ](../é›†æˆæŒ‡å—/Webåº”ç”¨é›†æˆ.md)** - é›†æˆåˆ°Webåº”ç”¨
2. **[å¾®æœåŠ¡é›†æˆ](../é›†æˆæŒ‡å—/å¾®æœåŠ¡é›†æˆ.md)** - å¾®æœåŠ¡ç¯å¢ƒéƒ¨ç½²
3. **[æ•°æ®åº“é›†æˆ](../é›†æˆæŒ‡å—/æ•°æ®åº“é›†æˆ.md)** - æ•°æ®åº“æ“ä½œç›‘æ§

### æ€§èƒ½ä¼˜åŒ–

1. **[æ€§èƒ½ä¼˜åŒ–æŒ‡å—](../æ€§èƒ½è°ƒä¼˜/ä¼˜åŒ–ç­–ç•¥.md)** - æå‡åº”ç”¨æ€§èƒ½
2. **[ç›‘æ§å‘Šè­¦è®¾ç½®](../éƒ¨ç½²è¿ç»´/ç›‘æ§å‘Šè­¦.md)** - å»ºç«‹ç›‘æ§ä½“ç³»
3. **[æ•…éšœæ’æŸ¥æŒ‡å—](../éƒ¨ç½²è¿ç»´/æ•…éšœæ’æŸ¥.md)** - å¿«é€Ÿå®šä½é—®é¢˜

---

**åŸºç¡€ä½¿ç”¨ç¤ºä¾‹ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ27æ—¥  
**ç»´æŠ¤è€…**: OTLP 2025 æ–‡æ¡£å›¢é˜Ÿ
