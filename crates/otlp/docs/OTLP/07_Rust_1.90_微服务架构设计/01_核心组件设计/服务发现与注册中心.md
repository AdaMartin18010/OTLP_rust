# 服务发现与注册中心 - Rust 1.90 微服务架构设计

## 目录

- [服务发现与注册中心 - Rust 1.90 微服务架构设计](#服务发现与注册中心---rust-190-微服务架构设计)
  - [目录](#目录)
  - [📋 概述](#-概述)
  - [🏗️ 架构设计](#️-架构设计)
    - [1. 整体架构图](#1-整体架构图)
    - [2. 核心组件](#2-核心组件)
      - [2.1 服务注册器 (Service Registrar)](#21-服务注册器-service-registrar)
      - [2.2 服务发现器 (Service Discovery)](#22-服务发现器-service-discovery)
      - [2.3 健康检查器 (Health Checker)](#23-健康检查器-health-checker)
      - [2.4 负载均衡器 (Load Balancer)](#24-负载均衡器-load-balancer)
  - [🔧 配置管理](#-配置管理)
    - [1. 配置结构](#1-配置结构)
    - [2. 配置加载器](#2-配置加载器)
  - [🚀 使用示例](#-使用示例)
    - [1. 基本使用](#1-基本使用)
    - [2. 高级配置](#2-高级配置)
  - [📊 性能优化](#-性能优化)
    - [1. 缓存优化](#1-缓存优化)
    - [2. 并发优化](#2-并发优化)
  - [🔒 安全考虑](#-安全考虑)
    - [1. 认证与授权](#1-认证与授权)
  - [📈 监控与指标](#-监控与指标)
    - [1. 指标收集](#1-指标收集)
  - [🎯 总结](#-总结)

## 📋 概述

本文档详细阐述了基于 Rust 1.90 语言特性的服务发现与注册中心设计，展示了如何构建高性能、高可用的微服务发现机制。

## 🏗️ 架构设计

### 1. 整体架构图

```text
┌───────────────────────────────────────────────────────────────────┐
│                    服务发现与注册中心架构                           │
├─────────────────┬─────────────────┬─────────────────┬─────────────┤
│   服务注册层     │   服务发现层     │   健康检查层     │   配置管理层 │
│  (Registration) │  (Discovery)    │ (Health Check)  │ (Config)    │
│                 │                 │                 │             │
│ • 服务注册       │ • 服务查询      │ • 健康监控       │ • 配置存储   │
│ • 服务注销       │ • 负载均衡      │ • 故障检测       │ • 动态更新   │
│ • 元数据管理     │ • 服务路由       │ • 自动恢复       │ • 版本控制   │
└─────────────────┴─────────────────┴─────────────────┴─────────────┘
                                │
                    ┌─────────────────┐
                    │   存储后端层     │
                    │(Storage Backend)│
                    │                 │
                    │ • Consul        │
                    │ • etcd          │
                    │ • Kubernetes    │
                    │ • Redis         │
                    └─────────────────┘
```

### 2. 核心组件

#### 2.1 服务注册器 (Service Registrar)

```rust
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use serde::{Deserialize, Serialize};

/// 服务实例信息
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServiceInstance {
    pub id: String,
    pub name: String,
    pub address: String,
    pub port: u16,
    pub tags: Vec<String>,
    pub metadata: HashMap<String, String>,
    pub health_status: HealthStatus,
    pub last_heartbeat: chrono::DateTime<chrono::Utc>,
}

/// 健康状态
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum HealthStatus {
    Healthy,
    Unhealthy,
    Unknown,
}

/// 服务注册器 - 利用 Rust 1.90 特性
pub struct ServiceRegistrar {
    registry: Arc<RwLock<HashMap<String, Vec<ServiceInstance>>>>,
    health_checker: Arc<HealthChecker>,
    event_bus: Arc<EventBus>,
}

impl ServiceRegistrar {
    /// 创建新的服务注册器
    pub fn new(health_checker: Arc<HealthChecker>, event_bus: Arc<EventBus>) -> Self {
        Self {
            registry: Arc::new(RwLock::new(HashMap::new())),
            health_checker,
            event_bus,
        }
    }
    
    /// 注册服务实例 - 利用改进的异步特性
    pub async fn register(&self, instance: ServiceInstance) -> Result<(), RegistryError> {
        let service_name = instance.name.clone();
        
        // 写入注册表
        {
            let mut registry = self.registry.write().await;
            let instances = registry.entry(service_name.clone()).or_insert_with(Vec::new);
            
            // 检查是否已存在相同ID的实例
            if let Some(existing_index) = instances.iter().position(|i| i.id == instance.id) {
                instances[existing_index] = instance.clone();
            } else {
                instances.push(instance.clone());
            }
        }
        
        // 启动健康检查
        self.health_checker.start_monitoring(instance.clone()).await?;
        
        // 发布注册事件
        self.event_bus.publish(RegistryEvent::ServiceRegistered {
            service_name,
            instance: instance.clone(),
        }).await?;
        
        tracing::info!("服务实例已注册: {}:{}", instance.name, instance.id);
        Ok(())
    }
    
    /// 注销服务实例
    pub async fn deregister(&self, service_name: &str, instance_id: &str) -> Result<(), RegistryError> {
        let removed_instance = {
            let mut registry = self.registry.write().await;
            if let Some(instances) = registry.get_mut(service_name) {
                if let Some(index) = instances.iter().position(|i| i.id == instance_id) {
                    let removed = instances.remove(index);
                    if instances.is_empty() {
                        registry.remove(service_name);
                    }
                    Some(removed)
                } else {
                    None
                }
            } else {
                None
            }
        };
        
        if let Some(instance) = removed_instance {
            // 停止健康检查
            self.health_checker.stop_monitoring(&instance.id).await?;
            
            // 发布注销事件
            self.event_bus.publish(RegistryEvent::ServiceDeregistered {
                service_name: service_name.to_string(),
                instance_id: instance_id.to_string(),
            }).await?;
            
            tracing::info!("服务实例已注销: {}:{}", service_name, instance_id);
        }
        
        Ok(())
    }
    
    /// 获取服务实例列表
    pub async fn get_instances(&self, service_name: &str) -> Result<Vec<ServiceInstance>, RegistryError> {
        let registry = self.registry.read().await;
        let instances = registry.get(service_name)
            .cloned()
            .unwrap_or_default();
        
        Ok(instances)
    }
    
    /// 获取健康的服务实例
    pub async fn get_healthy_instances(&self, service_name: &str) -> Result<Vec<ServiceInstance>, RegistryError> {
        let instances = self.get_instances(service_name).await?;
        let healthy_instances = instances.into_iter()
            .filter(|instance| instance.health_status == HealthStatus::Healthy)
            .collect();
        
        Ok(healthy_instances)
    }
}
```

#### 2.2 服务发现器 (Service Discovery)

```rust
/// 服务发现器 - 利用 Rust 1.90 的异步特性
pub struct ServiceDiscovery {
    registrar: Arc<ServiceRegistrar>,
    load_balancer: Arc<LoadBalancer>,
    cache: Arc<RwLock<HashMap<String, CachedServiceInfo>>>,
    cache_ttl: Duration,
}

/// 缓存的服务信息
#[derive(Debug, Clone)]
struct CachedServiceInfo {
    instances: Vec<ServiceInstance>,
    last_updated: chrono::DateTime<chrono::Utc>,
}

impl ServiceDiscovery {
    /// 创建新的服务发现器
    pub fn new(
        registrar: Arc<ServiceRegistrar>,
        load_balancer: Arc<LoadBalancer>,
        cache_ttl: Duration,
    ) -> Self {
        Self {
            registrar,
            load_balancer,
            cache: Arc::new(RwLock::new(HashMap::new())),
            cache_ttl,
        }
    }
    
    /// 发现服务实例 - 利用改进的异步特性
    pub async fn discover(&self, service_name: &str) -> Result<Vec<ServiceInstance>, DiscoveryError> {
        // 检查缓存
        if let Some(cached) = self.get_cached_instances(service_name).await? {
            return Ok(cached.instances);
        }
        
        // 从注册表获取实例
        let instances = self.registrar.get_healthy_instances(service_name).await?;
        
        // 更新缓存
        self.update_cache(service_name, instances.clone()).await?;
        
        Ok(instances)
    }
    
    /// 选择服务实例（负载均衡）
    pub async fn select_instance(
        &self,
        service_name: &str,
        strategy: LoadBalanceStrategy,
    ) -> Result<ServiceInstance, DiscoveryError> {
        let instances = self.discover(service_name).await?;
        
        if instances.is_empty() {
            return Err(DiscoveryError::NoHealthyInstances);
        }
        
        // 使用负载均衡器选择实例
        let selected = self.load_balancer.select_instance(instances, strategy).await?;
        Ok(selected)
    }
    
    /// 获取缓存的服务实例
    async fn get_cached_instances(&self, service_name: &str) -> Result<Option<CachedServiceInfo>, DiscoveryError> {
        let cache = self.cache.read().await;
        if let Some(cached) = cache.get(service_name) {
            let now = chrono::Utc::now();
            if now.signed_duration_since(cached.last_updated) < self.cache_ttl {
                return Ok(Some(cached.clone()));
            }
        }
        Ok(None)
    }
    
    /// 更新缓存
    async fn update_cache(&self, service_name: &str, instances: Vec<ServiceInstance>) -> Result<(), DiscoveryError> {
        let mut cache = self.cache.write().await;
        cache.insert(service_name.to_string(), CachedServiceInfo {
            instances,
            last_updated: chrono::Utc::now(),
        });
        Ok(())
    }
}
```

#### 2.3 健康检查器 (Health Checker)

```rust
use tokio::time::{interval, Duration};
use std::collections::HashMap;

/// 健康检查器 - 利用 Rust 1.90 的并发特性
pub struct HealthChecker {
    checks: Arc<RwLock<HashMap<String, HealthCheck>>>,
    interval: Duration,
    timeout: Duration,
    http_client: reqwest::Client,
}

/// 健康检查配置
#[derive(Debug, Clone)]
struct HealthCheck {
    instance: ServiceInstance,
    check_type: HealthCheckType,
    endpoint: String,
    interval: Duration,
}

/// 健康检查类型
#[derive(Debug, Clone)]
enum HealthCheckType {
    Http,
    Tcp,
    Custom,
}

impl HealthChecker {
    /// 创建新的健康检查器
    pub fn new(interval: Duration, timeout: Duration) -> Self {
        Self {
            checks: Arc::new(RwLock::new(HashMap::new())),
            interval,
            timeout,
            http_client: reqwest::Client::builder()
                .timeout(timeout)
                .build()
                .expect("Failed to create HTTP client"),
        }
    }
    
    /// 开始监控服务实例
    pub async fn start_monitoring(&self, instance: ServiceInstance) -> Result<(), HealthCheckError> {
        let health_check = HealthCheck {
            instance: instance.clone(),
            check_type: HealthCheckType::Http,
            endpoint: format!("http://{}:{}/health", instance.address, instance.port),
            interval: self.interval,
        };
        
        // 添加到检查列表
        {
            let mut checks = self.checks.write().await;
            checks.insert(instance.id.clone(), health_check.clone());
        }
        
        // 启动异步健康检查任务
        self.spawn_health_check_task(health_check).await;
        
        Ok(())
    }
    
    /// 停止监控服务实例
    pub async fn stop_monitoring(&self, instance_id: &str) -> Result<(), HealthCheckError> {
        let mut checks = self.checks.write().await;
        checks.remove(instance_id);
        Ok(())
    }
    
    /// 生成健康检查任务
    async fn spawn_health_check_task(&self, health_check: HealthCheck) {
        let checks = Arc::clone(&self.checks);
        let http_client = self.http_client.clone();
        let instance_id = health_check.instance.id.clone();
        
        tokio::spawn(async move {
            let mut interval = tokio::time::interval(health_check.interval);
            
            loop {
                interval.tick().await;
                
                // 检查是否还在监控列表中
                {
                    let checks_guard = checks.read().await;
                    if !checks_guard.contains_key(&instance_id) {
                        break; // 停止监控
                    }
                }
                
                // 执行健康检查
                match Self::perform_health_check(&http_client, &health_check).await {
                    Ok(is_healthy) => {
                        // 更新健康状态
                        Self::update_health_status(&checks, &instance_id, is_healthy).await;
                    }
                    Err(e) => {
                        tracing::warn!("健康检查失败 {}: {}", instance_id, e);
                        Self::update_health_status(&checks, &instance_id, false).await;
                    }
                }
            }
        });
    }
    
    /// 执行健康检查
    async fn perform_health_check(
        client: &reqwest::Client,
        health_check: &HealthCheck,
    ) -> Result<bool, HealthCheckError> {
        match health_check.check_type {
            HealthCheckType::Http => {
                let response = client
                    .get(&health_check.endpoint)
                    .send()
                    .await?;
                
                Ok(response.status().is_success())
            }
            HealthCheckType::Tcp => {
                // TCP 连接检查实现
                Self::check_tcp_connection(&health_check.endpoint).await
            }
            HealthCheckType::Custom => {
                // 自定义健康检查实现
                Self::perform_custom_check(health_check).await
            }
        }
    }
    
    /// 更新健康状态
    async fn update_health_status(
        checks: &Arc<RwLock<HashMap<String, HealthCheck>>>,
        instance_id: &str,
        is_healthy: bool,
    ) {
        let mut checks_guard = checks.write().await;
        if let Some(health_check) = checks_guard.get_mut(instance_id) {
            health_check.instance.health_status = if is_healthy {
                HealthStatus::Healthy
            } else {
                HealthStatus::Unhealthy
            };
            health_check.instance.last_heartbeat = chrono::Utc::now();
        }
    }
}
```

#### 2.4 负载均衡器 (Load Balancer)

```rust
use rand::Rng;

/// 负载均衡策略
#[derive(Debug, Clone)]
pub enum LoadBalanceStrategy {
    RoundRobin,
    WeightedRoundRobin,
    LeastConnections,
    Random,
    ConsistentHash,
}

/// 负载均衡器 - 利用 Rust 1.90 特性
pub struct LoadBalancer {
    round_robin_counters: Arc<RwLock<HashMap<String, usize>>>,
    connection_counts: Arc<RwLock<HashMap<String, usize>>>,
    hash_ring: Arc<RwLock<ConsistentHashRing>>,
}

/// 一致性哈希环
#[derive(Debug)]
struct ConsistentHashRing {
    nodes: Vec<HashNode>,
}

#[derive(Debug)]
struct HashNode {
    hash: u32,
    instance: ServiceInstance,
}

impl LoadBalancer {
    /// 创建新的负载均衡器
    pub fn new() -> Self {
        Self {
            round_robin_counters: Arc::new(RwLock::new(HashMap::new())),
            connection_counts: Arc::new(RwLock::new(HashMap::new())),
            hash_ring: Arc::new(RwLock::new(ConsistentHashRing::new())),
        }
    }
    
    /// 选择服务实例
    pub async fn select_instance(
        &self,
        instances: Vec<ServiceInstance>,
        strategy: LoadBalanceStrategy,
    ) -> Result<ServiceInstance, LoadBalanceError> {
        if instances.is_empty() {
            return Err(LoadBalanceError::NoInstances);
        }
        
        match strategy {
            LoadBalanceStrategy::RoundRobin => {
                self.select_round_robin(instances).await
            }
            LoadBalanceStrategy::WeightedRoundRobin => {
                self.select_weighted_round_robin(instances).await
            }
            LoadBalanceStrategy::LeastConnections => {
                self.select_least_connections(instances).await
            }
            LoadBalanceStrategy::Random => {
                self.select_random(instances).await
            }
            LoadBalanceStrategy::ConsistentHash => {
                self.select_consistent_hash(instances).await
            }
        }
    }
    
    /// 轮询选择
    async fn select_round_robin(&self, instances: Vec<ServiceInstance>) -> Result<ServiceInstance, LoadBalanceError> {
        let service_name = instances[0].name.clone();
        let mut counters = self.round_robin_counters.write().await;
        
        let counter = counters.entry(service_name).or_insert(0);
        let index = *counter % instances.len();
        *counter += 1;
        
        Ok(instances[index].clone())
    }
    
    /// 加权轮询选择
    async fn select_weighted_round_robin(&self, instances: Vec<ServiceInstance>) -> Result<ServiceInstance, LoadBalanceError> {
        // 实现加权轮询逻辑
        let total_weight: usize = instances.iter()
            .map(|i| i.metadata.get("weight").unwrap_or(&"1".to_string()).parse::<usize>().unwrap_or(1))
            .sum();
        
        let mut counters = self.round_robin_counters.write().await;
        let service_name = instances[0].name.clone();
        let counter = counters.entry(service_name).or_insert(0);
        
        let mut current_weight = 0;
        for instance in &instances {
            let weight = instance.metadata.get("weight").unwrap_or(&"1".to_string()).parse::<usize>().unwrap_or(1);
            current_weight += weight;
            
            if *counter < current_weight {
                *counter += 1;
                return Ok(instance.clone());
            }
        }
        
        // 重置计数器
        *counter = 0;
        Ok(instances[0].clone())
    }
    
    /// 最少连接选择
    async fn select_least_connections(&self, instances: Vec<ServiceInstance>) -> Result<ServiceInstance, LoadBalanceError> {
        let mut connection_counts = self.connection_counts.read().await;
        
        let selected = instances.iter()
            .min_by_key(|instance| connection_counts.get(&instance.id).unwrap_or(&0))
            .ok_or(LoadBalanceError::NoInstances)?;
        
        // 增加连接计数
        let count = connection_counts.entry(selected.id.clone()).or_insert(0);
        *count += 1;
        
        Ok(selected.clone())
    }
    
    /// 随机选择
    async fn select_random(&self, instances: Vec<ServiceInstance>) -> Result<ServiceInstance, LoadBalanceError> {
        let mut rng = rand::thread_rng();
        let index = rng.gen_range(0..instances.len());
        Ok(instances[index].clone())
    }
    
    /// 一致性哈希选择
    async fn select_consistent_hash(&self, instances: Vec<ServiceInstance>) -> Result<ServiceInstance, LoadBalanceError> {
        let mut hash_ring = self.hash_ring.write().await;
        hash_ring.update_nodes(instances.clone());
        
        // 使用请求的某种标识符（如用户ID）进行哈希
        let request_key = "default_key"; // 实际应用中应该使用真实的请求标识
        let selected = hash_ring.get_node(request_key)?;
        
        Ok(selected.clone())
    }
}
```

## 🔧 配置管理

### 1. 配置结构

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// 服务发现配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServiceDiscoveryConfig {
    pub registry: RegistryConfig,
    pub discovery: DiscoveryConfig,
    pub health_check: HealthCheckConfig,
    pub load_balancer: LoadBalancerConfig,
}

/// 注册中心配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RegistryConfig {
    pub backend: RegistryBackend,
    pub consul: Option<ConsulConfig>,
    pub etcd: Option<EtcdConfig>,
    pub kubernetes: Option<KubernetesConfig>,
}

/// 注册中心后端类型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RegistryBackend {
    Consul,
    Etcd,
    Kubernetes,
    InMemory,
}

/// Consul 配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConsulConfig {
    pub address: String,
    pub datacenter: Option<String>,
    pub token: Option<String>,
    pub tls: Option<TlsConfig>,
}

/// 服务发现配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DiscoveryConfig {
    pub cache_ttl: Duration,
    pub refresh_interval: Duration,
    pub max_retries: u32,
    pub retry_delay: Duration,
}

/// 健康检查配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HealthCheckConfig {
    pub interval: Duration,
    pub timeout: Duration,
    pub max_failures: u32,
    pub recovery_threshold: u32,
}

/// 负载均衡配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LoadBalancerConfig {
    pub default_strategy: LoadBalanceStrategy,
    pub strategies: HashMap<String, LoadBalanceStrategy>,
}
```

### 2. 配置加载器

```rust
/// 配置加载器 - 利用 Rust 1.90 特性
pub struct ConfigLoader {
    config_path: String,
    config: Option<ServiceDiscoveryConfig>,
}

impl ConfigLoader {
    /// 创建新的配置加载器
    pub fn new(config_path: String) -> Self {
        Self {
            config_path,
            config: None,
        }
    }
    
    /// 加载配置
    pub async fn load(&mut self) -> Result<ServiceDiscoveryConfig, ConfigError> {
        let content = tokio::fs::read_to_string(&self.config_path).await?;
        let config: ServiceDiscoveryConfig = toml::from_str(&content)?;
        self.config = Some(config.clone());
        Ok(config)
    }
    
    /// 热重载配置
    pub async fn reload(&mut self) -> Result<ServiceDiscoveryConfig, ConfigError> {
        self.load().await
    }
    
    /// 获取当前配置
    pub fn get_config(&self) -> Option<&ServiceDiscoveryConfig> {
        self.config.as_ref()
    }
}
```

## 🚀 使用示例

### 1. 基本使用

```rust
use std::time::Duration;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 初始化日志
    tracing_subscriber::init();
    
    // 创建健康检查器
    let health_checker = Arc::new(HealthChecker::new(
        Duration::from_secs(30),
        Duration::from_secs(5),
    ));
    
    // 创建事件总线
    let event_bus = Arc::new(EventBus::new());
    
    // 创建服务注册器
    let registrar = Arc::new(ServiceRegistrar::new(health_checker, event_bus));
    
    // 创建负载均衡器
    let load_balancer = Arc::new(LoadBalancer::new());
    
    // 创建服务发现器
    let discovery = ServiceDiscovery::new(
        registrar.clone(),
        load_balancer,
        Duration::from_secs(60),
    );
    
    // 注册服务实例
    let instance = ServiceInstance {
        id: "service-1".to_string(),
        name: "user-service".to_string(),
        address: "127.0.0.1".to_string(),
        port: 8080,
        tags: vec!["v1".to_string(), "production".to_string()],
        metadata: HashMap::new(),
        health_status: HealthStatus::Healthy,
        last_heartbeat: chrono::Utc::now(),
    };
    
    registrar.register(instance).await?;
    
    // 发现服务实例
    let instances = discovery.discover("user-service").await?;
    println!("发现服务实例: {:?}", instances);
    
    // 选择服务实例
    let selected = discovery.select_instance("user-service", LoadBalanceStrategy::RoundRobin).await?;
    println!("选择的实例: {:?}", selected);
    
    Ok(())
}
```

### 2. 高级配置

```rust
/// 高级服务发现配置示例
pub async fn create_advanced_service_discovery() -> Result<ServiceDiscovery, Box<dyn std::error::Error>> {
    // 创建 Consul 配置
    let consul_config = ConsulConfig {
        address: "http://localhost:8500".to_string(),
        datacenter: Some("dc1".to_string()),
        token: None,
        tls: None,
    };
    
    // 创建注册中心配置
    let registry_config = RegistryConfig {
        backend: RegistryBackend::Consul,
        consul: Some(consul_config),
        etcd: None,
        kubernetes: None,
    };
    
    // 创建服务发现配置
    let discovery_config = ServiceDiscoveryConfig {
        registry: registry_config,
        discovery: DiscoveryConfig {
            cache_ttl: Duration::from_secs(60),
            refresh_interval: Duration::from_secs(30),
            max_retries: 3,
            retry_delay: Duration::from_secs(1),
        },
        health_check: HealthCheckConfig {
            interval: Duration::from_secs(30),
            timeout: Duration::from_secs(5),
            max_failures: 3,
            recovery_threshold: 2,
        },
        load_balancer: LoadBalancerConfig {
            default_strategy: LoadBalanceStrategy::RoundRobin,
            strategies: HashMap::new(),
        },
    };
    
    // 根据配置创建相应的组件
    // ... 实现细节
    
    Ok(discovery)
}
```

## 📊 性能优化

### 1. 缓存优化

```rust
/// 高性能缓存实现
pub struct HighPerformanceCache {
    cache: Arc<RwLock<HashMap<String, CacheEntry>>>,
    max_size: usize,
    ttl: Duration,
}

#[derive(Debug, Clone)]
struct CacheEntry {
    value: Vec<ServiceInstance>,
    created_at: chrono::DateTime<chrono::Utc>,
    access_count: usize,
}

impl HighPerformanceCache {
    /// 获取缓存项
    pub async fn get(&self, key: &str) -> Option<Vec<ServiceInstance>> {
        let mut cache = self.cache.write().await;
        
        if let Some(entry) = cache.get_mut(key) {
            let now = chrono::Utc::now();
            if now.signed_duration_since(entry.created_at) < self.ttl {
                entry.access_count += 1;
                return Some(entry.value.clone());
            } else {
                cache.remove(key);
            }
        }
        
        None
    }
    
    /// 设置缓存项
    pub async fn set(&self, key: String, value: Vec<ServiceInstance>) {
        let mut cache = self.cache.write().await;
        
        // 检查缓存大小限制
        if cache.len() >= self.max_size {
            self.evict_least_used(&mut cache).await;
        }
        
        let entry = CacheEntry {
            value,
            created_at: chrono::Utc::now(),
            access_count: 1,
        };
        
        cache.insert(key, entry);
    }
    
    /// 淘汰最少使用的缓存项
    async fn evict_least_used(&self, cache: &mut HashMap<String, CacheEntry>) {
        if let Some((key, _)) = cache.iter()
            .min_by_key(|(_, entry)| entry.access_count)
            .map(|(k, v)| (k.clone(), v.clone())) {
            cache.remove(&key);
        }
    }
}
```

### 2. 并发优化

```rust
/// 并发优化的服务发现器
pub struct ConcurrentServiceDiscovery {
    discovery: Arc<ServiceDiscovery>,
    cache: Arc<HighPerformanceCache>,
    semaphore: Arc<tokio::sync::Semaphore>,
}

impl ConcurrentServiceDiscovery {
    /// 并发发现服务
    pub async fn discover_concurrent(&self, service_names: Vec<String>) -> Result<HashMap<String, Vec<ServiceInstance>>, DiscoveryError> {
        let mut futures = Vec::new();
        
        for service_name in service_names {
            let discovery = Arc::clone(&self.discovery);
            let cache = Arc::clone(&self.cache);
            let permit = self.semaphore.clone().acquire_owned().await?;
            
            let future = tokio::spawn(async move {
                let _permit = permit;
                
                // 首先检查缓存
                if let Some(cached) = cache.get(&service_name).await {
                    return Ok((service_name, cached));
                }
                
                // 从服务发现器获取
                let instances = discovery.discover(&service_name).await?;
                
                // 更新缓存
                cache.set(service_name.clone(), instances.clone()).await;
                
                Ok((service_name, instances))
            });
            
            futures.push(future);
        }
        
        // 等待所有任务完成
        let results = futures::future::try_join_all(futures).await?;
        
        let mut result_map = HashMap::new();
        for result in results {
            let (service_name, instances) = result?;
            result_map.insert(service_name, instances);
        }
        
        Ok(result_map)
    }
}
```

## 🔒 安全考虑

### 1. 认证与授权

```rust
/// 安全的服务注册器
pub struct SecureServiceRegistrar {
    registrar: ServiceRegistrar,
    auth_manager: Arc<AuthManager>,
}

impl SecureServiceRegistrar {
    /// 注册服务（需要认证）
    pub async fn register_secure(&self, instance: ServiceInstance, token: &str) -> Result<(), RegistryError> {
        // 验证认证令牌
        if !self.auth_manager.validate_token(token).await? {
            return Err(RegistryError::Unauthorized);
        }
        
        // 执行注册
        self.registrar.register(instance).await
    }
    
    /// 注销服务（需要认证）
    pub async fn deregister_secure(&self, service_name: &str, instance_id: &str, token: &str) -> Result<(), RegistryError> {
        // 验证认证令牌
        if !self.auth_manager.validate_token(token).await? {
            return Err(RegistryError::Unauthorized);
        }
        
        // 执行注销
        self.registrar.deregister(service_name, instance_id).await
    }
}
```

## 📈 监控与指标

### 1. 指标收集

```rust
/// 服务发现指标收集器
pub struct ServiceDiscoveryMetrics {
    registry_operations: prometheus::CounterVec,
    discovery_operations: prometheus::CounterVec,
    health_check_failures: prometheus::CounterVec,
    cache_hit_ratio: prometheus::GaugeVec,
}

impl ServiceDiscoveryMetrics {
    /// 创建新的指标收集器
    pub fn new() -> Result<Self, prometheus::Error> {
        Ok(Self {
            registry_operations: prometheus::CounterVec::new(
                prometheus::Opts::new("service_discovery_registry_operations_total", "Total registry operations"),
                &["operation", "service_name", "status"]
            )?,
            discovery_operations: prometheus::CounterVec::new(
                prometheus::Opts::new("service_discovery_discovery_operations_total", "Total discovery operations"),
                &["service_name", "status"]
            )?,
            health_check_failures: prometheus::CounterVec::new(
                prometheus::Opts::new("service_discovery_health_check_failures_total", "Total health check failures"),
                &["service_name", "instance_id"]
            )?,
            cache_hit_ratio: prometheus::GaugeVec::new(
                prometheus::Opts::new("service_discovery_cache_hit_ratio", "Cache hit ratio"),
                &["cache_type"]
            )?,
        })
    }
    
    /// 记录注册操作
    pub fn record_registry_operation(&self, operation: &str, service_name: &str, status: &str) {
        self.registry_operations.with_label_values(&[operation, service_name, status]).inc();
    }
    
    /// 记录发现操作
    pub fn record_discovery_operation(&self, service_name: &str, status: &str) {
        self.discovery_operations.with_label_values(&[service_name, status]).inc();
    }
    
    /// 记录健康检查失败
    pub fn record_health_check_failure(&self, service_name: &str, instance_id: &str) {
        self.health_check_failures.with_label_values(&[service_name, instance_id]).inc();
    }
    
    /// 更新缓存命中率
    pub fn update_cache_hit_ratio(&self, cache_type: &str, ratio: f64) {
        self.cache_hit_ratio.with_label_values(&[cache_type]).set(ratio);
    }
}
```

## 🎯 总结

基于 Rust 1.90 的服务发现与注册中心设计提供了：

1. **高性能**: 利用异步特性和零拷贝优化
2. **高可用**: 健康检查和故障转移机制
3. **可扩展**: 支持多种负载均衡策略和存储后端
4. **类型安全**: 充分利用 Rust 的类型系统
5. **可观测性**: 完整的监控和指标收集

这个设计为微服务架构提供了可靠的服务发现基础设施，支持现代云原生应用的部署和运维需求。
