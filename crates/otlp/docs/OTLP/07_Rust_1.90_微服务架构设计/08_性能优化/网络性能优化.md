# ç½‘ç»œæ€§èƒ½ä¼˜åŒ–

## ç›®å½•

- [ç½‘ç»œæ€§èƒ½ä¼˜åŒ–](#ç½‘ç»œæ€§èƒ½ä¼˜åŒ–)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ¯ HTTP/2 ä¼˜åŒ–](#-http2-ä¼˜åŒ–)
  - [âš¡ gRPC æ€§èƒ½è°ƒä¼˜](#-grpc-æ€§èƒ½è°ƒä¼˜)
  - [ğŸ”„ è¿æ¥å¤ç”¨](#-è¿æ¥å¤ç”¨)
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)

## ğŸ“‹ æ¦‚è¿°

ç½‘ç»œé€šä¿¡æ˜¯å¾®æœåŠ¡æ€§èƒ½çš„å…³é”®ç“¶é¢ˆ,é€šè¿‡ä¼˜åŒ–ç½‘ç»œå±‚å¯ä»¥æ˜¾è‘—æå‡æ•´ä½“æ€§èƒ½ã€‚

## ğŸ¯ HTTP/2 ä¼˜åŒ–

```rust
use hyper::server::Server;
use hyper::service::{make_service_fn, service_fn};

/// HTTP/2 æœåŠ¡å™¨é…ç½®
pub async fn create_http2_server() -> Result<(), ServerError> {
    let addr = ([0, 0, 0, 0], 8080).into();
    
    let make_svc = make_service_fn(|_conn| async {
        Ok::<_, hyper::Error>(service_fn(handle_request))
    });
    
    Server::bind(&addr)
        .http2_only(true)
        .http2_initial_stream_window_size(1024 * 1024)  // 1MB
        .http2_initial_connection_window_size(10 * 1024 * 1024)  // 10MB
        .http2_max_concurrent_streams(1000)
        .serve(make_svc)
        .await?;
    
    Ok(())
}
```

## âš¡ gRPC æ€§èƒ½è°ƒä¼˜

```rust
use tonic::transport::Server;

/// gRPC æœåŠ¡å™¨é…ç½®
pub async fn create_grpc_server() -> Result<(), ServerError> {
    Server::builder()
        .concurrency_limit_per_connection(256)
        .tcp_nodelay(true)
        .tcp_keepalive(Some(Duration::from_secs(60)))
        .http2_keepalive_interval(Some(Duration::from_secs(30)))
        .http2_keepalive_timeout(Some(Duration::from_secs(10)))
        .add_service(MyServiceServer::new(MyServiceImpl))
        .serve(addr)
        .await?;
    
    Ok(())
}

/// gRPC å®¢æˆ·ç«¯è¿æ¥æ± 
pub struct GrpcClientPool {
    clients: Vec<MyServiceClient<Channel>>,
    current: AtomicUsize,
}

impl GrpcClientPool {
    pub async fn new(endpoint: &str, pool_size: usize) -> Result<Self, ClientError> {
        let mut clients = Vec::with_capacity(pool_size);
        
        for _ in 0..pool_size {
            let channel = Channel::from_shared(endpoint.to_string())?
                .connect_timeout(Duration::from_secs(5))
                .timeout(Duration::from_secs(30))
                .tcp_nodelay(true)
                .http2_keep_alive_interval(Duration::from_secs(30))
                .connect()
                .await?;
            
            clients.push(MyServiceClient::new(channel));
        }
        
        Ok(Self {
            clients,
            current: AtomicUsize::new(0),
        })
    }
    
    pub fn get_client(&self) -> &MyServiceClient<Channel> {
        let index = self.current.fetch_add(1, Ordering::Relaxed) % self.clients.len();
        &self.clients[index]
    }
}
```

## ğŸ”„ è¿æ¥å¤ç”¨

```rust
/// HTTP å®¢æˆ·ç«¯è¿æ¥æ± 
pub struct HttpClientPool {
    client: reqwest::Client,
}

impl HttpClientPool {
    pub fn new() -> Self {
        let client = reqwest::Client::builder()
            .pool_max_idle_per_host(10)
            .pool_idle_timeout(Duration::from_secs(90))
            .timeout(Duration::from_secs(30))
            .tcp_nodelay(true)
            .http2_prior_knowledge()
            .build()
            .unwrap();
        
        Self { client }
    }
    
    pub async fn get(&self, url: &str) -> Result<Response, ClientError> {
        self.client.get(url).send().await.map_err(Into::into)
    }
}
```

## ğŸ¯ æœ€ä½³å®è·µ

1. **å¯ç”¨ HTTP/2**: åˆ©ç”¨å¤šè·¯å¤ç”¨å‡å°‘è¿æ¥æ•°
2. **TCP ä¼˜åŒ–**: å¯ç”¨ TCP_NODELAY å’Œ keepalive
3. **è¿æ¥æ± **: å¤ç”¨è¿æ¥å‡å°‘æ¡æ‰‹å¼€é”€
4. **å‹ç¼©**: å¯ç”¨ gzip/brotli å‹ç¼©
5. **è¶…æ—¶è®¾ç½®**: åˆç†è®¾ç½®è¿æ¥å’Œè¯·æ±‚è¶…æ—¶

---

**æ€»ç»“**: ç½‘ç»œå±‚ä¼˜åŒ–æ˜¯æå‡å¾®æœåŠ¡æ€§èƒ½çš„é‡è¦æ‰‹æ®µã€‚
