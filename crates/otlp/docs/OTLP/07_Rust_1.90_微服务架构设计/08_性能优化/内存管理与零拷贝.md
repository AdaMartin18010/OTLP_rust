# 内存管理与零拷贝

## 目录

- [内存管理与零拷贝](#内存管理与零拷贝)
  - [目录](#目录)
  - [📋 概述](#-概述)
  - [🎯 Rust 内存管理](#-rust-内存管理)
  - [⚡ 零拷贝技术](#-零拷贝技术)
  - [📊 内存池](#-内存池)
  - [🎯 最佳实践](#-最佳实践)

## 📋 概述

Rust 的所有权系统提供了内存安全保证,同时零拷贝技术可以显著提升性能。
本文档介绍在微服务中如何优化内存管理。

## 🎯 Rust 内存管理

```rust
/// 智能指针使用
pub struct ServiceData {
    // 使用 Arc 实现线程安全的共享所有权
    shared_config: Arc<Config>,
    
    // 使用 Box 堆分配大对象
    large_buffer: Box<[u8; 1024 * 1024]>,
    
    // 使用 Rc 单线程共享所有权
    cache: Rc<RefCell<HashMap<String, Value>>>,
}

/// 内存对齐优化
#[repr(align(64))]  // 缓存行对齐
pub struct AlignedData {
    counter: AtomicU64,
    _padding: [u8; 56],  // 填充到 64 字节
}
```

## ⚡ 零拷贝技术

```rust
use bytes::{Bytes, BytesMut};

/// 零拷贝缓冲区
pub struct ZeroCopyBuffer {
    data: Bytes,
}

impl ZeroCopyBuffer {
    /// 从切片创建 (零拷贝)
    pub fn from_slice(slice: &[u8]) -> Self {
        Self {
            data: Bytes::copy_from_slice(slice),
        }
    }
    
    /// 切片操作 (零拷贝)
    pub fn slice(&self, range: std::ops::Range<usize>) -> Bytes {
        self.data.slice(range)
    }
}

/// 零拷贝网络传输
pub async fn send_zero_copy(socket: &mut TcpStream, data: Bytes) -> io::Result<()> {
    // 使用 sendfile 系统调用 (零拷贝)
    socket.write_all(&data).await
}
```

## 📊 内存池

```rust
/// 对象池
pub struct ObjectPool<T> {
    objects: Arc<Mutex<Vec<T>>>,
    factory: Arc<dyn Fn() -> T + Send + Sync>,
}

impl<T: Send + 'static> ObjectPool<T> {
    pub fn new<F>(factory: F, initial_size: usize) -> Self
    where
        F: Fn() -> T + Send + Sync + 'static,
    {
        let factory = Arc::new(factory);
        let objects = (0..initial_size)
            .map(|_| factory())
            .collect();
        
        Self {
            objects: Arc::new(Mutex::new(objects)),
            factory,
        }
    }
    
    pub async fn acquire(&self) -> PooledObject<T> {
        let mut objects = self.objects.lock().await;
        let object = objects.pop().unwrap_or_else(|| (self.factory)());
        
        PooledObject {
            object: Some(object),
            pool: Arc::clone(&self.objects),
        }
    }
}

pub struct PooledObject<T> {
    object: Option<T>,
    pool: Arc<Mutex<Vec<T>>>,
}

impl<T> Drop for PooledObject<T> {
    fn drop(&mut self) {
        if let Some(object) = self.object.take() {
            if let Ok(mut pool) = self.pool.try_lock() {
                pool.push(object);
            }
        }
    }
}
```

## 🎯 最佳实践

1. **避免不必要的克隆**: 使用引用和借用
2. **使用 Cow**: 写时复制优化
3. **预分配容量**: `Vec::with_capacity`
4. **内存池**: 复用对象减少分配
5. **零拷贝**: 使用 `Bytes` 和 `BytesMut`

---

**总结**: 合理的内存管理和零拷贝技术可以显著提升微服务性能。
