# 熔断器模式

## 目录

- [熔断器模式](#熔断器模式)
  - [目录](#目录)
  - [📋 概述](#-概述)
  - [🎯 熔断器状态机](#-熔断器状态机)
  - [⚡ 熔断器实现](#-熔断器实现)
  - [📊 熔断器监控](#-熔断器监控)
  - [🎯 最佳实践](#-最佳实践)

## 📋 概述

熔断器模式通过监控服务调用失败率,在失败率超过阈值时自动切断请求,防止级联故障,保护系统稳定性。

## 🎯 熔断器状态机

```text
┌─────────────────────────────────────────────────────────────────┐
│                      熔断器状态转换                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│                    ┌──────────────┐                             │
│         成功次数    │              │  失败次数                    │
│         < 阈值     │   Closed     │  >= 阈值                     │
│        ┌──────────▶│   (关闭)     │──────────┐                  │
│        │           │              │          │                  │
│        │           └──────────────┘          │                  │
│        │                                     ▼                  │
│        │                          ┌──────────────┐              │
│        │                          │              │              │
│        │                          │     Open     │              │
│        │                          │    (打开)    │              │
│        │                          │              │              │
│        │                          └──────┬───────┘              │
│        │                                 │                      │
│        │                                 │ 超时后               │
│        │                                 ▼                      │
│        │                          ┌──────────────┐              │
│        │           成功            │              │  失败        │
│        └──────────────────────────│  Half-Open   │──────────┐   │
│                                   │   (半开)     │          │   │
│                                   │              │          │   │
│                                   └──────────────┘          │   │
│                                                             │   │
│                                                             ▼   │
│                                                    ┌──────────────┐
│                                                    │     Open     │
│                                                    │    (打开)    │
│                                                    └──────────────┘
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## ⚡ 熔断器实现

```rust
use std::sync::Arc;
use tokio::sync::RwLock;

/// 熔断器
pub struct CircuitBreaker {
    state: Arc<RwLock<CircuitBreakerState>>,
    config: CircuitBreakerConfig,
    metrics: Arc<CircuitBreakerMetrics>,
}

#[derive(Debug, Clone)]
pub struct CircuitBreakerConfig {
    pub failure_threshold: usize,
    pub success_threshold: usize,
    pub timeout: Duration,
    pub half_open_max_requests: usize,
}

#[derive(Debug, Clone)]
enum CircuitBreakerState {
    Closed {
        failure_count: usize,
        success_count: usize,
    },
    Open {
        opened_at: Instant,
    },
    HalfOpen {
        success_count: usize,
        request_count: usize,
    },
}

impl CircuitBreaker {
    pub fn new(config: CircuitBreakerConfig) -> Self {
        Self {
            state: Arc::new(RwLock::new(CircuitBreakerState::Closed {
                failure_count: 0,
                success_count: 0,
            })),
            config,
            metrics: Arc::new(CircuitBreakerMetrics::new()),
        }
    }
    
    /// 检查是否允许请求
    pub async fn allow_request(&self) -> bool {
        let mut state = self.state.write().await;
        
        match *state {
            CircuitBreakerState::Closed { .. } => true,
            CircuitBreakerState::Open { opened_at } => {
                if opened_at.elapsed() > self.config.timeout {
                    // 超时后进入半开状态
                    *state = CircuitBreakerState::HalfOpen {
                        success_count: 0,
                        request_count: 0,
                    };
                    self.metrics.state_change("half_open");
                    true
                } else {
                    false
                }
            }
            CircuitBreakerState::HalfOpen { request_count, .. } => {
                request_count < self.config.half_open_max_requests
            }
        }
    }
    
    /// 记录成功
    pub async fn record_success(&self) {
        let mut state = self.state.write().await;
        self.metrics.record_success();
        
        match *state {
            CircuitBreakerState::Closed { failure_count, success_count } => {
                *state = CircuitBreakerState::Closed {
                    failure_count: 0,
                    success_count: success_count + 1,
                };
            }
            CircuitBreakerState::HalfOpen { success_count, request_count } => {
                let new_success = success_count + 1;
                if new_success >= self.config.success_threshold {
                    // 恢复到关闭状态
                    *state = CircuitBreakerState::Closed {
                        failure_count: 0,
                        success_count: 0,
                    };
                    self.metrics.state_change("closed");
                } else {
                    *state = CircuitBreakerState::HalfOpen {
                        success_count: new_success,
                        request_count: request_count + 1,
                    };
                }
            }
            _ => {}
        }
    }
    
    /// 记录失败
    pub async fn record_failure(&self) {
        let mut state = self.state.write().await;
        self.metrics.record_failure();
        
        match *state {
            CircuitBreakerState::Closed { failure_count, .. } => {
                let new_failure = failure_count + 1;
                if new_failure >= self.config.failure_threshold {
                    // 打开熔断器
                    *state = CircuitBreakerState::Open {
                        opened_at: Instant::now(),
                    };
                    self.metrics.state_change("open");
                } else {
                    *state = CircuitBreakerState::Closed {
                        failure_count: new_failure,
                        success_count: 0,
                    };
                }
            }
            CircuitBreakerState::HalfOpen { .. } => {
                // 半开状态失败,重新打开
                *state = CircuitBreakerState::Open {
                    opened_at: Instant::now(),
                };
                self.metrics.state_change("open");
            }
            _ => {}
        }
    }
    
    /// 执行带熔断保护的操作
    pub async fn execute<F, T>(&self, operation: F) -> Result<T, CircuitBreakerError>
    where
        F: Future<Output = Result<T, Box<dyn std::error::Error>>>,
    {
        if !self.allow_request().await {
            return Err(CircuitBreakerError::Open);
        }
        
        match operation.await {
            Ok(result) => {
                self.record_success().await;
                Ok(result)
            }
            Err(e) => {
                self.record_failure().await;
                Err(CircuitBreakerError::OperationFailed(e.to_string()))
            }
        }
    }
}
```

## 📊 熔断器监控

```rust
/// 熔断器指标
pub struct CircuitBreakerMetrics {
    success_count: Counter,
    failure_count: Counter,
    state_changes: Counter,
    current_state: Gauge,
}

impl CircuitBreakerMetrics {
    pub fn new() -> Self {
        Self {
            success_count: Counter::new("circuit_breaker_success_total", "Total successes").unwrap(),
            failure_count: Counter::new("circuit_breaker_failure_total", "Total failures").unwrap(),
            state_changes: Counter::new("circuit_breaker_state_changes_total", "Total state changes").unwrap(),
            current_state: Gauge::new("circuit_breaker_state", "Current state (0=closed, 1=open, 2=half_open)").unwrap(),
        }
    }
    
    pub fn record_success(&self) {
        self.success_count.inc();
    }
    
    pub fn record_failure(&self) {
        self.failure_count.inc();
    }
    
    pub fn state_change(&self, new_state: &str) {
        self.state_changes.inc();
        let state_value = match new_state {
            "closed" => 0.0,
            "open" => 1.0,
            "half_open" => 2.0,
            _ => -1.0,
        };
        self.current_state.set(state_value);
    }
}
```

## 🎯 最佳实践

1. **合理阈值**: 根据服务特性设置失败阈值
2. **快速恢复**: 设置合理的超时时间
3. **监控告警**: 监控熔断器状态变化
4. **降级策略**: 熔断时提供降级服务
5. **分级熔断**: 对不同严重程度的错误采用不同策略

---

**总结**: 熔断器模式是防止级联故障、保护系统稳定性的重要机制。
