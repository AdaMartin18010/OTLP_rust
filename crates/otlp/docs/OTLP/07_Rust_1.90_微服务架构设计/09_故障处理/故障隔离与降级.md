# æ•…éšœéš”ç¦»ä¸é™çº§

## ç›®å½•

- [æ•…éšœéš”ç¦»ä¸é™çº§](#æ•…éšœéš”ç¦»ä¸é™çº§)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ¯ æ•…éšœéš”ç¦»æ¨¡å¼](#-æ•…éšœéš”ç¦»æ¨¡å¼)
  - [âš¡ æœåŠ¡é™çº§ç­–ç•¥](#-æœåŠ¡é™çº§ç­–ç•¥)
  - [ğŸ”’ èˆ±å£éš”ç¦»](#-èˆ±å£éš”ç¦»)
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)

## ğŸ“‹ æ¦‚è¿°

æ•…éšœéš”ç¦»å’ŒæœåŠ¡é™çº§æ˜¯ä¿è¯å¾®æœåŠ¡ç³»ç»Ÿé«˜å¯ç”¨çš„å…³é”®æœºåˆ¶,é€šè¿‡é™åˆ¶æ•…éšœå½±å“èŒƒå›´å’Œæä¾›é™çº§æœåŠ¡,ç¡®ä¿ç³»ç»Ÿæ•´ä½“ç¨³å®šã€‚

## ğŸ¯ æ•…éšœéš”ç¦»æ¨¡å¼

```rust
/// æ•…éšœéš”ç¦»å™¨
pub struct FaultIsolator {
    circuit_breaker: Arc<CircuitBreaker>,
    bulkhead: Arc<Semaphore>,
    timeout: Duration,
}

impl FaultIsolator {
    pub async fn execute<F, T>(&self, operation: F) -> Result<T, IsolationError>
    where
        F: Future<Output = Result<T, Box<dyn std::error::Error>>>,
    {
        // 1. æ£€æŸ¥æ–­è·¯å™¨
        if !self.circuit_breaker.allow_request() {
            return Err(IsolationError::CircuitBreakerOpen);
        }
        
        // 2. è·å–èˆ±å£è®¸å¯
        let _permit = self.bulkhead.acquire().await
            .map_err(|_| IsolationError::BulkheadFull)?;
        
        // 3. æ‰§è¡Œå¸¦è¶…æ—¶çš„æ“ä½œ
        match tokio::time::timeout(self.timeout, operation).await {
            Ok(Ok(result)) => {
                self.circuit_breaker.record_success();
                Ok(result)
            }
            Ok(Err(e)) => {
                self.circuit_breaker.record_failure();
                Err(IsolationError::OperationFailed(e.to_string()))
            }
            Err(_) => {
                self.circuit_breaker.record_failure();
                Err(IsolationError::Timeout)
            }
        }
    }
}
```

## âš¡ æœåŠ¡é™çº§ç­–ç•¥

```rust
/// é™çº§ç­–ç•¥
pub enum DegradationStrategy {
    /// è¿”å›ç¼“å­˜æ•°æ®
    ReturnCached,
    /// è¿”å›é»˜è®¤å€¼
    ReturnDefault,
    /// è¿”å›ç©ºç»“æœ
    ReturnEmpty,
    /// è°ƒç”¨å¤‡ç”¨æœåŠ¡
    Fallback(String),
}

/// é™çº§å¤„ç†å™¨
pub struct DegradationHandler {
    cache: Arc<Cache>,
    fallback_service: Arc<FallbackService>,
}

impl DegradationHandler {
    pub async fn handle_with_degradation<T>(
        &self,
        operation: impl Future<Output = Result<T, ServiceError>>,
        strategy: DegradationStrategy,
    ) -> Result<T, DegradationError>
    where
        T: Default + Clone + Serialize + DeserializeOwned,
    {
        match operation.await {
            Ok(result) => Ok(result),
            Err(e) => {
                tracing::warn!("Service failed, applying degradation: {:?}", e);
                
                match strategy {
                    DegradationStrategy::ReturnCached => {
                        self.cache.get("last_success")
                            .ok_or(DegradationError::NoCachedData)
                    }
                    DegradationStrategy::ReturnDefault => {
                        Ok(T::default())
                    }
                    DegradationStrategy::ReturnEmpty => {
                        Ok(T::default())
                    }
                    DegradationStrategy::Fallback(service_name) => {
                        self.fallback_service.call(&service_name).await
                    }
                }
            }
        }
    }
}
```

## ğŸ”’ èˆ±å£éš”ç¦»

```rust
/// èˆ±å£éš”ç¦» - çº¿ç¨‹æ± éš”ç¦»
pub struct BulkheadIsolation {
    pools: HashMap<String, Arc<Semaphore>>,
}

impl BulkheadIsolation {
    pub fn new() -> Self {
        let mut pools = HashMap::new();
        
        // ä¸ºä¸åŒæœåŠ¡åˆ†é…ç‹¬ç«‹çš„èµ„æºæ± 
        pools.insert("user-service".to_string(), Arc::new(Semaphore::new(100)));
        pools.insert("order-service".to_string(), Arc::new(Semaphore::new(50)));
        pools.insert("payment-service".to_string(), Arc::new(Semaphore::new(30)));
        
        Self { pools }
    }
    
    pub async fn execute<F, T>(
        &self,
        service_name: &str,
        operation: F,
    ) -> Result<T, BulkheadError>
    where
        F: Future<Output = T>,
    {
        let pool = self.pools.get(service_name)
            .ok_or(BulkheadError::UnknownService)?;
        
        let _permit = pool.acquire().await
            .map_err(|_| BulkheadError::ResourceExhausted)?;
        
        Ok(operation.await)
    }
}
```

## ğŸ¯ æœ€ä½³å®è·µ

1. **æ•…éšœéš”ç¦»**: ä½¿ç”¨æ–­è·¯å™¨å’Œèˆ±å£æ¨¡å¼éš”ç¦»æ•…éšœ
2. **ä¼˜é›…é™çº§**: æä¾›é™çº§æœåŠ¡è€Œä¸æ˜¯ç›´æ¥å¤±è´¥
3. **å¿«é€Ÿå¤±è´¥**: è¶…æ—¶å¿«é€Ÿå¤±è´¥,é¿å…çº§è”æ•…éšœ
4. **èµ„æºéš”ç¦»**: ä¸ºä¸åŒæœåŠ¡åˆ†é…ç‹¬ç«‹èµ„æºæ± 
5. **ç›‘æ§å‘Šè­¦**: ç›‘æ§é™çº§ç‡å’Œæ•…éšœç‡

---

**æ€»ç»“**: æ•…éšœéš”ç¦»å’ŒæœåŠ¡é™çº§æ˜¯æ„å»ºé«˜å¯ç”¨å¾®æœåŠ¡ç³»ç»Ÿçš„åŸºçŸ³ã€‚
