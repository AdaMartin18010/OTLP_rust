# é‡è¯•æœºåˆ¶ä¸é€€é¿ç­–ç•¥

## ç›®å½•

- [é‡è¯•æœºåˆ¶ä¸é€€é¿ç­–ç•¥](#é‡è¯•æœºåˆ¶ä¸é€€é¿ç­–ç•¥)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ¯ é‡è¯•ç­–ç•¥](#-é‡è¯•ç­–ç•¥)
  - [âš¡ é€€é¿ç®—æ³•](#-é€€é¿ç®—æ³•)
  - [ğŸ”„ å¹‚ç­‰æ€§ä¿è¯](#-å¹‚ç­‰æ€§ä¿è¯)
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)

## ğŸ“‹ æ¦‚è¿°

é‡è¯•æœºåˆ¶å’Œé€€é¿ç­–ç•¥æ˜¯æé«˜ç³»ç»Ÿå¯é æ€§çš„é‡è¦æ‰‹æ®µ,é€šè¿‡åˆç†çš„é‡è¯•å’Œé€€é¿,å¯ä»¥åº”å¯¹ä¸´æ—¶æ€§æ•…éšœ,æé«˜è¯·æ±‚æˆåŠŸç‡ã€‚

## ğŸ¯ é‡è¯•ç­–ç•¥

```rust
/// é‡è¯•ç­–ç•¥
pub struct RetryPolicy {
    pub max_attempts: usize,
    pub backoff: BackoffStrategy,
    pub retryable_errors: Vec<ErrorType>,
}

#[derive(Debug, Clone)]
pub enum BackoffStrategy {
    Fixed(Duration),
    Linear { initial: Duration, increment: Duration },
    Exponential { initial: Duration, multiplier: f64, max: Duration },
    ExponentialWithJitter { initial: Duration, multiplier: f64, max: Duration },
}

/// é‡è¯•æ‰§è¡Œå™¨
pub struct RetryExecutor {
    policy: RetryPolicy,
    metrics: Arc<RetryMetrics>,
}

impl RetryExecutor {
    pub async fn execute<F, T>(&self, operation: F) -> Result<T, RetryError>
    where
        F: Fn() -> BoxFuture<'static, Result<T, ServiceError>>,
    {
        let mut attempts = 0;
        let mut last_error = None;
        
        while attempts < self.policy.max_attempts {
            attempts += 1;
            
            match operation().await {
                Ok(result) => {
                    self.metrics.record_success(attempts);
                    return Ok(result);
                }
                Err(e) => {
                    // æ£€æŸ¥æ˜¯å¦å¯é‡è¯•
                    if !self.is_retryable(&e) {
                        self.metrics.record_non_retryable();
                        return Err(RetryError::NonRetryable(e));
                    }
                    
                    last_error = Some(e);
                    
                    // æœ€åä¸€æ¬¡å°è¯•ä¸éœ€è¦ç­‰å¾…
                    if attempts < self.policy.max_attempts {
                        let delay = self.calculate_backoff(attempts);
                        tokio::time::sleep(delay).await;
                    }
                }
            }
        }
        
        self.metrics.record_exhausted();
        Err(RetryError::MaxAttemptsExceeded(last_error.unwrap()))
    }
    
    fn is_retryable(&self, error: &ServiceError) -> bool {
        self.policy.retryable_errors.iter()
            .any(|err_type| error.matches(err_type))
    }
    
    fn calculate_backoff(&self, attempt: usize) -> Duration {
        match &self.policy.backoff {
            BackoffStrategy::Fixed(duration) => *duration,
            BackoffStrategy::Linear { initial, increment } => {
                *initial + *increment * (attempt as u32 - 1)
            }
            BackoffStrategy::Exponential { initial, multiplier, max } => {
                let delay = *initial * (*multiplier).powi(attempt as i32 - 1);
                delay.min(*max)
            }
            BackoffStrategy::ExponentialWithJitter { initial, multiplier, max } => {
                let base_delay = *initial * (*multiplier).powi(attempt as i32 - 1);
                let jitter = rand::random::<f64>() * 0.3 + 0.85;  // 0.85 ~ 1.15
                let delay = Duration::from_secs_f64(base_delay.as_secs_f64() * jitter);
                delay.min(*max)
            }
        }
    }
}
```

## âš¡ é€€é¿ç®—æ³•

```rust
/// æŒ‡æ•°é€€é¿å®ç°
pub struct ExponentialBackoff {
    initial_delay: Duration,
    max_delay: Duration,
    multiplier: f64,
    current_attempt: usize,
}

impl ExponentialBackoff {
    pub fn new(initial_delay: Duration, max_delay: Duration) -> Self {
        Self {
            initial_delay,
            max_delay,
            multiplier: 2.0,
            current_attempt: 0,
        }
    }
    
    pub fn next_delay(&mut self) -> Duration {
        self.current_attempt += 1;
        
        let delay = self.initial_delay.as_secs_f64() 
            * self.multiplier.powi(self.current_attempt as i32 - 1);
        
        Duration::from_secs_f64(delay.min(self.max_delay.as_secs_f64()))
    }
    
    pub fn reset(&mut self) {
        self.current_attempt = 0;
    }
}

/// å¸¦æŠ–åŠ¨çš„é€€é¿
pub struct JitteredBackoff {
    backoff: ExponentialBackoff,
}

impl JitteredBackoff {
    pub fn next_delay(&mut self) -> Duration {
        let base_delay = self.backoff.next_delay();
        let jitter = rand::random::<f64>();
        
        // æ·»åŠ  Â±30% çš„éšæœºæŠ–åŠ¨
        let jittered = base_delay.as_secs_f64() * (0.7 + jitter * 0.6);
        Duration::from_secs_f64(jittered)
    }
}
```

## ğŸ”„ å¹‚ç­‰æ€§ä¿è¯

```rust
/// å¹‚ç­‰æ€§ä»¤ç‰Œ
pub struct IdempotencyToken {
    token: String,
    created_at: Instant,
    ttl: Duration,
}

impl IdempotencyToken {
    pub fn new(ttl: Duration) -> Self {
        Self {
            token: Uuid::new_v4().to_string(),
            created_at: Instant::now(),
            ttl,
        }
    }
    
    pub fn is_expired(&self) -> bool {
        self.created_at.elapsed() > self.ttl
    }
}

/// å¹‚ç­‰æ€§ç®¡ç†å™¨
pub struct IdempotencyManager {
    tokens: Arc<RwLock<HashMap<String, IdempotencyResult>>>,
}

impl IdempotencyManager {
    pub async fn execute_idempotent<F, T>(
        &self,
        token: &str,
        operation: F,
    ) -> Result<T, IdempotencyError>
    where
        F: Future<Output = Result<T, ServiceError>>,
        T: Clone,
    {
        // æ£€æŸ¥æ˜¯å¦å·²æ‰§è¡Œè¿‡
        {
            let tokens = self.tokens.read().await;
            if let Some(result) = tokens.get(token) {
                if !result.is_expired() {
                    return Ok(result.value.clone());
                }
            }
        }
        
        // æ‰§è¡Œæ“ä½œ
        let result = operation.await?;
        
        // å­˜å‚¨ç»“æœ
        {
            let mut tokens = self.tokens.write().await;
            tokens.insert(token.to_string(), IdempotencyResult {
                value: result.clone(),
                created_at: Instant::now(),
                ttl: Duration::from_secs(3600),
            });
        }
        
        Ok(result)
    }
}
```

## ğŸ¯ æœ€ä½³å®è·µ

1. **åŒºåˆ†é”™è¯¯ç±»å‹**: åªå¯¹ä¸´æ—¶æ€§é”™è¯¯é‡è¯•
2. **æŒ‡æ•°é€€é¿**: ä½¿ç”¨æŒ‡æ•°é€€é¿é¿å…é›ªå´©
3. **æ·»åŠ æŠ–åŠ¨**: é¿å…é‡è¯•é£æš´
4. **å¹‚ç­‰æ€§**: ç¡®ä¿é‡è¯•æ“ä½œçš„å¹‚ç­‰æ€§
5. **é™åˆ¶é‡è¯•æ¬¡æ•°**: è®¾ç½®åˆç†çš„æœ€å¤§é‡è¯•æ¬¡æ•°

---

**æ€»ç»“**: åˆç†çš„é‡è¯•æœºåˆ¶å’Œé€€é¿ç­–ç•¥å¯ä»¥æ˜¾è‘—æé«˜ç³»ç»Ÿçš„å¯é æ€§å’Œå®¹é”™èƒ½åŠ›ã€‚
