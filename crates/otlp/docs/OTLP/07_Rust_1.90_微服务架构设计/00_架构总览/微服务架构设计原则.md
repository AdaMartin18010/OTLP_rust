# å¾®æœåŠ¡æ¶æ„è®¾è®¡åŸåˆ™

## ç›®å½•

- [å¾®æœåŠ¡æ¶æ„è®¾è®¡åŸåˆ™](#å¾®æœåŠ¡æ¶æ„è®¾è®¡åŸåˆ™)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ¯ æ ¸å¿ƒè®¾è®¡åŸåˆ™](#-æ ¸å¿ƒè®¾è®¡åŸåˆ™)
    - [1. å•ä¸€èŒè´£åŸåˆ™ (Single Responsibility Principle)](#1-å•ä¸€èŒè´£åŸåˆ™-single-responsibility-principle)
    - [2. æœåŠ¡è‡ªæ²»åŸåˆ™ (Service Autonomy)](#2-æœåŠ¡è‡ªæ²»åŸåˆ™-service-autonomy)
    - [3. å»ä¸­å¿ƒåŒ–æ²»ç† (Decentralized Governance)](#3-å»ä¸­å¿ƒåŒ–æ²»ç†-decentralized-governance)
    - [4. æ•…éšœéš”ç¦»åŸåˆ™ (Failure Isolation)](#4-æ•…éšœéš”ç¦»åŸåˆ™-failure-isolation)
    - [5. å¯è§‚æµ‹æ€§ä¼˜å…ˆ (Observability First)](#5-å¯è§‚æµ‹æ€§ä¼˜å…ˆ-observability-first)
  - [ğŸ—ï¸ æ¶æ„è®¾è®¡æ¨¡å¼](#ï¸-æ¶æ„è®¾è®¡æ¨¡å¼)
    - [1. API ç½‘å…³æ¨¡å¼](#1-api-ç½‘å…³æ¨¡å¼)
    - [2. æœåŠ¡å‘ç°æ¨¡å¼](#2-æœåŠ¡å‘ç°æ¨¡å¼)
    - [3. æ–­è·¯å™¨æ¨¡å¼](#3-æ–­è·¯å™¨æ¨¡å¼)
    - [4. äº‹ä»¶é©±åŠ¨æ¶æ„](#4-äº‹ä»¶é©±åŠ¨æ¶æ„)
    - [5. CQRS æ¨¡å¼](#5-cqrs-æ¨¡å¼)
  - [ğŸ“Š æ•°æ®ç®¡ç†åŸåˆ™](#-æ•°æ®ç®¡ç†åŸåˆ™)
    - [1. æ•°æ®åº“ç‹¬ç«‹åŸåˆ™](#1-æ•°æ®åº“ç‹¬ç«‹åŸåˆ™)
    - [2. æœ€ç»ˆä¸€è‡´æ€§](#2-æœ€ç»ˆä¸€è‡´æ€§)
    - [3. Saga æ¨¡å¼](#3-saga-æ¨¡å¼)
  - [ğŸ”’ å®‰å…¨è®¾è®¡åŸåˆ™](#-å®‰å…¨è®¾è®¡åŸåˆ™)
    - [1. é›¶ä¿¡ä»»æ¶æ„](#1-é›¶ä¿¡ä»»æ¶æ„)
    - [2. æ·±åº¦é˜²å¾¡](#2-æ·±åº¦é˜²å¾¡)
    - [3. æœ€å°æƒé™åŸåˆ™](#3-æœ€å°æƒé™åŸåˆ™)
  - [âš¡ æ€§èƒ½è®¾è®¡åŸåˆ™](#-æ€§èƒ½è®¾è®¡åŸåˆ™)
    - [1. å¼‚æ­¥ä¼˜å…ˆ](#1-å¼‚æ­¥ä¼˜å…ˆ)
    - [2. ç¼“å­˜ç­–ç•¥](#2-ç¼“å­˜ç­–ç•¥)
    - [3. è´Ÿè½½å‡è¡¡](#3-è´Ÿè½½å‡è¡¡)
  - [ğŸ¯ å®è·µå»ºè®®](#-å®è·µå»ºè®®)

## ğŸ“‹ æ¦‚è¿°

å¾®æœåŠ¡æ¶æ„è®¾è®¡åŸåˆ™æ˜¯æ„å»ºå¯æ‰©å±•ã€å¯ç»´æŠ¤ã€é«˜å¯ç”¨åˆ†å¸ƒå¼ç³»ç»Ÿçš„åŸºç¡€ã€‚æœ¬æ–‡æ¡£åŸºäº Rust 1.90 çš„ç‰¹æ€§,ç»“åˆ OTLP å¯è§‚æµ‹æ€§å¹³å°çš„å®è·µç»éªŒ,é˜è¿°å¾®æœåŠ¡æ¶æ„çš„æ ¸å¿ƒè®¾è®¡åŸåˆ™å’Œæœ€ä½³å®è·µã€‚

## ğŸ¯ æ ¸å¿ƒè®¾è®¡åŸåˆ™

### 1. å•ä¸€èŒè´£åŸåˆ™ (Single Responsibility Principle)

æ¯ä¸ªå¾®æœåŠ¡åº”è¯¥åªè´Ÿè´£ä¸€ä¸ªä¸šåŠ¡èƒ½åŠ›,ä¿æŒé«˜å†…èšã€ä½è€¦åˆã€‚

```rust
// âŒ é”™è¯¯ç¤ºä¾‹: æœåŠ¡èŒè´£è¿‡å¤š
pub struct UserService {
    user_repository: UserRepository,
    order_repository: OrderRepository,      // ä¸åº”è¯¥åœ¨ç”¨æˆ·æœåŠ¡ä¸­
    payment_processor: PaymentProcessor,    // ä¸åº”è¯¥åœ¨ç”¨æˆ·æœåŠ¡ä¸­
    notification_sender: NotificationSender, // ä¸åº”è¯¥åœ¨ç”¨æˆ·æœåŠ¡ä¸­
}

// âœ… æ­£ç¡®ç¤ºä¾‹: å•ä¸€èŒè´£
pub struct UserService {
    user_repository: UserRepository,
    event_publisher: EventPublisher, // é€šè¿‡äº‹ä»¶ä¸å…¶ä»–æœåŠ¡é€šä¿¡
}

impl UserService {
    /// ç”¨æˆ·æœåŠ¡åªè´Ÿè´£ç”¨æˆ·ç›¸å…³çš„æ ¸å¿ƒä¸šåŠ¡
    pub async fn create_user(&self, user_data: CreateUserRequest) -> Result<User, UserError> {
        // 1. åˆ›å»ºç”¨æˆ·
        let user = self.user_repository.create(user_data).await?;
        
        // 2. å‘å¸ƒç”¨æˆ·åˆ›å»ºäº‹ä»¶,è®©å…¶ä»–æœåŠ¡å“åº”
        self.event_publisher.publish(UserCreatedEvent {
            user_id: user.id.clone(),
            email: user.email.clone(),
            created_at: user.created_at,
        }).await?;
        
        Ok(user)
    }
}

// è®¢å•æœåŠ¡ç‹¬ç«‹è´Ÿè´£è®¢å•ä¸šåŠ¡
pub struct OrderService {
    order_repository: OrderRepository,
}

// æ”¯ä»˜æœåŠ¡ç‹¬ç«‹è´Ÿè´£æ”¯ä»˜ä¸šåŠ¡
pub struct PaymentService {
    payment_gateway: PaymentGateway,
}
```

**æœåŠ¡è¾¹ç•Œåˆ’åˆ†åŸåˆ™**:

```rust
/// æœåŠ¡è¾¹ç•Œå®šä¹‰
pub trait ServiceBoundary {
    /// æœåŠ¡åç§°
    fn service_name(&self) -> &str;
    
    /// æœåŠ¡è´Ÿè´£çš„ä¸šåŠ¡é¢†åŸŸ
    fn business_domain(&self) -> BusinessDomain;
    
    /// æœåŠ¡å¯¹å¤–æä¾›çš„èƒ½åŠ›
    fn capabilities(&self) -> Vec<ServiceCapability>;
}

/// ä¸šåŠ¡é¢†åŸŸ
#[derive(Debug, Clone)]
pub enum BusinessDomain {
    UserManagement,      // ç”¨æˆ·ç®¡ç†
    OrderProcessing,     // è®¢å•å¤„ç†
    PaymentProcessing,   // æ”¯ä»˜å¤„ç†
    InventoryManagement, // åº“å­˜ç®¡ç†
    Notification,        // é€šçŸ¥æœåŠ¡
}

/// ç”¨æˆ·æœåŠ¡çš„è¾¹ç•Œå®šä¹‰
pub struct UserServiceBoundary;

impl ServiceBoundary for UserServiceBoundary {
    fn service_name(&self) -> &str {
        "user-service"
    }
    
    fn business_domain(&self) -> BusinessDomain {
        BusinessDomain::UserManagement
    }
    
    fn capabilities(&self) -> Vec<ServiceCapability> {
        vec![
            ServiceCapability::CreateUser,
            ServiceCapability::UpdateUser,
            ServiceCapability::GetUser,
            ServiceCapability::DeleteUser,
            ServiceCapability::AuthenticateUser,
        ]
    }
}
```

### 2. æœåŠ¡è‡ªæ²»åŸåˆ™ (Service Autonomy)

æ¯ä¸ªæœåŠ¡åº”è¯¥èƒ½å¤Ÿç‹¬ç«‹å¼€å‘ã€éƒ¨ç½²ã€æ‰©å±•å’Œè¿è¡Œ,ä¸ä¾èµ–å…¶ä»–æœåŠ¡çš„å†…éƒ¨å®ç°ã€‚

```rust
/// è‡ªæ²»æœåŠ¡çš„æ ¸å¿ƒç‰¹å¾
pub struct AutonomousService {
    /// ç‹¬ç«‹çš„æ•°æ®å­˜å‚¨
    database: Arc<Database>,
    
    /// ç‹¬ç«‹çš„é…ç½®ç®¡ç†
    config: Arc<ServiceConfig>,
    
    /// ç‹¬ç«‹çš„æ—¥å¿—ç³»ç»Ÿ
    logger: Arc<Logger>,
    
    /// ç‹¬ç«‹çš„ç›‘æ§æŒ‡æ ‡
    metrics: Arc<MetricsCollector>,
    
    /// ç‹¬ç«‹çš„å¥åº·æ£€æŸ¥
    health_checker: Arc<HealthChecker>,
}

impl AutonomousService {
    /// æœåŠ¡å¯åŠ¨ - å®Œå…¨è‡ªä¸»
    pub async fn start(&self) -> Result<(), ServiceError> {
        // 1. åˆå§‹åŒ–æ•°æ®åº“è¿æ¥
        self.database.connect().await?;
        
        // 2. åŠ è½½é…ç½®
        self.config.load().await?;
        
        // 3. å¯åŠ¨å¥åº·æ£€æŸ¥
        self.health_checker.start().await?;
        
        // 4. æ³¨å†Œåˆ°æœåŠ¡æ³¨å†Œä¸­å¿ƒ
        self.register_to_discovery().await?;
        
        // 5. å¯åŠ¨ HTTP/gRPC æœåŠ¡å™¨
        self.start_server().await?;
        
        Ok(())
    }
    
    /// æœåŠ¡å…³é—­ - ä¼˜é›…é€€å‡º
    pub async fn shutdown(&self) -> Result<(), ServiceError> {
        // 1. ä»æœåŠ¡æ³¨å†Œä¸­å¿ƒæ³¨é”€
        self.deregister_from_discovery().await?;
        
        // 2. åœæ­¢æ¥æ”¶æ–°è¯·æ±‚
        self.stop_accepting_requests().await?;
        
        // 3. ç­‰å¾…ç°æœ‰è¯·æ±‚å®Œæˆ
        self.wait_for_active_requests().await?;
        
        // 4. å…³é—­æ•°æ®åº“è¿æ¥
        self.database.disconnect().await?;
        
        Ok(())
    }
}
```

**æœåŠ¡ç‰ˆæœ¬ç®¡ç†**:

```rust
/// æœåŠ¡ç‰ˆæœ¬åŒ– API
#[derive(Debug, Clone)]
pub struct VersionedApi {
    version: ApiVersion,
    endpoints: Vec<Endpoint>,
}

#[derive(Debug, Clone)]
pub enum ApiVersion {
    V1,
    V2,
    V3,
}

/// æ”¯æŒå¤šç‰ˆæœ¬å¹¶å­˜
pub struct MultiVersionService {
    v1_handler: Arc<V1Handler>,
    v2_handler: Arc<V2Handler>,
    v3_handler: Arc<V3Handler>,
}

impl MultiVersionService {
    /// æ ¹æ®ç‰ˆæœ¬è·¯ç”±è¯·æ±‚
    pub async fn handle_request(&self, request: HttpRequest) -> Result<HttpResponse, ApiError> {
        match self.extract_api_version(&request)? {
            ApiVersion::V1 => self.v1_handler.handle(request).await,
            ApiVersion::V2 => self.v2_handler.handle(request).await,
            ApiVersion::V3 => self.v3_handler.handle(request).await,
        }
    }
    
    fn extract_api_version(&self, request: &HttpRequest) -> Result<ApiVersion, ApiError> {
        // ä» URL è·¯å¾„æå–ç‰ˆæœ¬: /api/v1/users
        if request.path.starts_with("/api/v1/") {
            Ok(ApiVersion::V1)
        } else if request.path.starts_with("/api/v2/") {
            Ok(ApiVersion::V2)
        } else if request.path.starts_with("/api/v3/") {
            Ok(ApiVersion::V3)
        } else {
            Err(ApiError::InvalidVersion)
        }
    }
}
```

### 3. å»ä¸­å¿ƒåŒ–æ²»ç† (Decentralized Governance)

é¿å…ä¸­å¿ƒåŒ–çš„æ•°æ®åº“å’Œå…±äº«åº“,æ¯ä¸ªå›¢é˜Ÿå¯ä»¥é€‰æ‹©æœ€é€‚åˆçš„æŠ€æœ¯æ ˆã€‚

```rust
/// æœåŠ¡æŠ€æœ¯æ ˆé€‰æ‹©
pub struct ServiceTechStack {
    language: ProgrammingLanguage,
    database: DatabaseType,
    message_queue: MessageQueueType,
    cache: CacheType,
}

#[derive(Debug, Clone)]
pub enum ProgrammingLanguage {
    Rust,
    Go,
    Java,
    Python,
}

#[derive(Debug, Clone)]
pub enum DatabaseType {
    PostgreSQL,
    MySQL,
    MongoDB,
    Redis,
    Cassandra,
}

/// ç”¨æˆ·æœåŠ¡é€‰æ‹© Rust + PostgreSQL
pub fn user_service_stack() -> ServiceTechStack {
    ServiceTechStack {
        language: ProgrammingLanguage::Rust,
        database: DatabaseType::PostgreSQL,
        message_queue: MessageQueueType::Kafka,
        cache: CacheType::Redis,
    }
}

/// è®¢å•æœåŠ¡é€‰æ‹© Rust + MongoDB
pub fn order_service_stack() -> ServiceTechStack {
    ServiceTechStack {
        language: ProgrammingLanguage::Rust,
        database: DatabaseType::MongoDB,
        message_queue: MessageQueueType::Kafka,
        cache: CacheType::Redis,
    }
}
```

**æ ‡å‡†åŒ–æ¥å£å¥‘çº¦**:

```rust
/// æœåŠ¡é—´é€šä¿¡çš„æ ‡å‡†å¥‘çº¦
pub trait ServiceContract {
    /// API è§„èŒƒ (OpenAPI/gRPC)
    fn api_specification(&self) -> ApiSpec;
    
    /// äº‹ä»¶è§„èŒƒ (CloudEvents)
    fn event_specification(&self) -> EventSpec;
    
    /// å¯è§‚æµ‹æ€§è§„èŒƒ (OTLP)
    fn observability_specification(&self) -> ObservabilitySpec;
}

/// API è§„èŒƒ
#[derive(Debug, Clone)]
pub struct ApiSpec {
    pub format: ApiFormat,
    pub version: String,
    pub endpoints: Vec<EndpointSpec>,
}

#[derive(Debug, Clone)]
pub enum ApiFormat {
    RestOpenApi,
    Grpc,
    GraphQL,
}

/// äº‹ä»¶è§„èŒƒ
#[derive(Debug, Clone)]
pub struct EventSpec {
    pub format: EventFormat,
    pub events: Vec<EventDefinition>,
}

#[derive(Debug, Clone)]
pub enum EventFormat {
    CloudEvents,
    CustomJson,
}
```

### 4. æ•…éšœéš”ç¦»åŸåˆ™ (Failure Isolation)

ä¸€ä¸ªæœåŠ¡çš„å¤±è´¥ä¸åº”è¯¥å¯¼è‡´æ•´ä¸ªç³»ç»Ÿå´©æºƒ,é€šè¿‡éš”ç¦»æœºåˆ¶é™åˆ¶æ•…éšœå½±å“èŒƒå›´ã€‚

```rust
use std::sync::Arc;
use tokio::sync::Semaphore;

/// æ•…éšœéš”ç¦»å™¨
pub struct FailureIsolator {
    /// æ–­è·¯å™¨
    circuit_breaker: Arc<CircuitBreaker>,
    
    /// èˆ±å£éš”ç¦» (é™åˆ¶å¹¶å‘)
    bulkhead: Arc<Semaphore>,
    
    /// è¶…æ—¶æ§åˆ¶
    timeout: Duration,
    
    /// é‡è¯•ç­–ç•¥
    retry_policy: RetryPolicy,
}

impl FailureIsolator {
    /// æ‰§è¡Œéš”ç¦»çš„è°ƒç”¨
    pub async fn execute<F, T>(&self, operation: F) -> Result<T, IsolationError>
    where
        F: Future<Output = Result<T, Box<dyn std::error::Error>>>,
    {
        // 1. æ£€æŸ¥æ–­è·¯å™¨çŠ¶æ€
        if !self.circuit_breaker.allow_request() {
            return Err(IsolationError::CircuitBreakerOpen);
        }
        
        // 2. è·å–èˆ±å£è®¸å¯ (é™åˆ¶å¹¶å‘)
        let _permit = self.bulkhead.acquire().await
            .map_err(|_| IsolationError::BulkheadFull)?;
        
        // 3. å¸¦è¶…æ—¶æ‰§è¡Œæ“ä½œ
        let result = tokio::time::timeout(self.timeout, operation).await;
        
        match result {
            Ok(Ok(value)) => {
                // æˆåŠŸ - è®°å½•æˆåŠŸ
                self.circuit_breaker.record_success();
                Ok(value)
            }
            Ok(Err(e)) => {
                // å¤±è´¥ - è®°å½•å¤±è´¥
                self.circuit_breaker.record_failure();
                Err(IsolationError::OperationFailed(e.to_string()))
            }
            Err(_) => {
                // è¶…æ—¶ - è®°å½•å¤±è´¥
                self.circuit_breaker.record_failure();
                Err(IsolationError::Timeout)
            }
        }
    }
}

/// æ–­è·¯å™¨å®ç°
pub struct CircuitBreaker {
    state: Arc<RwLock<CircuitBreakerState>>,
    failure_threshold: usize,
    success_threshold: usize,
    timeout: Duration,
}

#[derive(Debug, Clone)]
enum CircuitBreakerState {
    Closed { failure_count: usize },
    Open { opened_at: Instant },
    HalfOpen { success_count: usize },
}

impl CircuitBreaker {
    pub fn allow_request(&self) -> bool {
        let state = self.state.read().unwrap();
        match *state {
            CircuitBreakerState::Closed { .. } => true,
            CircuitBreakerState::Open { opened_at } => {
                // è¶…æ—¶åè¿›å…¥åŠå¼€çŠ¶æ€
                opened_at.elapsed() > self.timeout
            }
            CircuitBreakerState::HalfOpen { .. } => true,
        }
    }
    
    pub fn record_success(&self) {
        let mut state = self.state.write().unwrap();
        match *state {
            CircuitBreakerState::Closed { .. } => {
                // ä¿æŒå…³é—­çŠ¶æ€
            }
            CircuitBreakerState::HalfOpen { success_count } => {
                if success_count + 1 >= self.success_threshold {
                    // æ¢å¤åˆ°å…³é—­çŠ¶æ€
                    *state = CircuitBreakerState::Closed { failure_count: 0 };
                } else {
                    *state = CircuitBreakerState::HalfOpen { success_count: success_count + 1 };
                }
            }
            CircuitBreakerState::Open { .. } => {
                // è¿›å…¥åŠå¼€çŠ¶æ€
                *state = CircuitBreakerState::HalfOpen { success_count: 1 };
            }
        }
    }
    
    pub fn record_failure(&self) {
        let mut state = self.state.write().unwrap();
        match *state {
            CircuitBreakerState::Closed { failure_count } => {
                if failure_count + 1 >= self.failure_threshold {
                    // æ‰“å¼€æ–­è·¯å™¨
                    *state = CircuitBreakerState::Open { opened_at: Instant::now() };
                } else {
                    *state = CircuitBreakerState::Closed { failure_count: failure_count + 1 };
                }
            }
            CircuitBreakerState::HalfOpen { .. } => {
                // é‡æ–°æ‰“å¼€æ–­è·¯å™¨
                *state = CircuitBreakerState::Open { opened_at: Instant::now() };
            }
            CircuitBreakerState::Open { .. } => {
                // ä¿æŒæ‰“å¼€çŠ¶æ€
            }
        }
    }
}
```

### 5. å¯è§‚æµ‹æ€§ä¼˜å…ˆ (Observability First)

ä»è®¾è®¡é˜¶æ®µå°±è€ƒè™‘å¯è§‚æµ‹æ€§,ç¡®ä¿ç³»ç»Ÿçš„è¿è¡ŒçŠ¶æ€å¯è§ã€å¯è¿½è¸ªã€å¯åˆ†æã€‚

```rust
use opentelemetry::trace::{Tracer, Span};
use opentelemetry::metrics::Meter;

/// å¯è§‚æµ‹æ€§é›†æˆçš„æœåŠ¡
pub struct ObservableService {
    tracer: Arc<Tracer>,
    meter: Arc<Meter>,
    logger: Arc<Logger>,
}

impl ObservableService {
    /// å¤„ç†è¯·æ±‚ - å®Œæ•´çš„å¯è§‚æµ‹æ€§
    pub async fn handle_request(&self, request: Request) -> Result<Response, ServiceError> {
        // 1. åˆ›å»ºè¿½è¸ª Span
        let span = self.tracer.start("handle_request");
        let _guard = span.enter();
        
        // æ·»åŠ è¯·æ±‚å±æ€§
        span.set_attribute("request.id", request.id.clone());
        span.set_attribute("request.method", request.method.as_str());
        span.set_attribute("request.path", request.path.as_str());
        
        // 2. è®°å½•æŒ‡æ ‡
        let start_time = Instant::now();
        self.meter.create_counter("requests_total").add(1, &[]);
        
        // 3. è®°å½•æ—¥å¿—
        tracing::info!(
            request_id = %request.id,
            method = %request.method,
            path = %request.path,
            "Processing request"
        );
        
        // 4. æ‰§è¡Œä¸šåŠ¡é€»è¾‘
        let result = self.process_request(request).await;
        
        // 5. è®°å½•ç»“æœ
        let duration = start_time.elapsed();
        match &result {
            Ok(response) => {
                span.set_attribute("response.status", "success");
                span.set_attribute("response.status_code", response.status_code as i64);
                self.meter.create_histogram("request_duration_ms").record(duration.as_millis() as f64, &[]);
                tracing::info!(duration_ms = duration.as_millis(), "Request completed successfully");
            }
            Err(e) => {
                span.set_attribute("response.status", "error");
                span.set_attribute("error.message", e.to_string());
                self.meter.create_counter("requests_failed_total").add(1, &[]);
                tracing::error!(error = %e, duration_ms = duration.as_millis(), "Request failed");
            }
        }
        
        result
    }
}
```

## ğŸ—ï¸ æ¶æ„è®¾è®¡æ¨¡å¼

### 1. API ç½‘å…³æ¨¡å¼

```rust
/// API ç½‘å…³ - ç»Ÿä¸€å…¥å£
pub struct ApiGateway {
    router: Arc<Router>,
    auth_service: Arc<AuthService>,
    rate_limiter: Arc<RateLimiter>,
    tracer: Arc<Tracer>,
}

impl ApiGateway {
    pub async fn handle_request(&self, request: HttpRequest) -> Result<HttpResponse, GatewayError> {
        let span = self.tracer.start("api_gateway_request");
        let _guard = span.enter();
        
        // 1. è®¤è¯
        let user = self.auth_service.authenticate(&request).await?;
        span.set_attribute("user.id", user.id.clone());
        
        // 2. é™æµ
        self.rate_limiter.check_rate_limit(&user.id).await?;
        
        // 3. è·¯ç”±åˆ°åç«¯æœåŠ¡
        let backend_service = self.router.route(&request)?;
        span.set_attribute("backend.service", backend_service.name.clone());
        
        // 4. è½¬å‘è¯·æ±‚
        let response = self.forward_to_backend(backend_service, request).await?;
        
        Ok(response)
    }
}
```

### 2. æœåŠ¡å‘ç°æ¨¡å¼

```rust
/// æœåŠ¡å‘ç°å®¢æˆ·ç«¯
pub struct ServiceDiscoveryClient {
    registry: Arc<ServiceRegistry>,
    load_balancer: Arc<LoadBalancer>,
    cache: Arc<RwLock<HashMap<String, Vec<ServiceInstance>>>>,
}

impl ServiceDiscoveryClient {
    /// å‘ç°æœåŠ¡å®ä¾‹
    pub async fn discover(&self, service_name: &str) -> Result<ServiceInstance, DiscoveryError> {
        // 1. ä»ç¼“å­˜è·å–
        if let Some(instances) = self.get_from_cache(service_name).await {
            return self.load_balancer.select(instances).await;
        }
        
        // 2. ä»æ³¨å†Œä¸­å¿ƒè·å–
        let instances = self.registry.get_instances(service_name).await?;
        
        // 3. æ›´æ–°ç¼“å­˜
        self.update_cache(service_name, instances.clone()).await;
        
        // 4. è´Ÿè½½å‡è¡¡é€‰æ‹©
        self.load_balancer.select(instances).await
    }
}
```

### 3. æ–­è·¯å™¨æ¨¡å¼

å·²åœ¨æ•…éšœéš”ç¦»åŸåˆ™ä¸­è¯¦ç»†è¯´æ˜ã€‚

### 4. äº‹ä»¶é©±åŠ¨æ¶æ„

```rust
/// äº‹ä»¶å‘å¸ƒå™¨
pub struct EventPublisher {
    kafka_producer: Arc<KafkaProducer>,
    tracer: Arc<Tracer>,
}

impl EventPublisher {
    /// å‘å¸ƒé¢†åŸŸäº‹ä»¶
    pub async fn publish<E: DomainEvent>(&self, event: E) -> Result<(), PublishError> {
        let span = self.tracer.start("publish_event");
        let _guard = span.enter();
        
        span.set_attribute("event.type", event.event_type());
        span.set_attribute("event.id", event.event_id());
        
        // åºåˆ—åŒ–äº‹ä»¶
        let payload = serde_json::to_vec(&event)?;
        
        // å‘å¸ƒåˆ° Kafka
        self.kafka_producer.send(event.topic(), payload).await?;
        
        Ok(())
    }
}

/// äº‹ä»¶æ¶ˆè´¹è€…
pub struct EventConsumer {
    kafka_consumer: Arc<KafkaConsumer>,
    handlers: HashMap<String, Box<dyn EventHandler>>,
    tracer: Arc<Tracer>,
}

impl EventConsumer {
    /// æ¶ˆè´¹äº‹ä»¶
    pub async fn consume(&self) -> Result<(), ConsumeError> {
        loop {
            let message = self.kafka_consumer.poll().await?;
            
            let span = self.tracer.start("consume_event");
            let _guard = span.enter();
            
            // æå–äº‹ä»¶ç±»å‹
            let event_type = self.extract_event_type(&message)?;
            span.set_attribute("event.type", event_type.clone());
            
            // æŸ¥æ‰¾å¤„ç†å™¨
            if let Some(handler) = self.handlers.get(&event_type) {
                handler.handle(message).await?;
            }
        }
    }
}
```

### 5. CQRS æ¨¡å¼

```rust
/// å‘½ä»¤å¤„ç†å™¨ (å†™æ“ä½œ)
pub struct CommandHandler {
    write_db: Arc<WriteDatabase>,
    event_publisher: Arc<EventPublisher>,
}

impl CommandHandler {
    pub async fn handle_create_order(&self, cmd: CreateOrderCommand) -> Result<OrderId, CommandError> {
        // 1. éªŒè¯å‘½ä»¤
        self.validate_command(&cmd)?;
        
        // 2. åˆ›å»ºè®¢å• (å†™å…¥ä¸»æ•°æ®åº“)
        let order_id = self.write_db.create_order(cmd).await?;
        
        // 3. å‘å¸ƒäº‹ä»¶
        self.event_publisher.publish(OrderCreatedEvent {
            order_id: order_id.clone(),
            user_id: cmd.user_id,
            items: cmd.items,
            created_at: Utc::now(),
        }).await?;
        
        Ok(order_id)
    }
}

/// æŸ¥è¯¢å¤„ç†å™¨ (è¯»æ“ä½œ)
pub struct QueryHandler {
    read_db: Arc<ReadDatabase>, // å¯ä»¥æ˜¯ä¸åŒçš„æ•°æ®åº“æˆ–ç¼“å­˜
}

impl QueryHandler {
    pub async fn get_order(&self, order_id: &OrderId) -> Result<OrderView, QueryError> {
        // ä»è¯»ä¼˜åŒ–çš„æ•°æ®åº“æŸ¥è¯¢
        self.read_db.get_order(order_id).await
    }
    
    pub async fn get_user_orders(&self, user_id: &UserId) -> Result<Vec<OrderView>, QueryError> {
        // ä»è¯»ä¼˜åŒ–çš„æ•°æ®åº“æŸ¥è¯¢
        self.read_db.get_user_orders(user_id).await
    }
}
```

## ğŸ“Š æ•°æ®ç®¡ç†åŸåˆ™

### 1. æ•°æ®åº“ç‹¬ç«‹åŸåˆ™

æ¯ä¸ªæœåŠ¡æ‹¥æœ‰è‡ªå·±çš„æ•°æ®åº“,é¿å…å…±äº«æ•°æ®åº“ã€‚

```rust
/// ç”¨æˆ·æœåŠ¡çš„æ•°æ®åº“
pub struct UserDatabase {
    pool: Arc<PgPool>, // PostgreSQL
}

/// è®¢å•æœåŠ¡çš„æ•°æ®åº“
pub struct OrderDatabase {
    client: Arc<MongoClient>, // MongoDB
}

/// äº§å“æœåŠ¡çš„æ•°æ®åº“
pub struct ProductDatabase {
    pool: Arc<PgPool>, // PostgreSQL
}
```

### 2. æœ€ç»ˆä¸€è‡´æ€§

é€šè¿‡äº‹ä»¶é©±åŠ¨å®ç°æœ€ç»ˆä¸€è‡´æ€§ã€‚

```rust
/// è®¢å•æœåŠ¡ - åˆ›å»ºè®¢å•
pub async fn create_order(order: CreateOrderRequest) -> Result<Order, OrderError> {
    // 1. åˆ›å»ºè®¢å•
    let order = order_db.create(order).await?;
    
    // 2. å‘å¸ƒè®¢å•åˆ›å»ºäº‹ä»¶
    event_publisher.publish(OrderCreatedEvent {
        order_id: order.id.clone(),
        user_id: order.user_id.clone(),
        items: order.items.clone(),
    }).await?;
    
    Ok(order)
}

/// åº“å­˜æœåŠ¡ - ç›‘å¬è®¢å•åˆ›å»ºäº‹ä»¶
pub async fn on_order_created(event: OrderCreatedEvent) -> Result<(), InventoryError> {
    // æ‰£å‡åº“å­˜
    for item in event.items {
        inventory_db.decrease_stock(item.product_id, item.quantity).await?;
    }
    
    // å‘å¸ƒåº“å­˜æ‰£å‡äº‹ä»¶
    event_publisher.publish(InventoryDecreasedEvent {
        order_id: event.order_id,
        items: event.items,
    }).await?;
    
    Ok(())
}
```

### 3. Saga æ¨¡å¼

åˆ†å¸ƒå¼äº‹åŠ¡çš„è¡¥å¿æœºåˆ¶ã€‚

```rust
/// Saga ç¼–æ’å™¨
pub struct SagaOrchestrator {
    steps: Vec<SagaStep>,
    compensation_steps: Vec<CompensationStep>,
}

impl SagaOrchestrator {
    /// æ‰§è¡Œ Saga
    pub async fn execute(&self) -> Result<(), SagaError> {
        let mut completed_steps = Vec::new();
        
        // æ‰§è¡Œæ‰€æœ‰æ­¥éª¤
        for step in &self.steps {
            match step.execute().await {
                Ok(_) => completed_steps.push(step),
                Err(e) => {
                    // å¤±è´¥ - æ‰§è¡Œè¡¥å¿
                    self.compensate(completed_steps).await?;
                    return Err(SagaError::StepFailed(e));
                }
            }
        }
        
        Ok(())
    }
    
    /// æ‰§è¡Œè¡¥å¿
    async fn compensate(&self, completed_steps: Vec<&SagaStep>) -> Result<(), SagaError> {
        // åå‘æ‰§è¡Œè¡¥å¿æ­¥éª¤
        for step in completed_steps.iter().rev() {
            step.compensate().await?;
        }
        Ok(())
    }
}

/// è®¢å• Saga ç¤ºä¾‹
pub async fn create_order_saga(order: CreateOrderRequest) -> Result<Order, SagaError> {
    let saga = SagaOrchestrator::new()
        // æ­¥éª¤ 1: åˆ›å»ºè®¢å•
        .add_step(CreateOrderStep { order: order.clone() })
        .with_compensation(CancelOrderStep { order_id: order.id })
        
        // æ­¥éª¤ 2: æ‰£å‡åº“å­˜
        .add_step(DecreaseInventoryStep { items: order.items.clone() })
        .with_compensation(RestoreInventoryStep { items: order.items.clone() })
        
        // æ­¥éª¤ 3: å¤„ç†æ”¯ä»˜
        .add_step(ProcessPaymentStep { amount: order.total_amount })
        .with_compensation(RefundPaymentStep { amount: order.total_amount });
    
    saga.execute().await
}
```

## ğŸ”’ å®‰å…¨è®¾è®¡åŸåˆ™

### 1. é›¶ä¿¡ä»»æ¶æ„

```rust
/// é›¶ä¿¡ä»»è®¤è¯ä¸­é—´ä»¶
pub struct ZeroTrustMiddleware {
    auth_service: Arc<AuthService>,
    policy_engine: Arc<PolicyEngine>,
}

impl ZeroTrustMiddleware {
    pub async fn authenticate(&self, request: &HttpRequest) -> Result<AuthContext, AuthError> {
        // 1. éªŒè¯ JWT Token
        let token = self.extract_token(request)?;
        let claims = self.auth_service.verify_token(&token).await?;
        
        // 2. æ£€æŸ¥æƒé™ç­–ç•¥
        let allowed = self.policy_engine.evaluate_policy(
            &claims.user_id,
            &request.method,
            &request.path,
        ).await?;
        
        if !allowed {
            return Err(AuthError::Forbidden);
        }
        
        Ok(AuthContext {
            user_id: claims.user_id,
            roles: claims.roles,
        })
    }
}
```

### 2. æ·±åº¦é˜²å¾¡

å¤šå±‚å®‰å…¨é˜²æŠ¤ã€‚

### 3. æœ€å°æƒé™åŸåˆ™

æœåŠ¡åªè·å–å¿…è¦çš„æƒé™ã€‚

## âš¡ æ€§èƒ½è®¾è®¡åŸåˆ™

### 1. å¼‚æ­¥ä¼˜å…ˆ

ä½¿ç”¨ Tokio å¼‚æ­¥è¿è¡Œæ—¶ã€‚

### 2. ç¼“å­˜ç­–ç•¥

```rust
/// å¤šçº§ç¼“å­˜
pub struct MultiLevelCache {
    l1_cache: Arc<LocalCache>,      // æœ¬åœ°ç¼“å­˜
    l2_cache: Arc<RedisCache>,      // Redis ç¼“å­˜
    database: Arc<Database>,         // æ•°æ®åº“
}

impl MultiLevelCache {
    pub async fn get(&self, key: &str) -> Result<Value, CacheError> {
        // 1. L1 ç¼“å­˜
        if let Some(value) = self.l1_cache.get(key) {
            return Ok(value);
        }
        
        // 2. L2 ç¼“å­˜
        if let Some(value) = self.l2_cache.get(key).await? {
            self.l1_cache.set(key, value.clone());
            return Ok(value);
        }
        
        // 3. æ•°æ®åº“
        let value = self.database.get(key).await?;
        self.l2_cache.set(key, value.clone()).await?;
        self.l1_cache.set(key, value.clone());
        
        Ok(value)
    }
}
```

### 3. è´Ÿè½½å‡è¡¡

å·²åœ¨æœåŠ¡å‘ç°æ¨¡å¼ä¸­è¯´æ˜ã€‚

## ğŸ¯ å®è·µå»ºè®®

1. **ä»å•ä½“å¼€å§‹**: ä¸è¦è¿‡æ—©å¾®æœåŠ¡åŒ–,å…ˆæ„å»ºå•ä½“åº”ç”¨,ç†è§£ä¸šåŠ¡è¾¹ç•Œåå†æ‹†åˆ†
2. **æ¸è¿›å¼æ‹†åˆ†**: é€æ­¥å°†å•ä½“æ‹†åˆ†ä¸ºå¾®æœåŠ¡,è€Œä¸æ˜¯ä¸€æ¬¡æ€§é‡å†™
3. **è‡ªåŠ¨åŒ–ä¼˜å…ˆ**: æŠ•èµ„è‡ªåŠ¨åŒ–æµ‹è¯•ã€CI/CDã€ç›‘æ§å‘Šè­¦
4. **æ–‡æ¡£é©±åŠ¨**: ç»´æŠ¤ API æ–‡æ¡£ã€æ¶æ„å†³ç­–è®°å½•(ADR)
5. **å›¢é˜Ÿè‡ªæ²»**: æ¯ä¸ªå›¢é˜Ÿè´Ÿè´£ç«¯åˆ°ç«¯çš„æœåŠ¡ç”Ÿå‘½å‘¨æœŸ

---

**æ€»ç»“**: å¾®æœåŠ¡æ¶æ„è®¾è®¡åŸåˆ™ä¸ºæ„å»ºå¯æ‰©å±•ã€å¯ç»´æŠ¤çš„åˆ†å¸ƒå¼ç³»ç»Ÿæä¾›äº†æŒ‡å¯¼ã€‚é€šè¿‡éµå¾ªè¿™äº›åŸåˆ™,ç»“åˆ Rust çš„æ€§èƒ½å’Œå®‰å…¨ç‰¹æ€§,å¯ä»¥æ„å»ºå‡ºé«˜è´¨é‡çš„å¾®æœåŠ¡ç³»ç»Ÿã€‚
