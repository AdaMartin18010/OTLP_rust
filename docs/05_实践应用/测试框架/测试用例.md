# OTLP Rust æµ‹è¯•æ¡†æ¶ä¸ç”¨ä¾‹

## ğŸ“š æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»äº†OTLP Rustå®ç°çš„æµ‹è¯•æ¡†æ¶ï¼ŒåŒ…æ‹¬å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ã€æ€§èƒ½æµ‹è¯•ã€å‹åŠ›æµ‹è¯•ç­‰ï¼Œä»¥åŠå®Œæ•´çš„æµ‹è¯•ç”¨ä¾‹è®¾è®¡ã€‚

## ğŸ§ª æµ‹è¯•æ¡†æ¶æ¶æ„

### 1. æµ‹è¯•åˆ†å±‚

```rust
// æµ‹è¯•åˆ†å±‚ç»“æ„
pub mod unit_tests {
    // å•å…ƒæµ‹è¯• - æµ‹è¯•å•ä¸ªå‡½æ•°å’Œæ¨¡å—
}

pub mod integration_tests {
    // é›†æˆæµ‹è¯• - æµ‹è¯•æ¨¡å—é—´äº¤äº’
}

pub mod performance_tests {
    // æ€§èƒ½æµ‹è¯• - æµ‹è¯•æ€§èƒ½æŒ‡æ ‡
}

pub mod stress_tests {
    // å‹åŠ›æµ‹è¯• - æµ‹è¯•ç³»ç»Ÿæé™
}

pub mod e2e_tests {
    // ç«¯åˆ°ç«¯æµ‹è¯• - æµ‹è¯•å®Œæ•´æµç¨‹
}
```

### 2. æµ‹è¯•å·¥å…·é“¾

```toml
# Cargo.toml æµ‹è¯•ä¾èµ–
[dev-dependencies]
tokio-test = "0.4"
criterion = { version = "0.5", features = ["html_reports"] }
proptest = "1.0"
mockito = "1.0"
testcontainers = "0.15"
serial_test = "2.0"
tempfile = "3.0"
assert_cmd = "2.0"
predicates = "3.0"
```

## ğŸ”¬ å•å…ƒæµ‹è¯•

### 1. å®¢æˆ·ç«¯æµ‹è¯•

```rust
#[cfg(test)]
mod client_tests {
    use super::*;
    use tokio_test;
    use mockito;

    #[tokio::test]
    async fn test_client_creation() {
        let config = OtlpConfig::default()
            .with_endpoint("http://localhost:4317")
            .with_service("test-service", "1.0.0");
        
        let client = OtlpClient::new(config).await;
        assert!(client.is_ok());
    }

    #[tokio::test]
    async fn test_client_initialization() {
        let config = OtlpConfig::default()
            .with_endpoint("http://localhost:4317");
        
        let client = OtlpClient::new(config).await.unwrap();
        let result = client.initialize().await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_invalid_endpoint() {
        let config = OtlpConfig::default()
            .with_endpoint("invalid-url");
        
        let client = OtlpClient::new(config).await;
        assert!(client.is_err());
    }
}
```

### 2. é…ç½®æµ‹è¯•

```rust
#[cfg(test)]
mod config_tests {
    use super::*;

    #[test]
    fn test_default_config() {
        let config = OtlpConfig::default();
        assert_eq!(config.endpoint, "http://localhost:4317");
        assert_eq!(config.protocol, TransportProtocol::Grpc);
        assert_eq!(config.sampling_ratio, 1.0);
    }

    #[test]
    fn test_config_builder() {
        let config = OtlpConfig::default()
            .with_endpoint("https://api.example.com")
            .with_protocol(TransportProtocol::Http)
            .with_sampling_ratio(0.1);
        
        assert_eq!(config.endpoint, "https://api.example.com");
        assert_eq!(config.protocol, TransportProtocol::Http);
        assert_eq!(config.sampling_ratio, 0.1);
    }

    #[test]
    fn test_config_validation() {
        // æµ‹è¯•æ— æ•ˆçš„é‡‡æ ·ç‡
        let config = OtlpConfig::default()
            .with_sampling_ratio(1.5);
        
        assert!(config.validate().is_err());
        
        // æµ‹è¯•æ— æ•ˆçš„ç«¯ç‚¹
        let config = OtlpConfig::default()
            .with_endpoint("");
        
        assert!(config.validate().is_err());
    }
}
```

### 3. æ•°æ®æ¨¡å‹æµ‹è¯•

```rust
#[cfg(test)]
mod data_tests {
    use super::*;

    #[test]
    fn test_telemetry_data_creation() {
        let trace_data = TelemetryData::trace("test-operation")
            .with_attribute("service.name", "test-service");
        
        assert_eq!(trace_data.operation_name(), "test-operation");
        assert!(trace_data.has_attribute("service.name"));
    }

    #[test]
    fn test_key_value_creation() {
        let kv = KeyValue::new("key", "value");
        assert_eq!(kv.key(), "key");
        assert_eq!(kv.value().as_str(), Some("value"));
        
        let numeric_kv = KeyValue::new("duration", 150.0);
        assert_eq!(numeric_kv.value().as_f64(), Some(150.0));
    }

    #[test]
    fn test_attribute_value_types() {
        let string_val = AttributeValue::String("test".to_string());
        let number_val = AttributeValue::Number(123.45);
        let bool_val = AttributeValue::Boolean(true);
        
        assert!(matches!(string_val, AttributeValue::String(_)));
        assert!(matches!(number_val, AttributeValue::Number(_)));
        assert!(matches!(bool_val, AttributeValue::Boolean(_)));
    }
}
```

## ğŸ”— é›†æˆæµ‹è¯•

### 1. ç«¯åˆ°ç«¯æµ‹è¯•

```rust
#[cfg(test)]
mod integration_tests {
    use super::*;
    use testcontainers::*;
    use testcontainers::images::generic::GenericImage;

    #[tokio::test]
    async fn test_full_otlp_flow() {
        // å¯åŠ¨æµ‹è¯•å®¹å™¨
        let docker = clients::Cli::default();
        let collector_image = GenericImage::new("otel/opentelemetry-collector", "latest");
        let collector = docker.run(collector_image);
        
        let collector_port = collector.get_host_port_ipv4(4317);
        let endpoint = format!("http://localhost:{}", collector_port);
        
        // åˆ›å»ºå®¢æˆ·ç«¯
        let config = OtlpConfig::default()
            .with_endpoint(&endpoint)
            .with_service("integration-test", "1.0.0");
        
        let client = OtlpClient::new(config).await.unwrap();
        client.initialize().await.unwrap();
        
        // å‘é€è¿½è¸ªæ•°æ®
        let trace_result = client.send_trace("integration-test-operation").await.unwrap()
            .with_attribute("test.type", "integration")
            .finish()
            .await.unwrap();
        
        assert!(trace_result.success_count > 0);
        
        // å‘é€æŒ‡æ ‡æ•°æ®
        let metric_result = client.send_metric("test_metric", 1.0).await.unwrap()
            .with_label("test", "integration")
            .send()
            .await.unwrap();
        
        assert!(metric_result.success_count > 0);
        
        // å‘é€æ—¥å¿—æ•°æ®
        let log_result = client.send_log("Integration test log", LogSeverity::Info).await.unwrap()
            .with_attribute("test.type", "integration")
            .send()
            .await.unwrap();
        
        assert!(log_result.success_count > 0);
        
        client.shutdown().await.unwrap();
    }
}
```

### 2. æ‰¹é‡å¤„ç†æµ‹è¯•

```rust
#[tokio::test]
async fn test_batch_processing() {
    let config = OtlpConfig::default()
        .with_endpoint("http://localhost:4317")
        .with_batch_config(BatchConfig {
            max_export_batch_size: 10,
            export_timeout: Duration::from_millis(1000),
            max_queue_size: 100,
            scheduled_delay: Duration::from_millis(100),
            max_export_timeout: Duration::from_secs(5),
        });
    
    let client = OtlpClient::new(config).await.unwrap();
    client.initialize().await.unwrap();
    
    // åˆ›å»ºæ‰¹é‡æ•°æ®
    let mut batch_data = Vec::new();
    for i in 0..20 {
        batch_data.push(TelemetryData::trace(format!("batch-operation-{}", i))
            .with_attribute("batch.id", "test-batch"));
    }
    
    let result = client.send_batch(batch_data).await.unwrap();
    assert!(result.success_count > 0);
    
    client.shutdown().await.unwrap();
}
```

### 3. é”™è¯¯å¤„ç†æµ‹è¯•

```rust
#[tokio::test]
async fn test_error_handling() {
    // æµ‹è¯•è¿æ¥é”™è¯¯
    let config = OtlpConfig::default()
        .with_endpoint("http://invalid-endpoint:9999");
    
    let client = OtlpClient::new(config).await.unwrap();
    let result = client.initialize().await;
    assert!(result.is_err());
    
    // æµ‹è¯•è¶…æ—¶é”™è¯¯
    let config = OtlpConfig::default()
        .with_endpoint("http://localhost:4317")
        .with_timeout(Duration::from_millis(1));
    
    let client = OtlpClient::new(config).await.unwrap();
    client.initialize().await.unwrap();
    
    let result = client.send_trace("timeout-test").await.unwrap()
        .finish()
        .await;
    
    assert!(result.is_err());
}
```

## ğŸ“Š æ€§èƒ½æµ‹è¯•

### 1. åŸºå‡†æµ‹è¯•

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn benchmark_trace_creation(c: &mut Criterion) {
    c.bench_function("trace_creation", |b| {
        b.iter(|| {
            let trace = TelemetryData::trace(black_box("benchmark-operation"))
                .with_attribute(black_box("service.name"), black_box("benchmark-service"))
                .with_numeric_attribute(black_box("duration"), black_box(150.0));
            black_box(trace)
        })
    });
}

fn benchmark_serialization(c: &mut Criterion) {
    let trace = TelemetryData::trace("serialization-test")
        .with_attribute("key1", "value1")
        .with_attribute("key2", "value2");
    
    c.bench_function("trace_serialization", |b| {
        b.iter(|| {
            let serialized = serde_json::to_vec(black_box(&trace)).unwrap();
            black_box(serialized)
        })
    });
}

fn benchmark_batch_processing(c: &mut Criterion) {
    let mut batch_data = Vec::new();
    for i in 0..100 {
        batch_data.push(TelemetryData::trace(format!("batch-{}", i)));
    }
    
    c.bench_function("batch_processing", |b| {
        b.iter(|| {
            let processed = process_batch(black_box(&batch_data));
            black_box(processed)
        })
    });
}

criterion_group!(benches, benchmark_trace_creation, benchmark_serialization, benchmark_batch_processing);
criterion_main!(benches);
```

### 2. è´Ÿè½½æµ‹è¯•

```rust
#[tokio::test]
async fn test_load_performance() {
    let config = OtlpConfig::default()
        .with_endpoint("http://localhost:4317")
        .with_batch_config(BatchConfig {
            max_export_batch_size: 1000,
            export_timeout: Duration::from_millis(5000),
            max_queue_size: 10000,
            scheduled_delay: Duration::from_millis(1000),
            max_export_timeout: Duration::from_secs(30),
        });
    
    let client = OtlpClient::new(config).await.unwrap();
    client.initialize().await.unwrap();
    
    let start_time = std::time::Instant::now();
    let num_requests = 10000;
    
    // å¹¶å‘å‘é€è¯·æ±‚
    let futures: Vec<_> = (0..num_requests)
        .map(|i| {
            let client = client.clone();
            tokio::spawn(async move {
                client.send_trace(format!("load-test-{}", i)).await.unwrap()
                    .with_attribute("load.test", "true")
                    .finish()
                    .await
            })
        })
        .collect();
    
    let results = futures::future::join_all(futures).await;
    let end_time = std::time::Instant::now();
    
    let successful_requests: usize = results.iter()
        .filter(|r| r.is_ok())
        .count();
    
    let duration = end_time.duration_since(start_time);
    let requests_per_second = num_requests as f64 / duration.as_secs_f64();
    
    println!("Load test results:");
    println!("  Total requests: {}", num_requests);
    println!("  Successful requests: {}", successful_requests);
    println!("  Duration: {:?}", duration);
    println!("  Requests per second: {:.2}", requests_per_second);
    
    assert!(successful_requests > num_requests * 95 / 100); // 95% æˆåŠŸç‡
    assert!(requests_per_second > 1000.0); // è‡³å°‘1000 RPS
    
    client.shutdown().await.unwrap();
}
```

## ğŸ§ª å‹åŠ›æµ‹è¯•

### 1. å†…å­˜å‹åŠ›æµ‹è¯•

```rust
#[tokio::test]
async fn test_memory_pressure() {
    let config = OtlpConfig::default()
        .with_memory_limit(100 * 1024 * 1024) // 100MBé™åˆ¶
        .with_endpoint("http://localhost:4317");
    
    let client = OtlpClient::new(config).await.unwrap();
    client.initialize().await.unwrap();
    
    // åˆ›å»ºå¤§é‡æ•°æ®ç›´åˆ°å†…å­˜é™åˆ¶
    let mut batch_data = Vec::new();
    let mut total_size = 0;
    
    while total_size < 50 * 1024 * 1024 { // 50MB
        let data = TelemetryData::trace(format!("memory-test-{}", total_size))
            .with_attribute("data", "x".repeat(1024)); // 1KBæ•°æ®
        
        batch_data.push(data);
        total_size += 1024;
    }
    
    // å‘é€æ•°æ®
    let result = client.send_batch(batch_data).await.unwrap();
    assert!(result.success_count > 0);
    
    client.shutdown().await.unwrap();
}
```

### 2. è¿æ¥å‹åŠ›æµ‹è¯•

```rust
#[tokio::test]
async fn test_connection_pressure() {
    let config = OtlpConfig::default()
        .with_endpoint("http://localhost:4317")
        .with_connection_pool_config(ConnectionPoolConfig {
            max_connections: 10,
            max_connections_per_route: 5,
            connection_timeout: Duration::from_millis(1000),
            keep_alive_timeout: Duration::from_secs(30),
            max_idle_timeout: Duration::from_secs(60),
        });
    
    let client = OtlpClient::new(config).await.unwrap();
    client.initialize().await.unwrap();
    
    // åˆ›å»ºå¤§é‡å¹¶å‘è¿æ¥
    let futures: Vec<_> = (0..100)
        .map(|i| {
            let client = client.clone();
            tokio::spawn(async move {
                client.send_trace(format!("connection-test-{}", i)).await.unwrap()
                    .finish()
                    .await
            })
        })
        .collect();
    
    let results = futures::future::join_all(futures).await;
    let successful = results.iter().filter(|r| r.is_ok()).count();
    
    assert!(successful > 90); // 90%æˆåŠŸç‡
    
    client.shutdown().await.unwrap();
}
```

## ğŸ” å±æ€§æµ‹è¯•

### 1. ä½¿ç”¨Proptestè¿›è¡Œå±æ€§æµ‹è¯•

```rust
use proptest::prelude::*;

proptest! {
    #[test]
    fn test_trace_creation_properties(
        operation_name in "\\PC*",
        attribute_count in 0..10usize,
    ) {
        let mut trace = TelemetryData::trace(&operation_name);
        
        for i in 0..attribute_count {
            trace = trace.with_attribute(
                format!("key{}", i),
                format!("value{}", i)
            );
        }
        
        assert_eq!(trace.operation_name(), operation_name);
        assert_eq!(trace.attribute_count(), attribute_count);
    }

    #[test]
    fn test_config_validation_properties(
        endpoint in "https?://[a-zA-Z0-9.-]+:[0-9]+",
        sampling_ratio in 0.0f64..1.0f64,
    ) {
        let config = OtlpConfig::default()
            .with_endpoint(&endpoint)
            .with_sampling_ratio(sampling_ratio);
        
        assert!(config.validate().is_ok());
    }

    #[test]
    fn test_serialization_roundtrip(
        operation_name in "\\PC*",
        attributes in prop::collection::hash_map(
            "\\PC*", "\\PC*", 0..5
        ),
    ) {
        let mut trace = TelemetryData::trace(&operation_name);
        
        for (key, value) in &attributes {
            trace = trace.with_attribute(key, value);
        }
        
        let serialized = serde_json::to_vec(&trace).unwrap();
        let deserialized: TelemetryData = serde_json::from_slice(&serialized).unwrap();
        
        assert_eq!(deserialized.operation_name(), operation_name);
        assert_eq!(deserialized.attribute_count(), attributes.len());
    }
}
```

## ğŸ¯ æµ‹è¯•å·¥å…·å’Œè¾…åŠ©å‡½æ•°

### 1. æµ‹è¯•è¾…åŠ©å·¥å…·

```rust
#[cfg(test)]
mod test_utils {
    use super::*;
    use std::sync::Arc;
    use tokio::sync::Mutex;

    pub struct MockCollector {
        pub received_traces: Arc<Mutex<Vec<Trace>>>,
        pub received_metrics: Arc<Mutex<Vec<Metric>>>,
        pub received_logs: Arc<Mutex<Vec<Log>>>,
    }

    impl MockCollector {
        pub fn new() -> Self {
            Self {
                received_traces: Arc::new(Mutex::new(Vec::new())),
                received_metrics: Arc::new(Mutex::new(Vec::new())),
                received_logs: Arc::new(Mutex::new(Vec::new())),
            }
        }

        pub async fn get_trace_count(&self) -> usize {
            self.received_traces.lock().await.len()
        }

        pub async fn get_metric_count(&self) -> usize {
            self.received_metrics.lock().await.len()
        }

        pub async fn get_log_count(&self) -> usize {
            self.received_logs.lock().await.len()
        }
    }

    pub fn create_test_config() -> OtlpConfig {
        OtlpConfig::default()
            .with_endpoint("http://localhost:4317")
            .with_service("test-service", "1.0.0")
            .with_debug(true)
    }

    pub async fn create_test_client() -> OtlpClient {
        let config = create_test_config();
        let client = OtlpClient::new(config).await.unwrap();
        client.initialize().await.unwrap();
        client
    }

    pub fn create_test_trace(operation: &str) -> TelemetryData {
        TelemetryData::trace(operation)
            .with_attribute("test.type", "unit_test")
            .with_attribute("test.timestamp", chrono::Utc::now().to_rfc3339())
    }

    pub fn create_test_metric(name: &str, value: f64) -> TelemetryData {
        TelemetryData::metric(name, value)
            .with_label("test", "true")
            .with_description("Test metric")
            .with_unit("count")
    }

    pub fn create_test_log(message: &str) -> TelemetryData {
        TelemetryData::log(message, LogSeverity::Info)
            .with_attribute("test.type", "unit_test")
    }
}
```

### 2. æµ‹è¯•æ•°æ®ç”Ÿæˆå™¨

```rust
#[cfg(test)]
mod test_data_generator {
    use super::*;
    use rand::Rng;

    pub struct TestDataGenerator {
        rng: rand::rngs::ThreadRng,
    }

    impl TestDataGenerator {
        pub fn new() -> Self {
            Self {
                rng: rand::thread_rng(),
            }
        }

        pub fn generate_trace(&mut self) -> TelemetryData {
            let operation = format!("operation_{}", self.rng.gen_range(0..1000));
            let duration = self.rng.gen_range(10.0..1000.0);
            
            TelemetryData::trace(operation)
                .with_attribute("duration", duration)
                .with_attribute("status", if self.rng.gen_bool(0.9) { "success" } else { "error" })
                .with_numeric_attribute("memory_usage", self.rng.gen_range(100.0..10000.0))
        }

        pub fn generate_metric(&mut self) -> TelemetryData {
            let metric_name = format!("metric_{}", self.rng.gen_range(0..100));
            let value = self.rng.gen_range(0.0..1000.0);
            
            TelemetryData::metric(metric_name, value)
                .with_label("service", format!("service_{}", self.rng.gen_range(0..10)))
                .with_label("instance", format!("instance_{}", self.rng.gen_range(0..100)))
        }

        pub fn generate_log(&mut self) -> TelemetryData {
            let messages = vec![
                "User login successful",
                "Database connection established",
                "Cache hit",
                "Request processed",
                "Error occurred",
            ];
            
            let message = messages[self.rng.gen_range(0..messages.len())];
            let severity = match self.rng.gen_range(0..4) {
                0 => LogSeverity::Error,
                1 => LogSeverity::Warn,
                2 => LogSeverity::Info,
                _ => LogSeverity::Debug,
            };
            
            TelemetryData::log(message, severity)
                .with_attribute("user_id", format!("user_{}", self.rng.gen_range(0..1000)))
                .with_attribute("session_id", format!("session_{}", self.rng.gen_range(0..10000)))
        }

        pub fn generate_batch(&mut self, size: usize) -> Vec<TelemetryData> {
            let mut batch = Vec::new();
            
            for _ in 0..size {
                match self.rng.gen_range(0..3) {
                    0 => batch.push(self.generate_trace()),
                    1 => batch.push(self.generate_metric()),
                    _ => batch.push(self.generate_log()),
                }
            }
            
            batch
        }
    }
}
```

## ğŸ“ˆ æµ‹è¯•è¦†ç›–ç‡

### 1. è¦†ç›–ç‡é…ç½®

```toml
# Cargo.toml
[dev-dependencies]
cargo-tarpaulin = "0.25"

# è¿è¡Œè¦†ç›–ç‡æµ‹è¯•
# cargo tarpaulin --out Html --output-dir coverage
```

### 2. è¦†ç›–ç‡ç›®æ ‡

- **å•å…ƒæµ‹è¯•è¦†ç›–ç‡**: â‰¥ 90%
- **é›†æˆæµ‹è¯•è¦†ç›–ç‡**: â‰¥ 80%
- **å…³é”®è·¯å¾„è¦†ç›–ç‡**: 100%

## ğŸš€ æµ‹è¯•æ‰§è¡Œ

### 1. æœ¬åœ°æµ‹è¯•

```bash
# è¿è¡Œæ‰€æœ‰æµ‹è¯•
cargo test

# è¿è¡Œç‰¹å®šæµ‹è¯•
cargo test test_client_creation

# è¿è¡Œé›†æˆæµ‹è¯•
cargo test --test integration_tests

# è¿è¡Œæ€§èƒ½æµ‹è¯•
cargo bench

# ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
cargo tarpaulin --out Html
```

### 2. CI/CDé›†æˆ

```yaml
# GitHub Actions æµ‹è¯•æ­¥éª¤
- name: Run tests
  run: cargo test --verbose

- name: Run integration tests
  run: cargo test --test '*' --verbose

- name: Generate coverage
  run: cargo tarpaulin --out Xml

- name: Upload coverage
  uses: codecov/codecov-action@v3
  with:
    file: ./cobertura.xml
```

## ğŸ“š æœ€ä½³å®è·µ

### 1. æµ‹è¯•è®¾è®¡åŸåˆ™

- **å•ä¸€èŒè´£**: æ¯ä¸ªæµ‹è¯•åªéªŒè¯ä¸€ä¸ªåŠŸèƒ½ç‚¹
- **ç‹¬ç«‹æ€§**: æµ‹è¯•ä¹‹é—´ä¸åº”è¯¥ç›¸äº’ä¾èµ–
- **å¯é‡å¤æ€§**: æµ‹è¯•ç»“æœåº”è¯¥æ˜¯ç¡®å®šæ€§çš„
- **å¿«é€Ÿæ‰§è¡Œ**: å•å…ƒæµ‹è¯•åº”è¯¥å¿«é€Ÿæ‰§è¡Œ

### 2. æµ‹è¯•å‘½åè§„èŒƒ

- **å•å…ƒæµ‹è¯•**: `test_<function_name>`
- **é›†æˆæµ‹è¯•**: `test_<module>_<functionality>`
- **æ€§èƒ½æµ‹è¯•**: `benchmark_<operation>`
- **å‹åŠ›æµ‹è¯•**: `test_<component>_stress`

### 3. æµ‹è¯•æ•°æ®ç®¡ç†

- **ä½¿ç”¨å·¥å‚æ¨¡å¼**: åˆ›å»ºæµ‹è¯•æ•°æ®ç”Ÿæˆå™¨
- **æ¨¡æ‹Ÿå¤–éƒ¨ä¾èµ–**: ä½¿ç”¨mockå¯¹è±¡
- **æ¸…ç†èµ„æº**: ç¡®ä¿æµ‹è¯•åæ¸…ç†èµ„æº
- **å¹¶è¡Œæ‰§è¡Œ**: æ”¯æŒæµ‹è¯•å¹¶è¡Œæ‰§è¡Œ

---

**æµ‹è¯•æ¡†æ¶ä¸ç”¨ä¾‹ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ27æ—¥  
**ç»´æŠ¤è€…**: OTLP 2025 æ–‡æ¡£å›¢é˜Ÿ
