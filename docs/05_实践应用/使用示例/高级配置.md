# OTLP é«˜çº§é…ç½®æŒ‡å—

## ğŸ“š æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»äº†OTLP Rustå®ç°çš„é«˜çº§é…ç½®é€‰é¡¹ï¼ŒåŒ…æ‹¬ç”Ÿäº§ç¯å¢ƒé…ç½®ã€æ€§èƒ½ä¼˜åŒ–ã€å®‰å…¨è®¾ç½®å’Œè‡ªå®šä¹‰é…ç½®ç­‰ã€‚

## ğŸ­ ç”Ÿäº§ç¯å¢ƒé…ç½®

### 1. é«˜å¯ç”¨é…ç½®

```rust
use c21_otlp::{OtlpClient, OtlpConfig, BatchConfig, RetryConfig};
use c21_otlp::transport::{TransportProtocol, Compression};
use std::time::Duration;

async fn create_production_config() -> OtlpConfig {
    OtlpConfig::default()
        // åŸºç¡€è¿æ¥é…ç½®
        .with_endpoint("https://api.honeycomb.io:443")
        .with_protocol(TransportProtocol::Grpc)
        .with_tls(true)
        
        // è®¤è¯é…ç½®
        .with_api_key("your-production-api-key")
        .with_bearer_token("your-bearer-token")
        
        // å‹ç¼©é…ç½®
        .with_compression(Compression::Gzip)
        
        // é‡‡æ ·é…ç½®
        .with_sampling_ratio(0.1) // 10%é‡‡æ ·ç‡
        
        // èµ„æºå±æ€§
        .with_resource_attribute("service.name", "production-service")
        .with_resource_attribute("service.version", "2.1.0")
        .with_resource_attribute("deployment.environment", "production")
        .with_resource_attribute("deployment.region", "us-west-2")
        .with_resource_attribute("deployment.zone", "us-west-2a")
        .with_resource_attribute("deployment.instance", "prod-instance-01")
        
        // æ‰¹å¤„ç†é…ç½®
        .with_batch_config(BatchConfig {
            max_export_batch_size: 512,
            export_timeout: Duration::from_millis(5000),
            max_queue_size: 2048,
            scheduled_delay: Duration::from_millis(5000),
            max_export_timeout: Duration::from_secs(30),
        })
        
        // é‡è¯•é…ç½®
        .with_retry_config(RetryConfig {
            max_retries: 5,
            initial_retry_delay: Duration::from_millis(1000),
            max_retry_delay: Duration::from_secs(30),
            retry_delay_multiplier: 2.0,
            randomize_retry_delay: true,
            retryable_status_codes: vec![429, 500, 502, 503, 504],
        })
        
        // è¶…æ—¶é…ç½®
        .with_timeout(Duration::from_secs(30))
        .with_connection_timeout(Duration::from_secs(10))
        
        // è°ƒè¯•é…ç½®
        .with_debug(false)
        .with_verbose_logging(false)
}
```

### 2. å¤šç«¯ç‚¹é…ç½®

```rust
use c21_otlp::transport::LoadBalancingStrategy;

async fn create_multi_endpoint_config() -> OtlpConfig {
    let endpoints = vec![
        "https://api1.honeycomb.io:443".to_string(),
        "https://api2.honeycomb.io:443".to_string(),
        "https://api3.honeycomb.io:443".to_string(),
    ];
    
    OtlpConfig::default()
        .with_endpoints(endpoints)
        .with_load_balancing_strategy(LoadBalancingStrategy::RoundRobin)
        .with_protocol(TransportProtocol::Grpc)
        .with_health_check_interval(Duration::from_secs(30))
        .with_circuit_breaker_config(CircuitBreakerConfig {
            failure_threshold: 5,
            recovery_timeout: Duration::from_secs(60),
            half_open_max_calls: 3,
        })
}
```

### 3. åœ°åŸŸåˆ†å¸ƒé…ç½®

```rust
async fn create_region_distributed_config() -> OtlpConfig {
    OtlpConfig::default()
        // ä¸»åŒºåŸŸé…ç½®
        .with_primary_endpoint("https://us-west-2.api.honeycomb.io:443")
        .with_primary_region("us-west-2")
        
        // å¤‡ç”¨åŒºåŸŸé…ç½®
        .with_fallback_endpoints(vec![
            "https://us-east-1.api.honeycomb.io:443".to_string(),
            "https://eu-west-1.api.honeycomb.io:443".to_string(),
        ])
        .with_fallback_regions(vec!["us-east-1".to_string(), "eu-west-1".to_string()])
        
        // åŒºåŸŸæ•…éšœè½¬ç§»é…ç½®
        .with_region_failover_enabled(true)
        .with_region_failover_threshold(3)
        .with_region_failover_timeout(Duration::from_secs(30))
        
        // æ•°æ®æœ¬åœ°åŒ–é…ç½®
        .with_data_localization(true)
        .with_region_preference("us-west-2")
}
```

## âš¡ æ€§èƒ½ä¼˜åŒ–é…ç½®

### 1. é«˜ååé‡é…ç½®

```rust
async fn create_high_throughput_config() -> OtlpConfig {
    OtlpConfig::default()
        .with_endpoint("http://localhost:4317")
        .with_protocol(TransportProtocol::Grpc)
        
        // æ‰¹å¤„ç†ä¼˜åŒ–
        .with_batch_config(BatchConfig {
            max_export_batch_size: 1024, // å¢å¤§æ‰¹å¤„ç†å¤§å°
            export_timeout: Duration::from_millis(2000), // å‡å°‘è¶…æ—¶æ—¶é—´
            max_queue_size: 4096, // å¢å¤§é˜Ÿåˆ—å¤§å°
            scheduled_delay: Duration::from_millis(1000), // å‡å°‘è°ƒåº¦å»¶è¿Ÿ
            max_export_timeout: Duration::from_secs(10),
        })
        
        // å‹ç¼©ä¼˜åŒ–
        .with_compression(Compression::Zstd) // ä½¿ç”¨æ›´é«˜æ•ˆçš„å‹ç¼©ç®—æ³•
        
        // è¿æ¥æ± ä¼˜åŒ–
        .with_connection_pool_config(ConnectionPoolConfig {
            max_connections: 100,
            max_connections_per_route: 20,
            connection_timeout: Duration::from_millis(5000),
            keep_alive_timeout: Duration::from_secs(30),
            max_idle_timeout: Duration::from_secs(60),
        })
        
        // å¹¶å‘ä¼˜åŒ–
        .with_concurrent_exports(10)
        .with_max_concurrent_requests(50)
        
        // å†…å­˜ä¼˜åŒ–
        .with_memory_pool_config(MemoryPoolConfig {
            initial_pool_size: 1024 * 1024, // 1MB
            max_pool_size: 10 * 1024 * 1024, // 10MB
            pool_growth_factor: 2.0,
        })
}
```

### 2. ä½å»¶è¿Ÿé…ç½®

```rust
async fn create_low_latency_config() -> OtlpConfig {
    OtlpConfig::default()
        .with_endpoint("http://localhost:4317")
        .with_protocol(TransportProtocol::Grpc)
        
        // å°æ‰¹é‡å¿«é€Ÿå‘é€
        .with_batch_config(BatchConfig {
            max_export_batch_size: 10, // å°æ‰¹é‡
            export_timeout: Duration::from_millis(100), // å¿«é€Ÿè¶…æ—¶
            max_queue_size: 100, // å°é˜Ÿåˆ—
            scheduled_delay: Duration::from_millis(50), // å¿«é€Ÿè°ƒåº¦
            max_export_timeout: Duration::from_millis(500),
        })
        
        // æ— å‹ç¼©ä»¥å‡å°‘CPUå¼€é”€
        .with_compression(Compression::None)
        
        // å¿«é€Ÿè¿æ¥
        .with_connection_pool_config(ConnectionPoolConfig {
            max_connections: 20,
            max_connections_per_route: 5,
            connection_timeout: Duration::from_millis(1000),
            keep_alive_timeout: Duration::from_secs(10),
            max_idle_timeout: Duration::from_secs(30),
        })
        
        // é«˜ä¼˜å…ˆçº§å¤„ç†
        .with_priority_queue(true)
        .with_high_priority_threshold(Duration::from_millis(10))
}
```

### 3. å†…å­˜ä¼˜åŒ–é…ç½®

```rust
async fn create_memory_optimized_config() -> OtlpConfig {
    OtlpConfig::default()
        .with_endpoint("http://localhost:4317")
        
        // å†…å­˜é™åˆ¶
        .with_memory_limit(50 * 1024 * 1024) // 50MBé™åˆ¶
        
        // æµå¼å¤„ç†
        .with_streaming_enabled(true)
        .with_stream_buffer_size(64 * 1024) // 64KBç¼“å†²åŒº
        
        // å¯¹è±¡æ± 
        .with_object_pool_config(ObjectPoolConfig {
            span_pool_size: 1000,
            metric_pool_size: 1000,
            log_pool_size: 1000,
            attribute_pool_size: 5000,
        })
        
        // åƒåœ¾å›æ”¶ä¼˜åŒ–
        .with_gc_config(GCConfig {
            gc_threshold: 0.8, // 80%å†…å­˜ä½¿ç”¨ç‡æ—¶è§¦å‘GC
            gc_interval: Duration::from_secs(30),
            aggressive_gc: false,
        })
        
        // æ•°æ®å‹ç¼©
        .with_compression(Compression::Gzip)
        .with_compression_level(6) // å¹³è¡¡å‹ç¼©ç‡å’ŒCPUä½¿ç”¨
}
```

## ğŸ”’ å®‰å…¨é…ç½®

### 1. TLS/mTLSé…ç½®

```rust
async fn create_tls_config() -> OtlpConfig {
    OtlpConfig::default()
        .with_endpoint("https://secure-api.honeycomb.io:443")
        .with_tls(true)
        
        // TLSé…ç½®
        .with_tls_config(TlsConfig {
            verify_certificates: true,
            verify_hostname: true,
            min_tls_version: TlsVersion::Tls12,
            max_tls_version: TlsVersion::Tls13,
            cipher_suites: vec![
                "TLS_AES_256_GCM_SHA384".to_string(),
                "TLS_CHACHA20_POLY1305_SHA256".to_string(),
                "TLS_AES_128_GCM_SHA256".to_string(),
            ],
        })
        
        // å®¢æˆ·ç«¯è¯ä¹¦é…ç½®
        .with_client_certificate("path/to/client.crt")
        .with_client_private_key("path/to/client.key")
        .with_ca_certificate("path/to/ca.crt")
        
        // è¯ä¹¦éªŒè¯
        .with_certificate_pinning(true)
        .with_pinned_certificates(vec![
            "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=".to_string(),
        ])
}
```

### 2. è®¤è¯é…ç½®

```rust
async fn create_authenticated_config() -> OtlpConfig {
    OtlpConfig::default()
        .with_endpoint("https://api.honeycomb.io:443")
        
        // APIå¯†é’¥è®¤è¯
        .with_api_key("your-secure-api-key")
        
        // Bearer Tokenè®¤è¯
        .with_bearer_token("your-bearer-token")
        
        // OAuth 2.0é…ç½®
        .with_oauth_config(OAuthConfig {
            client_id: "your-client-id".to_string(),
            client_secret: "your-client-secret".to_string(),
            token_url: "https://auth.example.com/oauth/token".to_string(),
            scope: "opentelemetry".to_string(),
            token_refresh_threshold: Duration::from_secs(300), // 5åˆ†é’Ÿ
        })
        
        // JWTé…ç½®
        .with_jwt_config(JwtConfig {
            secret: "your-jwt-secret".to_string(),
            issuer: "your-service".to_string(),
            audience: "opentelemetry-api".to_string(),
            expiration: Duration::from_hours(1),
        })
        
        // è¯·æ±‚ç­¾å
        .with_request_signing(true)
        .with_signing_key("your-signing-key")
        .with_signature_algorithm("HMAC-SHA256")
}
```

### 3. æ•°æ®éšç§é…ç½®

```rust
async fn create_privacy_config() -> OtlpConfig {
    OtlpConfig::default()
        .with_endpoint("http://localhost:4317")
        
        // æ•°æ®è„±æ•
        .with_data_masking(true)
        .with_masking_rules(vec![
            MaskingRule::new("user.email")
                .with_pattern(r"\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b")
                .with_replacement("***@***.***"),
            MaskingRule::new("user.phone")
                .with_pattern(r"\b\d{3}-\d{3}-\d{4}\b")
                .with_replacement("***-***-****"),
            MaskingRule::new("credit_card")
                .with_pattern(r"\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b")
                .with_replacement("****-****-****-****"),
        ])
        
        // æ•°æ®è¿‡æ»¤
        .with_attribute_filter(AttributeFilter::new()
            .block_sensitive_attributes(vec![
                "password".to_string(),
                "secret".to_string(),
                "token".to_string(),
                "key".to_string(),
            ])
            .allow_only_public_attributes(true)
        )
        
        // æ•°æ®åŠ å¯†
        .with_field_encryption(true)
        .with_encryption_key("your-encryption-key")
        .with_encryption_algorithm("AES-256-GCM")
        
        // å®¡è®¡æ—¥å¿—
        .with_audit_logging(true)
        .with_audit_log_level(AuditLogLevel::Info)
}
```

## ğŸ¯ è‡ªå®šä¹‰é…ç½®

### 1. ç¯å¢ƒç‰¹å®šé…ç½®

```rust
use std::env;

async fn create_environment_specific_config() -> OtlpConfig {
    let environment = env::var("ENVIRONMENT").unwrap_or_else(|_| "development".to_string());
    
    match environment.as_str() {
        "development" => create_development_config().await,
        "staging" => create_staging_config().await,
        "production" => create_production_config().await,
        _ => create_default_config().await,
    }
}

async fn create_development_config() -> OtlpConfig {
    OtlpConfig::default()
        .with_endpoint("http://localhost:4317")
        .with_debug(true)
        .with_sampling_ratio(1.0) // 100%é‡‡æ ·ç”¨äºè°ƒè¯•
        .with_batch_config(BatchConfig {
            max_export_batch_size: 10,
            export_timeout: Duration::from_millis(1000),
            max_queue_size: 100,
            scheduled_delay: Duration::from_millis(1000),
            max_export_timeout: Duration::from_secs(5),
        })
}

async fn create_staging_config() -> OtlpConfig {
    OtlpConfig::default()
        .with_endpoint("https://staging-api.honeycomb.io:443")
        .with_api_key(&env::var("STAGING_API_KEY").unwrap())
        .with_sampling_ratio(0.5) // 50%é‡‡æ ·
        .with_batch_config(BatchConfig {
            max_export_batch_size: 256,
            export_timeout: Duration::from_millis(3000),
            max_queue_size: 1024,
            scheduled_delay: Duration::from_millis(2000),
            max_export_timeout: Duration::from_secs(15),
        })
}
```

### 2. åŠ¨æ€é…ç½®

```rust
use std::sync::Arc;
use tokio::sync::RwLock;

struct DynamicOtlpConfig {
    config: Arc<RwLock<OtlpConfig>>,
    config_watcher: ConfigWatcher,
}

impl DynamicOtlpConfig {
    async fn new() -> Result<Self, Box<dyn std::error::Error>> {
        let initial_config = Self::load_config_from_file("config.yaml").await?;
        let config = Arc::new(RwLock::new(initial_config));
        
        let config_watcher = ConfigWatcher::new("config.yaml", config.clone()).await?;
        
        Ok(Self {
            config,
            config_watcher,
        })
    }
    
    async fn get_config(&self) -> OtlpConfig {
        self.config.read().await.clone()
    }
    
    async fn update_config(&self, new_config: OtlpConfig) {
        let mut config = self.config.write().await;
        *config = new_config;
    }
    
    async fn load_config_from_file(path: &str) -> Result<OtlpConfig, Box<dyn std::error::Error>> {
        let content = tokio::fs::read_to_string(path).await?;
        let config: OtlpConfig = serde_yaml::from_str(&content)?;
        Ok(config)
    }
}
```

### 3. é…ç½®éªŒè¯

```rust
use validator::{Validate, ValidationError};

#[derive(Debug, Validate, Clone)]
pub struct OtlpConfigValidator {
    #[validate(url)]
    pub endpoint: String,
    
    #[validate(range(min = 0.0, max = 1.0))]
    pub sampling_ratio: f64,
    
    #[validate(range(min = 1, max = 10000))]
    pub max_batch_size: usize,
    
    #[validate(range(min = 1, max = 300))]
    pub timeout_seconds: u64,
    
    #[validate(custom = "validate_api_key")]
    pub api_key: Option<String>,
}

fn validate_api_key(api_key: &Option<String>) -> Result<(), ValidationError> {
    if let Some(key) = api_key {
        if key.len() < 32 {
            return Err(ValidationError::new("api_key_too_short"));
        }
        if !key.chars().all(|c| c.is_alphanumeric() || c == '-') {
            return Err(ValidationError::new("api_key_invalid_chars"));
        }
    }
    Ok(())
}

impl OtlpConfigValidator {
    pub fn validate_config(&self) -> Result<(), validator::ValidationErrors> {
        self.validate()
    }
    
    pub fn to_otlp_config(&self) -> OtlpConfig {
        let mut config = OtlpConfig::default()
            .with_endpoint(&self.endpoint)
            .with_sampling_ratio(self.sampling_ratio)
            .with_batch_config(BatchConfig {
                max_export_batch_size: self.max_batch_size,
                export_timeout: Duration::from_secs(self.timeout_seconds),
                max_queue_size: self.max_batch_size * 4,
                scheduled_delay: Duration::from_secs(5),
                max_export_timeout: Duration::from_secs(30),
            });
        
        if let Some(api_key) = &self.api_key {
            config = config.with_api_key(api_key);
        }
        
        config
    }
}
```

## ğŸ”§ é…ç½®ç®¡ç†å·¥å…·

### 1. é…ç½®åŠ è½½å™¨

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize, Serialize)]
pub struct OtlpConfigFile {
    pub endpoint: String,
    pub protocol: String,
    pub service_name: String,
    pub service_version: String,
    pub sampling_ratio: f64,
    pub batch_config: BatchConfigFile,
    pub retry_config: RetryConfigFile,
    pub security: SecurityConfig,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct BatchConfigFile {
    pub max_export_batch_size: usize,
    pub export_timeout_ms: u64,
    pub max_queue_size: usize,
    pub scheduled_delay_ms: u64,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct RetryConfigFile {
    pub max_retries: u32,
    pub initial_retry_delay_ms: u64,
    pub max_retry_delay_ms: u64,
    pub retry_delay_multiplier: f64,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct SecurityConfig {
    pub tls_enabled: bool,
    pub api_key: Option<String>,
    pub bearer_token: Option<String>,
    pub client_certificate: Option<String>,
    pub client_private_key: Option<String>,
}

pub struct ConfigLoader;

impl ConfigLoader {
    pub async fn load_from_file(path: &str) -> Result<OtlpConfig, Box<dyn std::error::Error>> {
        let content = tokio::fs::read_to_string(path).await?;
        let config_file: OtlpConfigFile = match path.ends_with(".json") {
            true => serde_json::from_str(&content)?,
            false => serde_yaml::from_str(&content)?,
        };
        
        Ok(Self::convert_to_otlp_config(config_file))
    }
    
    pub async fn load_from_env() -> Result<OtlpConfig, Box<dyn std::error::Error>> {
        let config = OtlpConfig::default()
            .with_endpoint(&env::var("OTLP_ENDPOINT")?)
            .with_service(
                &env::var("SERVICE_NAME")?,
                &env::var("SERVICE_VERSION")?,
            )
            .with_sampling_ratio(env::var("SAMPLING_RATIO")?.parse()?)
            .with_debug(env::var("DEBUG").is_ok());
        
        Ok(config)
    }
    
    fn convert_to_otlp_config(config_file: OtlpConfigFile) -> OtlpConfig {
        let protocol = match config_file.protocol.as_str() {
            "grpc" => TransportProtocol::Grpc,
            "http" => TransportProtocol::Http,
            _ => TransportProtocol::Grpc,
        };
        
        OtlpConfig::default()
            .with_endpoint(&config_file.endpoint)
            .with_protocol(protocol)
            .with_service(&config_file.service_name, &config_file.service_version)
            .with_sampling_ratio(config_file.sampling_ratio)
            .with_batch_config(BatchConfig {
                max_export_batch_size: config_file.batch_config.max_export_batch_size,
                export_timeout: Duration::from_millis(config_file.batch_config.export_timeout_ms),
                max_queue_size: config_file.batch_config.max_queue_size,
                scheduled_delay: Duration::from_millis(config_file.batch_config.scheduled_delay_ms),
                max_export_timeout: Duration::from_secs(30),
            })
            .with_retry_config(RetryConfig {
                max_retries: config_file.retry_config.max_retries,
                initial_retry_delay: Duration::from_millis(config_file.retry_config.initial_retry_delay_ms),
                max_retry_delay: Duration::from_millis(config_file.retry_config.max_retry_delay_ms),
                retry_delay_multiplier: config_file.retry_config.retry_delay_multiplier,
                randomize_retry_delay: true,
                retryable_status_codes: vec![429, 500, 502, 503, 504],
            })
            .with_tls(config_file.security.tls_enabled)
            .with_api_key_opt(config_file.security.api_key)
            .with_bearer_token_opt(config_file.security.bearer_token)
    }
}
```

### 2. é…ç½®æ¨¡æ¿

```yaml
# config.yaml æ¨¡æ¿
endpoint: "https://api.honeycomb.io:443"
protocol: "grpc"
service_name: "my-service"
service_version: "1.0.0"
sampling_ratio: 0.1

batch_config:
  max_export_batch_size: 512
  export_timeout_ms: 5000
  max_queue_size: 2048
  scheduled_delay_ms: 5000

retry_config:
  max_retries: 5
  initial_retry_delay_ms: 1000
  max_retry_delay_ms: 30000
  retry_delay_multiplier: 2.0

security:
  tls_enabled: true
  api_key: "your-api-key"
  bearer_token: null
  client_certificate: null
  client_private_key: null
```

## ğŸ“Š ç›‘æ§é…ç½®

### 1. é…ç½®æŒ‡æ ‡ç›‘æ§

```rust
use std::sync::atomic::{AtomicU64, Ordering};

pub struct ConfigMetrics {
    pub config_changes: AtomicU64,
    pub config_validation_failures: AtomicU64,
    pub config_load_time: AtomicU64,
}

impl ConfigMetrics {
    pub fn new() -> Self {
        Self {
            config_changes: AtomicU64::new(0),
            config_validation_failures: AtomicU64::new(0),
            config_load_time: AtomicU64::new(0),
        }
    }
    
    pub fn record_config_change(&self) {
        self.config_changes.fetch_add(1, Ordering::Relaxed);
    }
    
    pub fn record_validation_failure(&self) {
        self.config_validation_failures.fetch_add(1, Ordering::Relaxed);
    }
    
    pub fn record_load_time(&self, duration: Duration) {
        self.config_load_time.store(duration.as_millis() as u64, Ordering::Relaxed);
    }
}
```

### 2. é…ç½®å¥åº·æ£€æŸ¥

```rust
pub struct ConfigHealthChecker {
    config: Arc<RwLock<OtlpConfig>>,
    metrics: Arc<ConfigMetrics>,
}

impl ConfigHealthChecker {
    pub async fn check_config_health(&self) -> HealthStatus {
        let config = self.config.read().await;
        
        // æ£€æŸ¥é…ç½®æœ‰æ•ˆæ€§
        if config.endpoint.is_empty() {
            return HealthStatus::Unhealthy("endpoint is empty".to_string());
        }
        
        if config.sampling_ratio < 0.0 || config.sampling_ratio > 1.0 {
            return HealthStatus::Unhealthy("invalid sampling ratio".to_string());
        }
        
        // æ£€æŸ¥è¿æ¥æ€§
        if let Err(e) = self.test_connection(&config).await {
            return HealthStatus::Degraded(format!("connection test failed: {}", e));
        }
        
        HealthStatus::Healthy
    }
    
    async fn test_connection(&self, config: &OtlpConfig) -> Result<(), Box<dyn std::error::Error>> {
        // å®ç°è¿æ¥æµ‹è¯•é€»è¾‘
        let client = OtlpClient::new(config.clone()).await?;
        client.initialize().await?;
        client.shutdown().await?;
        Ok(())
    }
}

#[derive(Debug)]
pub enum HealthStatus {
    Healthy,
    Degraded(String),
    Unhealthy(String),
}
```

## ğŸš€ æœ€ä½³å®è·µ

### 1. é…ç½®åˆ†å±‚

```rust
// åŸºç¡€é…ç½®
pub struct BaseConfig {
    pub endpoint: String,
    pub service_name: String,
    pub service_version: String,
}

// ç¯å¢ƒç‰¹å®šé…ç½®
pub struct EnvironmentConfig {
    pub base: BaseConfig,
    pub sampling_ratio: f64,
    pub debug: bool,
}

// å®Œæ•´é…ç½®
pub struct FullConfig {
    pub environment: EnvironmentConfig,
    pub batch: BatchConfig,
    pub retry: RetryConfig,
    pub security: SecurityConfig,
}

impl FullConfig {
    pub fn to_otlp_config(&self) -> OtlpConfig {
        OtlpConfig::default()
            .with_endpoint(&self.environment.base.endpoint)
            .with_service(
                &self.environment.base.service_name,
                &self.environment.base.service_version,
            )
            .with_sampling_ratio(self.environment.sampling_ratio)
            .with_debug(self.environment.debug)
            .with_batch_config(self.batch.clone())
            .with_retry_config(self.retry.clone())
            .with_tls(self.security.tls_enabled)
            .with_api_key_opt(self.security.api_key.clone())
    }
}
```

### 2. é…ç½®éªŒè¯

```rust
pub trait ConfigValidator {
    fn validate(&self) -> Result<(), ValidationError>;
}

impl ConfigValidator for OtlpConfig {
    fn validate(&self) -> Result<(), ValidationError> {
        // éªŒè¯ç«¯ç‚¹
        if self.endpoint.is_empty() {
            return Err(ValidationError::new("endpoint_required"));
        }
        
        // éªŒè¯é‡‡æ ·ç‡
        if self.sampling_ratio < 0.0 || self.sampling_ratio > 1.0 {
            return Err(ValidationError::new("invalid_sampling_ratio"));
        }
        
        // éªŒè¯æ‰¹å¤„ç†é…ç½®
        if self.batch_config.max_export_batch_size == 0 {
            return Err(ValidationError::new("invalid_batch_size"));
        }
        
        Ok(())
    }
}

#[derive(Debug)]
pub struct ValidationError {
    pub message: String,
    pub field: Option<String>,
}

impl ValidationError {
    pub fn new(message: &str) -> Self {
        Self {
            message: message.to_string(),
            field: None,
        }
    }
}
```

## ğŸ“š æ€»ç»“

é«˜çº§é…ç½®æ˜¯OTLPå®ç°æˆåŠŸéƒ¨ç½²çš„å…³é”®å› ç´ ã€‚é€šè¿‡åˆç†é…ç½®ï¼š

1. **ç”Ÿäº§ç¯å¢ƒ**: ç¡®ä¿é«˜å¯ç”¨æ€§å’Œæ€§èƒ½
2. **å®‰å…¨è®¾ç½®**: ä¿æŠ¤æ•°æ®ä¼ è¾“å’Œè®¿é—®
3. **æ€§èƒ½ä¼˜åŒ–**: æ»¡è¶³ä¸åŒçš„æ€§èƒ½è¦æ±‚
4. **åŠ¨æ€é…ç½®**: æ”¯æŒé…ç½®çš„çƒ­æ›´æ–°
5. **ç›‘æ§éªŒè¯**: ç¡®ä¿é…ç½®çš„æ­£ç¡®æ€§

é€‰æ‹©åˆé€‚çš„é…ç½®ç­–ç•¥å¯¹äºæ„å»ºç¨³å®šã€é«˜æ•ˆçš„å¯è§‚æµ‹æ€§ç³»ç»Ÿè‡³å…³é‡è¦ã€‚

---

**é«˜çº§é…ç½®æŒ‡å—ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ27æ—¥  
**ç»´æŠ¤è€…**: OTLP 2025 æ–‡æ¡£å›¢é˜Ÿ
