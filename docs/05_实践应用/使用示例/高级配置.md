# OTLP 高级配置指南

## 📚 概述

本文档详细介绍了OTLP Rust实现的高级配置选项，包括生产环境配置、性能优化、安全设置和自定义配置等。

## 🏭 生产环境配置

### 1. 高可用配置

```rust
use c21_otlp::{OtlpClient, OtlpConfig, BatchConfig, RetryConfig};
use c21_otlp::transport::{TransportProtocol, Compression};
use std::time::Duration;

async fn create_production_config() -> OtlpConfig {
    OtlpConfig::default()
        // 基础连接配置
        .with_endpoint("https://api.honeycomb.io:443")
        .with_protocol(TransportProtocol::Grpc)
        .with_tls(true)
        
        // 认证配置
        .with_api_key("your-production-api-key")
        .with_bearer_token("your-bearer-token")
        
        // 压缩配置
        .with_compression(Compression::Gzip)
        
        // 采样配置
        .with_sampling_ratio(0.1) // 10%采样率
        
        // 资源属性
        .with_resource_attribute("service.name", "production-service")
        .with_resource_attribute("service.version", "2.1.0")
        .with_resource_attribute("deployment.environment", "production")
        .with_resource_attribute("deployment.region", "us-west-2")
        .with_resource_attribute("deployment.zone", "us-west-2a")
        .with_resource_attribute("deployment.instance", "prod-instance-01")
        
        // 批处理配置
        .with_batch_config(BatchConfig {
            max_export_batch_size: 512,
            export_timeout: Duration::from_millis(5000),
            max_queue_size: 2048,
            scheduled_delay: Duration::from_millis(5000),
            max_export_timeout: Duration::from_secs(30),
        })
        
        // 重试配置
        .with_retry_config(RetryConfig {
            max_retries: 5,
            initial_retry_delay: Duration::from_millis(1000),
            max_retry_delay: Duration::from_secs(30),
            retry_delay_multiplier: 2.0,
            randomize_retry_delay: true,
            retryable_status_codes: vec![429, 500, 502, 503, 504],
        })
        
        // 超时配置
        .with_timeout(Duration::from_secs(30))
        .with_connection_timeout(Duration::from_secs(10))
        
        // 调试配置
        .with_debug(false)
        .with_verbose_logging(false)
}
```

### 2. 多端点配置

```rust
use c21_otlp::transport::LoadBalancingStrategy;

async fn create_multi_endpoint_config() -> OtlpConfig {
    let endpoints = vec![
        "https://api1.honeycomb.io:443".to_string(),
        "https://api2.honeycomb.io:443".to_string(),
        "https://api3.honeycomb.io:443".to_string(),
    ];
    
    OtlpConfig::default()
        .with_endpoints(endpoints)
        .with_load_balancing_strategy(LoadBalancingStrategy::RoundRobin)
        .with_protocol(TransportProtocol::Grpc)
        .with_health_check_interval(Duration::from_secs(30))
        .with_circuit_breaker_config(CircuitBreakerConfig {
            failure_threshold: 5,
            recovery_timeout: Duration::from_secs(60),
            half_open_max_calls: 3,
        })
}
```

### 3. 地域分布配置

```rust
async fn create_region_distributed_config() -> OtlpConfig {
    OtlpConfig::default()
        // 主区域配置
        .with_primary_endpoint("https://us-west-2.api.honeycomb.io:443")
        .with_primary_region("us-west-2")
        
        // 备用区域配置
        .with_fallback_endpoints(vec![
            "https://us-east-1.api.honeycomb.io:443".to_string(),
            "https://eu-west-1.api.honeycomb.io:443".to_string(),
        ])
        .with_fallback_regions(vec!["us-east-1".to_string(), "eu-west-1".to_string()])
        
        // 区域故障转移配置
        .with_region_failover_enabled(true)
        .with_region_failover_threshold(3)
        .with_region_failover_timeout(Duration::from_secs(30))
        
        // 数据本地化配置
        .with_data_localization(true)
        .with_region_preference("us-west-2")
}
```

## ⚡ 性能优化配置

### 1. 高吞吐量配置

```rust
async fn create_high_throughput_config() -> OtlpConfig {
    OtlpConfig::default()
        .with_endpoint("http://localhost:4317")
        .with_protocol(TransportProtocol::Grpc)
        
        // 批处理优化
        .with_batch_config(BatchConfig {
            max_export_batch_size: 1024, // 增大批处理大小
            export_timeout: Duration::from_millis(2000), // 减少超时时间
            max_queue_size: 4096, // 增大队列大小
            scheduled_delay: Duration::from_millis(1000), // 减少调度延迟
            max_export_timeout: Duration::from_secs(10),
        })
        
        // 压缩优化
        .with_compression(Compression::Zstd) // 使用更高效的压缩算法
        
        // 连接池优化
        .with_connection_pool_config(ConnectionPoolConfig {
            max_connections: 100,
            max_connections_per_route: 20,
            connection_timeout: Duration::from_millis(5000),
            keep_alive_timeout: Duration::from_secs(30),
            max_idle_timeout: Duration::from_secs(60),
        })
        
        // 并发优化
        .with_concurrent_exports(10)
        .with_max_concurrent_requests(50)
        
        // 内存优化
        .with_memory_pool_config(MemoryPoolConfig {
            initial_pool_size: 1024 * 1024, // 1MB
            max_pool_size: 10 * 1024 * 1024, // 10MB
            pool_growth_factor: 2.0,
        })
}
```

### 2. 低延迟配置

```rust
async fn create_low_latency_config() -> OtlpConfig {
    OtlpConfig::default()
        .with_endpoint("http://localhost:4317")
        .with_protocol(TransportProtocol::Grpc)
        
        // 小批量快速发送
        .with_batch_config(BatchConfig {
            max_export_batch_size: 10, // 小批量
            export_timeout: Duration::from_millis(100), // 快速超时
            max_queue_size: 100, // 小队列
            scheduled_delay: Duration::from_millis(50), // 快速调度
            max_export_timeout: Duration::from_millis(500),
        })
        
        // 无压缩以减少CPU开销
        .with_compression(Compression::None)
        
        // 快速连接
        .with_connection_pool_config(ConnectionPoolConfig {
            max_connections: 20,
            max_connections_per_route: 5,
            connection_timeout: Duration::from_millis(1000),
            keep_alive_timeout: Duration::from_secs(10),
            max_idle_timeout: Duration::from_secs(30),
        })
        
        // 高优先级处理
        .with_priority_queue(true)
        .with_high_priority_threshold(Duration::from_millis(10))
}
```

### 3. 内存优化配置

```rust
async fn create_memory_optimized_config() -> OtlpConfig {
    OtlpConfig::default()
        .with_endpoint("http://localhost:4317")
        
        // 内存限制
        .with_memory_limit(50 * 1024 * 1024) // 50MB限制
        
        // 流式处理
        .with_streaming_enabled(true)
        .with_stream_buffer_size(64 * 1024) // 64KB缓冲区
        
        // 对象池
        .with_object_pool_config(ObjectPoolConfig {
            span_pool_size: 1000,
            metric_pool_size: 1000,
            log_pool_size: 1000,
            attribute_pool_size: 5000,
        })
        
        // 垃圾回收优化
        .with_gc_config(GCConfig {
            gc_threshold: 0.8, // 80%内存使用率时触发GC
            gc_interval: Duration::from_secs(30),
            aggressive_gc: false,
        })
        
        // 数据压缩
        .with_compression(Compression::Gzip)
        .with_compression_level(6) // 平衡压缩率和CPU使用
}
```

## 🔒 安全配置

### 1. TLS/mTLS配置

```rust
async fn create_tls_config() -> OtlpConfig {
    OtlpConfig::default()
        .with_endpoint("https://secure-api.honeycomb.io:443")
        .with_tls(true)
        
        // TLS配置
        .with_tls_config(TlsConfig {
            verify_certificates: true,
            verify_hostname: true,
            min_tls_version: TlsVersion::Tls12,
            max_tls_version: TlsVersion::Tls13,
            cipher_suites: vec![
                "TLS_AES_256_GCM_SHA384".to_string(),
                "TLS_CHACHA20_POLY1305_SHA256".to_string(),
                "TLS_AES_128_GCM_SHA256".to_string(),
            ],
        })
        
        // 客户端证书配置
        .with_client_certificate("path/to/client.crt")
        .with_client_private_key("path/to/client.key")
        .with_ca_certificate("path/to/ca.crt")
        
        // 证书验证
        .with_certificate_pinning(true)
        .with_pinned_certificates(vec![
            "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=".to_string(),
        ])
}
```

### 2. 认证配置

```rust
async fn create_authenticated_config() -> OtlpConfig {
    OtlpConfig::default()
        .with_endpoint("https://api.honeycomb.io:443")
        
        // API密钥认证
        .with_api_key("your-secure-api-key")
        
        // Bearer Token认证
        .with_bearer_token("your-bearer-token")
        
        // OAuth 2.0配置
        .with_oauth_config(OAuthConfig {
            client_id: "your-client-id".to_string(),
            client_secret: "your-client-secret".to_string(),
            token_url: "https://auth.example.com/oauth/token".to_string(),
            scope: "opentelemetry".to_string(),
            token_refresh_threshold: Duration::from_secs(300), // 5分钟
        })
        
        // JWT配置
        .with_jwt_config(JwtConfig {
            secret: "your-jwt-secret".to_string(),
            issuer: "your-service".to_string(),
            audience: "opentelemetry-api".to_string(),
            expiration: Duration::from_hours(1),
        })
        
        // 请求签名
        .with_request_signing(true)
        .with_signing_key("your-signing-key")
        .with_signature_algorithm("HMAC-SHA256")
}
```

### 3. 数据隐私配置

```rust
async fn create_privacy_config() -> OtlpConfig {
    OtlpConfig::default()
        .with_endpoint("http://localhost:4317")
        
        // 数据脱敏
        .with_data_masking(true)
        .with_masking_rules(vec![
            MaskingRule::new("user.email")
                .with_pattern(r"\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b")
                .with_replacement("***@***.***"),
            MaskingRule::new("user.phone")
                .with_pattern(r"\b\d{3}-\d{3}-\d{4}\b")
                .with_replacement("***-***-****"),
            MaskingRule::new("credit_card")
                .with_pattern(r"\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b")
                .with_replacement("****-****-****-****"),
        ])
        
        // 数据过滤
        .with_attribute_filter(AttributeFilter::new()
            .block_sensitive_attributes(vec![
                "password".to_string(),
                "secret".to_string(),
                "token".to_string(),
                "key".to_string(),
            ])
            .allow_only_public_attributes(true)
        )
        
        // 数据加密
        .with_field_encryption(true)
        .with_encryption_key("your-encryption-key")
        .with_encryption_algorithm("AES-256-GCM")
        
        // 审计日志
        .with_audit_logging(true)
        .with_audit_log_level(AuditLogLevel::Info)
}
```

## 🎯 自定义配置

### 1. 环境特定配置

```rust
use std::env;

async fn create_environment_specific_config() -> OtlpConfig {
    let environment = env::var("ENVIRONMENT").unwrap_or_else(|_| "development".to_string());
    
    match environment.as_str() {
        "development" => create_development_config().await,
        "staging" => create_staging_config().await,
        "production" => create_production_config().await,
        _ => create_default_config().await,
    }
}

async fn create_development_config() -> OtlpConfig {
    OtlpConfig::default()
        .with_endpoint("http://localhost:4317")
        .with_debug(true)
        .with_sampling_ratio(1.0) // 100%采样用于调试
        .with_batch_config(BatchConfig {
            max_export_batch_size: 10,
            export_timeout: Duration::from_millis(1000),
            max_queue_size: 100,
            scheduled_delay: Duration::from_millis(1000),
            max_export_timeout: Duration::from_secs(5),
        })
}

async fn create_staging_config() -> OtlpConfig {
    OtlpConfig::default()
        .with_endpoint("https://staging-api.honeycomb.io:443")
        .with_api_key(&env::var("STAGING_API_KEY").unwrap())
        .with_sampling_ratio(0.5) // 50%采样
        .with_batch_config(BatchConfig {
            max_export_batch_size: 256,
            export_timeout: Duration::from_millis(3000),
            max_queue_size: 1024,
            scheduled_delay: Duration::from_millis(2000),
            max_export_timeout: Duration::from_secs(15),
        })
}
```

### 2. 动态配置

```rust
use std::sync::Arc;
use tokio::sync::RwLock;

struct DynamicOtlpConfig {
    config: Arc<RwLock<OtlpConfig>>,
    config_watcher: ConfigWatcher,
}

impl DynamicOtlpConfig {
    async fn new() -> Result<Self, Box<dyn std::error::Error>> {
        let initial_config = Self::load_config_from_file("config.yaml").await?;
        let config = Arc::new(RwLock::new(initial_config));
        
        let config_watcher = ConfigWatcher::new("config.yaml", config.clone()).await?;
        
        Ok(Self {
            config,
            config_watcher,
        })
    }
    
    async fn get_config(&self) -> OtlpConfig {
        self.config.read().await.clone()
    }
    
    async fn update_config(&self, new_config: OtlpConfig) {
        let mut config = self.config.write().await;
        *config = new_config;
    }
    
    async fn load_config_from_file(path: &str) -> Result<OtlpConfig, Box<dyn std::error::Error>> {
        let content = tokio::fs::read_to_string(path).await?;
        let config: OtlpConfig = serde_yaml::from_str(&content)?;
        Ok(config)
    }
}
```

### 3. 配置验证

```rust
use validator::{Validate, ValidationError};

#[derive(Debug, Validate, Clone)]
pub struct OtlpConfigValidator {
    #[validate(url)]
    pub endpoint: String,
    
    #[validate(range(min = 0.0, max = 1.0))]
    pub sampling_ratio: f64,
    
    #[validate(range(min = 1, max = 10000))]
    pub max_batch_size: usize,
    
    #[validate(range(min = 1, max = 300))]
    pub timeout_seconds: u64,
    
    #[validate(custom = "validate_api_key")]
    pub api_key: Option<String>,
}

fn validate_api_key(api_key: &Option<String>) -> Result<(), ValidationError> {
    if let Some(key) = api_key {
        if key.len() < 32 {
            return Err(ValidationError::new("api_key_too_short"));
        }
        if !key.chars().all(|c| c.is_alphanumeric() || c == '-') {
            return Err(ValidationError::new("api_key_invalid_chars"));
        }
    }
    Ok(())
}

impl OtlpConfigValidator {
    pub fn validate_config(&self) -> Result<(), validator::ValidationErrors> {
        self.validate()
    }
    
    pub fn to_otlp_config(&self) -> OtlpConfig {
        let mut config = OtlpConfig::default()
            .with_endpoint(&self.endpoint)
            .with_sampling_ratio(self.sampling_ratio)
            .with_batch_config(BatchConfig {
                max_export_batch_size: self.max_batch_size,
                export_timeout: Duration::from_secs(self.timeout_seconds),
                max_queue_size: self.max_batch_size * 4,
                scheduled_delay: Duration::from_secs(5),
                max_export_timeout: Duration::from_secs(30),
            });
        
        if let Some(api_key) = &self.api_key {
            config = config.with_api_key(api_key);
        }
        
        config
    }
}
```

## 🔧 配置管理工具

### 1. 配置加载器

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize, Serialize)]
pub struct OtlpConfigFile {
    pub endpoint: String,
    pub protocol: String,
    pub service_name: String,
    pub service_version: String,
    pub sampling_ratio: f64,
    pub batch_config: BatchConfigFile,
    pub retry_config: RetryConfigFile,
    pub security: SecurityConfig,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct BatchConfigFile {
    pub max_export_batch_size: usize,
    pub export_timeout_ms: u64,
    pub max_queue_size: usize,
    pub scheduled_delay_ms: u64,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct RetryConfigFile {
    pub max_retries: u32,
    pub initial_retry_delay_ms: u64,
    pub max_retry_delay_ms: u64,
    pub retry_delay_multiplier: f64,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct SecurityConfig {
    pub tls_enabled: bool,
    pub api_key: Option<String>,
    pub bearer_token: Option<String>,
    pub client_certificate: Option<String>,
    pub client_private_key: Option<String>,
}

pub struct ConfigLoader;

impl ConfigLoader {
    pub async fn load_from_file(path: &str) -> Result<OtlpConfig, Box<dyn std::error::Error>> {
        let content = tokio::fs::read_to_string(path).await?;
        let config_file: OtlpConfigFile = match path.ends_with(".json") {
            true => serde_json::from_str(&content)?,
            false => serde_yaml::from_str(&content)?,
        };
        
        Ok(Self::convert_to_otlp_config(config_file))
    }
    
    pub async fn load_from_env() -> Result<OtlpConfig, Box<dyn std::error::Error>> {
        let config = OtlpConfig::default()
            .with_endpoint(&env::var("OTLP_ENDPOINT")?)
            .with_service(
                &env::var("SERVICE_NAME")?,
                &env::var("SERVICE_VERSION")?,
            )
            .with_sampling_ratio(env::var("SAMPLING_RATIO")?.parse()?)
            .with_debug(env::var("DEBUG").is_ok());
        
        Ok(config)
    }
    
    fn convert_to_otlp_config(config_file: OtlpConfigFile) -> OtlpConfig {
        let protocol = match config_file.protocol.as_str() {
            "grpc" => TransportProtocol::Grpc,
            "http" => TransportProtocol::Http,
            _ => TransportProtocol::Grpc,
        };
        
        OtlpConfig::default()
            .with_endpoint(&config_file.endpoint)
            .with_protocol(protocol)
            .with_service(&config_file.service_name, &config_file.service_version)
            .with_sampling_ratio(config_file.sampling_ratio)
            .with_batch_config(BatchConfig {
                max_export_batch_size: config_file.batch_config.max_export_batch_size,
                export_timeout: Duration::from_millis(config_file.batch_config.export_timeout_ms),
                max_queue_size: config_file.batch_config.max_queue_size,
                scheduled_delay: Duration::from_millis(config_file.batch_config.scheduled_delay_ms),
                max_export_timeout: Duration::from_secs(30),
            })
            .with_retry_config(RetryConfig {
                max_retries: config_file.retry_config.max_retries,
                initial_retry_delay: Duration::from_millis(config_file.retry_config.initial_retry_delay_ms),
                max_retry_delay: Duration::from_millis(config_file.retry_config.max_retry_delay_ms),
                retry_delay_multiplier: config_file.retry_config.retry_delay_multiplier,
                randomize_retry_delay: true,
                retryable_status_codes: vec![429, 500, 502, 503, 504],
            })
            .with_tls(config_file.security.tls_enabled)
            .with_api_key_opt(config_file.security.api_key)
            .with_bearer_token_opt(config_file.security.bearer_token)
    }
}
```

### 2. 配置模板

```yaml
# config.yaml 模板
endpoint: "https://api.honeycomb.io:443"
protocol: "grpc"
service_name: "my-service"
service_version: "1.0.0"
sampling_ratio: 0.1

batch_config:
  max_export_batch_size: 512
  export_timeout_ms: 5000
  max_queue_size: 2048
  scheduled_delay_ms: 5000

retry_config:
  max_retries: 5
  initial_retry_delay_ms: 1000
  max_retry_delay_ms: 30000
  retry_delay_multiplier: 2.0

security:
  tls_enabled: true
  api_key: "your-api-key"
  bearer_token: null
  client_certificate: null
  client_private_key: null
```

## 📊 监控配置

### 1. 配置指标监控

```rust
use std::sync::atomic::{AtomicU64, Ordering};

pub struct ConfigMetrics {
    pub config_changes: AtomicU64,
    pub config_validation_failures: AtomicU64,
    pub config_load_time: AtomicU64,
}

impl ConfigMetrics {
    pub fn new() -> Self {
        Self {
            config_changes: AtomicU64::new(0),
            config_validation_failures: AtomicU64::new(0),
            config_load_time: AtomicU64::new(0),
        }
    }
    
    pub fn record_config_change(&self) {
        self.config_changes.fetch_add(1, Ordering::Relaxed);
    }
    
    pub fn record_validation_failure(&self) {
        self.config_validation_failures.fetch_add(1, Ordering::Relaxed);
    }
    
    pub fn record_load_time(&self, duration: Duration) {
        self.config_load_time.store(duration.as_millis() as u64, Ordering::Relaxed);
    }
}
```

### 2. 配置健康检查

```rust
pub struct ConfigHealthChecker {
    config: Arc<RwLock<OtlpConfig>>,
    metrics: Arc<ConfigMetrics>,
}

impl ConfigHealthChecker {
    pub async fn check_config_health(&self) -> HealthStatus {
        let config = self.config.read().await;
        
        // 检查配置有效性
        if config.endpoint.is_empty() {
            return HealthStatus::Unhealthy("endpoint is empty".to_string());
        }
        
        if config.sampling_ratio < 0.0 || config.sampling_ratio > 1.0 {
            return HealthStatus::Unhealthy("invalid sampling ratio".to_string());
        }
        
        // 检查连接性
        if let Err(e) = self.test_connection(&config).await {
            return HealthStatus::Degraded(format!("connection test failed: {}", e));
        }
        
        HealthStatus::Healthy
    }
    
    async fn test_connection(&self, config: &OtlpConfig) -> Result<(), Box<dyn std::error::Error>> {
        // 实现连接测试逻辑
        let client = OtlpClient::new(config.clone()).await?;
        client.initialize().await?;
        client.shutdown().await?;
        Ok(())
    }
}

#[derive(Debug)]
pub enum HealthStatus {
    Healthy,
    Degraded(String),
    Unhealthy(String),
}
```

## 🚀 最佳实践

### 1. 配置分层

```rust
// 基础配置
pub struct BaseConfig {
    pub endpoint: String,
    pub service_name: String,
    pub service_version: String,
}

// 环境特定配置
pub struct EnvironmentConfig {
    pub base: BaseConfig,
    pub sampling_ratio: f64,
    pub debug: bool,
}

// 完整配置
pub struct FullConfig {
    pub environment: EnvironmentConfig,
    pub batch: BatchConfig,
    pub retry: RetryConfig,
    pub security: SecurityConfig,
}

impl FullConfig {
    pub fn to_otlp_config(&self) -> OtlpConfig {
        OtlpConfig::default()
            .with_endpoint(&self.environment.base.endpoint)
            .with_service(
                &self.environment.base.service_name,
                &self.environment.base.service_version,
            )
            .with_sampling_ratio(self.environment.sampling_ratio)
            .with_debug(self.environment.debug)
            .with_batch_config(self.batch.clone())
            .with_retry_config(self.retry.clone())
            .with_tls(self.security.tls_enabled)
            .with_api_key_opt(self.security.api_key.clone())
    }
}
```

### 2. 配置验证

```rust
pub trait ConfigValidator {
    fn validate(&self) -> Result<(), ValidationError>;
}

impl ConfigValidator for OtlpConfig {
    fn validate(&self) -> Result<(), ValidationError> {
        // 验证端点
        if self.endpoint.is_empty() {
            return Err(ValidationError::new("endpoint_required"));
        }
        
        // 验证采样率
        if self.sampling_ratio < 0.0 || self.sampling_ratio > 1.0 {
            return Err(ValidationError::new("invalid_sampling_ratio"));
        }
        
        // 验证批处理配置
        if self.batch_config.max_export_batch_size == 0 {
            return Err(ValidationError::new("invalid_batch_size"));
        }
        
        Ok(())
    }
}

#[derive(Debug)]
pub struct ValidationError {
    pub message: String,
    pub field: Option<String>,
}

impl ValidationError {
    pub fn new(message: &str) -> Self {
        Self {
            message: message.to_string(),
            field: None,
        }
    }
}
```

## 📚 总结

高级配置是OTLP实现成功部署的关键因素。通过合理配置：

1. **生产环境**: 确保高可用性和性能
2. **安全设置**: 保护数据传输和访问
3. **性能优化**: 满足不同的性能要求
4. **动态配置**: 支持配置的热更新
5. **监控验证**: 确保配置的正确性

选择合适的配置策略对于构建稳定、高效的可观测性系统至关重要。

---

**高级配置指南版本**: v1.0  
**最后更新**: 2025年1月27日  
**维护者**: OTLP 2025 文档团队
