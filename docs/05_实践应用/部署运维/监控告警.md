# ÁõëÊéßÂëäË≠¶ÈÖçÁΩÆÊåáÂçó

## üìö Ê¶ÇËø∞

Êú¨ÊñáÊ°£ËØ¶ÁªÜ‰ªãÁªç‰∫ÜOTLP RustÂ∫îÁî®ÁöÑÁõëÊéßÂíåÂëäË≠¶ÈÖçÁΩÆÔºåÂåÖÊã¨PrometheusÊåáÊ†áÊî∂ÈõÜ„ÄÅGrafana‰ª™Ë°®Áõò„ÄÅÂëäË≠¶ËßÑÂàôËÆæÁΩÆÁ≠âÂÆåÊï¥ÁöÑÁõëÊéß‰ΩìÁ≥ª„ÄÇ

## üìä Prometheus ÁõëÊéßÈÖçÁΩÆ

### 1. Â∫îÁî®ÊåáÊ†áÊö¥Èú≤

```rust
// src/metrics.rs
use prometheus::{Counter, Histogram, Gauge, Registry, TextEncoder, Encoder};
use std::sync::Arc;
use tokio::sync::RwLock;

pub struct Metrics {
    // ËØ∑Ê±ÇÊåáÊ†á
    pub requests_total: Counter,
    pub request_duration: Histogram,
    pub active_connections: Gauge,
    
    // ‰∏öÂä°ÊåáÊ†á
    pub traces_sent: Counter,
    pub metrics_sent: Counter,
    pub logs_sent: Counter,
    
    // ÈîôËØØÊåáÊ†á
    pub errors_total: Counter,
    pub connection_errors: Counter,
    
    // Á≥ªÁªüÊåáÊ†á
    pub memory_usage: Gauge,
    pub cpu_usage: Gauge,
    pub queue_size: Gauge,
}

impl Metrics {
    pub fn new() -> Self {
        Self {
            requests_total: Counter::new(
                "otlp_requests_total",
                "Total number of requests"
            ).unwrap(),
            
            request_duration: Histogram::new(
                "otlp_request_duration_seconds",
                "Request duration in seconds"
            ).unwrap(),
            
            active_connections: Gauge::new(
                "otlp_active_connections",
                "Number of active connections"
            ).unwrap(),
            
            traces_sent: Counter::new(
                "otlp_traces_sent_total",
                "Total number of traces sent"
            ).unwrap(),
            
            metrics_sent: Counter::new(
                "otlp_metrics_sent_total",
                "Total number of metrics sent"
            ).unwrap(),
            
            logs_sent: Counter::new(
                "otlp_logs_sent_total",
                "Total number of logs sent"
            ).unwrap(),
            
            errors_total: Counter::new(
                "otlp_errors_total",
                "Total number of errors"
            ).unwrap(),
            
            connection_errors: Counter::new(
                "otlp_connection_errors_total",
                "Total number of connection errors"
            ).unwrap(),
            
            memory_usage: Gauge::new(
                "otlp_memory_usage_bytes",
                "Memory usage in bytes"
            ).unwrap(),
            
            cpu_usage: Gauge::new(
                "otlp_cpu_usage_percent",
                "CPU usage percentage"
            ).unwrap(),
            
            queue_size: Gauge::new(
                "otlp_queue_size",
                "Current queue size"
            ).unwrap(),
        }
    }
    
    pub fn register(&self, registry: &Registry) -> Result<(), prometheus::Error> {
        registry.register(Box::new(self.requests_total.clone()))?;
        registry.register(Box::new(self.request_duration.clone()))?;
        registry.register(Box::new(self.active_connections.clone()))?;
        registry.register(Box::new(self.traces_sent.clone()))?;
        registry.register(Box::new(self.metrics_sent.clone()))?;
        registry.register(Box::new(self.logs_sent.clone()))?;
        registry.register(Box::new(self.errors_total.clone()))?;
        registry.register(Box::new(self.connection_errors.clone()))?;
        registry.register(Box::new(self.memory_usage.clone()))?;
        registry.register(Box::new(self.cpu_usage.clone()))?;
        registry.register(Box::new(self.queue_size.clone()))?;
        
        Ok(())
    }
}

pub struct MetricsCollector {
    metrics: Arc<Metrics>,
    registry: Registry,
}

impl MetricsCollector {
    pub fn new() -> Self {
        let metrics = Arc::new(Metrics::new());
        let registry = Registry::new();
        
        metrics.register(&registry).unwrap();
        
        Self {
            metrics,
            registry,
        }
    }
    
    pub fn metrics(&self) -> Arc<Metrics> {
        self.metrics.clone()
    }
    
    pub fn gather(&self) -> String {
        let metric_families = self.registry.gather();
        let encoder = TextEncoder::new();
        let mut buffer = Vec::new();
        encoder.encode(&metric_families, &mut buffer).unwrap();
        String::from_utf8(buffer).unwrap()
    }
}
```

### 2. HTTPÊåáÊ†áÁ´ØÁÇπ

```rust
// src/server.rs
use warp::Filter;
use std::sync::Arc;

pub fn create_metrics_routes(collector: Arc<MetricsCollector>) -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    let metrics = collector.metrics();
    
    // ÂÅ•Â∫∑Ê£ÄÊü•Á´ØÁÇπ
    let health = warp::path("health")
        .and(warp::get())
        .map(|| "OK");
    
    // Â∞±Áª™Ê£ÄÊü•Á´ØÁÇπ
    let ready = warp::path("ready")
        .and(warp::get())
        .map(|| "Ready");
    
    // ÊåáÊ†áÁ´ØÁÇπ
    let metrics_endpoint = warp::path("metrics")
        .and(warp::get())
        .map(move || collector.gather());
    
    // Ëá™ÂÆö‰πâÊåáÊ†áÁ´ØÁÇπ
    let custom_metrics = warp::path("custom-metrics")
        .and(warp::get())
        .and(with_metrics(metrics))
        .and_then(get_custom_metrics);
    
    health.or(ready).or(metrics_endpoint).or(custom_metrics)
}

fn with_metrics(metrics: Arc<Metrics>) -> impl Filter<Extract = (Arc<Metrics>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || metrics.clone())
}

async fn get_custom_metrics(metrics: Arc<Metrics>) -> Result<impl warp::Reply, warp::Rejection> {
    let custom_metrics = serde_json::json!({
        "traces_sent": metrics.traces_sent.get(),
        "metrics_sent": metrics.metrics_sent.get(),
        "logs_sent": metrics.logs_sent.get(),
        "active_connections": metrics.active_connections.get(),
        "queue_size": metrics.queue_size.get(),
        "memory_usage": metrics.memory_usage.get(),
        "cpu_usage": metrics.cpu_usage.get(),
    });
    
    Ok(warp::reply::json(&custom_metrics))
}
```

## üìà Grafana ‰ª™Ë°®ÁõòÈÖçÁΩÆ

### 1. Â∫îÁî®‰ª™Ë°®Áõò

```json
{
  "dashboard": {
    "id": null,
    "title": "OTLP Rust Application Dashboard",
    "tags": ["otlp", "rust", "observability"],
    "timezone": "browser",
    "panels": [
      {
        "id": 1,
        "title": "Request Rate",
        "type": "graph",
        "gridPos": {"h": 8, "w": 12, "x": 0, "y": 0},
        "targets": [
          {
            "expr": "rate(otlp_requests_total[5m])",
            "legendFormat": "Requests/sec",
            "refId": "A"
          }
        ],
        "yAxes": [
          {
            "label": "Requests/sec",
            "min": 0
          }
        ]
      },
      {
        "id": 2,
        "title": "Request Duration",
        "type": "graph",
        "gridPos": {"h": 8, "w": 12, "x": 12, "y": 0},
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(otlp_request_duration_seconds_bucket[5m]))",
            "legendFormat": "95th percentile",
            "refId": "A"
          },
          {
            "expr": "histogram_quantile(0.50, rate(otlp_request_duration_seconds_bucket[5m]))",
            "legendFormat": "50th percentile",
            "refId": "B"
          }
        ],
        "yAxes": [
          {
            "label": "Duration (seconds)",
            "min": 0
          }
        ]
      },
      {
        "id": 3,
        "title": "Error Rate",
        "type": "graph",
        "gridPos": {"h": 8, "w": 12, "x": 0, "y": 8},
        "targets": [
          {
            "expr": "rate(otlp_errors_total[5m])",
            "legendFormat": "Errors/sec",
            "refId": "A"
          }
        ],
        "yAxes": [
          {
            "label": "Errors/sec",
            "min": 0
          }
        ]
      },
      {
        "id": 4,
        "title": "Active Connections",
        "type": "graph",
        "gridPos": {"h": 8, "w": 12, "x": 12, "y": 8},
        "targets": [
          {
            "expr": "otlp_active_connections",
            "legendFormat": "Active Connections",
            "refId": "A"
          }
        ],
        "yAxes": [
          {
            "label": "Connections",
            "min": 0
          }
        ]
      },
      {
        "id": 5,
        "title": "Data Sent",
        "type": "graph",
        "gridPos": {"h": 8, "w": 24, "x": 0, "y": 16},
        "targets": [
          {
            "expr": "rate(otlp_traces_sent_total[5m])",
            "legendFormat": "Traces/sec",
            "refId": "A"
          },
          {
            "expr": "rate(otlp_metrics_sent_total[5m])",
            "legendFormat": "Metrics/sec",
            "refId": "B"
          },
          {
            "expr": "rate(otlp_logs_sent_total[5m])",
            "legendFormat": "Logs/sec",
            "refId": "C"
          }
        ],
        "yAxes": [
          {
            "label": "Data/sec",
            "min": 0
          }
        ]
      },
      {
        "id": 6,
        "title": "System Resources",
        "type": "graph",
        "gridPos": {"h": 8, "w": 12, "x": 0, "y": 24},
        "targets": [
          {
            "expr": "otlp_memory_usage_bytes / 1024 / 1024",
            "legendFormat": "Memory (MB)",
            "refId": "A"
          }
        ],
        "yAxes": [
          {
            "label": "Memory (MB)",
            "min": 0
          }
        ]
      },
      {
        "id": 7,
        "title": "Queue Size",
        "type": "graph",
        "gridPos": {"h": 8, "w": 12, "x": 12, "y": 24},
        "targets": [
          {
            "expr": "otlp_queue_size",
            "legendFormat": "Queue Size",
            "refId": "A"
          }
        ],
        "yAxes": [
          {
            "label": "Items",
            "min": 0
          }
        ]
      }
    ],
    "time": {
      "from": "now-1h",
      "to": "now"
    },
    "refresh": "30s"
  }
}
```

### 2. ‰∏öÂä°ÊåáÊ†á‰ª™Ë°®Áõò

```json
{
  "dashboard": {
    "id": null,
    "title": "OTLP Business Metrics",
    "tags": ["otlp", "business"],
    "panels": [
      {
        "id": 1,
        "title": "Data Processing Rate",
        "type": "stat",
        "gridPos": {"h": 8, "w": 6, "x": 0, "y": 0},
        "targets": [
          {
            "expr": "rate(otlp_traces_sent_total[1m]) * 60",
            "legendFormat": "Traces/min",
            "refId": "A"
          }
        ],
        "valueName": "current"
      },
      {
        "id": 2,
        "title": "Success Rate",
        "type": "stat",
        "gridPos": {"h": 8, "w": 6, "x": 6, "y": 0},
        "targets": [
          {
            "expr": "(1 - rate(otlp_errors_total[5m]) / rate(otlp_requests_total[5m])) * 100",
            "legendFormat": "Success Rate %",
            "refId": "A"
          }
        ],
        "valueName": "current",
        "unit": "percent"
      },
      {
        "id": 3,
        "title": "Average Latency",
        "type": "stat",
        "gridPos": {"h": 8, "w": 6, "x": 12, "y": 0},
        "targets": [
          {
            "expr": "histogram_quantile(0.50, rate(otlp_request_duration_seconds_bucket[5m])) * 1000",
            "legendFormat": "Avg Latency (ms)",
            "refId": "A"
          }
        ],
        "valueName": "current",
        "unit": "ms"
      },
      {
        "id": 4,
        "title": "Throughput",
        "type": "stat",
        "gridPos": {"h": 8, "w": 6, "x": 18, "y": 0},
        "targets": [
          {
            "expr": "rate(otlp_requests_total[1m])",
            "legendFormat": "Requests/sec",
            "refId": "A"
          }
        ],
        "valueName": "current"
      }
    ]
  }
}
```

## üö® ÂëäË≠¶ËßÑÂàôÈÖçÁΩÆ

### 1. Prometheus ÂëäË≠¶ËßÑÂàô

```yaml
# prometheus-alerts.yaml
groups:
- name: otlp.rules
  rules:
  # È´òÈîôËØØÁéáÂëäË≠¶
  - alert: OtlpHighErrorRate
    expr: rate(otlp_errors_total[5m]) / rate(otlp_requests_total[5m]) > 0.05
    for: 2m
    labels:
      severity: warning
      service: otlp-rust
    annotations:
      summary: "OTLP Rust high error rate detected"
      description: "Error rate is {{ $value | humanizePercentage }} for the last 5 minutes"
      runbook_url: "https://docs.example.com/runbooks/high-error-rate"

  # È´òÂª∂ËøüÂëäË≠¶
  - alert: OtlpHighLatency
    expr: histogram_quantile(0.95, rate(otlp_request_duration_seconds_bucket[5m])) > 1
    for: 5m
    labels:
      severity: warning
      service: otlp-rust
    annotations:
      summary: "OTLP Rust high latency detected"
      description: "95th percentile latency is {{ $value }} seconds"
      runbook_url: "https://docs.example.com/runbooks/high-latency"

  # Â∫îÁî®ÂÆïÊú∫ÂëäË≠¶
  - alert: OtlpAppDown
    expr: up{job="otlp-rust"} == 0
    for: 1m
    labels:
      severity: critical
      service: otlp-rust
    annotations:
      summary: "OTLP Rust application is down"
      description: "OTLP Rust application has been down for more than 1 minute"
      runbook_url: "https://docs.example.com/runbooks/app-down"

  # ÈòüÂàóÁßØÂéãÂëäË≠¶
  - alert: OtlpQueueBacklog
    expr: otlp_queue_size > 1000
    for: 2m
    labels:
      severity: warning
      service: otlp-rust
    annotations:
      summary: "OTLP Rust queue backlog detected"
      description: "Queue size is {{ $value }} items"
      runbook_url: "https://docs.example.com/runbooks/queue-backlog"

  # ËøûÊé•ÈîôËØØÂëäË≠¶
  - alert: OtlpConnectionErrors
    expr: rate(otlp_connection_errors_total[5m]) > 0.1
    for: 1m
    labels:
      severity: critical
      service: otlp-rust
    annotations:
      summary: "OTLP Rust connection errors detected"
      description: "Connection error rate is {{ $value }} errors per second"
      runbook_url: "https://docs.example.com/runbooks/connection-errors"

  # ÂÜÖÂ≠ò‰ΩøÁî®ÁéáÂëäË≠¶
  - alert: OtlpHighMemoryUsage
    expr: otlp_memory_usage_bytes > 100 * 1024 * 1024 * 1024  # 100GB
    for: 5m
    labels:
      severity: warning
      service: otlp-rust
    annotations:
      summary: "OTLP Rust high memory usage"
      description: "Memory usage is {{ $value | humanizeBytes }}"
      runbook_url: "https://docs.example.com/runbooks/high-memory"

  # Êï∞ÊçÆÂèëÈÄÅÂ§±Ë¥•ÂëäË≠¶
  - alert: OtlpDataSendFailures
    expr: rate(otlp_traces_sent_total[5m]) == 0 and rate(otlp_metrics_sent_total[5m]) == 0
    for: 5m
    labels:
      severity: critical
      service: otlp-rust
    annotations:
      summary: "OTLP Rust data sending failures"
      description: "No data has been sent in the last 5 minutes"
      runbook_url: "https://docs.example.com/runbooks/data-send-failures"

  # ÂìçÂ∫îÊó∂Èó¥ÂºÇÂ∏∏ÂëäË≠¶
  - alert: OtlpResponseTimeAnomaly
    expr: (
      histogram_quantile(0.95, rate(otlp_request_duration_seconds_bucket[5m])) -
      histogram_quantile(0.95, rate(otlp_request_duration_seconds_bucket[15m] offset 5m))
      / histogram_quantile(0.95, rate(otlp_request_duration_seconds_bucket[15m] offset 5m)) > 0.5
    for: 3m
    labels:
      severity: warning
      service: otlp-rust
    annotations:
      summary: "OTLP Rust response time anomaly detected"
      description: "Response time has increased by more than 50%"
      runbook_url: "https://docs.example.com/runbooks/response-time-anomaly"
```

### 2. Alertmanager ÈÖçÁΩÆ

```yaml
# alertmanager.yml
global:
  smtp_smarthost: 'localhost:587'
  smtp_from: 'alerts@example.com'
  smtp_auth_username: 'alerts@example.com'
  smtp_auth_password: 'password'

route:
  group_by: ['alertname', 'service']
  group_wait: 10s
  group_interval: 10s
  repeat_interval: 1h
  receiver: 'web.hook'
  routes:
  - match:
      severity: critical
    receiver: 'critical-alerts'
  - match:
      severity: warning
    receiver: 'warning-alerts'

receivers:
- name: 'web.hook'
  webhook_configs:
  - url: 'http://localhost:5001/webhook'

- name: 'critical-alerts'
  email_configs:
  - to: 'oncall@example.com'
    subject: 'CRITICAL: {{ .GroupLabels.alertname }}'
    body: |
      {{ range .Alerts }}
      Alert: {{ .Annotations.summary }}
      Description: {{ .Annotations.description }}
      Runbook: {{ .Annotations.runbook_url }}
      {{ end }}
  slack_configs:
  - api_url: 'https://hooks.slack.com/services/...'
    channel: '#critical-alerts'
    title: 'Critical Alert'
    text: '{{ range .Alerts }}{{ .Annotations.summary }}{{ end }}'

- name: 'warning-alerts'
  email_configs:
  - to: 'team@example.com'
    subject: 'WARNING: {{ .GroupLabels.alertname }}'
    body: |
      {{ range .Alerts }}
      Alert: {{ .Annotations.summary }}
      Description: {{ .Annotations.description }}
      Runbook: {{ .Annotations.runbook_url }}
      {{ end }}
  slack_configs:
  - api_url: 'https://hooks.slack.com/services/...'
    channel: '#alerts'
    title: 'Warning Alert'
    text: '{{ range .Alerts }}{{ .Annotations.summary }}{{ end }}'
```

## üì± ÈÄöÁü•Ê∏†ÈÅìÈÖçÁΩÆ

### 1. Slack ÈõÜÊàê

```rust
// src/notifications.rs
use serde_json::json;
use std::collections::HashMap;

pub struct SlackNotifier {
    webhook_url: String,
    channel: String,
}

impl SlackNotifier {
    pub fn new(webhook_url: String, channel: String) -> Self {
        Self {
            webhook_url,
            channel,
        }
    }
    
    pub async fn send_alert(&self, alert: &Alert) -> Result<(), Box<dyn std::error::Error>> {
        let payload = json!({
            "channel": self.channel,
            "username": "OTLP Monitor",
            "icon_emoji": ":warning:",
            "attachments": [{
                "color": self.get_color_for_severity(&alert.severity),
                "title": alert.summary,
                "text": alert.description,
                "fields": [
                    {
                        "title": "Severity",
                        "value": alert.severity.to_string(),
                        "short": true
                    },
                    {
                        "title": "Service",
                        "value": alert.service,
                        "short": true
                    },
                    {
                        "title": "Timestamp",
                        "value": alert.timestamp,
                        "short": true
                    }
                ],
                "actions": [
                    {
                        "type": "button",
                        "text": "View Dashboard",
                        "url": "https://grafana.example.com/d/otlp-dashboard"
                    },
                    {
                        "type": "button",
                        "text": "Runbook",
                        "url": alert.runbook_url
                    }
                ]
            }]
        });
        
        let client = reqwest::Client::new();
        let response = client
            .post(&self.webhook_url)
            .json(&payload)
            .send()
            .await?;
        
        if response.status().is_success() {
            println!("Alert sent to Slack successfully");
        } else {
            println!("Failed to send alert to Slack: {}", response.status());
        }
        
        Ok(())
    }
    
    fn get_color_for_severity(&self, severity: &AlertSeverity) -> &'static str {
        match severity {
            AlertSeverity::Critical => "danger",
            AlertSeverity::Warning => "warning",
            AlertSeverity::Info => "good",
        }
    }
}

#[derive(Debug)]
pub struct Alert {
    pub summary: String,
    pub description: String,
    pub severity: AlertSeverity,
    pub service: String,
    pub timestamp: String,
    pub runbook_url: String,
}

#[derive(Debug)]
pub enum AlertSeverity {
    Critical,
    Warning,
    Info,
}

impl std::fmt::Display for AlertSeverity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AlertSeverity::Critical => write!(f, "Critical"),
            AlertSeverity::Warning => write!(f, "Warning"),
            AlertSeverity::Info => write!(f, "Info"),
        }
    }
}
```

### 2. ÈÇÆ‰ª∂ÈÄöÁü•

```rust
// src/email_notifier.rs
use lettre::{Message, SmtpTransport, Transport};
use lettre::message::header::ContentType;
use lettre::transport::smtp::authentication::Credentials;

pub struct EmailNotifier {
    smtp_server: String,
    credentials: Credentials,
    from_email: String,
}

impl EmailNotifier {
    pub fn new(smtp_server: String, username: String, password: String, from_email: String) -> Self {
        Self {
            smtp_server,
            credentials: Credentials::new(username, password),
            from_email,
        }
    }
    
    pub async fn send_alert(&self, alert: &Alert, recipients: &[String]) -> Result<(), Box<dyn std::error::Error>> {
        let subject = format!("[{}] {}", alert.severity, alert.summary);
        
        let html_body = format!(
            r#"
            <html>
            <body>
                <h2>Alert Notification</h2>
                <table border="1" style="border-collapse: collapse;">
                    <tr><td><strong>Summary</strong></td><td>{}</td></tr>
                    <tr><td><strong>Description</strong></td><td>{}</td></tr>
                    <tr><td><strong>Severity</strong></td><td>{}</td></tr>
                    <tr><td><strong>Service</strong></td><td>{}</td></tr>
                    <tr><td><strong>Timestamp</strong></td><td>{}</td></tr>
                </table>
                <p><a href="{}">View Runbook</a></p>
                <p><a href="https://grafana.example.com/d/otlp-dashboard">View Dashboard</a></p>
            </body>
            </html>
            "#,
            alert.summary,
            alert.description,
            alert.severity,
            alert.service,
            alert.timestamp,
            alert.runbook_url
        );
        
        for recipient in recipients {
            let email = Message::builder()
                .from(self.from_email.parse()?)
                .to(recipient.parse()?)
                .subject(&subject)
                .header(ContentType::TEXT_HTML)
                .body(html_body.clone())?;
            
            let mailer = SmtpTransport::relay(&self.smtp_server)?
                .credentials(self.credentials.clone())
                .build();
            
            match mailer.send(&email) {
                Ok(_) => println!("Alert email sent to {}", recipient),
                Err(e) => println!("Failed to send email to {}: {}", recipient, e),
            }
        }
        
        Ok(())
    }
}
```

## üîç ÁõëÊéßËÑöÊú¨

### 1. ÂÅ•Â∫∑Ê£ÄÊü•ËÑöÊú¨

```bash
#!/bin/bash
# health-check.sh

set -euo pipefail

NAMESPACE=${1:-otlp-system}
TIMEOUT=${2:-30}

log_info() {
    echo "[INFO] $1"
}

log_error() {
    echo "[ERROR] $1" >&2
}

check_pod_health() {
    local pod_name=$1
    
    log_info "Checking health of pod: $pod_name"
    
    # Ê£ÄÊü•PodÁä∂ÊÄÅ
    local pod_status=$(kubectl get pod "$pod_name" -n "$NAMESPACE" -o jsonpath='{.status.phase}')
    if [ "$pod_status" != "Running" ]; then
        log_error "Pod $pod_name is not running (status: $pod_status)"
        return 1
    fi
    
    # Ê£ÄÊü•ÂÆπÂô®Áä∂ÊÄÅ
    local container_status=$(kubectl get pod "$pod_name" -n "$NAMESPACE" -o jsonpath='{.status.containerStatuses[0].ready}')
    if [ "$container_status" != "true" ]; then
        log_error "Container in pod $pod_name is not ready"
        return 1
    fi
    
    log_info "Pod $pod_name is healthy"
    return 0
}

check_service_health() {
    local service_name=$1
    
    log_info "Checking health of service: $service_name"
    
    # Á´ØÂè£ËΩ¨Âèë
    kubectl port-forward -n "$NAMESPACE" "svc/$service_name" 8080:80 &
    local port_forward_pid=$!
    
    # Á≠âÂæÖÁ´ØÂè£ËΩ¨ÂèëÂ∞±Áª™
    sleep 5
    
    # ÂÅ•Â∫∑Ê£ÄÊü•
    local health_status=0
    if curl -f -s --max-time "$TIMEOUT" http://localhost:8080/health > /dev/null; then
        log_info "Health check passed"
    else
        log_error "Health check failed"
        health_status=1
    fi
    
    # Â∞±Áª™Ê£ÄÊü•
    if curl -f -s --max-time "$TIMEOUT" http://localhost:8080/ready > /dev/null; then
        log_info "Readiness check passed"
    else
        log_error "Readiness check failed"
        health_status=1
    fi
    
    # ÊåáÊ†áÊ£ÄÊü•
    if curl -f -s --max-time "$TIMEOUT" http://localhost:8080/metrics > /dev/null; then
        log_info "Metrics endpoint accessible"
    else
        log_error "Metrics endpoint not accessible"
        health_status=1
    fi
    
    # Ê∏ÖÁêÜÁ´ØÂè£ËΩ¨Âèë
    kill "$port_forward_pid" 2>/dev/null || true
    
    return $health_status
}

check_deployment_health() {
    local deployment_name=$1
    
    log_info "Checking health of deployment: $deployment_name"
    
    # Ê£ÄÊü•ÈÉ®ÁΩ≤Áä∂ÊÄÅ
    local deployment_status=$(kubectl get deployment "$deployment_name" -n "$NAMESPACE" -o jsonpath='{.status.conditions[?(@.type=="Available")].status}')
    if [ "$deployment_status" != "True" ]; then
        log_error "Deployment $deployment_name is not available"
        return 1
    fi
    
    # Ê£ÄÊü•ÂâØÊú¨Êï∞
    local desired_replicas=$(kubectl get deployment "$deployment_name" -n "$NAMESPACE" -o jsonpath='{.spec.replicas}')
    local available_replicas=$(kubectl get deployment "$deployment_name" -n "$NAMESPACE" -o jsonpath='{.status.availableReplicas}')
    
    if [ "$desired_replicas" != "$available_replicas" ]; then
        log_error "Deployment $deployment_name has $available_replicas available replicas, expected $desired_replicas"
        return 1
    fi
    
    log_info "Deployment $deployment_name is healthy"
    return 0
}

main() {
    log_info "Starting health check for namespace: $NAMESPACE"
    
    local exit_code=0
    
    # Ê£ÄÊü•ÈÉ®ÁΩ≤
    if ! check_deployment_health "otlp-app"; then
        exit_code=1
    fi
    
    # Ëé∑ÂèñPodÂêçÁß∞
    local pod_name=$(kubectl get pods -n "$NAMESPACE" -l app=otlp-app -o jsonpath='{.items[0].metadata.name}')
    
    if [ -n "$pod_name" ]; then
        # Ê£ÄÊü•Pod
        if ! check_pod_health "$pod_name"; then
            exit_code=1
        fi
        
        # Ê£ÄÊü•ÊúçÂä°
        if ! check_service_health "otlp-app-service"; then
            exit_code=1
        fi
    else
        log_error "No pods found for app=otlp-app"
        exit_code=1
    fi
    
    if [ $exit_code -eq 0 ]; then
        log_info "All health checks passed"
    else
        log_error "Some health checks failed"
    fi
    
    exit $exit_code
}

main "$@"
```

### 2. ÁõëÊéßÊï∞ÊçÆÊî∂ÈõÜËÑöÊú¨

```bash
#!/bin/bash
# collect-metrics.sh

set -euo pipefail

NAMESPACE=${1:-otlp-system}
OUTPUT_DIR=${2:-./metrics}

log_info() {
    echo "[INFO] $1"
}

create_output_dir() {
    mkdir -p "$OUTPUT_DIR"
    log_info "Created output directory: $OUTPUT_DIR"
}

collect_prometheus_metrics() {
    log_info "Collecting Prometheus metrics..."
    
    # Á´ØÂè£ËΩ¨Âèë
    kubectl port-forward -n "$NAMESPACE" svc/otlp-app-service 8080:80 &
    local port_forward_pid=$!
    
    sleep 5
    
    # Êî∂ÈõÜÊåáÊ†á
    curl -s http://localhost:8080/metrics > "$OUTPUT_DIR/prometheus_metrics.txt"
    
    # Êî∂ÈõÜËá™ÂÆö‰πâÊåáÊ†á
    curl -s http://localhost:8080/custom-metrics > "$OUTPUT_DIR/custom_metrics.json"
    
    kill "$port_forward_pid" 2>/dev/null || true
    
    log_info "Prometheus metrics collected"
}

collect_kubernetes_metrics() {
    log_info "Collecting Kubernetes metrics..."
    
    # PodÊåáÊ†á
    kubectl top pods -n "$NAMESPACE" -l app=otlp-app > "$OUTPUT_DIR/pod_metrics.txt"
    
    # ËäÇÁÇπÊåáÊ†á
    kubectl top nodes > "$OUTPUT_DIR/node_metrics.txt"
    
    # ÈÉ®ÁΩ≤Áä∂ÊÄÅ
    kubectl get deployment otlp-app -n "$NAMESPACE" -o yaml > "$OUTPUT_DIR/deployment_status.yaml"
    
    # PodÁä∂ÊÄÅ
    kubectl get pods -n "$NAMESPACE" -l app=otlp-app -o yaml > "$OUTPUT_DIR/pod_status.yaml"
    
    log_info "Kubernetes metrics collected"
}

collect_logs() {
    log_info "Collecting application logs..."
    
    # Ëé∑ÂèñPodÂêçÁß∞
    local pod_name=$(kubectl get pods -n "$NAMESPACE" -l app=otlp-app -o jsonpath='{.items[0].metadata.name}')
    
    if [ -n "$pod_name" ]; then
        # Êî∂ÈõÜÊúÄËøë100Ë°åÊó•Âøó
        kubectl logs "$pod_name" -n "$NAMESPACE" --tail=100 > "$OUTPUT_DIR/app_logs.txt"
        
        # Êî∂ÈõÜÈîôËØØÊó•Âøó
        kubectl logs "$pod_name" -n "$NAMESPACE" --tail=100 | grep -i error > "$OUTPUT_DIR/error_logs.txt" || true
    fi
    
    log_info "Application logs collected"
}

collect_events() {
    log_info "Collecting Kubernetes events..."
    
    kubectl get events -n "$NAMESPACE" --sort-by='.lastTimestamp' > "$OUTPUT_DIR/events.txt"
    
    log_info "Kubernetes events collected"
}

generate_report() {
    log_info "Generating monitoring report..."
    
    cat > "$OUTPUT_DIR/report.md" << EOF
# OTLP Monitoring Report

Generated at: $(date)

## Summary

- Namespace: $NAMESPACE
- Collection time: $(date)

## Files Collected

- prometheus_metrics.txt: Prometheus metrics
- custom_metrics.json: Custom application metrics
- pod_metrics.txt: Pod resource usage
- node_metrics.txt: Node resource usage
- deployment_status.yaml: Deployment status
- pod_status.yaml: Pod status
- app_logs.txt: Application logs
- error_logs.txt: Error logs
- events.txt: Kubernetes events

## Quick Stats

EOF
    
    # Ê∑ªÂä†Âø´ÈÄüÁªüËÆ°
    if [ -f "$OUTPUT_DIR/prometheus_metrics.txt" ]; then
        echo "- Total metrics: $(wc -l < "$OUTPUT_DIR/prometheus_metrics.txt")" >> "$OUTPUT_DIR/report.md"
    fi
    
    if [ -f "$OUTPUT_DIR/app_logs.txt" ]; then
        echo "- Total log lines: $(wc -l < "$OUTPUT_DIR/app_logs.txt")" >> "$OUTPUT_DIR/report.md"
    fi
    
    if [ -f "$OUTPUT_DIR/error_logs.txt" ]; then
        echo "- Error log lines: $(wc -l < "$OUTPUT_DIR/error_logs.txt")" >> "$OUTPUT_DIR/report.md"
    fi
    
    log_info "Monitoring report generated"
}

main() {
    log_info "Starting metrics collection for namespace: $NAMESPACE"
    
    create_output_dir
    collect_prometheus_metrics
    collect_kubernetes_metrics
    collect_logs
    collect_events
    generate_report
    
    log_info "Metrics collection completed. Output directory: $OUTPUT_DIR"
}

main "$@"
```

## üìö ÊúÄ‰Ω≥ÂÆûË∑µ

### 1. ÁõëÊéßËÆæËÆ°ÂéüÂàô

- **ÂàÜÂ±ÇÁõëÊéß**: Âü∫Á°ÄËÆæÊñΩ„ÄÅÂ∫îÁî®„ÄÅ‰∏öÂä°‰∏âÂ±ÇÁõëÊéß
- **ÂÖ≥ÈîÆÊåáÊ†á**: ‰∏ìÊ≥®‰∫éSLAÁõ∏ÂÖ≥ÁöÑÂÖ≥ÈîÆÊåáÊ†á
- **ÂëäË≠¶ÂàÜÁ∫ß**: Ê†πÊçÆ‰∏•ÈáçÁ®ãÂ∫¶ÂàÜÁ∫ßÂëäË≠¶
- **Ëá™Âä®ÂåñÂìçÂ∫î**: ÂÆûÁé∞Ëá™Âä®ÂåñÁöÑÊïÖÈöúÂìçÂ∫î

### 2. ÂëäË≠¶ËÆæËÆ°ÂéüÂàô

- **ÈÅøÂÖçÂëäË≠¶Áñ≤Âä≥**: ËÆæÁΩÆÂêàÁêÜÁöÑÈòàÂÄºÂíåÈ¢ëÁéá
- **Êèê‰æõ‰∏ä‰∏ãÊñá**: ÂëäË≠¶‰ø°ÊÅØÂåÖÂê´Ë∂≥Â§üÁöÑ‰∏ä‰∏ãÊñá
- **ÂèØÊìç‰ΩúÊÄß**: Êèê‰æõÊòéÁ°ÆÁöÑÂ§ÑÁêÜÊ≠•È™§
- **ÊåÅÁª≠ÊîπËøõ**: ÂÆöÊúüÂÆ°Êü•Âíå‰ºòÂåñÂëäË≠¶ËßÑÂàô

### 3. ÁõëÊéßÊï∞ÊçÆÁÆ°ÁêÜ

- **Êï∞ÊçÆ‰øùÁïô**: ËÆæÁΩÆÂêàÁêÜÁöÑÊï∞ÊçÆ‰øùÁïôÁ≠ñÁï•
- **Êï∞ÊçÆÂéãÁº©**: ‰ΩøÁî®Êï∞ÊçÆÂéãÁº©ÂáèÂ∞ëÂ≠òÂÇ®ÊàêÊú¨
- **Êï∞ÊçÆÂ§á‰ªΩ**: ÂÆöÊúüÂ§á‰ªΩÈáçË¶ÅÁöÑÁõëÊéßÊï∞ÊçÆ
- **Êï∞ÊçÆÂÆâÂÖ®**: ‰øùÊä§ÁõëÊéßÊï∞ÊçÆÁöÑÂÆâÂÖ®ÊÄß

---

**ÁõëÊéßÂëäË≠¶ÈÖçÁΩÆÊåáÂçóÁâàÊú¨**: v1.0  
**ÊúÄÂêéÊõ¥Êñ∞**: 2025Âπ¥1Êúà27Êó•  
**Áª¥Êä§ËÄÖ**: OTLP 2025 ÊñáÊ°£Âõ¢Èòü
