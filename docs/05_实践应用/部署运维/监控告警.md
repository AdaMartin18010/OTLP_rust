# ç›‘æ§å‘Šè­¦é…ç½®æŒ‡å—

## ğŸ“š æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»äº†OTLP Ruståº”ç”¨çš„ç›‘æ§å’Œå‘Šè­¦é…ç½®ï¼ŒåŒ…æ‹¬PrometheusæŒ‡æ ‡æ”¶é›†ã€Grafanaä»ªè¡¨ç›˜ã€å‘Šè­¦è§„åˆ™è®¾ç½®ç­‰å®Œæ•´çš„ç›‘æ§ä½“ç³»ã€‚

## ğŸ“Š Prometheus ç›‘æ§é…ç½®

### 1. åº”ç”¨æŒ‡æ ‡æš´éœ²

```rust
// src/metrics.rs
use prometheus::{Counter, Histogram, Gauge, Registry, TextEncoder, Encoder};
use std::sync::Arc;
use tokio::sync::RwLock;

pub struct Metrics {
    // è¯·æ±‚æŒ‡æ ‡
    pub requests_total: Counter,
    pub request_duration: Histogram,
    pub active_connections: Gauge,
    
    // ä¸šåŠ¡æŒ‡æ ‡
    pub traces_sent: Counter,
    pub metrics_sent: Counter,
    pub logs_sent: Counter,
    
    // é”™è¯¯æŒ‡æ ‡
    pub errors_total: Counter,
    pub connection_errors: Counter,
    
    // ç³»ç»ŸæŒ‡æ ‡
    pub memory_usage: Gauge,
    pub cpu_usage: Gauge,
    pub queue_size: Gauge,
}

impl Metrics {
    pub fn new() -> Self {
        Self {
            requests_total: Counter::new(
                "otlp_requests_total",
                "Total number of requests"
            ).unwrap(),
            
            request_duration: Histogram::new(
                "otlp_request_duration_seconds",
                "Request duration in seconds"
            ).unwrap(),
            
            active_connections: Gauge::new(
                "otlp_active_connections",
                "Number of active connections"
            ).unwrap(),
            
            traces_sent: Counter::new(
                "otlp_traces_sent_total",
                "Total number of traces sent"
            ).unwrap(),
            
            metrics_sent: Counter::new(
                "otlp_metrics_sent_total",
                "Total number of metrics sent"
            ).unwrap(),
            
            logs_sent: Counter::new(
                "otlp_logs_sent_total",
                "Total number of logs sent"
            ).unwrap(),
            
            errors_total: Counter::new(
                "otlp_errors_total",
                "Total number of errors"
            ).unwrap(),
            
            connection_errors: Counter::new(
                "otlp_connection_errors_total",
                "Total number of connection errors"
            ).unwrap(),
            
            memory_usage: Gauge::new(
                "otlp_memory_usage_bytes",
                "Memory usage in bytes"
            ).unwrap(),
            
            cpu_usage: Gauge::new(
                "otlp_cpu_usage_percent",
                "CPU usage percentage"
            ).unwrap(),
            
            queue_size: Gauge::new(
                "otlp_queue_size",
                "Current queue size"
            ).unwrap(),
        }
    }
    
    pub fn register(&self, registry: &Registry) -> Result<(), prometheus::Error> {
        registry.register(Box::new(self.requests_total.clone()))?;
        registry.register(Box::new(self.request_duration.clone()))?;
        registry.register(Box::new(self.active_connections.clone()))?;
        registry.register(Box::new(self.traces_sent.clone()))?;
        registry.register(Box::new(self.metrics_sent.clone()))?;
        registry.register(Box::new(self.logs_sent.clone()))?;
        registry.register(Box::new(self.errors_total.clone()))?;
        registry.register(Box::new(self.connection_errors.clone()))?;
        registry.register(Box::new(self.memory_usage.clone()))?;
        registry.register(Box::new(self.cpu_usage.clone()))?;
        registry.register(Box::new(self.queue_size.clone()))?;
        
        Ok(())
    }
}

pub struct MetricsCollector {
    metrics: Arc<Metrics>,
    registry: Registry,
}

impl MetricsCollector {
    pub fn new() -> Self {
        let metrics = Arc::new(Metrics::new());
        let registry = Registry::new();
        
        metrics.register(&registry).unwrap();
        
        Self {
            metrics,
            registry,
        }
    }
    
    pub fn metrics(&self) -> Arc<Metrics> {
        self.metrics.clone()
    }
    
    pub fn gather(&self) -> String {
        let metric_families = self.registry.gather();
        let encoder = TextEncoder::new();
        let mut buffer = Vec::new();
        encoder.encode(&metric_families, &mut buffer).unwrap();
        String::from_utf8(buffer).unwrap()
    }
}
```

### 2. HTTPæŒ‡æ ‡ç«¯ç‚¹

```rust
// src/server.rs
use warp::Filter;
use std::sync::Arc;

pub fn create_metrics_routes(collector: Arc<MetricsCollector>) -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    let metrics = collector.metrics();
    
    // å¥åº·æ£€æŸ¥ç«¯ç‚¹
    let health = warp::path("health")
        .and(warp::get())
        .map(|| "OK");
    
    // å°±ç»ªæ£€æŸ¥ç«¯ç‚¹
    let ready = warp::path("ready")
        .and(warp::get())
        .map(|| "Ready");
    
    // æŒ‡æ ‡ç«¯ç‚¹
    let metrics_endpoint = warp::path("metrics")
        .and(warp::get())
        .map(move || collector.gather());
    
    // è‡ªå®šä¹‰æŒ‡æ ‡ç«¯ç‚¹
    let custom_metrics = warp::path("custom-metrics")
        .and(warp::get())
        .and(with_metrics(metrics))
        .and_then(get_custom_metrics);
    
    health.or(ready).or(metrics_endpoint).or(custom_metrics)
}

fn with_metrics(metrics: Arc<Metrics>) -> impl Filter<Extract = (Arc<Metrics>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || metrics.clone())
}

async fn get_custom_metrics(metrics: Arc<Metrics>) -> Result<impl warp::Reply, warp::Rejection> {
    let custom_metrics = serde_json::json!({
        "traces_sent": metrics.traces_sent.get(),
        "metrics_sent": metrics.metrics_sent.get(),
        "logs_sent": metrics.logs_sent.get(),
        "active_connections": metrics.active_connections.get(),
        "queue_size": metrics.queue_size.get(),
        "memory_usage": metrics.memory_usage.get(),
        "cpu_usage": metrics.cpu_usage.get(),
    });
    
    Ok(warp::reply::json(&custom_metrics))
}
```

## ğŸ“ˆ Grafana ä»ªè¡¨ç›˜é…ç½®

### 1. åº”ç”¨ä»ªè¡¨ç›˜

```json
{
  "dashboard": {
    "id": null,
    "title": "OTLP Rust Application Dashboard",
    "tags": ["otlp", "rust", "observability"],
    "timezone": "browser",
    "panels": [
      {
        "id": 1,
        "title": "Request Rate",
        "type": "graph",
        "gridPos": {"h": 8, "w": 12, "x": 0, "y": 0},
        "targets": [
          {
            "expr": "rate(otlp_requests_total[5m])",
            "legendFormat": "Requests/sec",
            "refId": "A"
          }
        ],
        "yAxes": [
          {
            "label": "Requests/sec",
            "min": 0
          }
        ]
      },
      {
        "id": 2,
        "title": "Request Duration",
        "type": "graph",
        "gridPos": {"h": 8, "w": 12, "x": 12, "y": 0},
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(otlp_request_duration_seconds_bucket[5m]))",
            "legendFormat": "95th percentile",
            "refId": "A"
          },
          {
            "expr": "histogram_quantile(0.50, rate(otlp_request_duration_seconds_bucket[5m]))",
            "legendFormat": "50th percentile",
            "refId": "B"
          }
        ],
        "yAxes": [
          {
            "label": "Duration (seconds)",
            "min": 0
          }
        ]
      },
      {
        "id": 3,
        "title": "Error Rate",
        "type": "graph",
        "gridPos": {"h": 8, "w": 12, "x": 0, "y": 8},
        "targets": [
          {
            "expr": "rate(otlp_errors_total[5m])",
            "legendFormat": "Errors/sec",
            "refId": "A"
          }
        ],
        "yAxes": [
          {
            "label": "Errors/sec",
            "min": 0
          }
        ]
      },
      {
        "id": 4,
        "title": "Active Connections",
        "type": "graph",
        "gridPos": {"h": 8, "w": 12, "x": 12, "y": 8},
        "targets": [
          {
            "expr": "otlp_active_connections",
            "legendFormat": "Active Connections",
            "refId": "A"
          }
        ],
        "yAxes": [
          {
            "label": "Connections",
            "min": 0
          }
        ]
      },
      {
        "id": 5,
        "title": "Data Sent",
        "type": "graph",
        "gridPos": {"h": 8, "w": 24, "x": 0, "y": 16},
        "targets": [
          {
            "expr": "rate(otlp_traces_sent_total[5m])",
            "legendFormat": "Traces/sec",
            "refId": "A"
          },
          {
            "expr": "rate(otlp_metrics_sent_total[5m])",
            "legendFormat": "Metrics/sec",
            "refId": "B"
          },
          {
            "expr": "rate(otlp_logs_sent_total[5m])",
            "legendFormat": "Logs/sec",
            "refId": "C"
          }
        ],
        "yAxes": [
          {
            "label": "Data/sec",
            "min": 0
          }
        ]
      },
      {
        "id": 6,
        "title": "System Resources",
        "type": "graph",
        "gridPos": {"h": 8, "w": 12, "x": 0, "y": 24},
        "targets": [
          {
            "expr": "otlp_memory_usage_bytes / 1024 / 1024",
            "legendFormat": "Memory (MB)",
            "refId": "A"
          }
        ],
        "yAxes": [
          {
            "label": "Memory (MB)",
            "min": 0
          }
        ]
      },
      {
        "id": 7,
        "title": "Queue Size",
        "type": "graph",
        "gridPos": {"h": 8, "w": 12, "x": 12, "y": 24},
        "targets": [
          {
            "expr": "otlp_queue_size",
            "legendFormat": "Queue Size",
            "refId": "A"
          }
        ],
        "yAxes": [
          {
            "label": "Items",
            "min": 0
          }
        ]
      }
    ],
    "time": {
      "from": "now-1h",
      "to": "now"
    },
    "refresh": "30s"
  }
}
```

### 2. ä¸šåŠ¡æŒ‡æ ‡ä»ªè¡¨ç›˜

```json
{
  "dashboard": {
    "id": null,
    "title": "OTLP Business Metrics",
    "tags": ["otlp", "business"],
    "panels": [
      {
        "id": 1,
        "title": "Data Processing Rate",
        "type": "stat",
        "gridPos": {"h": 8, "w": 6, "x": 0, "y": 0},
        "targets": [
          {
            "expr": "rate(otlp_traces_sent_total[1m]) * 60",
            "legendFormat": "Traces/min",
            "refId": "A"
          }
        ],
        "valueName": "current"
      },
      {
        "id": 2,
        "title": "Success Rate",
        "type": "stat",
        "gridPos": {"h": 8, "w": 6, "x": 6, "y": 0},
        "targets": [
          {
            "expr": "(1 - rate(otlp_errors_total[5m]) / rate(otlp_requests_total[5m])) * 100",
            "legendFormat": "Success Rate %",
            "refId": "A"
          }
        ],
        "valueName": "current",
        "unit": "percent"
      },
      {
        "id": 3,
        "title": "Average Latency",
        "type": "stat",
        "gridPos": {"h": 8, "w": 6, "x": 12, "y": 0},
        "targets": [
          {
            "expr": "histogram_quantile(0.50, rate(otlp_request_duration_seconds_bucket[5m])) * 1000",
            "legendFormat": "Avg Latency (ms)",
            "refId": "A"
          }
        ],
        "valueName": "current",
        "unit": "ms"
      },
      {
        "id": 4,
        "title": "Throughput",
        "type": "stat",
        "gridPos": {"h": 8, "w": 6, "x": 18, "y": 0},
        "targets": [
          {
            "expr": "rate(otlp_requests_total[1m])",
            "legendFormat": "Requests/sec",
            "refId": "A"
          }
        ],
        "valueName": "current"
      }
    ]
  }
}
```

## ğŸš¨ å‘Šè­¦è§„åˆ™é…ç½®

### 1. Prometheus å‘Šè­¦è§„åˆ™

```yaml
# prometheus-alerts.yaml
groups:
- name: otlp.rules
  rules:
  # é«˜é”™è¯¯ç‡å‘Šè­¦
  - alert: OtlpHighErrorRate
    expr: rate(otlp_errors_total[5m]) / rate(otlp_requests_total[5m]) > 0.05
    for: 2m
    labels:
      severity: warning
      service: otlp-rust
    annotations:
      summary: "OTLP Rust high error rate detected"
      description: "Error rate is {{ $value | humanizePercentage }} for the last 5 minutes"
      runbook_url: "https://docs.example.com/runbooks/high-error-rate"

  # é«˜å»¶è¿Ÿå‘Šè­¦
  - alert: OtlpHighLatency
    expr: histogram_quantile(0.95, rate(otlp_request_duration_seconds_bucket[5m])) > 1
    for: 5m
    labels:
      severity: warning
      service: otlp-rust
    annotations:
      summary: "OTLP Rust high latency detected"
      description: "95th percentile latency is {{ $value }} seconds"
      runbook_url: "https://docs.example.com/runbooks/high-latency"

  # åº”ç”¨å®•æœºå‘Šè­¦
  - alert: OtlpAppDown
    expr: up{job="otlp-rust"} == 0
    for: 1m
    labels:
      severity: critical
      service: otlp-rust
    annotations:
      summary: "OTLP Rust application is down"
      description: "OTLP Rust application has been down for more than 1 minute"
      runbook_url: "https://docs.example.com/runbooks/app-down"

  # é˜Ÿåˆ—ç§¯å‹å‘Šè­¦
  - alert: OtlpQueueBacklog
    expr: otlp_queue_size > 1000
    for: 2m
    labels:
      severity: warning
      service: otlp-rust
    annotations:
      summary: "OTLP Rust queue backlog detected"
      description: "Queue size is {{ $value }} items"
      runbook_url: "https://docs.example.com/runbooks/queue-backlog"

  # è¿æ¥é”™è¯¯å‘Šè­¦
  - alert: OtlpConnectionErrors
    expr: rate(otlp_connection_errors_total[5m]) > 0.1
    for: 1m
    labels:
      severity: critical
      service: otlp-rust
    annotations:
      summary: "OTLP Rust connection errors detected"
      description: "Connection error rate is {{ $value }} errors per second"
      runbook_url: "https://docs.example.com/runbooks/connection-errors"

  # å†…å­˜ä½¿ç”¨ç‡å‘Šè­¦
  - alert: OtlpHighMemoryUsage
    expr: otlp_memory_usage_bytes > 100 * 1024 * 1024 * 1024  # 100GB
    for: 5m
    labels:
      severity: warning
      service: otlp-rust
    annotations:
      summary: "OTLP Rust high memory usage"
      description: "Memory usage is {{ $value | humanizeBytes }}"
      runbook_url: "https://docs.example.com/runbooks/high-memory"

  # æ•°æ®å‘é€å¤±è´¥å‘Šè­¦
  - alert: OtlpDataSendFailures
    expr: rate(otlp_traces_sent_total[5m]) == 0 and rate(otlp_metrics_sent_total[5m]) == 0
    for: 5m
    labels:
      severity: critical
      service: otlp-rust
    annotations:
      summary: "OTLP Rust data sending failures"
      description: "No data has been sent in the last 5 minutes"
      runbook_url: "https://docs.example.com/runbooks/data-send-failures"

  # å“åº”æ—¶é—´å¼‚å¸¸å‘Šè­¦
  - alert: OtlpResponseTimeAnomaly
    expr: (
      histogram_quantile(0.95, rate(otlp_request_duration_seconds_bucket[5m])) -
      histogram_quantile(0.95, rate(otlp_request_duration_seconds_bucket[15m] offset 5m))
      / histogram_quantile(0.95, rate(otlp_request_duration_seconds_bucket[15m] offset 5m)) > 0.5
    for: 3m
    labels:
      severity: warning
      service: otlp-rust
    annotations:
      summary: "OTLP Rust response time anomaly detected"
      description: "Response time has increased by more than 50%"
      runbook_url: "https://docs.example.com/runbooks/response-time-anomaly"
```

### 2. Alertmanager é…ç½®

```yaml
# alertmanager.yml
global:
  smtp_smarthost: 'localhost:587'
  smtp_from: 'alerts@example.com'
  smtp_auth_username: 'alerts@example.com'
  smtp_auth_password: 'password'

route:
  group_by: ['alertname', 'service']
  group_wait: 10s
  group_interval: 10s
  repeat_interval: 1h
  receiver: 'web.hook'
  routes:
  - match:
      severity: critical
    receiver: 'critical-alerts'
  - match:
      severity: warning
    receiver: 'warning-alerts'

receivers:
- name: 'web.hook'
  webhook_configs:
  - url: 'http://localhost:5001/webhook'

- name: 'critical-alerts'
  email_configs:
  - to: 'oncall@example.com'
    subject: 'CRITICAL: {{ .GroupLabels.alertname }}'
    body: |
      {{ range .Alerts }}
      Alert: {{ .Annotations.summary }}
      Description: {{ .Annotations.description }}
      Runbook: {{ .Annotations.runbook_url }}
      {{ end }}
  slack_configs:
  - api_url: 'https://hooks.slack.com/services/...'
    channel: '#critical-alerts'
    title: 'Critical Alert'
    text: '{{ range .Alerts }}{{ .Annotations.summary }}{{ end }}'

- name: 'warning-alerts'
  email_configs:
  - to: 'team@example.com'
    subject: 'WARNING: {{ .GroupLabels.alertname }}'
    body: |
      {{ range .Alerts }}
      Alert: {{ .Annotations.summary }}
      Description: {{ .Annotations.description }}
      Runbook: {{ .Annotations.runbook_url }}
      {{ end }}
  slack_configs:
  - api_url: 'https://hooks.slack.com/services/...'
    channel: '#alerts'
    title: 'Warning Alert'
    text: '{{ range .Alerts }}{{ .Annotations.summary }}{{ end }}'
```

## ğŸ“± é€šçŸ¥æ¸ é“é…ç½®

### 1. Slack é›†æˆ

```rust
// src/notifications.rs
use serde_json::json;
use std::collections::HashMap;

pub struct SlackNotifier {
    webhook_url: String,
    channel: String,
}

impl SlackNotifier {
    pub fn new(webhook_url: String, channel: String) -> Self {
        Self {
            webhook_url,
            channel,
        }
    }
    
    pub async fn send_alert(&self, alert: &Alert) -> Result<(), Box<dyn std::error::Error>> {
        let payload = json!({
            "channel": self.channel,
            "username": "OTLP Monitor",
            "icon_emoji": ":warning:",
            "attachments": [{
                "color": self.get_color_for_severity(&alert.severity),
                "title": alert.summary,
                "text": alert.description,
                "fields": [
                    {
                        "title": "Severity",
                        "value": alert.severity.to_string(),
                        "short": true
                    },
                    {
                        "title": "Service",
                        "value": alert.service,
                        "short": true
                    },
                    {
                        "title": "Timestamp",
                        "value": alert.timestamp,
                        "short": true
                    }
                ],
                "actions": [
                    {
                        "type": "button",
                        "text": "View Dashboard",
                        "url": "https://grafana.example.com/d/otlp-dashboard"
                    },
                    {
                        "type": "button",
                        "text": "Runbook",
                        "url": alert.runbook_url
                    }
                ]
            }]
        });
        
        let client = reqwest::Client::new();
        let response = client
            .post(&self.webhook_url)
            .json(&payload)
            .send()
            .await?;
        
        if response.status().is_success() {
            println!("Alert sent to Slack successfully");
        } else {
            println!("Failed to send alert to Slack: {}", response.status());
        }
        
        Ok(())
    }
    
    fn get_color_for_severity(&self, severity: &AlertSeverity) -> &'static str {
        match severity {
            AlertSeverity::Critical => "danger",
            AlertSeverity::Warning => "warning",
            AlertSeverity::Info => "good",
        }
    }
}

#[derive(Debug)]
pub struct Alert {
    pub summary: String,
    pub description: String,
    pub severity: AlertSeverity,
    pub service: String,
    pub timestamp: String,
    pub runbook_url: String,
}

#[derive(Debug)]
pub enum AlertSeverity {
    Critical,
    Warning,
    Info,
}

impl std::fmt::Display for AlertSeverity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AlertSeverity::Critical => write!(f, "Critical"),
            AlertSeverity::Warning => write!(f, "Warning"),
            AlertSeverity::Info => write!(f, "Info"),
        }
    }
}
```

### 2. é‚®ä»¶é€šçŸ¥

```rust
// src/email_notifier.rs
use lettre::{Message, SmtpTransport, Transport};
use lettre::message::header::ContentType;
use lettre::transport::smtp::authentication::Credentials;

pub struct EmailNotifier {
    smtp_server: String,
    credentials: Credentials,
    from_email: String,
}

impl EmailNotifier {
    pub fn new(smtp_server: String, username: String, password: String, from_email: String) -> Self {
        Self {
            smtp_server,
            credentials: Credentials::new(username, password),
            from_email,
        }
    }
    
    pub async fn send_alert(&self, alert: &Alert, recipients: &[String]) -> Result<(), Box<dyn std::error::Error>> {
        let subject = format!("[{}] {}", alert.severity, alert.summary);
        
        let html_body = format!(
            r#"
            <html>
            <body>
                <h2>Alert Notification</h2>
                <table border="1" style="border-collapse: collapse;">
                    <tr><td><strong>Summary</strong></td><td>{}</td></tr>
                    <tr><td><strong>Description</strong></td><td>{}</td></tr>
                    <tr><td><strong>Severity</strong></td><td>{}</td></tr>
                    <tr><td><strong>Service</strong></td><td>{}</td></tr>
                    <tr><td><strong>Timestamp</strong></td><td>{}</td></tr>
                </table>
                <p><a href="{}">View Runbook</a></p>
                <p><a href="https://grafana.example.com/d/otlp-dashboard">View Dashboard</a></p>
            </body>
            </html>
            "#,
            alert.summary,
            alert.description,
            alert.severity,
            alert.service,
            alert.timestamp,
            alert.runbook_url
        );
        
        for recipient in recipients {
            let email = Message::builder()
                .from(self.from_email.parse()?)
                .to(recipient.parse()?)
                .subject(&subject)
                .header(ContentType::TEXT_HTML)
                .body(html_body.clone())?;
            
            let mailer = SmtpTransport::relay(&self.smtp_server)?
                .credentials(self.credentials.clone())
                .build();
            
            match mailer.send(&email) {
                Ok(_) => println!("Alert email sent to {}", recipient),
                Err(e) => println!("Failed to send email to {}: {}", recipient, e),
            }
        }
        
        Ok(())
    }
}
```

## ğŸ” ç›‘æ§è„šæœ¬

### 1. å¥åº·æ£€æŸ¥è„šæœ¬

```bash
#!/bin/bash
# health-check.sh

set -euo pipefail

NAMESPACE=${1:-otlp-system}
TIMEOUT=${2:-30}

log_info() {
    echo "[INFO] $1"
}

log_error() {
    echo "[ERROR] $1" >&2
}

check_pod_health() {
    local pod_name=$1
    
    log_info "Checking health of pod: $pod_name"
    
    # æ£€æŸ¥PodçŠ¶æ€
    local pod_status=$(kubectl get pod "$pod_name" -n "$NAMESPACE" -o jsonpath='{.status.phase}')
    if [ "$pod_status" != "Running" ]; then
        log_error "Pod $pod_name is not running (status: $pod_status)"
        return 1
    fi
    
    # æ£€æŸ¥å®¹å™¨çŠ¶æ€
    local container_status=$(kubectl get pod "$pod_name" -n "$NAMESPACE" -o jsonpath='{.status.containerStatuses[0].ready}')
    if [ "$container_status" != "true" ]; then
        log_error "Container in pod $pod_name is not ready"
        return 1
    fi
    
    log_info "Pod $pod_name is healthy"
    return 0
}

check_service_health() {
    local service_name=$1
    
    log_info "Checking health of service: $service_name"
    
    # ç«¯å£è½¬å‘
    kubectl port-forward -n "$NAMESPACE" "svc/$service_name" 8080:80 &
    local port_forward_pid=$!
    
    # ç­‰å¾…ç«¯å£è½¬å‘å°±ç»ª
    sleep 5
    
    # å¥åº·æ£€æŸ¥
    local health_status=0
    if curl -f -s --max-time "$TIMEOUT" http://localhost:8080/health > /dev/null; then
        log_info "Health check passed"
    else
        log_error "Health check failed"
        health_status=1
    fi
    
    # å°±ç»ªæ£€æŸ¥
    if curl -f -s --max-time "$TIMEOUT" http://localhost:8080/ready > /dev/null; then
        log_info "Readiness check passed"
    else
        log_error "Readiness check failed"
        health_status=1
    fi
    
    # æŒ‡æ ‡æ£€æŸ¥
    if curl -f -s --max-time "$TIMEOUT" http://localhost:8080/metrics > /dev/null; then
        log_info "Metrics endpoint accessible"
    else
        log_error "Metrics endpoint not accessible"
        health_status=1
    fi
    
    # æ¸…ç†ç«¯å£è½¬å‘
    kill "$port_forward_pid" 2>/dev/null || true
    
    return $health_status
}

check_deployment_health() {
    local deployment_name=$1
    
    log_info "Checking health of deployment: $deployment_name"
    
    # æ£€æŸ¥éƒ¨ç½²çŠ¶æ€
    local deployment_status=$(kubectl get deployment "$deployment_name" -n "$NAMESPACE" -o jsonpath='{.status.conditions[?(@.type=="Available")].status}')
    if [ "$deployment_status" != "True" ]; then
        log_error "Deployment $deployment_name is not available"
        return 1
    fi
    
    # æ£€æŸ¥å‰¯æœ¬æ•°
    local desired_replicas=$(kubectl get deployment "$deployment_name" -n "$NAMESPACE" -o jsonpath='{.spec.replicas}')
    local available_replicas=$(kubectl get deployment "$deployment_name" -n "$NAMESPACE" -o jsonpath='{.status.availableReplicas}')
    
    if [ "$desired_replicas" != "$available_replicas" ]; then
        log_error "Deployment $deployment_name has $available_replicas available replicas, expected $desired_replicas"
        return 1
    fi
    
    log_info "Deployment $deployment_name is healthy"
    return 0
}

main() {
    log_info "Starting health check for namespace: $NAMESPACE"
    
    local exit_code=0
    
    # æ£€æŸ¥éƒ¨ç½²
    if ! check_deployment_health "otlp-app"; then
        exit_code=1
    fi
    
    # è·å–Podåç§°
    local pod_name=$(kubectl get pods -n "$NAMESPACE" -l app=otlp-app -o jsonpath='{.items[0].metadata.name}')
    
    if [ -n "$pod_name" ]; then
        # æ£€æŸ¥Pod
        if ! check_pod_health "$pod_name"; then
            exit_code=1
        fi
        
        # æ£€æŸ¥æœåŠ¡
        if ! check_service_health "otlp-app-service"; then
            exit_code=1
        fi
    else
        log_error "No pods found for app=otlp-app"
        exit_code=1
    fi
    
    if [ $exit_code -eq 0 ]; then
        log_info "All health checks passed"
    else
        log_error "Some health checks failed"
    fi
    
    exit $exit_code
}

main "$@"
```

### 2. ç›‘æ§æ•°æ®æ”¶é›†è„šæœ¬

```bash
#!/bin/bash
# collect-metrics.sh

set -euo pipefail

NAMESPACE=${1:-otlp-system}
OUTPUT_DIR=${2:-./metrics}

log_info() {
    echo "[INFO] $1"
}

create_output_dir() {
    mkdir -p "$OUTPUT_DIR"
    log_info "Created output directory: $OUTPUT_DIR"
}

collect_prometheus_metrics() {
    log_info "Collecting Prometheus metrics..."
    
    # ç«¯å£è½¬å‘
    kubectl port-forward -n "$NAMESPACE" svc/otlp-app-service 8080:80 &
    local port_forward_pid=$!
    
    sleep 5
    
    # æ”¶é›†æŒ‡æ ‡
    curl -s http://localhost:8080/metrics > "$OUTPUT_DIR/prometheus_metrics.txt"
    
    # æ”¶é›†è‡ªå®šä¹‰æŒ‡æ ‡
    curl -s http://localhost:8080/custom-metrics > "$OUTPUT_DIR/custom_metrics.json"
    
    kill "$port_forward_pid" 2>/dev/null || true
    
    log_info "Prometheus metrics collected"
}

collect_kubernetes_metrics() {
    log_info "Collecting Kubernetes metrics..."
    
    # PodæŒ‡æ ‡
    kubectl top pods -n "$NAMESPACE" -l app=otlp-app > "$OUTPUT_DIR/pod_metrics.txt"
    
    # èŠ‚ç‚¹æŒ‡æ ‡
    kubectl top nodes > "$OUTPUT_DIR/node_metrics.txt"
    
    # éƒ¨ç½²çŠ¶æ€
    kubectl get deployment otlp-app -n "$NAMESPACE" -o yaml > "$OUTPUT_DIR/deployment_status.yaml"
    
    # PodçŠ¶æ€
    kubectl get pods -n "$NAMESPACE" -l app=otlp-app -o yaml > "$OUTPUT_DIR/pod_status.yaml"
    
    log_info "Kubernetes metrics collected"
}

collect_logs() {
    log_info "Collecting application logs..."
    
    # è·å–Podåç§°
    local pod_name=$(kubectl get pods -n "$NAMESPACE" -l app=otlp-app -o jsonpath='{.items[0].metadata.name}')
    
    if [ -n "$pod_name" ]; then
        # æ”¶é›†æœ€è¿‘100è¡Œæ—¥å¿—
        kubectl logs "$pod_name" -n "$NAMESPACE" --tail=100 > "$OUTPUT_DIR/app_logs.txt"
        
        # æ”¶é›†é”™è¯¯æ—¥å¿—
        kubectl logs "$pod_name" -n "$NAMESPACE" --tail=100 | grep -i error > "$OUTPUT_DIR/error_logs.txt" || true
    fi
    
    log_info "Application logs collected"
}

collect_events() {
    log_info "Collecting Kubernetes events..."
    
    kubectl get events -n "$NAMESPACE" --sort-by='.lastTimestamp' > "$OUTPUT_DIR/events.txt"
    
    log_info "Kubernetes events collected"
}

generate_report() {
    log_info "Generating monitoring report..."
    
    cat > "$OUTPUT_DIR/report.md" << EOF
# OTLP Monitoring Report

Generated at: $(date)

## Summary

- Namespace: $NAMESPACE
- Collection time: $(date)

## Files Collected

- prometheus_metrics.txt: Prometheus metrics
- custom_metrics.json: Custom application metrics
- pod_metrics.txt: Pod resource usage
- node_metrics.txt: Node resource usage
- deployment_status.yaml: Deployment status
- pod_status.yaml: Pod status
- app_logs.txt: Application logs
- error_logs.txt: Error logs
- events.txt: Kubernetes events

## Quick Stats

EOF
    
    # æ·»åŠ å¿«é€Ÿç»Ÿè®¡
    if [ -f "$OUTPUT_DIR/prometheus_metrics.txt" ]; then
        echo "- Total metrics: $(wc -l < "$OUTPUT_DIR/prometheus_metrics.txt")" >> "$OUTPUT_DIR/report.md"
    fi
    
    if [ -f "$OUTPUT_DIR/app_logs.txt" ]; then
        echo "- Total log lines: $(wc -l < "$OUTPUT_DIR/app_logs.txt")" >> "$OUTPUT_DIR/report.md"
    fi
    
    if [ -f "$OUTPUT_DIR/error_logs.txt" ]; then
        echo "- Error log lines: $(wc -l < "$OUTPUT_DIR/error_logs.txt")" >> "$OUTPUT_DIR/report.md"
    fi
    
    log_info "Monitoring report generated"
}

main() {
    log_info "Starting metrics collection for namespace: $NAMESPACE"
    
    create_output_dir
    collect_prometheus_metrics
    collect_kubernetes_metrics
    collect_logs
    collect_events
    generate_report
    
    log_info "Metrics collection completed. Output directory: $OUTPUT_DIR"
}

main "$@"
```

## ğŸ“š æœ€ä½³å®è·µ

### 1. ç›‘æ§è®¾è®¡åŸåˆ™

- **åˆ†å±‚ç›‘æ§**: åŸºç¡€è®¾æ–½ã€åº”ç”¨ã€ä¸šåŠ¡ä¸‰å±‚ç›‘æ§
- **å…³é”®æŒ‡æ ‡**: ä¸“æ³¨äºSLAç›¸å…³çš„å…³é”®æŒ‡æ ‡
- **å‘Šè­¦åˆ†çº§**: æ ¹æ®ä¸¥é‡ç¨‹åº¦åˆ†çº§å‘Šè­¦
- **è‡ªåŠ¨åŒ–å“åº”**: å®ç°è‡ªåŠ¨åŒ–çš„æ•…éšœå“åº”

### 2. å‘Šè­¦è®¾è®¡åŸåˆ™

- **é¿å…å‘Šè­¦ç–²åŠ³**: è®¾ç½®åˆç†çš„é˜ˆå€¼å’Œé¢‘ç‡
- **æä¾›ä¸Šä¸‹æ–‡**: å‘Šè­¦ä¿¡æ¯åŒ…å«è¶³å¤Ÿçš„ä¸Šä¸‹æ–‡
- **å¯æ“ä½œæ€§**: æä¾›æ˜ç¡®çš„å¤„ç†æ­¥éª¤
- **æŒç»­æ”¹è¿›**: å®šæœŸå®¡æŸ¥å’Œä¼˜åŒ–å‘Šè­¦è§„åˆ™

### 3. ç›‘æ§æ•°æ®ç®¡ç†

- **æ•°æ®ä¿ç•™**: è®¾ç½®åˆç†çš„æ•°æ®ä¿ç•™ç­–ç•¥
- **æ•°æ®å‹ç¼©**: ä½¿ç”¨æ•°æ®å‹ç¼©å‡å°‘å­˜å‚¨æˆæœ¬
- **æ•°æ®å¤‡ä»½**: å®šæœŸå¤‡ä»½é‡è¦çš„ç›‘æ§æ•°æ®
- **æ•°æ®å®‰å…¨**: ä¿æŠ¤ç›‘æ§æ•°æ®çš„å®‰å…¨æ€§

---

**ç›‘æ§å‘Šè­¦é…ç½®æŒ‡å—ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ27æ—¥  
**ç»´æŠ¤è€…**: OTLP 2025 æ–‡æ¡£å›¢é˜Ÿ
