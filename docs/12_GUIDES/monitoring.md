# ğŸ“Š ç›‘æ§é…ç½®æŒ‡å—

**ç‰ˆæœ¬**: 1.0  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ26æ—¥  
**çŠ¶æ€**: ğŸŸ¢ æ´»è·ƒç»´æŠ¤

> **ç®€ä»‹**: ç›‘æ§é…ç½®æŒ‡å— - ç³»ç»ŸæŒ‡æ ‡ã€åˆ†å¸ƒå¼è¿½è¸ªã€å‘Šè­¦å’Œä»ªè¡¨æ¿çš„å®Œæ•´é…ç½®ã€‚

---

## ğŸ“‹ ç›®å½•

- [ğŸ“Š ç›‘æ§é…ç½®æŒ‡å—](#-ç›‘æ§é…ç½®æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ ç›‘æ§æ¦‚è§ˆ](#-ç›‘æ§æ¦‚è§ˆ)
    - [ç›‘æ§ç›®æ ‡](#ç›‘æ§ç›®æ ‡)
    - [ç›‘æ§æ¶æ„](#ç›‘æ§æ¶æ„)
  - [âš™ï¸ åŸºç¡€ç›‘æ§é…ç½®](#ï¸-åŸºç¡€ç›‘æ§é…ç½®)
    - [å®¢æˆ·ç«¯ç›‘æ§é…ç½®](#å®¢æˆ·ç«¯ç›‘æ§é…ç½®)
    - [ç³»ç»ŸæŒ‡æ ‡æ”¶é›†](#ç³»ç»ŸæŒ‡æ ‡æ”¶é›†)
  - [ğŸ”§ é«˜çº§ç›‘æ§åŠŸèƒ½](#-é«˜çº§ç›‘æ§åŠŸèƒ½)
    - [è‡ªå®šä¹‰æŒ‡æ ‡](#è‡ªå®šä¹‰æŒ‡æ ‡)
    - [åˆ†å¸ƒå¼è¿½è¸ªç›‘æ§](#åˆ†å¸ƒå¼è¿½è¸ªç›‘æ§)
  - [ğŸš¨ å‘Šè­¦é…ç½®](#-å‘Šè­¦é…ç½®)
    - [å‘Šè­¦è§„åˆ™é…ç½®](#å‘Šè­¦è§„åˆ™é…ç½®)
    - [å‘Šè­¦å¤„ç†](#å‘Šè­¦å¤„ç†)
  - [ğŸ“Š ä»ªè¡¨æ¿é…ç½®](#-ä»ªè¡¨æ¿é…ç½®)
    - [Grafana ä»ªè¡¨æ¿](#grafana-ä»ªè¡¨æ¿)
    - [è‡ªå®šä¹‰ä»ªè¡¨æ¿](#è‡ªå®šä¹‰ä»ªè¡¨æ¿)
  - [âš¡ æ€§èƒ½ç›‘æ§](#-æ€§èƒ½ç›‘æ§)
    - [æ€§èƒ½æŒ‡æ ‡æ”¶é›†](#æ€§èƒ½æŒ‡æ ‡æ”¶é›†)
    - [æ€§èƒ½åˆ†æ](#æ€§èƒ½åˆ†æ)
  - [ğŸ“ æ—¥å¿—ç›‘æ§](#-æ—¥å¿—ç›‘æ§)
    - [æ—¥å¿—èšåˆå’Œæœç´¢](#æ—¥å¿—èšåˆå’Œæœç´¢)
    - [æ—¥å¿—æ¨¡å¼æ£€æµ‹](#æ—¥å¿—æ¨¡å¼æ£€æµ‹)
  - [ğŸ› ï¸ è‡ªå®šä¹‰ç›‘æ§](#ï¸-è‡ªå®šä¹‰ç›‘æ§)
    - [è‡ªå®šä¹‰æŒ‡æ ‡æ”¶é›†å™¨](#è‡ªå®šä¹‰æŒ‡æ ‡æ”¶é›†å™¨)
    - [è‡ªå®šä¹‰å‘Šè­¦è§„åˆ™](#è‡ªå®šä¹‰å‘Šè­¦è§„åˆ™)
  - [ğŸ¯ ç›‘æ§æœ€ä½³å®è·µ](#-ç›‘æ§æœ€ä½³å®è·µ)
    - [ç›‘æ§ç­–ç•¥](#ç›‘æ§ç­–ç•¥)
    - [ç›‘æ§é…ç½®æ¨¡æ¿](#ç›‘æ§é…ç½®æ¨¡æ¿)
    - [ç›‘æ§æ£€æŸ¥æ¸…å•](#ç›‘æ§æ£€æŸ¥æ¸…å•)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
    - [ç›‘æ§å·¥å…·](#ç›‘æ§å·¥å…·)
    - [ç›¸å…³æ–‡æ¡£](#ç›¸å…³æ–‡æ¡£)

---

## ğŸ¯ ç›‘æ§æ¦‚è§ˆ

### ç›‘æ§ç›®æ ‡

| ç›‘æ§ç±»å‹ | ç›®æ ‡ | å…³é”®æŒ‡æ ‡ |
|----------|------|----------|
| **ç³»ç»Ÿç›‘æ§** | ç³»ç»Ÿå¥åº·çŠ¶æ€ | CPUã€å†…å­˜ã€ç£ç›˜ã€ç½‘ç»œ |
| **åº”ç”¨ç›‘æ§** | åº”ç”¨æ€§èƒ½ | å“åº”æ—¶é—´ã€ååé‡ã€é”™è¯¯ç‡ |
| **ä¸šåŠ¡ç›‘æ§** | ä¸šåŠ¡æŒ‡æ ‡ | ç”¨æˆ·æ´»è·ƒåº¦ã€äº¤æ˜“é‡ã€è½¬åŒ–ç‡ |
| **åŸºç¡€è®¾æ–½ç›‘æ§** | åŸºç¡€è®¾æ–½çŠ¶æ€ | æœåŠ¡å¯ç”¨æ€§ã€èµ„æºä½¿ç”¨ç‡ |

### ç›‘æ§æ¶æ„

```mermaid
graph TB
    A[åº”ç”¨] --> B[OTLP å®¢æˆ·ç«¯]
    B --> C[OpenTelemetry Collector]
    C --> D[ç›‘æ§åç«¯]
    D --> E[å‘Šè­¦ç³»ç»Ÿ]
    D --> F[ä»ªè¡¨æ¿]
    D --> G[æ—¥å¿—ç³»ç»Ÿ]
```

---

## âš™ï¸ åŸºç¡€ç›‘æ§é…ç½®

### å®¢æˆ·ç«¯ç›‘æ§é…ç½®

```rust
use otlp::core::EnhancedOtlpClient;
use otlp::config::*;
use std::time::Duration;

// åŸºç¡€ç›‘æ§é…ç½®
let client = EnhancedOtlpClient::builder()
    .with_endpoint("http://localhost:4317")
    .with_service_name("monitored-app")
    .with_service_version("1.0.0")
    
    // å¯ç”¨ç›‘æ§
    .with_monitoring_enabled(true)
    .with_metrics_interval(Duration::from_secs(10))
    .with_health_check_interval(Duration::from_secs(30))
    
    // ç›‘æ§é…ç½®
    .with_monitoring_config(MonitoringConfig {
        enable_performance_metrics: true,
        enable_resource_metrics: true,
        enable_custom_metrics: true,
        metrics_export_interval: Duration::from_secs(10),
        health_check_endpoint: Some("http://localhost:8080/health".to_string()),
    })
    
    .build()
    .await?;
```

### ç³»ç»ŸæŒ‡æ ‡æ”¶é›†

```rust
use otlp::monitoring::SystemMetricsCollector;

// ç³»ç»ŸæŒ‡æ ‡æ”¶é›†å™¨
let system_collector = SystemMetricsCollector::new()
    .with_cpu_monitoring(true)
    .with_memory_monitoring(true)
    .with_disk_monitoring(true)
    .with_network_monitoring(true)
    .with_collection_interval(Duration::from_secs(5));

let client = EnhancedOtlpClient::builder()
    .with_endpoint("http://localhost:4317")
    .with_system_metrics_collector(system_collector)
    .build()
    .await?;

// è·å–ç³»ç»ŸæŒ‡æ ‡
async fn get_system_metrics() -> Result<(), Box<dyn std::error::Error>> {
    let metrics = client.get_system_metrics().await?;
    
    println!("CPU ä½¿ç”¨ç‡: {:.2}%", metrics.cpu_usage * 100.0);
    println!("å†…å­˜ä½¿ç”¨ç‡: {:.2}%", metrics.memory_usage * 100.0);
    println!("ç£ç›˜ä½¿ç”¨ç‡: {:.2}%", metrics.disk_usage * 100.0);
    println!("ç½‘ç»œååé‡: {:.2} MB/s", metrics.network_throughput);
    
    Ok(())
}
```

---

## ğŸ”§ é«˜çº§ç›‘æ§åŠŸèƒ½

### è‡ªå®šä¹‰æŒ‡æ ‡

```rust
use otlp::monitoring::CustomMetricsCollector;
use opentelemetry::metrics::{Meter, Counter, Histogram, Unit};
use std::collections::HashMap;

// è‡ªå®šä¹‰æŒ‡æ ‡æ”¶é›†å™¨
let custom_collector = CustomMetricsCollector::new()
    .with_business_metrics(true)
    .with_user_metrics(true)
    .with_transaction_metrics(true);

let client = EnhancedOtlpClient::builder()
    .with_endpoint("http://localhost:4317")
    .with_custom_metrics_collector(custom_collector)
    .build()
    .await?;

let meter = client.meter("business-metrics");

// ä¸šåŠ¡æŒ‡æ ‡
let user_registrations = meter
    .u64_counter("user_registrations_total")
    .with_description("Total user registrations")
    .with_unit(Unit::new("1"))
    .init();

let transaction_amount = meter
    .f64_histogram("transaction_amount")
    .with_description("Transaction amount distribution")
    .with_unit(Unit::new("USD"))
    .init();

// è®°å½•ä¸šåŠ¡æŒ‡æ ‡
async fn record_business_metrics() -> Result<(), Box<dyn std::error::Error>> {
    let mut attributes = HashMap::new();
    attributes.insert("source".to_string(), "web".into());
    attributes.insert("country".to_string(), "US".into());
    
    // è®°å½•ç”¨æˆ·æ³¨å†Œ
    user_registrations.add(1, &attributes);
    
    // è®°å½•äº¤æ˜“é‡‘é¢
    let amount = 150.0;
    transaction_amount.record(amount, &attributes);
    
    Ok(())
}
```

### åˆ†å¸ƒå¼è¿½è¸ªç›‘æ§

```rust
use otlp::monitoring::TraceMonitor;
use opentelemetry::trace::{Tracer, SpanKind, StatusCode};

// è¿½è¸ªç›‘æ§å™¨
let trace_monitor = TraceMonitor::new()
    .with_slow_query_threshold(Duration::from_millis(1000))
    .with_error_tracking(true)
    .with_performance_tracking(true);

let client = EnhancedOtlpClient::builder()
    .with_endpoint("http://localhost:4317")
    .with_trace_monitor(trace_monitor)
    .build()
    .await?;

let tracer = client.tracer("monitored-component");

// ç›‘æ§è¿½è¸ª
async fn monitored_operation() -> Result<(), Box<dyn std::error::Error>> {
    let mut span = tracer.start_with_kind("monitored-operation", SpanKind::Internal);
    
    span.set_attribute("operation.type", "business_logic");
    span.set_attribute("user.id", "12345");
    
    // æ‰§è¡Œä¸šåŠ¡é€»è¾‘
    let result = execute_business_logic().await;
    
    match result {
        Ok(_) => {
            span.set_status(StatusCode::Ok, "Operation successful".to_string());
            println!("âœ… æ“ä½œæˆåŠŸå®Œæˆ");
        }
        Err(e) => {
            span.set_status(StatusCode::Error, e.to_string());
            span.set_attribute("error.type", "business_error");
            println!("âŒ æ“ä½œå¤±è´¥: {}", e);
        }
    }
    
    span.end();
    Ok(())
}
```

---

## ğŸš¨ å‘Šè­¦é…ç½®

### å‘Šè­¦è§„åˆ™é…ç½®

```rust
use otlp::monitoring::AlertManager;
use otlp::config::AlertRule;

// å‘Šè­¦ç®¡ç†å™¨
let alert_manager = AlertManager::new()
    .with_alert_endpoint("http://localhost:9093/api/v1/alerts")
    .with_notification_channels(vec![
        "email:admin@example.com".to_string(),
        "slack:#alerts".to_string(),
        "webhook:https://hooks.slack.com/services/...".to_string(),
    ]);

// å‘Šè­¦è§„åˆ™
let alert_rules = vec![
    AlertRule {
        name: "high_error_rate".to_string(),
        condition: "error_rate > 0.05".to_string(), // 5% é”™è¯¯ç‡
        duration: Duration::from_secs(300), // æŒç»­5åˆ†é’Ÿ
        severity: AlertSeverity::Critical,
        description: "Error rate is too high".to_string(),
    },
    AlertRule {
        name: "high_response_time".to_string(),
        condition: "response_time_p99 > 1000".to_string(), // P99 > 1ç§’
        duration: Duration::from_secs(600), // æŒç»­10åˆ†é’Ÿ
        severity: AlertSeverity::Warning,
        description: "Response time is too high".to_string(),
    },
    AlertRule {
        name: "low_throughput".to_string(),
        condition: "throughput < 100".to_string(), // ååé‡ < 100 req/s
        duration: Duration::from_secs(900), // æŒç»­15åˆ†é’Ÿ
        severity: AlertSeverity::Warning,
        description: "Throughput is too low".to_string(),
    },
];

let client = EnhancedOtlpClient::builder()
    .with_endpoint("http://localhost:4317")
    .with_alert_manager(alert_manager)
    .with_alert_rules(alert_rules)
    .build()
    .await?;
```

### å‘Šè­¦å¤„ç†

```rust
use otlp::monitoring::AlertHandler;

// å‘Šè­¦å¤„ç†å™¨
let alert_handler = AlertHandler::new()
    .with_escalation_policy(EscalationPolicy {
        levels: vec![
            EscalationLevel {
                duration: Duration::from_secs(300),
                notifications: vec!["email:oncall@example.com".to_string()],
            },
            EscalationLevel {
                duration: Duration::from_secs(600),
                notifications: vec![
                    "email:manager@example.com".to_string(),
                    "slack:#critical-alerts".to_string(),
                ],
            },
        ],
    })
    .with_suppression_rules(vec![
        SuppressionRule {
            condition: "time.hour >= 22 || time.hour <= 6".to_string(),
            action: SuppressionAction::Delay,
            duration: Duration::from_hours(8),
        },
    ]);

// å¤„ç†å‘Šè­¦
async fn handle_alert(alert: Alert) -> Result<(), Box<dyn std::error::Error>> {
    println!("ğŸš¨ æ”¶åˆ°å‘Šè­¦: {}", alert.name);
    println!("ä¸¥é‡ç¨‹åº¦: {:?}", alert.severity);
    println!("æè¿°: {}", alert.description);
    println!("æ—¶é—´: {}", alert.timestamp);
    
    // å‘é€é€šçŸ¥
    alert_handler.send_notification(&alert).await?;
    
    // è®°å½•å‘Šè­¦
    alert_handler.log_alert(&alert).await?;
    
    Ok(())
}
```

---

## ğŸ“Š ä»ªè¡¨æ¿é…ç½®

### Grafana ä»ªè¡¨æ¿

```rust
use otlp::monitoring::DashboardManager;

// ä»ªè¡¨æ¿ç®¡ç†å™¨
let dashboard_manager = DashboardManager::new()
    .with_grafana_endpoint("http://localhost:3000")
    .with_api_key("your-grafana-api-key");

// åˆ›å»ºä»ªè¡¨æ¿
async fn create_dashboard() -> Result<(), Box<dyn std::error::Error>> {
    let dashboard = Dashboard {
        title: "OTLP Application Monitoring".to_string(),
        panels: vec![
            Panel {
                title: "Request Rate".to_string(),
                query: "rate(requests_total[5m])".to_string(),
                visualization: Visualization::Graph,
                y_axis: YAxis {
                    label: "Requests/sec".to_string(),
                    min: Some(0.0),
                    max: None,
                },
            },
            Panel {
                title: "Response Time".to_string(),
                query: "histogram_quantile(0.99, rate(response_time_seconds_bucket[5m]))".to_string(),
                visualization: Visualization::Graph,
                y_axis: YAxis {
                    label: "Seconds".to_string(),
                    min: Some(0.0),
                    max: Some(5.0),
                },
            },
            Panel {
                title: "Error Rate".to_string(),
                query: "rate(errors_total[5m]) / rate(requests_total[5m])".to_string(),
                visualization: Visualization::Graph,
                y_axis: YAxis {
                    label: "Error Rate".to_string(),
                    min: Some(0.0),
                    max: Some(1.0),
                },
            },
            Panel {
                title: "System Resources".to_string(),
                query: "cpu_usage_percent".to_string(),
                visualization: Visualization::Graph,
                y_axis: YAxis {
                    label: "Percentage".to_string(),
                    min: Some(0.0),
                    max: Some(100.0),
                },
            },
        ],
    };
    
    dashboard_manager.create_dashboard(&dashboard).await?;
    println!("âœ… ä»ªè¡¨æ¿åˆ›å»ºæˆåŠŸ");
    
    Ok(())
}
```

### è‡ªå®šä¹‰ä»ªè¡¨æ¿

```rust
use otlp::monitoring::CustomDashboard;

// è‡ªå®šä¹‰ä»ªè¡¨æ¿
let custom_dashboard = CustomDashboard::new()
    .with_title("Business Metrics Dashboard")
    .with_refresh_interval(Duration::from_secs(30))
    .with_time_range(Duration::from_hours(24));

// æ·»åŠ ä¸šåŠ¡æŒ‡æ ‡é¢æ¿
custom_dashboard.add_panel(Panel {
    title: "User Registrations".to_string(),
    query: "rate(user_registrations_total[1h])".to_string(),
    visualization: Visualization::Counter,
    thresholds: vec![
        Threshold {
            value: 10.0,
            color: "green".to_string(),
        },
        Threshold {
            value: 5.0,
            color: "yellow".to_string(),
        },
        Threshold {
            value: 1.0,
            color: "red".to_string(),
        },
    ],
});

// æ·»åŠ äº¤æ˜“æŒ‡æ ‡é¢æ¿
custom_dashboard.add_panel(Panel {
    title: "Transaction Volume".to_string(),
    query: "sum(transaction_amount)".to_string(),
    visualization: Visualization::Graph,
    y_axis: YAxis {
        label: "USD".to_string(),
        min: Some(0.0),
        max: None,
    },
});

// éƒ¨ç½²ä»ªè¡¨æ¿
custom_dashboard.deploy().await?;
```

---

## âš¡ æ€§èƒ½ç›‘æ§

### æ€§èƒ½æŒ‡æ ‡æ”¶é›†

```rust
use otlp::monitoring::PerformanceMonitor;

// æ€§èƒ½ç›‘æ§å™¨
let performance_monitor = PerformanceMonitor::new()
    .with_throughput_monitoring(true)
    .with_latency_monitoring(true)
    .with_resource_monitoring(true)
    .with_collection_interval(Duration::from_secs(5));

let client = EnhancedOtlpClient::builder()
    .with_endpoint("http://localhost:4317")
    .with_performance_monitor(performance_monitor)
    .build()
    .await?;

// æ€§èƒ½æŒ‡æ ‡
async fn collect_performance_metrics() -> Result<(), Box<dyn std::error::Error>> {
    let metrics = client.get_performance_metrics().await?;
    
    println!("ğŸ“Š æ€§èƒ½æŒ‡æ ‡:");
    println!("  ååé‡: {:.2} req/s", metrics.throughput);
    println!("  å¹³å‡å»¶è¿Ÿ: {:.2}ms", metrics.avg_latency.as_millis());
    println!("  P95å»¶è¿Ÿ: {:.2}ms", metrics.p95_latency.as_millis());
    println!("  P99å»¶è¿Ÿ: {:.2}ms", metrics.p99_latency.as_millis());
    println!("  é”™è¯¯ç‡: {:.2}%", metrics.error_rate * 100.0);
    
    // æ£€æŸ¥æ€§èƒ½é˜ˆå€¼
    if metrics.error_rate > 0.05 {
        println!("âš ï¸ é”™è¯¯ç‡è¿‡é«˜: {:.2}%", metrics.error_rate * 100.0);
    }
    
    if metrics.p99_latency > Duration::from_millis(1000) {
        println!("âš ï¸ P99å»¶è¿Ÿè¿‡é«˜: {:.2}ms", metrics.p99_latency.as_millis());
    }
    
    Ok(())
}
```

### æ€§èƒ½åˆ†æ

```rust
use otlp::monitoring::PerformanceAnalyzer;

// æ€§èƒ½åˆ†æå™¨
let performance_analyzer = PerformanceAnalyzer::new()
    .with_trend_analysis(true)
    .with_anomaly_detection(true)
    .with_capacity_planning(true);

// åˆ†ææ€§èƒ½è¶‹åŠ¿
async fn analyze_performance_trends() -> Result<(), Box<dyn std::error::Error>> {
    let analysis = performance_analyzer.analyze_trends().await?;
    
    println!("ğŸ“ˆ æ€§èƒ½è¶‹åŠ¿åˆ†æ:");
    println!("  ååé‡è¶‹åŠ¿: {:?}", analysis.throughput_trend);
    println!("  å»¶è¿Ÿè¶‹åŠ¿: {:?}", analysis.latency_trend);
    println!("  é”™è¯¯ç‡è¶‹åŠ¿: {:?}", analysis.error_rate_trend);
    
    // å®¹é‡è§„åˆ’å»ºè®®
    if let Some(capacity_advice) = analysis.capacity_advice {
        println!("ğŸ’¡ å®¹é‡è§„åˆ’å»ºè®®:");
        println!("  {}", capacity_advice);
    }
    
    // å¼‚å¸¸æ£€æµ‹
    if let Some(anomalies) = analysis.anomalies {
        println!("ğŸš¨ æ£€æµ‹åˆ°å¼‚å¸¸:");
        for anomaly in anomalies {
            println!("  - {}: {}", anomaly.metric, anomaly.description);
        }
    }
    
    Ok(())
}
```

---

## ğŸ“ æ—¥å¿—ç›‘æ§

### æ—¥å¿—èšåˆå’Œæœç´¢

```rust
use otlp::monitoring::LogMonitor;

// æ—¥å¿—ç›‘æ§å™¨
let log_monitor = LogMonitor::new()
    .with_log_levels(vec![LogLevel::Error, LogLevel::Warn, LogLevel::Info])
    .with_keyword_filtering(true)
    .with_pattern_detection(true);

let client = EnhancedOtlpClient::builder()
    .with_endpoint("http://localhost:4317")
    .with_log_monitor(log_monitor)
    .build()
    .await?;

// æ—¥å¿—æœç´¢
async fn search_logs() -> Result<(), Box<dyn std::error::Error>> {
    let search_query = LogSearchQuery {
        query: "error".to_string(),
        time_range: TimeRange {
            start: chrono::Utc::now() - chrono::Duration::hours(1),
            end: chrono::Utc::now(),
        },
        log_levels: vec![LogLevel::Error, LogLevel::Warn],
        limit: 100,
    };
    
    let logs = client.search_logs(&search_query).await?;
    
    println!("ğŸ” æ‰¾åˆ° {} æ¡ç›¸å…³æ—¥å¿—", logs.len());
    for log in logs {
        println!("[{}] {}: {}", 
                log.timestamp, 
                log.level, 
                log.message);
    }
    
    Ok(())
}
```

### æ—¥å¿—æ¨¡å¼æ£€æµ‹

```rust
use otlp::monitoring::LogPatternDetector;

// æ—¥å¿—æ¨¡å¼æ£€æµ‹å™¨
let pattern_detector = LogPatternDetector::new()
    .with_frequency_analysis(true)
    .with_anomaly_detection(true)
    .with_clustering(true);

// æ£€æµ‹æ—¥å¿—æ¨¡å¼
async fn detect_log_patterns() -> Result<(), Box<dyn std::error::Error>> {
    let patterns = pattern_detector.detect_patterns().await?;
    
    println!("ğŸ” æ£€æµ‹åˆ°çš„æ—¥å¿—æ¨¡å¼:");
    for pattern in patterns {
        println!("  æ¨¡å¼: {}", pattern.pattern);
        println!("  é¢‘ç‡: {}", pattern.frequency);
        println!("  ç¤ºä¾‹: {}", pattern.example);
        println!("  ---");
    }
    
    // å¼‚å¸¸æ—¥å¿—æ£€æµ‹
    let anomalies = pattern_detector.detect_anomalies().await?;
    if !anomalies.is_empty() {
        println!("ğŸš¨ æ£€æµ‹åˆ°å¼‚å¸¸æ—¥å¿—:");
        for anomaly in anomalies {
            println!("  - {}", anomaly.description);
        }
    }
    
    Ok(())
}
```

---

## ğŸ› ï¸ è‡ªå®šä¹‰ç›‘æ§

### è‡ªå®šä¹‰æŒ‡æ ‡æ”¶é›†å™¨

```rust
use otlp::monitoring::{CustomMetricsCollector, MetricCollector};

// è‡ªå®šä¹‰æŒ‡æ ‡æ”¶é›†å™¨
struct BusinessMetricsCollector {
    user_count: AtomicU64,
    transaction_count: AtomicU64,
    revenue: AtomicU64,
}

impl MetricCollector for BusinessMetricsCollector {
    async fn collect(&self) -> Result<Vec<Metric>, Box<dyn std::error::Error>> {
        let mut metrics = Vec::new();
        
        // ç”¨æˆ·æ•°é‡æŒ‡æ ‡
        metrics.push(Metric {
            name: "business_users_total".to_string(),
            value: MetricValue::Counter(self.user_count.load(Ordering::Relaxed)),
            labels: vec![("source".to_string(), "business".to_string())],
            timestamp: chrono::Utc::now(),
        });
        
        // äº¤æ˜“æ•°é‡æŒ‡æ ‡
        metrics.push(Metric {
            name: "business_transactions_total".to_string(),
            value: MetricValue::Counter(self.transaction_count.load(Ordering::Relaxed)),
            labels: vec![("type".to_string(), "payment".to_string())],
            timestamp: chrono::Utc::now(),
        });
        
        // æ”¶å…¥æŒ‡æ ‡
        metrics.push(Metric {
            name: "business_revenue_total".to_string(),
            value: MetricValue::Counter(self.revenue.load(Ordering::Relaxed)),
            labels: vec![("currency".to_string(), "USD".to_string())],
            timestamp: chrono::Utc::now(),
        });
        
        Ok(metrics)
    }
}

// ä½¿ç”¨è‡ªå®šä¹‰æ”¶é›†å™¨
let business_collector = BusinessMetricsCollector {
    user_count: AtomicU64::new(0),
    transaction_count: AtomicU64::new(0),
    revenue: AtomicU64::new(0),
};

let client = EnhancedOtlpClient::builder()
    .with_endpoint("http://localhost:4317")
    .with_custom_collector(Box::new(business_collector))
    .build()
    .await?;
```

### è‡ªå®šä¹‰å‘Šè­¦è§„åˆ™

```rust
use otlp::monitoring::CustomAlertRule;

// è‡ªå®šä¹‰å‘Šè­¦è§„åˆ™
struct BusinessAlertRule {
    name: String,
    condition: Box<dyn Fn(&Metrics) -> bool>,
    severity: AlertSeverity,
    description: String,
}

impl AlertRule for BusinessAlertRule {
    fn name(&self) -> &str {
        &self.name
    }
    
    fn check(&self, metrics: &Metrics) -> Option<Alert> {
        if (self.condition)(metrics) {
            Some(Alert {
                name: self.name.clone(),
                severity: self.severity,
                description: self.description.clone(),
                timestamp: chrono::Utc::now(),
                metrics: metrics.clone(),
            })
        } else {
            None
        }
    }
}

// åˆ›å»ºä¸šåŠ¡å‘Šè­¦è§„åˆ™
let business_rules = vec![
    Box::new(BusinessAlertRule {
        name: "low_user_registration".to_string(),
        condition: Box::new(|metrics| {
            metrics.get_counter("user_registrations_total")
                .map(|count| *count < 10)
                .unwrap_or(false)
        }),
        severity: AlertSeverity::Warning,
        description: "User registration rate is too low".to_string(),
    }),
    Box::new(BusinessAlertRule {
        name: "high_transaction_failure".to_string(),
        condition: Box::new(|metrics| {
            let total = metrics.get_counter("transactions_total").unwrap_or(&0);
            let failed = metrics.get_counter("transaction_failures_total").unwrap_or(&0);
            *failed as f64 / *total as f64 > 0.1 // 10% å¤±è´¥ç‡
        }),
        severity: AlertSeverity::Critical,
        description: "Transaction failure rate is too high".to_string(),
    }),
];

let client = EnhancedOtlpClient::builder()
    .with_endpoint("http://localhost:4317")
    .with_custom_alert_rules(business_rules)
    .build()
    .await?;
```

---

## ğŸ¯ ç›‘æ§æœ€ä½³å®è·µ

### ç›‘æ§ç­–ç•¥

```rust
// åˆ†å±‚ç›‘æ§ç­–ç•¥
let monitoring_strategy = MonitoringStrategy {
    // åŸºç¡€è®¾æ–½å±‚
    infrastructure: InfrastructureMonitoring {
        cpu_threshold: 0.8,
        memory_threshold: 0.85,
        disk_threshold: 0.9,
        network_threshold: 0.8,
    },
    
    // åº”ç”¨å±‚
    application: ApplicationMonitoring {
        response_time_threshold: Duration::from_millis(1000),
        error_rate_threshold: 0.05,
        throughput_threshold: 100.0,
    },
    
    // ä¸šåŠ¡å±‚
    business: BusinessMonitoring {
        user_satisfaction_threshold: 0.9,
        conversion_rate_threshold: 0.05,
        revenue_threshold: 10000.0,
    },
};

let client = EnhancedOtlpClient::builder()
    .with_endpoint("http://localhost:4317")
    .with_monitoring_strategy(monitoring_strategy)
    .build()
    .await?;
```

### ç›‘æ§é…ç½®æ¨¡æ¿

```rust
// ç”Ÿäº§ç¯å¢ƒç›‘æ§é…ç½®
fn create_production_monitoring_config() -> MonitoringConfig {
    MonitoringConfig {
        // åŸºç¡€ç›‘æ§
        enable_system_metrics: true,
        enable_application_metrics: true,
        enable_business_metrics: true,
        
        // æ”¶é›†é—´éš”
        system_metrics_interval: Duration::from_secs(30),
        application_metrics_interval: Duration::from_secs(10),
        business_metrics_interval: Duration::from_secs(60),
        
        // å‘Šè­¦é…ç½®
        alert_rules: vec![
            AlertRule {
                name: "critical_error_rate".to_string(),
                condition: "error_rate > 0.1".to_string(),
                duration: Duration::from_secs(300),
                severity: AlertSeverity::Critical,
            },
            AlertRule {
                name: "high_response_time".to_string(),
                condition: "response_time_p99 > 2000".to_string(),
                duration: Duration::from_secs(600),
                severity: AlertSeverity::Warning,
            },
        ],
        
        // ä»ªè¡¨æ¿é…ç½®
        dashboard_config: DashboardConfig {
            auto_refresh: true,
            refresh_interval: Duration::from_secs(30),
            time_range: Duration::from_hours(24),
        },
        
        // æ—¥å¿—é…ç½®
        log_config: LogConfig {
            enable_structured_logging: true,
            log_level: LogLevel::Info,
            enable_log_aggregation: true,
        },
    }
}
```

### ç›‘æ§æ£€æŸ¥æ¸…å•

- [ ] **ç³»ç»Ÿç›‘æ§**: CPUã€å†…å­˜ã€ç£ç›˜ã€ç½‘ç»œç›‘æ§
- [ ] **åº”ç”¨ç›‘æ§**: å“åº”æ—¶é—´ã€ååé‡ã€é”™è¯¯ç‡
- [ ] **ä¸šåŠ¡ç›‘æ§**: å…³é”®ä¸šåŠ¡æŒ‡æ ‡
- [ ] **å‘Šè­¦é…ç½®**: åˆç†çš„å‘Šè­¦é˜ˆå€¼å’Œé€šçŸ¥
- [ ] **ä»ªè¡¨æ¿**: ç›´è§‚çš„å¯è§†åŒ–ç•Œé¢
- [ ] **æ—¥å¿—ç›‘æ§**: æ—¥å¿—èšåˆå’Œæœç´¢
- [ ] **æ€§èƒ½ç›‘æ§**: æ€§èƒ½è¶‹åŠ¿å’Œå¼‚å¸¸æ£€æµ‹
- [ ] **è‡ªå®šä¹‰ç›‘æ§**: ç‰¹å®šä¸šåŠ¡éœ€æ±‚

---

## ğŸ“š å‚è€ƒèµ„æº

### ç›‘æ§å·¥å…·

- ğŸ“Š [Grafana](https://grafana.com/) - ä»ªè¡¨æ¿å’Œå¯è§†åŒ–
- ğŸš¨ [Prometheus](https://prometheus.io/) - æŒ‡æ ‡æ”¶é›†å’Œå‘Šè­¦
- ğŸ“ [ELK Stack](https://www.elastic.co/elk-stack) - æ—¥å¿—èšåˆå’Œåˆ†æ
- ğŸ” [Jaeger](https://www.jaegertracing.io/) - åˆ†å¸ƒå¼è¿½è¸ª

### ç›¸å…³æ–‡æ¡£

- ğŸ“– [æ€§èƒ½ä¼˜åŒ–æŒ‡å—](performance-optimization.md)
- ğŸš€ [éƒ¨ç½²æŒ‡å—](deployment.md)
- ğŸ”§ [æ•…éšœæ’é™¤](troubleshooting.md)

---

*æœ€åæ›´æ–°: 2025å¹´10æœˆ20æ—¥*  
*ç‰ˆæœ¬: 1.0.0*
