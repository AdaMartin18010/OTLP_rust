# ğŸš€ æ€§èƒ½ä¼˜åŒ–æŒ‡å—

**ç‰ˆæœ¬**: 1.0
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ26æ—¥
**çŠ¶æ€**: ğŸŸ¢ æ´»è·ƒç»´æŠ¤

> **ç®€ä»‹**: æ€§èƒ½ä¼˜åŒ–æŒ‡å— - å®¢æˆ·ç«¯é…ç½®ã€æ‰¹å¤„ç†ã€å‹ç¼©ã€å¼‚æ­¥ä¼˜åŒ–ç­‰å®Œæ•´æ€§èƒ½è°ƒä¼˜æ–¹æ¡ˆã€‚

---

## ğŸ“‹ ç›®å½•

- [ğŸš€ æ€§èƒ½ä¼˜åŒ–æŒ‡å—](#-æ€§èƒ½ä¼˜åŒ–æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ æ€§èƒ½ä¼˜åŒ–æ¦‚è§ˆ](#-æ€§èƒ½ä¼˜åŒ–æ¦‚è§ˆ)
    - [ä¼˜åŒ–ç›®æ ‡](#ä¼˜åŒ–ç›®æ ‡)
    - [ä¼˜åŒ–ç­–ç•¥](#ä¼˜åŒ–ç­–ç•¥)
  - [âš™ï¸ å®¢æˆ·ç«¯é…ç½®ä¼˜åŒ–](#ï¸-å®¢æˆ·ç«¯é…ç½®ä¼˜åŒ–)
    - [åŸºç¡€é…ç½®ä¼˜åŒ–](#åŸºç¡€é…ç½®ä¼˜åŒ–)
    - [é«˜çº§é…ç½®é€‰é¡¹](#é«˜çº§é…ç½®é€‰é¡¹)
  - [ğŸ“¦ æ‰¹å¤„ç†ä¼˜åŒ–](#-æ‰¹å¤„ç†ä¼˜åŒ–)
    - [æ‰¹å¤„ç†ç­–ç•¥](#æ‰¹å¤„ç†ç­–ç•¥)
    - [åŠ¨æ€æ‰¹å¤„ç†è°ƒæ•´](#åŠ¨æ€æ‰¹å¤„ç†è°ƒæ•´)
    - [æ‰¹å¤„ç†æœ€ä½³å®è·µ](#æ‰¹å¤„ç†æœ€ä½³å®è·µ)
  - [ğŸ”— è¿æ¥æ± ä¼˜åŒ–](#-è¿æ¥æ± ä¼˜åŒ–)
    - [è¿æ¥æ± é…ç½®](#è¿æ¥æ± é…ç½®)
    - [è¿æ¥å¤ç”¨ä¼˜åŒ–](#è¿æ¥å¤ç”¨ä¼˜åŒ–)
  - [ğŸ—œï¸ å‹ç¼©ä¼˜åŒ–](#ï¸-å‹ç¼©ä¼˜åŒ–)
    - [å‹ç¼©ç­–ç•¥é€‰æ‹©](#å‹ç¼©ç­–ç•¥é€‰æ‹©)
    - [è‡ªé€‚åº”å‹ç¼©](#è‡ªé€‚åº”å‹ç¼©)
    - [å‹ç¼©æ€§èƒ½å¯¹æ¯”](#å‹ç¼©æ€§èƒ½å¯¹æ¯”)
  - [ğŸ’¾ å†…å­˜ä¼˜åŒ–](#-å†…å­˜ä¼˜åŒ–)
    - [å†…å­˜æ± é…ç½®](#å†…å­˜æ± é…ç½®)
    - [é›¶æ‹·è´ä¼˜åŒ–](#é›¶æ‹·è´ä¼˜åŒ–)
    - [å†…å­˜ç›‘æ§](#å†…å­˜ç›‘æ§)
  - [ğŸ”„ å¹¶å‘ä¼˜åŒ–](#-å¹¶å‘ä¼˜åŒ–)
    - [å¼‚æ­¥å¹¶å‘](#å¼‚æ­¥å¹¶å‘)
    - [å·¥ä½œæ± æ¨¡å¼](#å·¥ä½œæ± æ¨¡å¼)
    - [èƒŒå‹æ§åˆ¶](#èƒŒå‹æ§åˆ¶)
  - [ğŸ“Š ç›‘æ§å’Œè°ƒä¼˜](#-ç›‘æ§å’Œè°ƒä¼˜)
    - [æ€§èƒ½æŒ‡æ ‡æ”¶é›†](#æ€§èƒ½æŒ‡æ ‡æ”¶é›†)
    - [å®æ—¶è°ƒä¼˜](#å®æ—¶è°ƒä¼˜)
  - [ğŸƒ æ€§èƒ½åŸºå‡†æµ‹è¯•](#-æ€§èƒ½åŸºå‡†æµ‹è¯•)
    - [åŸºå‡†æµ‹è¯•æ¡†æ¶](#åŸºå‡†æµ‹è¯•æ¡†æ¶)
    - [æ€§èƒ½æµ‹è¯•è„šæœ¬](#æ€§èƒ½æµ‹è¯•è„šæœ¬)
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
    - [é…ç½®æœ€ä½³å®è·µ](#é…ç½®æœ€ä½³å®è·µ)
    - [æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥æ¸…å•](#æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥æ¸…å•)
    - [å¸¸è§æ€§èƒ½é—®é¢˜](#å¸¸è§æ€§èƒ½é—®é¢˜)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
    - [æ€§èƒ½ä¼˜åŒ–å·¥å…·](#æ€§èƒ½ä¼˜åŒ–å·¥å…·)
    - [ç›¸å…³æ–‡æ¡£](#ç›¸å…³æ–‡æ¡£)

---

## ğŸ¯ æ€§èƒ½ä¼˜åŒ–æ¦‚è§ˆ

### ä¼˜åŒ–ç›®æ ‡

| æŒ‡æ ‡ | ç›®æ ‡å€¼ | è¯´æ˜ |
|------|--------|------|
| **ååé‡** | > 10,000 spans/s | æ¯ç§’å¤„ç†çš„ Span æ•°é‡ |
| **å»¶è¿Ÿ** | < 100ms P99 | 99% è¯·æ±‚çš„å»¶è¿Ÿ |
| **å†…å­˜ä½¿ç”¨** | < 500MB | å®¢æˆ·ç«¯å†…å­˜å ç”¨ |
| **CPU ä½¿ç”¨** | < 50% | å•æ ¸ CPU ä½¿ç”¨ç‡ |
| **ç½‘ç»œæ•ˆç‡** | > 80% | æœ‰æ•ˆæ•°æ®ä¼ è¾“æ¯”ä¾‹ |

### ä¼˜åŒ–ç­–ç•¥

1. **æ‰¹å¤„ç†ä¼˜åŒ–**: å‡å°‘ç½‘ç»œè¯·æ±‚æ¬¡æ•°
2. **è¿æ¥å¤ç”¨**: é™ä½è¿æ¥å»ºç«‹å¼€é”€
3. **å‹ç¼©ä¼ è¾“**: å‡å°‘ç½‘ç»œå¸¦å®½ä½¿ç”¨
4. **å†…å­˜ç®¡ç†**: ä¼˜åŒ–å†…å­˜åˆ†é…å’Œå›æ”¶
5. **å¹¶å‘æ§åˆ¶**: åˆç†ä½¿ç”¨å¼‚æ­¥å’Œå¹¶å‘

---

## âš™ï¸ å®¢æˆ·ç«¯é…ç½®ä¼˜åŒ–

### åŸºç¡€é…ç½®ä¼˜åŒ–

```rust
use otlp::core::EnhancedOtlpClient;
use otlp::config::*;
use std::time::Duration;

// é«˜æ€§èƒ½é…ç½®
let client = EnhancedOtlpClient::builder()
    .with_endpoint("http://localhost:4317")
    .with_service_name("high-performance-app")

    // è¿æ¥ä¼˜åŒ–
    .with_connect_timeout(Duration::from_secs(5))
    .with_request_timeout(Duration::from_secs(30))
    .with_keep_alive_timeout(Duration::from_secs(60))
    .with_max_idle_connections(100)

    // ä¼ è¾“ä¼˜åŒ–
    .with_grpc_transport() // gRPC æ¯” HTTP æ›´é«˜æ•ˆ
    .with_compression(Compression::Gzip) // å¯ç”¨å‹ç¼©

    // é‡è¯•ä¼˜åŒ–
    .with_retry_config(RetryConfig {
        max_attempts: 3,
        initial_interval: Duration::from_millis(100),
        max_interval: Duration::from_secs(5),
        multiplier: 2.0,
        randomization_factor: 0.1,
        retryable_errors: vec![ErrorType::Network, ErrorType::Timeout],
    })

    .build()
    .await?;
```

### é«˜çº§é…ç½®é€‰é¡¹

```rust
// è‡ªå®šä¹‰é…ç½®
let custom_config = OtlpConfig {
    // æ‰¹å¤„ç†é…ç½®
    batch: BatchConfig {
        max_batch_size: 2000,        // å¢å¤§æ‰¹æ¬¡å¤§å°
        batch_timeout: Duration::from_millis(100), // å‡å°‘ç­‰å¾…æ—¶é—´
        max_queue_size: 50000,       // å¢å¤§é˜Ÿåˆ—å®¹é‡
        strategy: BatchStrategy::Hybrid, // æ··åˆç­–ç•¥
    },

    // è¿æ¥æ± é…ç½®
    connection_pool: ConnectionPoolConfig {
        max_connections: 200,        // æœ€å¤§è¿æ¥æ•°
        min_connections: 10,         // æœ€å°è¿æ¥æ•°
        connection_timeout: Duration::from_secs(10),
        idle_timeout: Duration::from_secs(300),
        keep_alive: true,
    },

    // æ€§èƒ½é…ç½®
    performance: PerformanceConfig {
        enable_zero_copy: true,      // é›¶æ‹·è´ä¼˜åŒ–
        enable_memory_pool: true,    // å†…å­˜æ± 
        max_memory_usage: 1024 * 1024 * 1024, // 1GB
        gc_threshold: 0.8,           // GC é˜ˆå€¼
    },

    // ç›‘æ§é…ç½®
    monitoring: MonitoringConfig {
        enable_metrics: true,
        metrics_interval: Duration::from_secs(10),
        enable_tracing: true,
        log_level: LogLevel::Info,
    },
};

let client = EnhancedOtlpClient::with_config(custom_config).await?;
```

---

## ğŸ“¦ æ‰¹å¤„ç†ä¼˜åŒ–

### æ‰¹å¤„ç†ç­–ç•¥

```rust
use otlp::config::BatchStrategy;

// 1. æ—¶é—´ä¼˜å…ˆç­–ç•¥ - é€‚åˆä½å»¶è¿Ÿåœºæ™¯
let time_first_config = BatchConfig {
    max_batch_size: 100,
    batch_timeout: Duration::from_millis(50),
    strategy: BatchStrategy::TimeFirst,
};

// 2. å¤§å°ä¼˜å…ˆç­–ç•¥ - é€‚åˆé«˜åååœºæ™¯
let size_first_config = BatchConfig {
    max_batch_size: 2000,
    batch_timeout: Duration::from_secs(5),
    strategy: BatchStrategy::SizeFirst,
};

// 3. æ··åˆç­–ç•¥ - å¹³è¡¡å»¶è¿Ÿå’Œåå
let hybrid_config = BatchConfig {
    max_batch_size: 1000,
    batch_timeout: Duration::from_millis(200),
    strategy: BatchStrategy::Hybrid,
};
```

### åŠ¨æ€æ‰¹å¤„ç†è°ƒæ•´

```rust
use otlp::core::BatchManager;

// åˆ›å»ºæ‰¹å¤„ç†ç®¡ç†å™¨
let mut batch_manager = BatchManager::new()
    .with_initial_config(hybrid_config)
    .with_adaptive_adjustment(true)
    .with_performance_targets(PerformanceTargets {
        target_latency: Duration::from_millis(100),
        target_throughput: 10000,
        max_memory_usage: 500 * 1024 * 1024, // 500MB
    });

// æ ¹æ®æ€§èƒ½æŒ‡æ ‡åŠ¨æ€è°ƒæ•´
batch_manager.adjust_batch_size_based_on_performance(&metrics).await?;
```

### æ‰¹å¤„ç†æœ€ä½³å®è·µ

```rust
// 1. æ ¹æ®è´Ÿè½½è°ƒæ•´æ‰¹æ¬¡å¤§å°
fn calculate_optimal_batch_size(current_load: f64) -> usize {
    match current_load {
        load if load < 0.3 => 500,   // ä½è´Ÿè½½ï¼Œå°æ‰¹æ¬¡
        load if load < 0.7 => 1000,  // ä¸­ç­‰è´Ÿè½½ï¼Œä¸­ç­‰æ‰¹æ¬¡
        _ => 2000,                   // é«˜è´Ÿè½½ï¼Œå¤§æ‰¹æ¬¡
    }
}

// 2. æ™ºèƒ½æ‰¹å¤„ç†
async fn smart_batching_example() -> Result<(), Box<dyn std::error::Error>> {
    let client = EnhancedOtlpClient::builder()
        .with_endpoint("http://localhost:4317")
        .with_service_name("smart-batching")
        .with_batch_config(BatchConfig {
            max_batch_size: 1000,
            batch_timeout: Duration::from_millis(100),
            strategy: BatchStrategy::Hybrid,
            adaptive_sizing: true,    // å¯ç”¨è‡ªé€‚åº”å¤§å°
            load_balancing: true,     // å¯ç”¨è´Ÿè½½å‡è¡¡
        })
        .build()
        .await?;

    // ç›‘æ§æ‰¹å¤„ç†æ€§èƒ½
    let metrics = client.get_batch_metrics().await?;
    println!("æ‰¹å¤„ç†æ€§èƒ½: {:?}", metrics);

    Ok(())
}
```

---

## ğŸ”— è¿æ¥æ± ä¼˜åŒ–

### è¿æ¥æ± é…ç½®

```rust
use otlp::config::ConnectionPoolConfig;

// é«˜æ€§èƒ½è¿æ¥æ± é…ç½®
let pool_config = ConnectionPoolConfig {
    max_connections: 200,           // æœ€å¤§è¿æ¥æ•°
    min_connections: 20,             // æœ€å°è¿æ¥æ•°
    connection_timeout: Duration::from_secs(5),
    idle_timeout: Duration::from_secs(300),
    keep_alive: true,
    keep_alive_timeout: Duration::from_secs(60),
    max_lifetime: Duration::from_secs(3600),

    // é«˜çº§é€‰é¡¹
    enable_connection_prewarming: true,  // é¢„çƒ­è¿æ¥
    enable_connection_validation: true, // è¿æ¥éªŒè¯
    validation_interval: Duration::from_secs(30),
};

let client = EnhancedOtlpClient::builder()
    .with_endpoint("http://localhost:4317")
    .with_connection_pool_config(pool_config)
    .build()
    .await?;
```

### è¿æ¥å¤ç”¨ä¼˜åŒ–

```rust
use otlp::core::ConnectionManager;

// è¿æ¥ç®¡ç†å™¨
let connection_manager = ConnectionManager::new()
    .with_pool_size(100)
    .with_reuse_strategy(ReuseStrategy::Aggressive) // æ¿€è¿›å¤ç”¨
    .with_health_check_interval(Duration::from_secs(10));

// ä½¿ç”¨è¿æ¥æ± 
async fn optimized_request_example() -> Result<(), Box<dyn std::error::Error>> {
    let client = EnhancedOtlpClient::builder()
        .with_endpoint("http://localhost:4317")
        .with_connection_manager(connection_manager)
        .build()
        .await?;

    // å¹¶å‘è¯·æ±‚ä¼šå¤ç”¨è¿æ¥
    let futures: Vec<_> = (0..100)
        .map(|i| async move {
            let tracer = client.tracer("concurrent-component");
            let mut span = tracer.start("concurrent-operation");
            span.set_attribute("request.id", i);
            span.end();
        })
        .collect();

    futures::future::join_all(futures).await;

    Ok(())
}
```

---

## ğŸ—œï¸ å‹ç¼©ä¼˜åŒ–

### å‹ç¼©ç­–ç•¥é€‰æ‹©

```rust
use otlp::config::Compression;

// 1. Gzip å‹ç¼© - å¹³è¡¡å‹ç¼©ç‡å’Œæ€§èƒ½
let gzip_client = EnhancedOtlpClient::builder()
    .with_endpoint("http://localhost:4317")
    .with_compression(Compression::Gzip)
    .build()
    .await?;

// 2. Brotli å‹ç¼© - æ›´é«˜å‹ç¼©ç‡
let brotli_client = EnhancedOtlpClient::builder()
    .with_endpoint("http://localhost:4317")
    .with_compression(Compression::Brotli)
    .build()
    .await?;

// 3. æ— å‹ç¼© - æœ€ä½å»¶è¿Ÿ
let no_compression_client = EnhancedOtlpClient::builder()
    .with_endpoint("http://localhost:4317")
    .with_compression(Compression::None)
    .build()
    .await?;
```

### è‡ªé€‚åº”å‹ç¼©

```rust
use otlp::core::AdaptiveCompression;

// è‡ªé€‚åº”å‹ç¼©ç­–ç•¥
let adaptive_compression = AdaptiveCompression::new()
    .with_network_condition_threshold(1000) // 1Mbps
    .with_cpu_usage_threshold(0.8)         // 80%
    .with_latency_threshold(Duration::from_millis(200));

let client = EnhancedOtlpClient::builder()
    .with_endpoint("http://localhost:4317")
    .with_adaptive_compression(adaptive_compression)
    .build()
    .await?;
```

### å‹ç¼©æ€§èƒ½å¯¹æ¯”

```rust
// å‹ç¼©æ€§èƒ½æµ‹è¯•
async fn compression_performance_test() -> Result<(), Box<dyn std::error::Error>> {
    let test_data = generate_test_spans(1000);

    // æµ‹è¯•ä¸åŒå‹ç¼©ç®—æ³•
    let compressions = vec![
        Compression::None,
        Compression::Gzip,
        Compression::Brotli,
    ];

    for compression in compressions {
        let start = std::time::Instant::now();

        let client = EnhancedOtlpClient::builder()
            .with_endpoint("http://localhost:4317")
            .with_compression(compression)
            .build()
            .await?;

        client.export_spans(test_data.clone()).await?;

        let duration = start.elapsed();
        println!("å‹ç¼©ç®—æ³•: {:?}, è€—æ—¶: {:?}", compression, duration);
    }

    Ok(())
}
```

---

## ğŸ’¾ å†…å­˜ä¼˜åŒ–

### å†…å­˜æ± é…ç½®

```rust
use otlp::core::MemoryPool;

// å†…å­˜æ± é…ç½®
let memory_pool = MemoryPool::new()
    .with_initial_size(1024 * 1024)      // 1MB åˆå§‹å¤§å°
    .with_max_size(100 * 1024 * 1024)   // 100MB æœ€å¤§å¤§å°
    .with_chunk_size(64 * 1024)         // 64KB å—å¤§å°
    .with_growth_factor(2.0)             // 2å€å¢é•¿
    .with_gc_threshold(0.8);             // 80% è§¦å‘ GC

let client = EnhancedOtlpClient::builder()
    .with_endpoint("http://localhost:4317")
    .with_memory_pool(memory_pool)
    .build()
    .await?;
```

### é›¶æ‹·è´ä¼˜åŒ–

```rust
use otlp::core::ZeroCopyBuffer;

// é›¶æ‹·è´ç¼“å†²åŒº
let zero_copy_buffer = ZeroCopyBuffer::new()
    .with_capacity(1024 * 1024)         // 1MB å®¹é‡
    .with_alignment(64)                  // 64å­—èŠ‚å¯¹é½
    .with_prefetch_size(256 * 1024);    // 256KB é¢„å–

// ä½¿ç”¨é›¶æ‹·è´
async fn zero_copy_example() -> Result<(), Box<dyn std::error::Error>> {
    let client = EnhancedOtlpClient::builder()
        .with_endpoint("http://localhost:4317")
        .with_zero_copy_buffer(zero_copy_buffer)
        .build()
        .await?;

    // é›¶æ‹·è´æ“ä½œ
    let mut buffer = client.get_zero_copy_buffer().await?;
    buffer.write_spans(&spans).await?;
    client.send_buffer(buffer).await?;

    Ok(())
}
```

### å†…å­˜ç›‘æ§

```rust
use otlp::monitoring::MemoryMonitor;

// å†…å­˜ç›‘æ§
let memory_monitor = MemoryMonitor::new()
    .with_monitoring_interval(Duration::from_secs(5))
    .with_thresholds(MemoryThresholds {
        warning: 0.7,    // 70% è­¦å‘Š
        critical: 0.9,   // 90% ä¸¥é‡
    })
    .with_gc_trigger(true);

// ç›‘æ§å†…å­˜ä½¿ç”¨
async fn memory_monitoring_example() -> Result<(), Box<dyn std::error::Error>> {
    let client = EnhancedOtlpClient::builder()
        .with_endpoint("http://localhost:4317")
        .with_memory_monitor(memory_monitor)
        .build()
        .await?;

    // è·å–å†…å­˜ç»Ÿè®¡
    let memory_stats = client.get_memory_stats().await?;
    println!("å†…å­˜ä½¿ç”¨: {:?}", memory_stats);

    Ok(())
}
```

---

## ğŸ”„ å¹¶å‘ä¼˜åŒ–

### å¼‚æ­¥å¹¶å‘

```rust
use tokio::task;
use std::sync::Arc;

// é«˜å¹¶å‘å¤„ç†
async fn high_concurrency_example() -> Result<(), Box<dyn std::error::Error>> {
    let client = Arc::new(
        EnhancedOtlpClient::builder()
            .with_endpoint("http://localhost:4317")
            .with_service_name("high-concurrency")
            .build()
            .await?
    );

    // åˆ›å»ºå¤šä¸ªå¹¶å‘ä»»åŠ¡
    let tasks: Vec<_> = (0..1000)
        .map(|i| {
            let client = Arc::clone(&client);
            task::spawn(async move {
                let tracer = client.tracer("concurrent-component");
                let mut span = tracer.start("concurrent-operation");
                span.set_attribute("task.id", i);

                // æ¨¡æ‹Ÿå·¥ä½œ
                tokio::time::sleep(Duration::from_millis(10)).await;

                span.end();
            })
        })
        .collect();

    // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    futures::future::join_all(tasks).await;

    Ok(())
}
```

### å·¥ä½œæ± æ¨¡å¼

```rust
use otlp::core::WorkerPool;

// å·¥ä½œæ± é…ç½®
let worker_pool = WorkerPool::new()
    .with_worker_count(num_cpus::get())  // CPU æ ¸å¿ƒæ•°
    .with_queue_size(10000)              // é˜Ÿåˆ—å¤§å°
    .with_batch_size(100)                // æ‰¹å¤„ç†å¤§å°
    .with_timeout(Duration::from_secs(30));

let client = EnhancedOtlpClient::builder()
    .with_endpoint("http://localhost:4317")
    .with_worker_pool(worker_pool)
    .build()
    .await?;
```

### èƒŒå‹æ§åˆ¶

```rust
use otlp::core::BackpressureController;

// èƒŒå‹æ§åˆ¶å™¨
let backpressure_controller = BackpressureController::new()
    .with_max_queue_size(50000)         // æœ€å¤§é˜Ÿåˆ—å¤§å°
    .with_queue_threshold(0.8)          // 80% é˜ˆå€¼
    .with_drop_strategy(DropStrategy::OldestFirst) // ä¸¢å¼ƒæœ€è€çš„
    .with_adaptive_throttling(true);    // è‡ªé€‚åº”èŠ‚æµ

let client = EnhancedOtlpClient::builder()
    .with_endpoint("http://localhost:4317")
    .with_backpressure_controller(backpressure_controller)
    .build()
    .await?;
```

---

## ğŸ“Š ç›‘æ§å’Œè°ƒä¼˜

### æ€§èƒ½æŒ‡æ ‡æ”¶é›†

```rust
use otlp::monitoring::PerformanceMonitor;

// æ€§èƒ½ç›‘æ§å™¨
let performance_monitor = PerformanceMonitor::new()
    .with_metrics_interval(Duration::from_secs(10))
    .with_enabled_metrics(vec![
        MetricType::Throughput,
        MetricType::Latency,
        MetricType::MemoryUsage,
        MetricType::CpuUsage,
        MetricType::NetworkUsage,
    ]);

let client = EnhancedOtlpClient::builder()
    .with_endpoint("http://localhost:4317")
    .with_performance_monitor(performance_monitor)
    .build()
    .await?;

// è·å–æ€§èƒ½æŒ‡æ ‡
async fn get_performance_metrics() -> Result<(), Box<dyn std::error::Error>> {
    let metrics = client.get_performance_metrics().await?;

    println!("ååé‡: {:.2} spans/s", metrics.throughput);
    println!("å¹³å‡å»¶è¿Ÿ: {:.2}ms", metrics.avg_latency.as_millis());
    println!("P99å»¶è¿Ÿ: {:.2}ms", metrics.p99_latency.as_millis());
    println!("å†…å­˜ä½¿ç”¨: {:.2}MB", metrics.memory_usage / 1024.0 / 1024.0);
    println!("CPUä½¿ç”¨: {:.2}%", metrics.cpu_usage * 100.0);

    Ok(())
}
```

### å®æ—¶è°ƒä¼˜

```rust
use otlp::core::AutoTuner;

// è‡ªåŠ¨è°ƒä¼˜å™¨
let auto_tuner = AutoTuner::new()
    .with_tuning_interval(Duration::from_secs(30))
    .with_performance_targets(PerformanceTargets {
        target_throughput: 10000,
        target_latency: Duration::from_millis(100),
        max_memory_usage: 500 * 1024 * 1024,
        max_cpu_usage: 0.8,
    })
    .with_tuning_strategies(vec![
        TuningStrategy::BatchSize,
        TuningStrategy::ConnectionPool,
        TuningStrategy::Compression,
    ]);

let client = EnhancedOtlpClient::builder()
    .with_endpoint("http://localhost:4317")
    .with_auto_tuner(auto_tuner)
    .build()
    .await?;
```

---

## ğŸƒ æ€§èƒ½åŸºå‡†æµ‹è¯•

### åŸºå‡†æµ‹è¯•æ¡†æ¶

```rust
use criterion::{criterion_group, criterion_main, Criterion, BenchmarkId};
use otlp::core::EnhancedOtlpClient;

fn benchmark_otlp_client(c: &mut Criterion) {
    let rt = tokio::runtime::Runtime::new().unwrap();

    let mut group = c.benchmark_group("otlp_client");

    // æµ‹è¯•ä¸åŒæ‰¹æ¬¡å¤§å°
    for batch_size in [100, 500, 1000, 2000].iter() {
        group.bench_with_input(
            BenchmarkId::new("batch_export", batch_size),
            batch_size,
            |b, &batch_size| {
                b.to_async(&rt).iter(|| async {
                    let client = EnhancedOtlpClient::builder()
                        .with_endpoint("http://localhost:4317")
                        .with_batch_config(BatchConfig {
                            max_batch_size: batch_size,
                            batch_timeout: Duration::from_millis(100),
                            strategy: BatchStrategy::Hybrid,
                        })
                        .build()
                        .await
                        .unwrap();

                    let spans = generate_test_spans(batch_size);
                    client.export_spans(spans).await.unwrap();
                });
            },
        );
    }

    group.finish();
}

criterion_group!(benches, benchmark_otlp_client);
criterion_main!(benches);
```

### æ€§èƒ½æµ‹è¯•è„šæœ¬

```rust
// æ€§èƒ½æµ‹è¯•å·¥å…·
async fn performance_test_suite() -> Result<(), Box<dyn std::error::Error>> {
    println!("ğŸš€ å¼€å§‹æ€§èƒ½æµ‹è¯•å¥—ä»¶");

    // 1. ååé‡æµ‹è¯•
    println!("ğŸ“Š ååé‡æµ‹è¯•...");
    let throughput_result = throughput_test().await?;
    println!("ååé‡: {:.2} spans/s", throughput_result);

    // 2. å»¶è¿Ÿæµ‹è¯•
    println!("â±ï¸ å»¶è¿Ÿæµ‹è¯•...");
    let latency_result = latency_test().await?;
    println!("å¹³å‡å»¶è¿Ÿ: {:.2}ms", latency_result.avg.as_millis());
    println!("P99å»¶è¿Ÿ: {:.2}ms", latency_result.p99.as_millis());

    // 3. å†…å­˜æµ‹è¯•
    println!("ğŸ’¾ å†…å­˜æµ‹è¯•...");
    let memory_result = memory_test().await?;
    println!("å³°å€¼å†…å­˜: {:.2}MB", memory_result.peak / 1024.0 / 1024.0);

    // 4. å¹¶å‘æµ‹è¯•
    println!("ğŸ”„ å¹¶å‘æµ‹è¯•...");
    let concurrency_result = concurrency_test().await?;
    println!("å¹¶å‘å¤„ç†èƒ½åŠ›: {:.2} requests/s", concurrency_result);

    println!("âœ… æ€§èƒ½æµ‹è¯•å®Œæˆ");
    Ok(())
}
```

---

## ğŸ¯ æœ€ä½³å®è·µ

### é…ç½®æœ€ä½³å®è·µ

```rust
// ç”Ÿäº§ç¯å¢ƒæ¨èé…ç½®
fn create_production_client() -> EnhancedOtlpClient {
    EnhancedOtlpClient::builder()
        .with_endpoint("http://otel-collector:4317")
        .with_service_name("production-app")
        .with_service_version("1.0.0")

        // è¿æ¥ä¼˜åŒ–
        .with_grpc_transport()
        .with_compression(Compression::Gzip)
        .with_connect_timeout(Duration::from_secs(10))
        .with_request_timeout(Duration::from_secs(60))

        // æ‰¹å¤„ç†ä¼˜åŒ–
        .with_batch_config(BatchConfig {
            max_batch_size: 1000,
            batch_timeout: Duration::from_millis(200),
            max_queue_size: 50000,
            strategy: BatchStrategy::Hybrid,
        })

        // è¿æ¥æ± ä¼˜åŒ–
        .with_connection_pool_config(ConnectionPoolConfig {
            max_connections: 100,
            min_connections: 10,
            connection_timeout: Duration::from_secs(5),
            idle_timeout: Duration::from_secs(300),
            keep_alive: true,
        })

        // é‡è¯•ä¼˜åŒ–
        .with_retry_config(RetryConfig {
            max_attempts: 3,
            initial_interval: Duration::from_millis(100),
            max_interval: Duration::from_secs(5),
            multiplier: 2.0,
            randomization_factor: 0.1,
            retryable_errors: vec![ErrorType::Network, ErrorType::Timeout],
        })

        // ç›‘æ§
        .with_performance_monitor(PerformanceMonitor::new())
        .with_memory_monitor(MemoryMonitor::new())

        .build()
        .await
        .unwrap()
}
```

### æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥æ¸…å•

- [ ] **æ‰¹å¤„ç†é…ç½®**: æ ¹æ®è´Ÿè½½è°ƒæ•´æ‰¹æ¬¡å¤§å°
- [ ] **è¿æ¥æ± **: é…ç½®åˆé€‚çš„è¿æ¥æ± å¤§å°
- [ ] **å‹ç¼©**: å¯ç”¨é€‚å½“çš„å‹ç¼©ç®—æ³•
- [ ] **å†…å­˜ç®¡ç†**: ä½¿ç”¨å†…å­˜æ± å’Œé›¶æ‹·è´
- [ ] **å¹¶å‘æ§åˆ¶**: åˆç†ä½¿ç”¨å¼‚æ­¥å’Œå¹¶å‘
- [ ] **ç›‘æ§**: å¯ç”¨æ€§èƒ½ç›‘æ§å’ŒæŒ‡æ ‡æ”¶é›†
- [ ] **åŸºå‡†æµ‹è¯•**: å®šæœŸè¿è¡Œæ€§èƒ½æµ‹è¯•
- [ ] **è°ƒä¼˜**: æ ¹æ®ç›‘æ§æ•°æ®æŒç»­ä¼˜åŒ–

### å¸¸è§æ€§èƒ½é—®é¢˜

1. **é«˜å»¶è¿Ÿ**: æ£€æŸ¥ç½‘ç»œè¿æ¥å’Œæ‰¹å¤„ç†é…ç½®
2. **ä½ååé‡**: å¢åŠ æ‰¹æ¬¡å¤§å°å’Œå¹¶å‘æ•°
3. **é«˜å†…å­˜ä½¿ç”¨**: å¯ç”¨å†…å­˜æ± å’Œåƒåœ¾å›æ”¶
4. **CPU ä½¿ç”¨ç‡é«˜**: ä¼˜åŒ–å‹ç¼©ç®—æ³•å’Œæ‰¹å¤„ç†ç­–ç•¥
5. **ç½‘ç»œæ‹¥å¡**: å¯ç”¨å‹ç¼©å’Œè¿æ¥å¤ç”¨

---

## ğŸ“š å‚è€ƒèµ„æº

### æ€§èƒ½ä¼˜åŒ–å·¥å…·

- ğŸ“Š [æ€§èƒ½ç›‘æ§å·¥å…·](../monitoring.md)
- ğŸ§ª [åŸºå‡†æµ‹è¯•å·¥å…·](../testing.md)
- ğŸ“ˆ [æ€§èƒ½åˆ†æå·¥å…·](../profiling.md)

### ç›¸å…³æ–‡æ¡£

- ğŸ“– [API å‚è€ƒ](../api/otlp.md)
- ğŸš€ [éƒ¨ç½²æŒ‡å—](../guides/deployment.md)
- ğŸ”§ [æ•…éšœæ’é™¤](../troubleshooting.md)

---

_æœ€åæ›´æ–°: 2025å¹´10æœˆ20æ—¥_
_ç‰ˆæœ¬: 1.0.0_
