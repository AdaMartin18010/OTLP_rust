# 服务发现与注册中心设计

## 🎯 概述

服务发现是微服务架构中的核心组件，负责服务的注册、发现和健康检查。
本文将详细介绍基于Rust 1.90和OTLP的服务发现与注册中心的设计与实现。

## 🏗️ 架构设计

### 整体架构图

```text
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   服务提供者     │    │   注册中心       │    │   服务消费者     │
│  (Provider)     │    │  (Registry)     │    │  (Consumer)     │
│                 │    │                 │    │                 │
│ • 服务注册       │───▶│ • 服务存储       │◀───│ • 服务发现       │
│ • 健康检查       │    │ • 健康监控       │    │ • 负载均衡       │
│ • 心跳维持       │    │ • 配置管理       │    │ • 故障转移       │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 │
                    ┌─────────────────┐
                    │   OTLP监控      │
                    │  (Monitoring)   │
                    │                 │
                    │ • 追踪数据       │
                    │ • 指标收集       │
                    │ • 日志聚合       │
                    └─────────────────┘
```

## 🔧 核心组件实现

### 1. 服务注册中心

```rust
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use serde::{Deserialize, Serialize};
use opentelemetry::trace::{Tracer, SpanKind};
use opentelemetry::metrics::{Counter, Histogram};
use tracing::{info, warn, error};

/// 服务信息结构
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServiceInfo {
    pub id: String,
    pub name: String,
    pub version: String,
    pub host: String,
    pub port: u16,
    pub protocol: ServiceProtocol,
    pub tags: HashMap<String, String>,
    pub metadata: HashMap<String, String>,
    pub health_check: HealthCheckConfig,
    pub registration_time: chrono::DateTime<chrono::Utc>,
    pub last_heartbeat: chrono::DateTime<chrono::Utc>,
}

/// 服务协议类型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ServiceProtocol {
    Http,
    Https,
    Grpc,
    Tcp,
    Udp,
}

/// 健康检查配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HealthCheckConfig {
    pub endpoint: String,
    pub interval: Duration,
    pub timeout: Duration,
    pub retries: u32,
}

/// 服务注册中心
pub struct ServiceRegistry {
    services: Arc<RwLock<HashMap<String, ServiceInfo>>>,
    health_checker: Arc<HealthChecker>,
    metrics: RegistryMetrics,
    tracer: opentelemetry::trace::Tracer,
}

/// 注册中心指标
pub struct RegistryMetrics {
    pub registered_services: Counter<u64>,
    pub deregistered_services: Counter<u64>,
    pub discovery_requests: Counter<u64>,
    pub health_check_failures: Counter<u64>,
    pub registration_latency: Histogram<f64>,
}

impl ServiceRegistry {
    pub fn new() -> Result<Self, RegistryError> {
        let tracer = global::tracer("service-registry");
        
        let metrics = RegistryMetrics {
            registered_services: global::meter("service-registry")
                .u64_counter("registered_services_total")
                .with_description("Total number of registered services")
                .init(),
            deregistered_services: global::meter("service-registry")
                .u64_counter("deregistered_services_total")
                .with_description("Total number of deregistered services")
                .init(),
            discovery_requests: global::meter("service-registry")
                .u64_counter("discovery_requests_total")
                .with_description("Total number of service discovery requests")
                .init(),
            health_check_failures: global::meter("service-registry")
                .u64_counter("health_check_failures_total")
                .with_description("Total number of health check failures")
                .init(),
            registration_latency: global::meter("service-registry")
                .f64_histogram("registration_latency_seconds")
                .with_description("Service registration latency")
                .init(),
        };

        Ok(Self {
            services: Arc::new(RwLock::new(HashMap::new())),
            health_checker: Arc::new(HealthChecker::new()),
            metrics,
            tracer,
        })
    }

    /// 注册服务
    pub async fn register_service(&self, service: ServiceInfo) -> Result<(), RegistryError> {
        let start_time = std::time::Instant::now();
        let span = self.tracer
            .span_builder("register_service")
            .with_kind(SpanKind::Server)
            .with_attributes(vec![
                KeyValue::new("service.name", service.name.clone()),
                KeyValue::new("service.id", service.id.clone()),
                KeyValue::new("service.version", service.version.clone()),
            ])
            .start(&self.tracer);

        let result = async {
            let mut services = self.services.write().await;
            
            // 检查服务是否已存在
            if services.contains_key(&service.id) {
                return Err(RegistryError::ServiceAlreadyExists(service.id.clone()));
            }

            // 验证服务信息
            self.validate_service_info(&service)?;

            // 注册服务
            let mut service_to_register = service;
            service_to_register.registration_time = chrono::Utc::now();
            service_to_register.last_heartbeat = chrono::Utc::now();
            
            services.insert(service_to_register.id.clone(), service_to_register.clone());
            
            // 启动健康检查
            self.health_checker.start_checking(service_to_register.clone()).await?;
            
            info!(
                service_id = %service_to_register.id,
                service_name = %service_to_register.name,
                "Service registered successfully"
            );

            // 更新指标
            self.metrics.registered_services.add(1, &[]);
            
            Ok::<(), RegistryError>(())
        }.await;

        // 记录延迟指标
        let duration = start_time.elapsed();
        self.metrics.registration_latency.record(duration.as_secs_f64(), &[]);
        
        span.set_status(result.as_ref().map(|_| Status::Ok).unwrap_or(Status::Error));
        span.end();

        result
    }

    /// 注销服务
    pub async fn deregister_service(&self, service_id: &str) -> Result<(), RegistryError> {
        let span = self.tracer
            .span_builder("deregister_service")
            .with_kind(SpanKind::Server)
            .with_attributes(vec![
                KeyValue::new("service.id", service_id.to_string()),
            ])
            .start(&self.tracer);

        let result = async {
            let mut services = self.services.write().await;
            
            if let Some(service) = services.remove(service_id) {
                // 停止健康检查
                self.health_checker.stop_checking(service_id).await;
                
                info!(
                    service_id = %service_id,
                    service_name = %service.name,
                    "Service deregistered successfully"
                );

                // 更新指标
                self.metrics.deregistered_services.add(1, &[]);
                
                Ok(())
            } else {
                Err(RegistryError::ServiceNotFound(service_id.to_string()))
            }
        }.await;

        span.set_status(result.as_ref().map(|_| Status::Ok).unwrap_or(Status::Error));
        span.end();

        result
    }

    /// 发现服务
    pub async fn discover_services(&self, service_name: &str) -> Result<Vec<ServiceInfo>, RegistryError> {
        let span = self.tracer
            .span_builder("discover_services")
            .with_kind(SpanKind::Client)
            .with_attributes(vec![
                KeyValue::new("service.name", service_name.to_string()),
            ])
            .start(&self.tracer);

        let result = async {
            let services = self.services.read().await;
            
            let matching_services: Vec<ServiceInfo> = services
                .values()
                .filter(|service| {
                    service.name == service_name && 
                    self.is_service_healthy(service).await
                })
                .cloned()
                .collect();

            // 更新指标
            self.metrics.discovery_requests.add(1, &[]);
            
            info!(
                service_name = %service_name,
                found_count = matching_services.len(),
                "Service discovery completed"
            );

            Ok(matching_services)
        }.await;

        span.set_status(result.as_ref().map(|_| Status::Ok).unwrap_or(Status::Error));
        span.end();

        result
    }

    /// 更新服务心跳
    pub async fn update_heartbeat(&self, service_id: &str) -> Result<(), RegistryError> {
        let mut services = self.services.write().await;
        
        if let Some(service) = services.get_mut(service_id) {
            service.last_heartbeat = chrono::Utc::now();
            Ok(())
        } else {
            Err(RegistryError::ServiceNotFound(service_id.to_string()))
        }
    }

    /// 获取所有服务
    pub async fn list_services(&self) -> Result<Vec<ServiceInfo>, RegistryError> {
        let services = self.services.read().await;
        Ok(services.values().cloned().collect())
    }

    /// 验证服务信息
    fn validate_service_info(&self, service: &ServiceInfo) -> Result<(), RegistryError> {
        if service.id.is_empty() {
            return Err(RegistryError::InvalidServiceInfo("Service ID cannot be empty".to_string()));
        }
        
        if service.name.is_empty() {
            return Err(RegistryError::InvalidServiceInfo("Service name cannot be empty".to_string()));
        }
        
        if service.host.is_empty() {
            return Err(RegistryError::InvalidServiceInfo("Service host cannot be empty".to_string()));
        }
        
        if service.port == 0 {
            return Err(RegistryError::InvalidServiceInfo("Service port cannot be 0".to_string()));
        }

        Ok(())
    }

    /// 检查服务健康状态
    async fn is_service_healthy(&self, service: &ServiceInfo) -> bool {
        let now = chrono::Utc::now();
        let heartbeat_timeout = Duration::from_secs(30);
        
        now.signed_duration_since(service.last_heartbeat).num_seconds() < heartbeat_timeout.as_secs() as i64
    }
}
```

### 2. 健康检查器

```rust
use tokio::time::{sleep, Duration, interval};
use std::collections::HashMap;
use reqwest::Client;

/// 健康检查器
pub struct HealthChecker {
    checks: Arc<RwLock<HashMap<String, HealthCheckTask>>>,
    client: Client,
    metrics: HealthCheckMetrics,
}

/// 健康检查任务
struct HealthCheckTask {
    service: ServiceInfo,
    task_handle: tokio::task::JoinHandle<()>,
}

/// 健康检查指标
pub struct HealthCheckMetrics {
    pub check_requests: Counter<u64>,
    pub check_failures: Counter<u64>,
    pub check_latency: Histogram<f64>,
}

impl HealthChecker {
    pub fn new() -> Self {
        let metrics = HealthCheckMetrics {
            check_requests: global::meter("health-checker")
                .u64_counter("check_requests_total")
                .with_description("Total number of health check requests")
                .init(),
            check_failures: global::meter("health-checker")
                .u64_counter("check_failures_total")
                .with_description("Total number of health check failures")
                .init(),
            check_latency: global::meter("health-checker")
                .f64_histogram("check_latency_seconds")
                .with_description("Health check latency")
                .init(),
        };

        Self {
            checks: Arc::new(RwLock::new(HashMap::new())),
            client: Client::new(),
            metrics,
        }
    }

    /// 启动健康检查
    pub async fn start_checking(&self, service: ServiceInfo) -> Result<(), RegistryError> {
        let service_id = service.id.clone();
        let health_check = service.health_check.clone();
        let client = self.client.clone();
        let metrics = self.metrics.clone();

        let task_handle = tokio::spawn(async move {
            let mut interval = interval(health_check.interval);
            
            loop {
                interval.tick().await;
                
                let start_time = std::time::Instant::now();
                let result = Self::perform_health_check(&client, &service, &health_check).await;
                let duration = start_time.elapsed();
                
                // 更新指标
                metrics.check_requests.add(1, &[]);
                metrics.check_latency.record(duration.as_secs_f64(), &[]);
                
                match result {
                    Ok(_) => {
                        info!(
                            service_id = %service_id,
                            "Health check passed"
                        );
                    }
                    Err(e) => {
                        metrics.check_failures.add(1, &[]);
                        warn!(
                            service_id = %service_id,
                            error = %e,
                            "Health check failed"
                        );
                    }
                }
            }
        });

        let mut checks = self.checks.write().await;
        checks.insert(service_id.clone(), HealthCheckTask {
            service,
            task_handle,
        });

        Ok(())
    }

    /// 停止健康检查
    pub async fn stop_checking(&self, service_id: &str) {
        let mut checks = self.checks.write().await;
        if let Some(check_task) = checks.remove(service_id) {
            check_task.task_handle.abort();
            info!(service_id = %service_id, "Health check stopped");
        }
    }

    /// 执行健康检查
    async fn perform_health_check(
        client: &Client,
        service: &ServiceInfo,
        config: &HealthCheckConfig,
    ) -> Result<(), HealthCheckError> {
        let url = format!("{}://{}:{}{}", 
            match service.protocol {
                ServiceProtocol::Http => "http",
                ServiceProtocol::Https => "https",
                _ => return Err(HealthCheckError::UnsupportedProtocol),
            },
            service.host,
            service.port,
            config.endpoint
        );

        let response = client
            .get(&url)
            .timeout(config.timeout)
            .send()
            .await?;

        if response.status().is_success() {
            Ok(())
        } else {
            Err(HealthCheckError::Unhealthy(response.status()))
        }
    }
}
```

### 3. 服务发现客户端

```rust
/// 服务发现客户端
pub struct ServiceDiscoveryClient {
    registry: Arc<ServiceRegistry>,
    cache: Arc<RwLock<HashMap<String, (Vec<ServiceInfo>, chrono::DateTime<chrono::Utc>)>>>,
    cache_ttl: Duration,
    load_balancer: Arc<dyn LoadBalancer + Send + Sync>,
}

/// 负载均衡器trait
#[async_trait]
pub trait LoadBalancer {
    async fn select_service(&self, services: &[ServiceInfo]) -> Option<&ServiceInfo>;
}

/// 轮询负载均衡器
pub struct RoundRobinLoadBalancer {
    current: AtomicUsize,
}

impl RoundRobinLoadBalancer {
    pub fn new() -> Self {
        Self {
            current: AtomicUsize::new(0),
        }
    }
}

#[async_trait]
impl LoadBalancer for RoundRobinLoadBalancer {
    async fn select_service(&self, services: &[ServiceInfo]) -> Option<&ServiceInfo> {
        if services.is_empty() {
            return None;
        }
        
        let index = self.current.fetch_add(1, Ordering::Relaxed) % services.len();
        Some(&services[index])
    }
}

impl ServiceDiscoveryClient {
    pub fn new(registry: Arc<ServiceRegistry>) -> Self {
        Self {
            registry,
            cache: Arc::new(RwLock::new(HashMap::new())),
            cache_ttl: Duration::from_secs(30),
            load_balancer: Arc::new(RoundRobinLoadBalancer::new()),
        }
    }

    /// 发现服务（带缓存）
    pub async fn discover_service(&self, service_name: &str) -> Result<Option<ServiceInfo>, RegistryError> {
        // 检查缓存
        if let Some(cached) = self.get_from_cache(service_name).await {
            if cached.1 + chrono::Duration::from_std(self.cache_ttl).unwrap() > chrono::Utc::now() {
                return Ok(self.load_balancer.select_service(&cached.0).cloned());
            }
        }

        // 从注册中心获取
        let services = self.registry.discover_services(service_name).await?;
        
        if services.is_empty() {
            return Ok(None);
        }

        // 更新缓存
        self.update_cache(service_name, services.clone()).await;

        // 使用负载均衡器选择服务
        Ok(self.load_balancer.select_service(&services).cloned())
    }

    /// 从缓存获取服务
    async fn get_from_cache(&self, service_name: &str) -> Option<(Vec<ServiceInfo>, chrono::DateTime<chrono::Utc>)> {
        let cache = self.cache.read().await;
        cache.get(service_name).cloned()
    }

    /// 更新缓存
    async fn update_cache(&self, service_name: &str, services: Vec<ServiceInfo>) {
        let mut cache = self.cache.write().await;
        cache.insert(service_name.to_string(), (services, chrono::Utc::now()));
    }

    /// 清除缓存
    pub async fn clear_cache(&self) {
        let mut cache = self.cache.write().await;
        cache.clear();
    }
}
```

## 🔌 集成OTLP监控

### 1. 分布式追踪集成

```rust
impl ServiceRegistry {
    /// 带追踪的服务注册
    pub async fn register_service_with_tracing(&self, service: ServiceInfo) -> Result<(), RegistryError> {
        let span = self.tracer
            .span_builder("service_registration")
            .with_kind(SpanKind::Server)
            .with_attributes(vec![
                KeyValue::new("service.name", service.name.clone()),
                KeyValue::new("service.id", service.id.clone()),
                KeyValue::new("service.version", service.version.clone()),
                KeyValue::new("service.protocol", format!("{:?}", service.protocol)),
            ])
            .start(&self.tracer);

        let _guard = span.enter();
        
        // 执行注册逻辑
        let result = self.register_service(service).await;
        
        // 设置span状态
        span.set_status(result.as_ref().map(|_| Status::Ok).unwrap_or(Status::Error));
        
        result
    }
}
```

### 2. 指标收集集成

```rust
impl ServiceRegistry {
    /// 获取注册中心指标
    pub async fn get_metrics(&self) -> RegistryMetricsSnapshot {
        let services = self.services.read().await;
        
        RegistryMetricsSnapshot {
            total_services: services.len(),
            healthy_services: services.values()
                .filter(|s| self.is_service_healthy(s).await)
                .count(),
            unhealthy_services: services.values()
                .filter(|s| !self.is_service_healthy(s).await)
                .count(),
            services_by_protocol: services.values()
                .fold(HashMap::new(), |mut acc, service| {
                    let protocol = format!("{:?}", service.protocol);
                    *acc.entry(protocol).or_insert(0) += 1;
                    acc
                }),
        }
    }
}

#[derive(Debug, Serialize)]
pub struct RegistryMetricsSnapshot {
    pub total_services: usize,
    pub healthy_services: usize,
    pub unhealthy_services: usize,
    pub services_by_protocol: HashMap<String, usize>,
}
```

## 🚀 使用示例

### 1. 服务提供者注册

```rust
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 初始化OTLP
    init_otlp().await?;
    
    // 创建服务注册中心
    let registry = Arc::new(ServiceRegistry::new()?);
    
    // 创建服务信息
    let service_info = ServiceInfo {
        id: "user-service-001".to_string(),
        name: "user-service".to_string(),
        version: "1.0.0".to_string(),
        host: "localhost".to_string(),
        port: 8080,
        protocol: ServiceProtocol::Http,
        tags: {
            let mut tags = HashMap::new();
            tags.insert("environment".to_string(), "production".to_string());
            tags.insert("team".to_string(), "backend".to_string());
            tags
        },
        metadata: {
            let mut metadata = HashMap::new();
            metadata.insert("description".to_string(), "User management service".to_string());
            metadata.insert("owner".to_string(), "backend-team".to_string());
            metadata
        },
        health_check: HealthCheckConfig {
            endpoint: "/health".to_string(),
            interval: Duration::from_secs(30),
            timeout: Duration::from_secs(5),
            retries: 3,
        },
        registration_time: chrono::Utc::now(),
        last_heartbeat: chrono::Utc::now(),
    };
    
    // 注册服务
    registry.register_service(service_info).await?;
    
    println!("Service registered successfully!");
    
    // 启动心跳服务
    let registry_clone = registry.clone();
    tokio::spawn(async move {
        let mut interval = tokio::time::interval(Duration::from_secs(10));
        loop {
            interval.tick().await;
            if let Err(e) = registry_clone.update_heartbeat("user-service-001").await {
                eprintln!("Failed to update heartbeat: {}", e);
            }
        }
    });
    
    // 保持服务运行
    tokio::signal::ctrl_c().await?;
    
    // 注销服务
    registry.deregister_service("user-service-001").await?;
    
    Ok(())
}
```

### 2. 服务消费者发现

```rust
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 初始化OTLP
    init_otlp().await?;
    
    // 创建服务注册中心
    let registry = Arc::new(ServiceRegistry::new()?);
    
    // 创建服务发现客户端
    let discovery_client = ServiceDiscoveryClient::new(registry);
    
    // 发现服务
    match discovery_client.discover_service("user-service").await? {
        Some(service) => {
            println!("Found service: {:?}", service);
            
            // 调用服务
            let client = reqwest::Client::new();
            let url = format!("http://{}:{}/users", service.host, service.port);
            let response = client.get(&url).send().await?;
            println!("Service response: {}", response.status());
        }
        None => {
            println!("No healthy user-service found");
        }
    }
    
    Ok(())
}
```

## 📊 性能优化

### 1. 缓存策略

- **本地缓存**: 减少注册中心访问频率
- **TTL缓存**: 自动过期机制
- **缓存预热**: 启动时预加载常用服务

### 2. 并发优化

- **读写锁**: 支持并发读取
- **异步处理**: 非阻塞操作
- **连接池**: 复用HTTP连接

### 3. 监控优化

- **批量指标**: 减少指标更新频率
- **采样策略**: 智能采样减少开销
- **异步上报**: 非阻塞监控数据上报

## 🔒 安全考虑

### 1. 认证授权

```rust
/// 服务认证信息
#[derive(Debug, Clone)]
pub struct ServiceAuth {
    pub token: String,
    pub permissions: Vec<String>,
}

impl ServiceRegistry {
    /// 带认证的服务注册
    pub async fn register_service_with_auth(
        &self, 
        service: ServiceInfo, 
        auth: ServiceAuth
    ) -> Result<(), RegistryError> {
        // 验证认证信息
        self.validate_auth(&auth)?;
        
        // 执行注册
        self.register_service(service).await
    }
    
    fn validate_auth(&self, auth: &ServiceAuth) -> Result<(), RegistryError> {
        // 实现认证逻辑
        // 验证token、检查权限等
        Ok(())
    }
}
```

### 2. 数据加密

- **传输加密**: TLS/SSL加密通信
- **存储加密**: 敏感数据加密存储
- **密钥管理**: 安全的密钥轮换机制

## 📚 参考资料

1. [Consul服务发现](https://www.consul.io/docs/discovery)
2. [etcd服务发现](https://etcd.io/docs/)
3. [OpenTelemetry Rust](https://opentelemetry.io/docs/instrumentation/rust/)
4. [微服务架构模式](https://microservices.io/)

---

**注意**: 本文档基于Rust 1.90和最新的微服务最佳实践，将持续更新以反映技术发展。
