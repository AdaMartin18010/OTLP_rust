# æœåŠ¡å‘ç°ä¸æ³¨å†Œä¸­å¿ƒè®¾è®¡

## ğŸ¯ æ¦‚è¿°

æœåŠ¡å‘ç°æ˜¯å¾®æœåŠ¡æ¶æ„ä¸­çš„æ ¸å¿ƒç»„ä»¶ï¼Œè´Ÿè´£æœåŠ¡çš„æ³¨å†Œã€å‘ç°å’Œå¥åº·æ£€æŸ¥ã€‚
æœ¬æ–‡å°†è¯¦ç»†ä»‹ç»åŸºäºRust 1.90å’ŒOTLPçš„æœåŠ¡å‘ç°ä¸æ³¨å†Œä¸­å¿ƒçš„è®¾è®¡ä¸å®ç°ã€‚

## ğŸ—ï¸ æ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„å›¾

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   æœåŠ¡æä¾›è€…     â”‚    â”‚   æ³¨å†Œä¸­å¿ƒ       â”‚    â”‚   æœåŠ¡æ¶ˆè´¹è€…     â”‚
â”‚  (Provider)     â”‚    â”‚  (Registry)     â”‚    â”‚  (Consumer)     â”‚
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚ â€¢ æœåŠ¡æ³¨å†Œ       â”‚â”€â”€â”€â–¶â”‚ â€¢ æœåŠ¡å­˜å‚¨       â”‚â—€â”€â”€â”€â”‚ â€¢ æœåŠ¡å‘ç°       â”‚
â”‚ â€¢ å¥åº·æ£€æŸ¥       â”‚    â”‚ â€¢ å¥åº·ç›‘æ§       â”‚    â”‚ â€¢ è´Ÿè½½å‡è¡¡       â”‚
â”‚ â€¢ å¿ƒè·³ç»´æŒ       â”‚    â”‚ â€¢ é…ç½®ç®¡ç†       â”‚    â”‚ â€¢ æ•…éšœè½¬ç§»       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚                       â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   OTLPç›‘æ§      â”‚
                    â”‚  (Monitoring)   â”‚
                    â”‚                 â”‚
                    â”‚ â€¢ è¿½è¸ªæ•°æ®       â”‚
                    â”‚ â€¢ æŒ‡æ ‡æ”¶é›†       â”‚
                    â”‚ â€¢ æ—¥å¿—èšåˆ       â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”§ æ ¸å¿ƒç»„ä»¶å®ç°

### 1. æœåŠ¡æ³¨å†Œä¸­å¿ƒ

```rust
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use serde::{Deserialize, Serialize};
use opentelemetry::trace::{Tracer, SpanKind};
use opentelemetry::metrics::{Counter, Histogram};
use tracing::{info, warn, error};

/// æœåŠ¡ä¿¡æ¯ç»“æ„
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServiceInfo {
    pub id: String,
    pub name: String,
    pub version: String,
    pub host: String,
    pub port: u16,
    pub protocol: ServiceProtocol,
    pub tags: HashMap<String, String>,
    pub metadata: HashMap<String, String>,
    pub health_check: HealthCheckConfig,
    pub registration_time: chrono::DateTime<chrono::Utc>,
    pub last_heartbeat: chrono::DateTime<chrono::Utc>,
}

/// æœåŠ¡åè®®ç±»å‹
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ServiceProtocol {
    Http,
    Https,
    Grpc,
    Tcp,
    Udp,
}

/// å¥åº·æ£€æŸ¥é…ç½®
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HealthCheckConfig {
    pub endpoint: String,
    pub interval: Duration,
    pub timeout: Duration,
    pub retries: u32,
}

/// æœåŠ¡æ³¨å†Œä¸­å¿ƒ
pub struct ServiceRegistry {
    services: Arc<RwLock<HashMap<String, ServiceInfo>>>,
    health_checker: Arc<HealthChecker>,
    metrics: RegistryMetrics,
    tracer: opentelemetry::trace::Tracer,
}

/// æ³¨å†Œä¸­å¿ƒæŒ‡æ ‡
pub struct RegistryMetrics {
    pub registered_services: Counter<u64>,
    pub deregistered_services: Counter<u64>,
    pub discovery_requests: Counter<u64>,
    pub health_check_failures: Counter<u64>,
    pub registration_latency: Histogram<f64>,
}

impl ServiceRegistry {
    pub fn new() -> Result<Self, RegistryError> {
        let tracer = global::tracer("service-registry");
        
        let metrics = RegistryMetrics {
            registered_services: global::meter("service-registry")
                .u64_counter("registered_services_total")
                .with_description("Total number of registered services")
                .init(),
            deregistered_services: global::meter("service-registry")
                .u64_counter("deregistered_services_total")
                .with_description("Total number of deregistered services")
                .init(),
            discovery_requests: global::meter("service-registry")
                .u64_counter("discovery_requests_total")
                .with_description("Total number of service discovery requests")
                .init(),
            health_check_failures: global::meter("service-registry")
                .u64_counter("health_check_failures_total")
                .with_description("Total number of health check failures")
                .init(),
            registration_latency: global::meter("service-registry")
                .f64_histogram("registration_latency_seconds")
                .with_description("Service registration latency")
                .init(),
        };

        Ok(Self {
            services: Arc::new(RwLock::new(HashMap::new())),
            health_checker: Arc::new(HealthChecker::new()),
            metrics,
            tracer,
        })
    }

    /// æ³¨å†ŒæœåŠ¡
    pub async fn register_service(&self, service: ServiceInfo) -> Result<(), RegistryError> {
        let start_time = std::time::Instant::now();
        let span = self.tracer
            .span_builder("register_service")
            .with_kind(SpanKind::Server)
            .with_attributes(vec![
                KeyValue::new("service.name", service.name.clone()),
                KeyValue::new("service.id", service.id.clone()),
                KeyValue::new("service.version", service.version.clone()),
            ])
            .start(&self.tracer);

        let result = async {
            let mut services = self.services.write().await;
            
            // æ£€æŸ¥æœåŠ¡æ˜¯å¦å·²å­˜åœ¨
            if services.contains_key(&service.id) {
                return Err(RegistryError::ServiceAlreadyExists(service.id.clone()));
            }

            // éªŒè¯æœåŠ¡ä¿¡æ¯
            self.validate_service_info(&service)?;

            // æ³¨å†ŒæœåŠ¡
            let mut service_to_register = service;
            service_to_register.registration_time = chrono::Utc::now();
            service_to_register.last_heartbeat = chrono::Utc::now();
            
            services.insert(service_to_register.id.clone(), service_to_register.clone());
            
            // å¯åŠ¨å¥åº·æ£€æŸ¥
            self.health_checker.start_checking(service_to_register.clone()).await?;
            
            info!(
                service_id = %service_to_register.id,
                service_name = %service_to_register.name,
                "Service registered successfully"
            );

            // æ›´æ–°æŒ‡æ ‡
            self.metrics.registered_services.add(1, &[]);
            
            Ok::<(), RegistryError>(())
        }.await;

        // è®°å½•å»¶è¿ŸæŒ‡æ ‡
        let duration = start_time.elapsed();
        self.metrics.registration_latency.record(duration.as_secs_f64(), &[]);
        
        span.set_status(result.as_ref().map(|_| Status::Ok).unwrap_or(Status::Error));
        span.end();

        result
    }

    /// æ³¨é”€æœåŠ¡
    pub async fn deregister_service(&self, service_id: &str) -> Result<(), RegistryError> {
        let span = self.tracer
            .span_builder("deregister_service")
            .with_kind(SpanKind::Server)
            .with_attributes(vec![
                KeyValue::new("service.id", service_id.to_string()),
            ])
            .start(&self.tracer);

        let result = async {
            let mut services = self.services.write().await;
            
            if let Some(service) = services.remove(service_id) {
                // åœæ­¢å¥åº·æ£€æŸ¥
                self.health_checker.stop_checking(service_id).await;
                
                info!(
                    service_id = %service_id,
                    service_name = %service.name,
                    "Service deregistered successfully"
                );

                // æ›´æ–°æŒ‡æ ‡
                self.metrics.deregistered_services.add(1, &[]);
                
                Ok(())
            } else {
                Err(RegistryError::ServiceNotFound(service_id.to_string()))
            }
        }.await;

        span.set_status(result.as_ref().map(|_| Status::Ok).unwrap_or(Status::Error));
        span.end();

        result
    }

    /// å‘ç°æœåŠ¡
    pub async fn discover_services(&self, service_name: &str) -> Result<Vec<ServiceInfo>, RegistryError> {
        let span = self.tracer
            .span_builder("discover_services")
            .with_kind(SpanKind::Client)
            .with_attributes(vec![
                KeyValue::new("service.name", service_name.to_string()),
            ])
            .start(&self.tracer);

        let result = async {
            let services = self.services.read().await;
            
            let matching_services: Vec<ServiceInfo> = services
                .values()
                .filter(|service| {
                    service.name == service_name && 
                    self.is_service_healthy(service).await
                })
                .cloned()
                .collect();

            // æ›´æ–°æŒ‡æ ‡
            self.metrics.discovery_requests.add(1, &[]);
            
            info!(
                service_name = %service_name,
                found_count = matching_services.len(),
                "Service discovery completed"
            );

            Ok(matching_services)
        }.await;

        span.set_status(result.as_ref().map(|_| Status::Ok).unwrap_or(Status::Error));
        span.end();

        result
    }

    /// æ›´æ–°æœåŠ¡å¿ƒè·³
    pub async fn update_heartbeat(&self, service_id: &str) -> Result<(), RegistryError> {
        let mut services = self.services.write().await;
        
        if let Some(service) = services.get_mut(service_id) {
            service.last_heartbeat = chrono::Utc::now();
            Ok(())
        } else {
            Err(RegistryError::ServiceNotFound(service_id.to_string()))
        }
    }

    /// è·å–æ‰€æœ‰æœåŠ¡
    pub async fn list_services(&self) -> Result<Vec<ServiceInfo>, RegistryError> {
        let services = self.services.read().await;
        Ok(services.values().cloned().collect())
    }

    /// éªŒè¯æœåŠ¡ä¿¡æ¯
    fn validate_service_info(&self, service: &ServiceInfo) -> Result<(), RegistryError> {
        if service.id.is_empty() {
            return Err(RegistryError::InvalidServiceInfo("Service ID cannot be empty".to_string()));
        }
        
        if service.name.is_empty() {
            return Err(RegistryError::InvalidServiceInfo("Service name cannot be empty".to_string()));
        }
        
        if service.host.is_empty() {
            return Err(RegistryError::InvalidServiceInfo("Service host cannot be empty".to_string()));
        }
        
        if service.port == 0 {
            return Err(RegistryError::InvalidServiceInfo("Service port cannot be 0".to_string()));
        }

        Ok(())
    }

    /// æ£€æŸ¥æœåŠ¡å¥åº·çŠ¶æ€
    async fn is_service_healthy(&self, service: &ServiceInfo) -> bool {
        let now = chrono::Utc::now();
        let heartbeat_timeout = Duration::from_secs(30);
        
        now.signed_duration_since(service.last_heartbeat).num_seconds() < heartbeat_timeout.as_secs() as i64
    }
}
```

### 2. å¥åº·æ£€æŸ¥å™¨

```rust
use tokio::time::{sleep, Duration, interval};
use std::collections::HashMap;
use reqwest::Client;

/// å¥åº·æ£€æŸ¥å™¨
pub struct HealthChecker {
    checks: Arc<RwLock<HashMap<String, HealthCheckTask>>>,
    client: Client,
    metrics: HealthCheckMetrics,
}

/// å¥åº·æ£€æŸ¥ä»»åŠ¡
struct HealthCheckTask {
    service: ServiceInfo,
    task_handle: tokio::task::JoinHandle<()>,
}

/// å¥åº·æ£€æŸ¥æŒ‡æ ‡
pub struct HealthCheckMetrics {
    pub check_requests: Counter<u64>,
    pub check_failures: Counter<u64>,
    pub check_latency: Histogram<f64>,
}

impl HealthChecker {
    pub fn new() -> Self {
        let metrics = HealthCheckMetrics {
            check_requests: global::meter("health-checker")
                .u64_counter("check_requests_total")
                .with_description("Total number of health check requests")
                .init(),
            check_failures: global::meter("health-checker")
                .u64_counter("check_failures_total")
                .with_description("Total number of health check failures")
                .init(),
            check_latency: global::meter("health-checker")
                .f64_histogram("check_latency_seconds")
                .with_description("Health check latency")
                .init(),
        };

        Self {
            checks: Arc::new(RwLock::new(HashMap::new())),
            client: Client::new(),
            metrics,
        }
    }

    /// å¯åŠ¨å¥åº·æ£€æŸ¥
    pub async fn start_checking(&self, service: ServiceInfo) -> Result<(), RegistryError> {
        let service_id = service.id.clone();
        let health_check = service.health_check.clone();
        let client = self.client.clone();
        let metrics = self.metrics.clone();

        let task_handle = tokio::spawn(async move {
            let mut interval = interval(health_check.interval);
            
            loop {
                interval.tick().await;
                
                let start_time = std::time::Instant::now();
                let result = Self::perform_health_check(&client, &service, &health_check).await;
                let duration = start_time.elapsed();
                
                // æ›´æ–°æŒ‡æ ‡
                metrics.check_requests.add(1, &[]);
                metrics.check_latency.record(duration.as_secs_f64(), &[]);
                
                match result {
                    Ok(_) => {
                        info!(
                            service_id = %service_id,
                            "Health check passed"
                        );
                    }
                    Err(e) => {
                        metrics.check_failures.add(1, &[]);
                        warn!(
                            service_id = %service_id,
                            error = %e,
                            "Health check failed"
                        );
                    }
                }
            }
        });

        let mut checks = self.checks.write().await;
        checks.insert(service_id.clone(), HealthCheckTask {
            service,
            task_handle,
        });

        Ok(())
    }

    /// åœæ­¢å¥åº·æ£€æŸ¥
    pub async fn stop_checking(&self, service_id: &str) {
        let mut checks = self.checks.write().await;
        if let Some(check_task) = checks.remove(service_id) {
            check_task.task_handle.abort();
            info!(service_id = %service_id, "Health check stopped");
        }
    }

    /// æ‰§è¡Œå¥åº·æ£€æŸ¥
    async fn perform_health_check(
        client: &Client,
        service: &ServiceInfo,
        config: &HealthCheckConfig,
    ) -> Result<(), HealthCheckError> {
        let url = format!("{}://{}:{}{}", 
            match service.protocol {
                ServiceProtocol::Http => "http",
                ServiceProtocol::Https => "https",
                _ => return Err(HealthCheckError::UnsupportedProtocol),
            },
            service.host,
            service.port,
            config.endpoint
        );

        let response = client
            .get(&url)
            .timeout(config.timeout)
            .send()
            .await?;

        if response.status().is_success() {
            Ok(())
        } else {
            Err(HealthCheckError::Unhealthy(response.status()))
        }
    }
}
```

### 3. æœåŠ¡å‘ç°å®¢æˆ·ç«¯

```rust
/// æœåŠ¡å‘ç°å®¢æˆ·ç«¯
pub struct ServiceDiscoveryClient {
    registry: Arc<ServiceRegistry>,
    cache: Arc<RwLock<HashMap<String, (Vec<ServiceInfo>, chrono::DateTime<chrono::Utc>)>>>,
    cache_ttl: Duration,
    load_balancer: Arc<dyn LoadBalancer + Send + Sync>,
}

/// è´Ÿè½½å‡è¡¡å™¨trait
#[async_trait]
pub trait LoadBalancer {
    async fn select_service(&self, services: &[ServiceInfo]) -> Option<&ServiceInfo>;
}

/// è½®è¯¢è´Ÿè½½å‡è¡¡å™¨
pub struct RoundRobinLoadBalancer {
    current: AtomicUsize,
}

impl RoundRobinLoadBalancer {
    pub fn new() -> Self {
        Self {
            current: AtomicUsize::new(0),
        }
    }
}

#[async_trait]
impl LoadBalancer for RoundRobinLoadBalancer {
    async fn select_service(&self, services: &[ServiceInfo]) -> Option<&ServiceInfo> {
        if services.is_empty() {
            return None;
        }
        
        let index = self.current.fetch_add(1, Ordering::Relaxed) % services.len();
        Some(&services[index])
    }
}

impl ServiceDiscoveryClient {
    pub fn new(registry: Arc<ServiceRegistry>) -> Self {
        Self {
            registry,
            cache: Arc::new(RwLock::new(HashMap::new())),
            cache_ttl: Duration::from_secs(30),
            load_balancer: Arc::new(RoundRobinLoadBalancer::new()),
        }
    }

    /// å‘ç°æœåŠ¡ï¼ˆå¸¦ç¼“å­˜ï¼‰
    pub async fn discover_service(&self, service_name: &str) -> Result<Option<ServiceInfo>, RegistryError> {
        // æ£€æŸ¥ç¼“å­˜
        if let Some(cached) = self.get_from_cache(service_name).await {
            if cached.1 + chrono::Duration::from_std(self.cache_ttl).unwrap() > chrono::Utc::now() {
                return Ok(self.load_balancer.select_service(&cached.0).cloned());
            }
        }

        // ä»æ³¨å†Œä¸­å¿ƒè·å–
        let services = self.registry.discover_services(service_name).await?;
        
        if services.is_empty() {
            return Ok(None);
        }

        // æ›´æ–°ç¼“å­˜
        self.update_cache(service_name, services.clone()).await;

        // ä½¿ç”¨è´Ÿè½½å‡è¡¡å™¨é€‰æ‹©æœåŠ¡
        Ok(self.load_balancer.select_service(&services).cloned())
    }

    /// ä»ç¼“å­˜è·å–æœåŠ¡
    async fn get_from_cache(&self, service_name: &str) -> Option<(Vec<ServiceInfo>, chrono::DateTime<chrono::Utc>)> {
        let cache = self.cache.read().await;
        cache.get(service_name).cloned()
    }

    /// æ›´æ–°ç¼“å­˜
    async fn update_cache(&self, service_name: &str, services: Vec<ServiceInfo>) {
        let mut cache = self.cache.write().await;
        cache.insert(service_name.to_string(), (services, chrono::Utc::now()));
    }

    /// æ¸…é™¤ç¼“å­˜
    pub async fn clear_cache(&self) {
        let mut cache = self.cache.write().await;
        cache.clear();
    }
}
```

## ğŸ”Œ é›†æˆOTLPç›‘æ§

### 1. åˆ†å¸ƒå¼è¿½è¸ªé›†æˆ

```rust
impl ServiceRegistry {
    /// å¸¦è¿½è¸ªçš„æœåŠ¡æ³¨å†Œ
    pub async fn register_service_with_tracing(&self, service: ServiceInfo) -> Result<(), RegistryError> {
        let span = self.tracer
            .span_builder("service_registration")
            .with_kind(SpanKind::Server)
            .with_attributes(vec![
                KeyValue::new("service.name", service.name.clone()),
                KeyValue::new("service.id", service.id.clone()),
                KeyValue::new("service.version", service.version.clone()),
                KeyValue::new("service.protocol", format!("{:?}", service.protocol)),
            ])
            .start(&self.tracer);

        let _guard = span.enter();
        
        // æ‰§è¡Œæ³¨å†Œé€»è¾‘
        let result = self.register_service(service).await;
        
        // è®¾ç½®spançŠ¶æ€
        span.set_status(result.as_ref().map(|_| Status::Ok).unwrap_or(Status::Error));
        
        result
    }
}
```

### 2. æŒ‡æ ‡æ”¶é›†é›†æˆ

```rust
impl ServiceRegistry {
    /// è·å–æ³¨å†Œä¸­å¿ƒæŒ‡æ ‡
    pub async fn get_metrics(&self) -> RegistryMetricsSnapshot {
        let services = self.services.read().await;
        
        RegistryMetricsSnapshot {
            total_services: services.len(),
            healthy_services: services.values()
                .filter(|s| self.is_service_healthy(s).await)
                .count(),
            unhealthy_services: services.values()
                .filter(|s| !self.is_service_healthy(s).await)
                .count(),
            services_by_protocol: services.values()
                .fold(HashMap::new(), |mut acc, service| {
                    let protocol = format!("{:?}", service.protocol);
                    *acc.entry(protocol).or_insert(0) += 1;
                    acc
                }),
        }
    }
}

#[derive(Debug, Serialize)]
pub struct RegistryMetricsSnapshot {
    pub total_services: usize,
    pub healthy_services: usize,
    pub unhealthy_services: usize,
    pub services_by_protocol: HashMap<String, usize>,
}
```

## ğŸš€ ä½¿ç”¨ç¤ºä¾‹

### 1. æœåŠ¡æä¾›è€…æ³¨å†Œ

```rust
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // åˆå§‹åŒ–OTLP
    init_otlp().await?;
    
    // åˆ›å»ºæœåŠ¡æ³¨å†Œä¸­å¿ƒ
    let registry = Arc::new(ServiceRegistry::new()?);
    
    // åˆ›å»ºæœåŠ¡ä¿¡æ¯
    let service_info = ServiceInfo {
        id: "user-service-001".to_string(),
        name: "user-service".to_string(),
        version: "1.0.0".to_string(),
        host: "localhost".to_string(),
        port: 8080,
        protocol: ServiceProtocol::Http,
        tags: {
            let mut tags = HashMap::new();
            tags.insert("environment".to_string(), "production".to_string());
            tags.insert("team".to_string(), "backend".to_string());
            tags
        },
        metadata: {
            let mut metadata = HashMap::new();
            metadata.insert("description".to_string(), "User management service".to_string());
            metadata.insert("owner".to_string(), "backend-team".to_string());
            metadata
        },
        health_check: HealthCheckConfig {
            endpoint: "/health".to_string(),
            interval: Duration::from_secs(30),
            timeout: Duration::from_secs(5),
            retries: 3,
        },
        registration_time: chrono::Utc::now(),
        last_heartbeat: chrono::Utc::now(),
    };
    
    // æ³¨å†ŒæœåŠ¡
    registry.register_service(service_info).await?;
    
    println!("Service registered successfully!");
    
    // å¯åŠ¨å¿ƒè·³æœåŠ¡
    let registry_clone = registry.clone();
    tokio::spawn(async move {
        let mut interval = tokio::time::interval(Duration::from_secs(10));
        loop {
            interval.tick().await;
            if let Err(e) = registry_clone.update_heartbeat("user-service-001").await {
                eprintln!("Failed to update heartbeat: {}", e);
            }
        }
    });
    
    // ä¿æŒæœåŠ¡è¿è¡Œ
    tokio::signal::ctrl_c().await?;
    
    // æ³¨é”€æœåŠ¡
    registry.deregister_service("user-service-001").await?;
    
    Ok(())
}
```

### 2. æœåŠ¡æ¶ˆè´¹è€…å‘ç°

```rust
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // åˆå§‹åŒ–OTLP
    init_otlp().await?;
    
    // åˆ›å»ºæœåŠ¡æ³¨å†Œä¸­å¿ƒ
    let registry = Arc::new(ServiceRegistry::new()?);
    
    // åˆ›å»ºæœåŠ¡å‘ç°å®¢æˆ·ç«¯
    let discovery_client = ServiceDiscoveryClient::new(registry);
    
    // å‘ç°æœåŠ¡
    match discovery_client.discover_service("user-service").await? {
        Some(service) => {
            println!("Found service: {:?}", service);
            
            // è°ƒç”¨æœåŠ¡
            let client = reqwest::Client::new();
            let url = format!("http://{}:{}/users", service.host, service.port);
            let response = client.get(&url).send().await?;
            println!("Service response: {}", response.status());
        }
        None => {
            println!("No healthy user-service found");
        }
    }
    
    Ok(())
}
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–

### 1. ç¼“å­˜ç­–ç•¥

- **æœ¬åœ°ç¼“å­˜**: å‡å°‘æ³¨å†Œä¸­å¿ƒè®¿é—®é¢‘ç‡
- **TTLç¼“å­˜**: è‡ªåŠ¨è¿‡æœŸæœºåˆ¶
- **ç¼“å­˜é¢„çƒ­**: å¯åŠ¨æ—¶é¢„åŠ è½½å¸¸ç”¨æœåŠ¡

### 2. å¹¶å‘ä¼˜åŒ–

- **è¯»å†™é”**: æ”¯æŒå¹¶å‘è¯»å–
- **å¼‚æ­¥å¤„ç†**: éé˜»å¡æ“ä½œ
- **è¿æ¥æ± **: å¤ç”¨HTTPè¿æ¥

### 3. ç›‘æ§ä¼˜åŒ–

- **æ‰¹é‡æŒ‡æ ‡**: å‡å°‘æŒ‡æ ‡æ›´æ–°é¢‘ç‡
- **é‡‡æ ·ç­–ç•¥**: æ™ºèƒ½é‡‡æ ·å‡å°‘å¼€é”€
- **å¼‚æ­¥ä¸ŠæŠ¥**: éé˜»å¡ç›‘æ§æ•°æ®ä¸ŠæŠ¥

## ğŸ”’ å®‰å…¨è€ƒè™‘

### 1. è®¤è¯æˆæƒ

```rust
/// æœåŠ¡è®¤è¯ä¿¡æ¯
#[derive(Debug, Clone)]
pub struct ServiceAuth {
    pub token: String,
    pub permissions: Vec<String>,
}

impl ServiceRegistry {
    /// å¸¦è®¤è¯çš„æœåŠ¡æ³¨å†Œ
    pub async fn register_service_with_auth(
        &self, 
        service: ServiceInfo, 
        auth: ServiceAuth
    ) -> Result<(), RegistryError> {
        // éªŒè¯è®¤è¯ä¿¡æ¯
        self.validate_auth(&auth)?;
        
        // æ‰§è¡Œæ³¨å†Œ
        self.register_service(service).await
    }
    
    fn validate_auth(&self, auth: &ServiceAuth) -> Result<(), RegistryError> {
        // å®ç°è®¤è¯é€»è¾‘
        // éªŒè¯tokenã€æ£€æŸ¥æƒé™ç­‰
        Ok(())
    }
}
```

### 2. æ•°æ®åŠ å¯†

- **ä¼ è¾“åŠ å¯†**: TLS/SSLåŠ å¯†é€šä¿¡
- **å­˜å‚¨åŠ å¯†**: æ•æ„Ÿæ•°æ®åŠ å¯†å­˜å‚¨
- **å¯†é’¥ç®¡ç†**: å®‰å…¨çš„å¯†é’¥è½®æ¢æœºåˆ¶

## ğŸ“š å‚è€ƒèµ„æ–™

1. [ConsulæœåŠ¡å‘ç°](https://www.consul.io/docs/discovery)
2. [etcdæœåŠ¡å‘ç°](https://etcd.io/docs/)
3. [OpenTelemetry Rust](https://opentelemetry.io/docs/instrumentation/rust/)
4. [å¾®æœåŠ¡æ¶æ„æ¨¡å¼](https://microservices.io/)

---

**æ³¨æ„**: æœ¬æ–‡æ¡£åŸºäºRust 1.90å’Œæœ€æ–°çš„å¾®æœåŠ¡æœ€ä½³å®è·µï¼Œå°†æŒç»­æ›´æ–°ä»¥åæ˜ æŠ€æœ¯å‘å±•ã€‚
