# OTLP Rust 快速开始指南

## 🚀 5分钟快速上手

本指南将帮助您在5分钟内快速上手OTLP Rust实现，从安装到发送第一条遥测数据。

## 📋 前置要求

### 系统要求

- **Rust 1.90+**: 确保安装了最新版本的Rust
- **网络连接**: 用于下载依赖和发送数据
- **基本Rust知识**: 了解基础的Rust语法

### 检查Rust版本

```bash
rustc --version
# 应该显示 rustc 1.90.0 或更高版本

cargo --version
# 应该显示 cargo 1.90.0 或更高版本
```

## 📦 第一步：创建项目

### 1.1 创建新项目

```bash
cargo new my-otlp-app
cd my-otlp-app
```

### 1.2 添加依赖

编辑 `Cargo.toml` 文件：

```toml
[package]
name = "my-otlp-app"
version = "0.1.0"
edition = "2021"

[dependencies]
c21_otlp = "0.1.0"
tokio = { version = "1.35", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
anyhow = "1.0"
```

## 🔧 第二步：基础配置

### 2.1 创建基础配置

创建 `src/main.rs` 文件：

```rust
use c21_otlp::{OtlpClient, OtlpConfig, TelemetryData};
use c21_otlp::data::{LogSeverity, StatusCode};
use c21_otlp::transport::TransportProtocol;
use std::time::Duration;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("🚀 启动 OTLP 应用...");
    
    // 创建基础配置
    let config = OtlpConfig::default()
        .with_endpoint("http://localhost:4317")
        .with_protocol(TransportProtocol::Grpc)
        .with_service("my-first-app", "1.0.0")
        .with_timeout(Duration::from_secs(10));
    
    println!("✅ 配置创建完成");
    
    // 创建客户端
    let client = OtlpClient::new(config).await?;
    client.initialize().await?;
    
    println!("✅ 客户端初始化完成");
    
    Ok(())
}
```

### 2.2 测试基础连接

```bash
cargo run
```

如果看到以下输出，说明基础配置成功：

```text
🚀 启动 OTLP 应用...
✅ 配置创建完成
✅ 客户端初始化完成
```

## 📊 第三步：发送第一条追踪数据

### 3.1 发送简单追踪

更新 `src/main.rs`：

```rust
use c21_otlp::{OtlpClient, OtlpConfig, TelemetryData};
use c21_otlp::data::{LogSeverity, StatusCode};
use c21_otlp::transport::TransportProtocol;
use std::time::Duration;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("🚀 启动 OTLP 应用...");
    
    // 创建配置
    let config = OtlpConfig::default()
        .with_endpoint("http://localhost:4317")
        .with_protocol(TransportProtocol::Grpc)
        .with_service("my-first-app", "1.0.0")
        .with_timeout(Duration::from_secs(10));
    
    // 创建并初始化客户端
    let client = OtlpClient::new(config).await?;
    client.initialize().await?;
    
    println!("✅ 客户端初始化完成");
    
    // 发送第一条追踪数据
    println!("📤 发送追踪数据...");
    
    let result = client.send_trace("hello-world-operation").await?
        .with_attribute("service.name", "my-first-app")
        .with_attribute("service.version", "1.0.0")
        .with_attribute("operation.type", "demo")
        .with_numeric_attribute("duration", 150.0)
        .with_status(StatusCode::Ok, Some("操作成功".to_string()))
        .finish()
        .await?;
    
    println!("✅ 追踪数据发送成功: {} 条", result.success_count);
    
    // 关闭客户端
    client.shutdown().await?;
    println!("🔚 应用关闭完成");
    
    Ok(())
}
```

### 3.2 运行并查看结果

```bash
cargo run
```

期望输出：

```text
🚀 启动 OTLP 应用...
✅ 客户端初始化完成
📤 发送追踪数据...
✅ 追踪数据发送成功: 1 条
🔚 应用关闭完成
```

## 📈 第四步：发送指标数据

### 4.1 添加指标发送

在追踪数据发送后添加指标发送：

```rust
    // 发送指标数据
    println!("📊 发送指标数据...");
    
    let metric_result = client.send_metric("request_count", 1.0).await?
        .with_label("method", "GET")
        .with_label("endpoint", "/hello")
        .with_description("Hello World 请求计数")
        .with_unit("count")
        .send()
        .await?;
    
    println!("✅ 指标数据发送成功: {} 条", metric_result.success_count);
```

### 4.2 发送延迟指标

```rust
    // 发送延迟指标
    let latency_result = client.send_metric("request_duration", 150.0).await?
        .with_label("operation", "hello-world")
        .with_label("status", "success")
        .with_description("请求处理延迟")
        .with_unit("milliseconds")
        .send()
        .await?;
    
    println!("✅ 延迟指标发送成功: {} 条", latency_result.success_count);
```

## 📝 第五步：发送日志数据

### 5.1 添加日志发送

```rust
    // 发送日志数据
    println!("📝 发送日志数据...");
    
    let log_result = client.send_log("Hello World 应用启动", LogSeverity::Info).await?
        .with_attribute("app.name", "my-first-app")
        .with_attribute("app.version", "1.0.0")
        .with_attribute("environment", "development")
        .with_trace_context("trace-123", "span-456")
        .send()
        .await?;
    
    println!("✅ 日志数据发送成功: {} 条", log_result.success_count);
```

## 🔄 第六步：批量发送数据

### 6.1 批量发送示例

```rust
    // 批量发送数据
    println!("📦 批量发送数据...");
    
    let mut batch_data = Vec::new();
    
    // 创建多个追踪数据
    for i in 0..5 {
        let trace_data = TelemetryData::trace(format!("batch-operation-{}", i))
            .with_attribute("batch_id", "demo-batch-001")
            .with_attribute("operation_index", i.to_string())
            .with_attribute("batch_size", "5");
        
        batch_data.push(trace_data);
    }
    
    let batch_result = client.send_batch(batch_data).await?;
    println!("✅ 批量数据发送成功: {} 条", batch_result.success_count);
```

## 🎯 完整示例代码

### 完整的 main.rs

```rust
use c21_otlp::{OtlpClient, OtlpConfig, TelemetryData};
use c21_otlp::data::{LogSeverity, StatusCode};
use c21_otlp::transport::TransportProtocol;
use std::time::Duration;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("🚀 启动 OTLP 应用...");
    
    // 创建配置
    let config = OtlpConfig::default()
        .with_endpoint("http://localhost:4317")
        .with_protocol(TransportProtocol::Grpc)
        .with_service("my-first-app", "1.0.0")
        .with_timeout(Duration::from_secs(10));
    
    // 创建并初始化客户端
    let client = OtlpClient::new(config).await?;
    client.initialize().await?;
    
    println!("✅ 客户端初始化完成");
    
    // 1. 发送追踪数据
    println!("📤 发送追踪数据...");
    
    let trace_result = client.send_trace("hello-world-operation").await?
        .with_attribute("service.name", "my-first-app")
        .with_attribute("service.version", "1.0.0")
        .with_attribute("operation.type", "demo")
        .with_numeric_attribute("duration", 150.0)
        .with_status(StatusCode::Ok, Some("操作成功".to_string()))
        .finish()
        .await?;
    
    println!("✅ 追踪数据发送成功: {} 条", trace_result.success_count);
    
    // 2. 发送指标数据
    println!("📊 发送指标数据...");
    
    let metric_result = client.send_metric("request_count", 1.0).await?
        .with_label("method", "GET")
        .with_label("endpoint", "/hello")
        .with_description("Hello World 请求计数")
        .with_unit("count")
        .send()
        .await?;
    
    println!("✅ 指标数据发送成功: {} 条", metric_result.success_count);
    
    // 3. 发送日志数据
    println!("📝 发送日志数据...");
    
    let log_result = client.send_log("Hello World 应用启动", LogSeverity::Info).await?
        .with_attribute("app.name", "my-first-app")
        .with_attribute("app.version", "1.0.0")
        .with_attribute("environment", "development")
        .with_trace_context("trace-123", "span-456")
        .send()
        .await?;
    
    println!("✅ 日志数据发送成功: {} 条", log_result.success_count);
    
    // 4. 批量发送数据
    println!("📦 批量发送数据...");
    
    let mut batch_data = Vec::new();
    
    for i in 0..5 {
        let trace_data = TelemetryData::trace(format!("batch-operation-{}", i))
            .with_attribute("batch_id", "demo-batch-001")
            .with_attribute("operation_index", i.to_string())
            .with_attribute("batch_size", "5");
        
        batch_data.push(trace_data);
    }
    
    let batch_result = client.send_batch(batch_data).await?;
    println!("✅ 批量数据发送成功: {} 条", batch_result.success_count);
    
    // 关闭客户端
    client.shutdown().await?;
    println!("🔚 应用关闭完成");
    
    Ok(())
}
```

## 🐳 第七步：设置OTLP收集器（可选）

### 7.1 使用Docker运行收集器

```bash
# 启动OpenTelemetry收集器
docker run -p 4317:4317 -p 4318:4318 \
  -v $(pwd)/collector-config.yaml:/etc/collector-config.yaml \
  otel/opentelemetry-collector:latest \
  --config=/etc/collector-config.yaml
```

### 7.2 基础收集器配置

创建 `collector-config.yaml`：

```yaml
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317
      http:
        endpoint: 0.0.0.0:4318

processors:
  batch:

exporters:
  logging:
    loglevel: debug

service:
  pipelines:
    traces:
      receivers: [otlp]
      processors: [batch]
      exporters: [logging]
    metrics:
      receivers: [otlp]
      processors: [batch]
      exporters: [logging]
    logs:
      receivers: [otlp]
      processors: [batch]
      exporters: [logging]
```

## 🎯 运行完整示例

### 8.1 启动收集器

```bash
docker run -p 4317:4317 -p 4318:4318 \
  -v $(pwd)/collector-config.yaml:/etc/collector-config.yaml \
  otel/opentelemetry-collector:latest \
  --config=/etc/collector-config.yaml
```

### 8.2 运行应用

```bash
cargo run
```

### 8.3 查看输出

您应该看到类似以下的输出：

```text
🚀 启动 OTLP 应用...
✅ 客户端初始化完成
📤 发送追踪数据...
✅ 追踪数据发送成功: 1 条
📊 发送指标数据...
✅ 指标数据发送成功: 1 条
📝 发送日志数据...
✅ 日志数据发送成功: 1 条
📦 批量发送数据...
✅ 批量数据发送成功: 5 条
🔚 应用关闭完成
```

## 🎉 恭喜

您已经成功完成了OTLP Rust的快速开始！您现在可以：

- ✅ 创建和配置OTLP客户端
- ✅ 发送追踪数据
- ✅ 发送指标数据
- ✅ 发送日志数据
- ✅ 批量发送数据

## 🚀 下一步

### 深入学习

1. **[高级配置指南](../03_技术实现/Rust实现/高级配置.md)** - 学习高级配置选项
2. **[架构设计模式](../04_架构设计/设计模式/创建型模式.md)** - 了解设计模式应用
3. **[性能优化策略](../03_技术实现/性能优化/内存优化.md)** - 优化应用性能
4. **[最佳实践指南](../04_架构设计/最佳实践/配置管理.md)** - 学习最佳实践

### 实际应用

1. **[Web应用集成](../05_实践应用/集成指南/Web应用集成.md)** - 集成到Web应用
2. **[微服务架构](../04_架构设计/系统架构/微服务架构.md)** - 微服务环境部署
3. **[云原生部署](../05_实践应用/部署运维/容器化部署.md)** - Kubernetes部署
4. **[监控告警设置](../05_实践应用/部署运维/监控告警.md)** - 建立监控体系

### 问题解决

1. **[常见问题解答](../09_参考资料/常见问题/使用问题.md)** - 解决常见问题
2. **[故障排查指南](../05_实践应用/部署运维/故障排查.md)** - 故障排查方法
3. **[性能问题诊断](../09_参考资料/常见问题/性能问题.md)** - 性能问题解决

## 📞 获取帮助

- **GitHub Issues**: 报告问题或提出建议
- **社区讨论**: 参与技术讨论
- **文档反馈**: 帮助改进文档
- **代码贡献**: 贡献代码改进

---

**快速开始指南版本**: v1.0  
**最后更新**: 2025年1月27日  
**维护者**: OTLP 2025 文档团队

> **下一步**: 查看 [📋 文档导航索引](文档导航索引.md) 了解更多详细信息
