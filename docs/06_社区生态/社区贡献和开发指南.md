# ç¤¾åŒºè´¡çŒ®å’Œå¼€å‘æŒ‡å—

## ğŸ“‹ ç›®å½•

- [é¡¹ç›®æ¦‚è§ˆ](#é¡¹ç›®æ¦‚è§ˆ)
- [å¼€å‘ç¯å¢ƒè®¾ç½®](#å¼€å‘ç¯å¢ƒè®¾ç½®)
- [è´¡çŒ®æµç¨‹](#è´¡çŒ®æµç¨‹)
- [ä»£ç è§„èŒƒ](#ä»£ç è§„èŒƒ)
- [æµ‹è¯•æŒ‡å—](#æµ‹è¯•æŒ‡å—)
- [æ–‡æ¡£è´¡çŒ®](#æ–‡æ¡£è´¡çŒ®)
- [å‘å¸ƒæµç¨‹](#å‘å¸ƒæµç¨‹)
- [ç¤¾åŒºæ²»ç†](#ç¤¾åŒºæ²»ç†)
- [å¼€å‘è€…èµ„æº](#å¼€å‘è€…èµ„æº)

## ğŸ¯ é¡¹ç›®æ¦‚è§ˆ

### 1. é¡¹ç›®ç›®æ ‡

OTLP Rust é¡¹ç›®æ—¨åœ¨æä¾›ï¼š

- é«˜æ€§èƒ½çš„ OpenTelemetry Protocol (OTLP) Rust å®ç°
- å®Œæ•´çš„å¯è§‚æµ‹æ€§æ•°æ®æ”¶é›†ã€å¤„ç†å’Œå¯¼å‡ºèƒ½åŠ›
- äº‘åŸç”Ÿå‹å¥½çš„æ¶æ„è®¾è®¡
- ä¼ä¸šçº§çš„å®‰å…¨å’Œå¯é æ€§ä¿éšœ

### 2. æŠ€æœ¯æ ˆ

```text
æ ¸å¿ƒæŠ€æœ¯æ ˆï¼š
â”œâ”€â”€ Rust 1.90+ (ç³»ç»Ÿç¼–ç¨‹è¯­è¨€)
â”œâ”€â”€ Tokio (å¼‚æ­¥è¿è¡Œæ—¶)
â”œâ”€â”€ Prost (Protocol Buffers)
â”œâ”€â”€ Serde (åºåˆ—åŒ–/ååºåˆ—åŒ–)
â”œâ”€â”€ Tonic (gRPC å®¢æˆ·ç«¯/æœåŠ¡ç«¯)
â”œâ”€â”€ Hyper (HTTP å®¢æˆ·ç«¯/æœåŠ¡ç«¯)
â”œâ”€â”€ Tracing (ç»“æ„åŒ–æ—¥å¿—)
â””â”€â”€ Metrics (æ€§èƒ½ç›‘æ§)

æµ‹è¯•æ¡†æ¶ï¼š
â”œâ”€â”€ Criterion (æ€§èƒ½åŸºå‡†æµ‹è¯•)
â”œâ”€â”€ Proptest (å±æ€§æµ‹è¯•)
â”œâ”€â”€ Mockall (Mock æµ‹è¯•)
â””â”€â”€ Tokio-test (å¼‚æ­¥æµ‹è¯•)

å¼€å‘å·¥å…·ï¼š
â”œâ”€â”€ Clippy (ä»£ç æ£€æŸ¥)
â”œâ”€â”€ Rustfmt (ä»£ç æ ¼å¼åŒ–)
â”œâ”€â”€ Cargo (åŒ…ç®¡ç†)
â””â”€â”€ Cross (äº¤å‰ç¼–è¯‘)
```

### 3. é¡¹ç›®ç»“æ„

```text
otlp/
â”œâ”€â”€ src/                    # æºä»£ç 
â”‚   â”œâ”€â”€ lib.rs             # åº“å…¥å£
â”‚   â”œâ”€â”€ client/            # å®¢æˆ·ç«¯å®ç°
â”‚   â”œâ”€â”€ server/            # æœåŠ¡ç«¯å®ç°
â”‚   â”œâ”€â”€ exporter/          # å¯¼å‡ºå™¨å®ç°
â”‚   â”œâ”€â”€ collector/         # æ”¶é›†å™¨å®ç°
â”‚   â”œâ”€â”€ config/            # é…ç½®ç®¡ç†
â”‚   â”œâ”€â”€ metrics/           # æŒ‡æ ‡å®ç°
â”‚   â”œâ”€â”€ trace/             # è¿½è¸ªå®ç°
â”‚   â”œâ”€â”€ logs/              # æ—¥å¿—å®ç°
â”‚   â””â”€â”€ utils/             # å·¥å…·å‡½æ•°
â”œâ”€â”€ tests/                  # é›†æˆæµ‹è¯•
â”œâ”€â”€ benches/               # æ€§èƒ½åŸºå‡†æµ‹è¯•
â”œâ”€â”€ examples/              # ç¤ºä¾‹ä»£ç 
â”œâ”€â”€ docs/                  # é¡¹ç›®æ–‡æ¡£
â”œâ”€â”€ Cargo.toml            # é¡¹ç›®é…ç½®
â””â”€â”€ README.md             # é¡¹ç›®è¯´æ˜
```

## ğŸ›  å¼€å‘ç¯å¢ƒè®¾ç½®

### 1. ç³»ç»Ÿè¦æ±‚

```bash
# æœ€ä½è¦æ±‚
Rust: 1.90.0+
Cargo: 1.90.0+
Git: 2.30.0+
Docker: 20.10.0+ (å¯é€‰)

# æ¨èé…ç½®
Rust: 1.95.0+
Cargo: 1.95.0+
Git: 2.40.0+
Docker: 24.0.0+
```

### 2. å¼€å‘ç¯å¢ƒå®‰è£…

```bash
# 1. å®‰è£… Rust (å¦‚æœæœªå®‰è£…)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source ~/.cargo/env

# 2. å®‰è£…å¼€å‘å·¥å…·
rustup component add rustfmt clippy
cargo install cargo-audit cargo-tarpaulin cargo-criterion

# 3. å…‹éš†é¡¹ç›®
git clone https://github.com/your-org/otlp-rust.git
cd otlp-rust

# 4. å®‰è£…ä¾èµ–
cargo build

# 5. è¿è¡Œæµ‹è¯•
cargo test

# 6. è¿è¡ŒåŸºå‡†æµ‹è¯•
cargo bench
```

### 3. IDE é…ç½®

#### VS Code é…ç½®

```json
{
  "rust-analyzer.checkOnSave.command": "clippy",
  "rust-analyzer.cargo.features": "all",
  "rust-analyzer.procMacro.enable": true,
  "rust-analyzer.completion.autoimport.enable": true,
  "rust-analyzer.diagnostics.enable": true,
  "rust-analyzer.lens.enable": true,
  "rust-analyzer.hover.actions.enable": true,
  "rust-analyzer.hover.documentation.enable": true,
  "rust-analyzer.inlayHints.enable": true,
  "rust-analyzer.inlayHints.parameterHints.enable": true,
  "rust-analyzer.inlayHints.typeHints.enable": true,
  "rust-analyzer.inlayHints.chainingHints.enable": true,
  "rust-analyzer.inlayHints.maxLength": 25,
  "rust-analyzer.completion.snippets.custom": {
    "Arc::new": {
      "postfix": "arc",
      "body": "Arc::new(${receiver})",
      "requires": "std::sync::Arc",
      "description": "Put the expression into an `Arc`"
    }
  }
}
```

#### IntelliJ IDEA é…ç½®

```yaml
# .idea/rust.xml
<component name="RustProjectSettings">
  <option name="autoImport" value="true" />
  <option name="checkOnSave" value="true" />
  <option name="clippyOnSave" value="true" />
  <option name="rustfmtOnSave" value="true" />
</component>
```

### 4. Git é’©å­é…ç½®

```bash
# å®‰è£… pre-commit é’©å­
cp scripts/pre-commit .git/hooks/
chmod +x .git/hooks/pre-commit

# pre-commit è„šæœ¬å†…å®¹
#!/bin/bash
set -e

echo "Running pre-commit checks..."

# ä»£ç æ ¼å¼åŒ–
cargo fmt --all -- --check

# ä»£ç æ£€æŸ¥
cargo clippy --all-targets --all-features -- -D warnings

# è¿è¡Œæµ‹è¯•
cargo test

# å®‰å…¨æ£€æŸ¥
cargo audit

echo "All checks passed!"
```

## ğŸ”„ è´¡çŒ®æµç¨‹

### 1. Fork å’Œå…‹éš†

```bash
# 1. Fork é¡¹ç›®åˆ°ä½ çš„ GitHub è´¦æˆ·
# 2. å…‹éš†ä½ çš„ Fork
git clone https://github.com/your-username/otlp-rust.git
cd otlp-rust

# 3. æ·»åŠ ä¸Šæ¸¸ä»“åº“
git remote add upstream https://github.com/your-org/otlp-rust.git

# 4. åˆ›å»ºå¼€å‘åˆ†æ”¯
git checkout -b feature/your-feature-name
```

### 2. å¼€å‘å·¥ä½œæµ

```bash
# 1. ç¡®ä¿ä»£ç æ˜¯æœ€æ–°çš„
git fetch upstream
git rebase upstream/main

# 2. è¿›è¡Œå¼€å‘
# ç¼–å†™ä»£ç ã€æµ‹è¯•ã€æ–‡æ¡£

# 3. æäº¤ä»£ç 
git add .
git commit -m "feat: add new feature X"

# 4. æ¨é€åˆ†æ”¯
git push origin feature/your-feature-name

# 5. åˆ›å»º Pull Request
```

### 3. æäº¤ä¿¡æ¯è§„èŒƒ

ä½¿ç”¨ [Conventional Commits](https://www.conventionalcommits.org/) è§„èŒƒï¼š

```text
<type>[optional scope]: <description>

[optional body]

[optional footer(s)]
```

#### ç±»å‹è¯´æ˜

```text
feat:     æ–°åŠŸèƒ½
fix:      ä¿®å¤bug
docs:     æ–‡æ¡£æ›´æ–°
style:    ä»£ç æ ¼å¼è°ƒæ•´
refactor: ä»£ç é‡æ„
test:     æµ‹è¯•ç›¸å…³
chore:    æ„å»ºè¿‡ç¨‹æˆ–è¾…åŠ©å·¥å…·çš„å˜åŠ¨
perf:     æ€§èƒ½ä¼˜åŒ–
ci:       CI/CD ç›¸å…³
build:    æ„å»ºç³»ç»Ÿç›¸å…³
```

#### ç¤ºä¾‹

```bash
# æ–°åŠŸèƒ½
git commit -m "feat(client): add async batch sending support"

# ä¿®å¤bug
git commit -m "fix(exporter): handle connection timeout properly"

# æ–‡æ¡£æ›´æ–°
git commit -m "docs: update API documentation for v1.0.0"

# æ€§èƒ½ä¼˜åŒ–
git commit -m "perf(metrics): optimize memory allocation in batch processing"

# ç ´åæ€§å˜æ›´
git commit -m "feat!: remove deprecated sync API

BREAKING CHANGE: The sync API has been removed in favor of async-only API"
```

### 4. Pull Request æµç¨‹

#### PR æ¨¡æ¿

```markdown
## ğŸ“ å˜æ›´æè¿°

ç®€è¦æè¿°æ­¤ PR çš„å˜æ›´å†…å®¹ã€‚

## ğŸ¯ å˜æ›´ç±»å‹

- [ ] æ–°åŠŸèƒ½
- [ ] Bug ä¿®å¤
- [ ] æ–‡æ¡£æ›´æ–°
- [ ] æ€§èƒ½ä¼˜åŒ–
- [ ] ä»£ç é‡æ„
- [ ] æµ‹è¯•æ”¹è¿›
- [ ] å…¶ä»– (è¯·æè¿°)

## ğŸ”— ç›¸å…³ Issue

å…³é—­ #(issueç¼–å·)

## ğŸ“‹ å˜æ›´æ¸…å•

- [ ] ä»£ç å·²é€šè¿‡æ‰€æœ‰æµ‹è¯•
- [ ] æ–°å¢ä»£ç å·²æ·»åŠ æµ‹è¯•
- [ ] æ–‡æ¡£å·²æ›´æ–°
- [ ] ä»£ç å·²é€šè¿‡ Clippy æ£€æŸ¥
- [ ] ä»£ç å·²æ ¼å¼åŒ–
- [ ] æ€§èƒ½æµ‹è¯•å·²é€šè¿‡
- [ ] å®‰å…¨æ£€æŸ¥å·²é€šè¿‡

## ğŸ§ª æµ‹è¯•è¯´æ˜

æè¿°å¦‚ä½•æµ‹è¯•æ­¤å˜æ›´ã€‚

## ğŸ“¸ æˆªå›¾ (å¦‚é€‚ç”¨)

æ·»åŠ ç›¸å…³æˆªå›¾ã€‚

## ğŸ“š é™„åŠ ä¿¡æ¯

ä»»ä½•å…¶ä»–ç›¸å…³ä¿¡æ¯ã€‚
```

#### PR å®¡æŸ¥æµç¨‹

```text
1. è‡ªåŠ¨æ£€æŸ¥ (CI/CD)
   â”œâ”€â”€ ä»£ç æ ¼å¼åŒ–æ£€æŸ¥
   â”œâ”€â”€ Clippy ä»£ç æ£€æŸ¥
   â”œâ”€â”€ å•å…ƒæµ‹è¯•
   â”œâ”€â”€ é›†æˆæµ‹è¯•
   â”œâ”€â”€ æ€§èƒ½åŸºå‡†æµ‹è¯•
   â”œâ”€â”€ å®‰å…¨æ£€æŸ¥
   â””â”€â”€ æ–‡æ¡£æ„å»ºæ£€æŸ¥

2. äººå·¥å®¡æŸ¥
   â”œâ”€â”€ ä»£ç è´¨é‡å®¡æŸ¥
   â”œâ”€â”€ æ¶æ„è®¾è®¡å®¡æŸ¥
   â”œâ”€â”€ æ€§èƒ½å½±å“è¯„ä¼°
   â”œâ”€â”€ å®‰å…¨æ€§å®¡æŸ¥
   â””â”€â”€ æ–‡æ¡£å®Œæ•´æ€§æ£€æŸ¥

3. åˆå¹¶è¦æ±‚
   â”œâ”€â”€ è‡³å°‘ 2 ä¸ªç»´æŠ¤è€…æ‰¹å‡†
   â”œâ”€â”€ æ‰€æœ‰ CI æ£€æŸ¥é€šè¿‡
   â”œâ”€â”€ æ— å†²çª
   â””â”€â”€ ç¬¦åˆé¡¹ç›®æ ‡å‡†
```

## ğŸ“ ä»£ç è§„èŒƒ

### 1. Rust ä»£ç è§„èŒƒ

#### å‘½åè§„èŒƒ

```rust
// æ¨¡å—å’ŒåŒ…åï¼šsnake_case
mod otlp_client;
use otlp_client::batch_sender;

// ç»“æ„ä½“å’Œæšä¸¾ï¼šPascalCase
struct OtlpConfig {
    endpoint: String,
    timeout: Duration,
}

enum OtlpError {
    ConnectionFailed,
    SerializationError,
}

// å‡½æ•°å’Œå˜é‡ï¼šsnake_case
fn create_otlp_client(config: OtlpConfig) -> Result<OtlpClient, OtlpError> {
    let client_config = ClientConfig::new(config.endpoint);
    Ok(OtlpClient::new(client_config))
}

// å¸¸é‡ï¼šSCREAMING_SNAKE_CASE
const DEFAULT_TIMEOUT_SECONDS: u64 = 30;
const MAX_BATCH_SIZE: usize = 1000;

// ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼šçŸ­åç§°
fn process_data<'a, 'b>(data: &'a [u8], buffer: &'b mut Vec<u8>) -> Result<(), Error>
where
    'a: 'b,
{
    // å®ç°
}
```

#### æ–‡æ¡£è§„èŒƒ

```rust
/// OTLP å®¢æˆ·ç«¯é…ç½®
///
/// ç”¨äºé…ç½® OpenTelemetry Protocol å®¢æˆ·ç«¯çš„è¡Œä¸ºå‚æ•°ã€‚
///
/// # ç¤ºä¾‹
///
/// ```rust
/// use otlp::client::OtlpConfig;
/// use std::time::Duration;
///
/// let config = OtlpConfig::builder()
///     .endpoint("http://localhost:4317")
///     .timeout(Duration::from_secs(30))
///     .build();
/// ```
///
/// # é”™è¯¯å¤„ç†
///
/// é…ç½®éªŒè¯å¤±è´¥æ—¶ä¼šè¿”å›ç›¸åº”çš„é”™è¯¯ç±»å‹ã€‚
///
/// # æ€§èƒ½è€ƒè™‘
///
/// å»ºè®®åœ¨ç”Ÿäº§ç¯å¢ƒä¸­è®¾ç½®åˆé€‚çš„è¶…æ—¶æ—¶é—´å’Œæ‰¹å¤„ç†å¤§å°ã€‚
#[derive(Debug, Clone)]
pub struct OtlpConfig {
    /// æœåŠ¡å™¨ç«¯ç‚¹ URL
    pub endpoint: String,
    /// è¯·æ±‚è¶…æ—¶æ—¶é—´
    pub timeout: Duration,
    /// æ‰¹å¤„ç†å¤§å°
    pub batch_size: usize,
}

impl OtlpConfig {
    /// åˆ›å»ºæ–°çš„é…ç½®æ„å»ºå™¨
    ///
    /// # è¿”å›å€¼
    ///
    /// è¿”å›é…ç½®æ„å»ºå™¨å®ä¾‹
    pub fn builder() -> OtlpConfigBuilder {
        OtlpConfigBuilder::new()
    }
}
```

#### é”™è¯¯å¤„ç†è§„èŒƒ

```rust
use thiserror::Error;

/// OTLP å®¢æˆ·ç«¯é”™è¯¯ç±»å‹
#[derive(Error, Debug)]
pub enum OtlpError {
    #[error("è¿æ¥å¤±è´¥: {0}")]
    ConnectionFailed(String),
    
    #[error("åºåˆ—åŒ–é”™è¯¯: {0}")]
    SerializationError(#[from] serde_json::Error),
    
    #[error("ç½‘ç»œé”™è¯¯: {0}")]
    NetworkError(#[from] reqwest::Error),
    
    #[error("é…ç½®é”™è¯¯: {0}")]
    ConfigError(String),
    
    #[error("è¶…æ—¶é”™è¯¯: æ“ä½œåœ¨ {timeout:?} åè¶…æ—¶")]
    TimeoutError {
        timeout: Duration,
    },
    
    #[error("æ‰¹å¤„ç†é”™è¯¯: æ‰¹å¤§å° {batch_size} è¶…è¿‡æœ€å¤§é™åˆ¶ {max_size}")]
    BatchSizeError {
        batch_size: usize,
        max_size: usize,
    },
}

// ç»“æœç±»å‹åˆ«å
pub type OtlpResult<T> = Result<T, OtlpError>;

// é”™è¯¯å¤„ç†ç¤ºä¾‹
fn send_batch(&self, batch: &[Span]) -> OtlpResult<()> {
    if batch.len() > self.config.max_batch_size {
        return Err(OtlpError::BatchSizeError {
            batch_size: batch.len(),
            max_size: self.config.max_batch_size,
        });
    }
    
    // å®é™…å‘é€é€»è¾‘
    Ok(())
}
```

### 2. æµ‹è¯•è§„èŒƒ

#### å•å…ƒæµ‹è¯•

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tokio_test;
    use mockall::predicate::*;

    #[tokio::test]
    async fn test_otlp_client_creation() {
        let config = OtlpConfig::builder()
            .endpoint("http://localhost:4317")
            .timeout(Duration::from_secs(30))
            .build();
        
        let client = OtlpClient::new(config).await;
        assert!(client.is_ok());
    }

    #[tokio::test]
    async fn test_batch_sending() {
        let mut mock_transport = MockTransport::new();
        mock_transport
            .expect_send()
            .times(1)
            .returning(|_| Ok(()));
        
        let client = OtlpClient::with_transport(mock_transport);
        let spans = create_test_spans(10);
        
        let result = client.send_batch(spans).await;
        assert!(result.is_ok());
    }

    #[test]
    fn test_config_validation() {
        // æµ‹è¯•æœ‰æ•ˆé…ç½®
        let valid_config = OtlpConfig::builder()
            .endpoint("http://localhost:4317")
            .build();
        assert!(valid_config.is_ok());
        
        // æµ‹è¯•æ— æ•ˆé…ç½®
        let invalid_config = OtlpConfig::builder()
            .endpoint("invalid-url")
            .build();
        assert!(invalid_config.is_err());
    }
}
```

#### é›†æˆæµ‹è¯•

```rust
#[cfg(test)]
mod integration_tests {
    use super::*;
    use testcontainers::*;
    use testcontainers::images::generic::GenericImage;

    #[tokio::test]
    async fn test_end_to_end_trace_collection() {
        // å¯åŠ¨æµ‹è¯•å®¹å™¨
        let docker = clients::Cli::default();
        let otel_collector = docker.run(
            GenericImage::new("otel/opentelemetry-collector", "latest")
                .with_exposed_port(4317)
        );
        
        let collector_port = otel_collector.get_host_port_ipv4(4317);
        
        // åˆ›å»ºå®¢æˆ·ç«¯
        let config = OtlpConfig::builder()
            .endpoint(&format!("http://localhost:{}", collector_port))
            .build();
        
        let client = OtlpClient::new(config).await.unwrap();
        
        // å‘é€æµ‹è¯•æ•°æ®
        let span = create_test_span();
        let result = client.send_span(span).await;
        
        assert!(result.is_ok());
        
        // éªŒè¯æ•°æ®æ¥æ”¶
        // è¿™é‡Œå¯ä»¥æ·»åŠ éªŒè¯é€»è¾‘
    }
}
```

#### å±æ€§æµ‹è¯•

```rust
use proptest::prelude::*;

proptest! {
    #[test]
    fn test_batch_size_properties(
        batch_size in 1..1000usize,
        data_size in 1..10000usize
    ) {
        let data = vec![0u8; data_size];
        let batches = create_batches(&data, batch_size);
        
        // å±æ€§ï¼šæ‰€æœ‰æ‰¹æ¬¡çš„å¤§å°éƒ½ä¸è¶…è¿‡æŒ‡å®šå¤§å°
        for batch in &batches {
            prop_assert!(batch.len() <= batch_size);
        }
        
        // å±æ€§ï¼šæ‰€æœ‰æ•°æ®éƒ½è¢«åŒ…å«åœ¨æ‰¹æ¬¡ä¸­
        let total_size: usize = batches.iter().map(|b| b.len()).sum();
        prop_assert_eq!(total_size, data_size);
    }
}
```

### 3. æ€§èƒ½æµ‹è¯•

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn benchmark_batch_processing(c: &mut Criterion) {
    let mut group = c.benchmark_group("batch_processing");
    
    // æµ‹è¯•ä¸åŒæ‰¹å¤§å°çš„æ€§èƒ½
    for batch_size in [10, 100, 1000, 10000].iter() {
        group.bench_with_input(
            format!("batch_size_{}", batch_size),
            batch_size,
            |b, &size| {
                let spans = create_test_spans(size);
                b.iter(|| {
                    let result = process_batch(black_box(&spans));
                    black_box(result)
                })
            },
        );
    }
    
    group.finish();
}

criterion_group!(benches, benchmark_batch_processing);
criterion_main!(benches);
```

## ğŸ“š æ–‡æ¡£è´¡çŒ®

### 1. æ–‡æ¡£ç»“æ„

```text
docs/
â”œâ”€â”€ 00_æ€»è§ˆä¸å¯¼èˆª/          # é¡¹ç›®æ¦‚è§ˆå’Œå¯¼èˆª
â”œâ”€â”€ 01_ç†è®ºåŸºç¡€/            # ç†è®ºåŸºç¡€å’Œæ¦‚å¿µ
â”œâ”€â”€ 02_æ ¸å¿ƒåŠŸèƒ½/            # æ ¸å¿ƒåŠŸèƒ½è¯´æ˜
â”œâ”€â”€ 03_æ¶æ„è®¾è®¡/            # æ¶æ„è®¾è®¡æ–‡æ¡£
â”œâ”€â”€ 04_å®è·µåº”ç”¨/            # å®è·µåº”ç”¨æŒ‡å—
â”œâ”€â”€ 05_éƒ¨ç½²è¿ç»´/            # éƒ¨ç½²è¿ç»´æŒ‡å—
â”œâ”€â”€ 06_ç¤¾åŒºç”Ÿæ€/            # ç¤¾åŒºå’Œç”Ÿæ€
â”œâ”€â”€ 07_å‚è€ƒèµ„æ–™/            # å‚è€ƒèµ„æ–™å’ŒAPIæ–‡æ¡£
â””â”€â”€ 08_å†å²ç‰ˆæœ¬/            # å†å²ç‰ˆæœ¬è®°å½•
```

### 2. æ–‡æ¡£ç¼–å†™è§„èŒƒ

#### Markdown è§„èŒƒ

```markdown
    # æ–‡æ¡£æ ‡é¢˜

    ## ğŸ“‹ ç›®å½•

    - [ç« èŠ‚1](#ç« èŠ‚1)
    - [ç« èŠ‚2](#ç« èŠ‚2)

    ## ğŸ¯ ç« èŠ‚1

    ### 1. å­ç« èŠ‚

    å†…å®¹æè¿°...

    #### ä»£ç ç¤ºä¾‹

    ```rust
    // ä»£ç æ³¨é‡Š
    fn example_function() -> Result<(), Error> {
        // å®ç°
        Ok(())
    }
    ```

    #### é…ç½®ç¤ºä¾‹

    ```yaml
    # YAML é…ç½®ç¤ºä¾‹
    server:
    endpoint: "http://localhost:4317"
    timeout: 30s
    ```

    ## ğŸ“š å‚è€ƒé“¾æ¥

    - [ç›¸å…³æ–‡æ¡£](./related.md)
    - [å¤–éƒ¨é“¾æ¥](https://example.com)

```

#### æ–‡æ¡£æ¨¡æ¿

```markdown
    # [æ–‡æ¡£æ ‡é¢˜]

    ## ğŸ“‹ ç›®å½•

    - [æ¦‚è¿°](#æ¦‚è¿°)
    - [å¿«é€Ÿå¼€å§‹](#å¿«é€Ÿå¼€å§‹)
    - [è¯¦ç»†è¯´æ˜](#è¯¦ç»†è¯´æ˜)
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
    - [æ•…éšœæ’æŸ¥](#æ•…éšœæ’æŸ¥)
    - [å‚è€ƒèµ„æº](#å‚è€ƒèµ„æº)

    ## ğŸ¯ æ¦‚è¿°

    ç®€è¦æè¿°æ–‡æ¡£å†…å®¹...

    ## ğŸš€ å¿«é€Ÿå¼€å§‹

    ### 1. å®‰è£…

    ```bash
    cargo add otlp
    ```

    ### 2. åŸºç¡€ä½¿ç”¨

    ```rust
    use otlp::client::OtlpClient;

    #[tokio::main]
    async fn main() -> Result<(), Box<dyn std::error::Error>> {
        let client = OtlpClient::new().await?;
        // ä½¿ç”¨å®¢æˆ·ç«¯
        Ok(())
    }
    ```

    ## ğŸ“– è¯¦ç»†è¯´æ˜

    è¯¦ç»†å†…å®¹...

    ## ğŸ’¡ æœ€ä½³å®è·µ

    1. å®è·µ1
    2. å®è·µ2

    ## ğŸ”§ æ•…éšœæ’æŸ¥

    å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ...

    ## ğŸ“š å‚è€ƒèµ„æº

    - [ç›¸å…³æ–‡æ¡£](./related.md)
    - [API æ–‡æ¡£](./api.md)

```

### 3. æ–‡æ¡£å®¡æŸ¥æµç¨‹

```text
1. å†…å®¹å®¡æŸ¥
   â”œâ”€â”€ å‡†ç¡®æ€§æ£€æŸ¥
   â”œâ”€â”€ å®Œæ•´æ€§æ£€æŸ¥
   â”œâ”€â”€ ä¸€è‡´æ€§æ£€æŸ¥
   â””â”€â”€ å¯è¯»æ€§æ£€æŸ¥

2. æŠ€æœ¯å®¡æŸ¥
   â”œâ”€â”€ ä»£ç ç¤ºä¾‹éªŒè¯
   â”œâ”€â”€ é…ç½®ç¤ºä¾‹æµ‹è¯•
   â”œâ”€â”€ é“¾æ¥æœ‰æ•ˆæ€§æ£€æŸ¥
   â””â”€â”€ æ ¼å¼è§„èŒƒæ£€æŸ¥

3. å‘å¸ƒæµç¨‹
   â”œâ”€â”€ æ–‡æ¡£æ„å»ºæµ‹è¯•
   â”œâ”€â”€ é¢„è§ˆç”Ÿæˆ
   â”œâ”€â”€ æœ€ç»ˆå®¡æŸ¥
   â””â”€â”€ å‘å¸ƒéƒ¨ç½²
```

## ğŸš€ å‘å¸ƒæµç¨‹

### 1. ç‰ˆæœ¬ç®¡ç†

#### è¯­ä¹‰åŒ–ç‰ˆæœ¬

```toml
# Cargo.toml
[package]
name = "otlp"
version = "1.0.0"  # ä¸»ç‰ˆæœ¬.æ¬¡ç‰ˆæœ¬.ä¿®è®¢ç‰ˆæœ¬
edition = "2021"
authors = ["OTLP Team <team@otlp.org>"]
license = "Apache-2.0"
description = "OpenTelemetry Protocol Rust implementation"
repository = "https://github.com/your-org/otlp-rust"
homepage = "https://otlp.org"
keywords = ["opentelemetry", "observability", "telemetry", "rust"]
categories = ["development-tools", "web-programming::http-server"]
```

#### ç‰ˆæœ¬å‘å¸ƒç­–ç•¥

```text
ä¸»ç‰ˆæœ¬ (MAJOR): ä¸å…¼å®¹çš„ API å˜æ›´
æ¬¡ç‰ˆæœ¬ (MINOR): å‘åå…¼å®¹çš„åŠŸèƒ½æ–°å¢
ä¿®è®¢ç‰ˆæœ¬ (PATCH): å‘åå…¼å®¹çš„é—®é¢˜ä¿®å¤

é¢„å‘å¸ƒç‰ˆæœ¬:
- alpha: å†…éƒ¨æµ‹è¯•ç‰ˆæœ¬
- beta: å…¬å¼€æµ‹è¯•ç‰ˆæœ¬
- rc: å€™é€‰å‘å¸ƒç‰ˆæœ¬
```

### 2. å‘å¸ƒæ£€æŸ¥æ¸…å•

```text
å‘å¸ƒå‰æ£€æŸ¥:
â–¡ æ‰€æœ‰æµ‹è¯•é€šè¿‡
â–¡ æ€§èƒ½åŸºå‡†æµ‹è¯•é€šè¿‡
â–¡ å®‰å…¨æ£€æŸ¥é€šè¿‡
â–¡ æ–‡æ¡£æ›´æ–°å®Œæˆ
â–¡ ç‰ˆæœ¬å·æ›´æ–°
â–¡ CHANGELOG æ›´æ–°
â–¡ æ ‡ç­¾åˆ›å»º
â–¡ å‘å¸ƒè¯´æ˜å‡†å¤‡

å‘å¸ƒåæ£€æŸ¥:
â–¡ åŒ…å‘å¸ƒæˆåŠŸ
â–¡ æ–‡æ¡£ç½‘ç«™æ›´æ–°
â–¡ ç¤¾åŒºé€šçŸ¥
â–¡ é—®é¢˜è·Ÿè¸ªæ›´æ–°
```

### 3. è‡ªåŠ¨åŒ–å‘å¸ƒ

#### GitHub Actions å·¥ä½œæµ

```yaml
# .github/workflows/release.yml
name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          
      - name: Run tests
        run: cargo test --all-features
        
      - name: Run security audit
        run: cargo audit
        
      - name: Build documentation
        run: cargo doc --all-features --no-deps
        
      - name: Publish to crates.io
        uses: actions-rs/cargo@v1
        with:
          command: publish
          args: --token ${{ secrets.CARGO_REGISTRY_TOKEN }}
          
      - name: Create GitHub Release
        uses: actions/create-release@v1
        with:
          tag_name: ${{ github.ref }}
          release_name: Release ${{ github.ref }}
          body_path: RELEASE_NOTES.md
          draft: false
          prerelease: false
```

#### å‘å¸ƒè„šæœ¬

```bash
#!/bin/bash
# scripts/release.sh

set -e

VERSION=$1
if [ -z "$VERSION" ]; then
    echo "Usage: $0 <version>"
    exit 1
fi

echo "Releasing version $VERSION..."

# 1. æ›´æ–°ç‰ˆæœ¬å·
cargo set-version $VERSION

# 2. æ›´æ–° CHANGELOG
# è¿™é‡Œå¯ä»¥æ·»åŠ è‡ªåŠ¨æ›´æ–° CHANGELOG çš„é€»è¾‘

# 3. è¿è¡Œæµ‹è¯•
cargo test --all-features

# 4. è¿è¡Œå®‰å…¨æ£€æŸ¥
cargo audit

# 5. æ„å»ºæ–‡æ¡£
cargo doc --all-features --no-deps

# 6. æäº¤æ›´æ”¹
git add .
git commit -m "chore: release v$VERSION"

# 7. åˆ›å»ºæ ‡ç­¾
git tag "v$VERSION"

# 8. æ¨é€
git push origin main
git push origin "v$VERSION"

# 9. å‘å¸ƒåˆ° crates.io
cargo publish

echo "Release $VERSION completed!"
```

## ğŸ‘¥ ç¤¾åŒºæ²»ç†

### 1. é¡¹ç›®ç»´æŠ¤è€…

#### ç»´æŠ¤è€…èŒè´£

```text
æ ¸å¿ƒç»´æŠ¤è€…:
â”œâ”€â”€ é¡¹ç›®æ¶æ„è®¾è®¡
â”œâ”€â”€ é‡å¤§å†³ç­–åˆ¶å®š
â”œâ”€â”€ ä»£ç å®¡æŸ¥
â”œâ”€â”€ å‘å¸ƒç®¡ç†
â””â”€â”€ ç¤¾åŒºç®¡ç†

é¢†åŸŸä¸“å®¶:
â”œâ”€â”€ ç‰¹å®šé¢†åŸŸè´¡çŒ®
â”œâ”€â”€ æŠ€æœ¯æŒ‡å¯¼
â”œâ”€â”€ æ–‡æ¡£ç»´æŠ¤
â””â”€â”€ é—®é¢˜è§£ç­”

ç¤¾åŒºè´¡çŒ®è€…:
â”œâ”€â”€ Bug ä¿®å¤
â”œâ”€â”€ åŠŸèƒ½å¼€å‘
â”œâ”€â”€ æ–‡æ¡£æ”¹è¿›
â””â”€â”€ ç¤¾åŒºæ”¯æŒ
```

#### ç»´æŠ¤è€…ç”³è¯·æµç¨‹

```text
1. è´¡çŒ®è®°å½•
   â”œâ”€â”€ è‡³å°‘ 6 ä¸ªæœˆçš„æ´»è·ƒè´¡çŒ®
   â”œâ”€â”€ è‡³å°‘ 10 ä¸ªåˆå¹¶çš„ PR
   â”œâ”€â”€ è‡³å°‘ 50 ä¸ªæœ‰æ„ä¹‰çš„ä»£ç å®¡æŸ¥
   â””â”€â”€ è‡³å°‘ 5 ä¸ªæ–‡æ¡£æ”¹è¿›

2. ç”³è¯·æµç¨‹
   â”œâ”€â”€ æäº¤ç»´æŠ¤è€…ç”³è¯·
   â”œâ”€â”€ ç°æœ‰ç»´æŠ¤è€…æŠ•ç¥¨
   â”œâ”€â”€ ç¤¾åŒºè®¨è®º
   â””â”€â”€ æœ€ç»ˆå†³å®š

3. ç»´æŠ¤è€…æƒåˆ©
   â”œâ”€â”€ ä»£ç åˆå¹¶æƒé™
   â”œâ”€â”€ å‘å¸ƒæƒé™
   â”œâ”€â”€ ä»“åº“ç®¡ç†æƒé™
   â””â”€â”€ ç¤¾åŒºç®¡ç†æƒé™
```

### 2. å†³ç­–æµç¨‹

#### RFC (Request for Comments) æµç¨‹

```text
1. ææ¡ˆé˜¶æ®µ
   â”œâ”€â”€ åˆ›å»º RFC Issue
   â”œâ”€â”€ è¯¦ç»†æè¿°ææ¡ˆ
   â”œâ”€â”€ ç¤¾åŒºè®¨è®º
   â””â”€â”€ åé¦ˆæ”¶é›†

2. è®¾è®¡é˜¶æ®µ
   â”œâ”€â”€ æŠ€æœ¯è®¾è®¡
   â”œâ”€â”€ API è®¾è®¡
   â”œâ”€â”€ å®ç°è®¡åˆ’
   â””â”€â”€ æµ‹è¯•ç­–ç•¥

3. å®ç°é˜¶æ®µ
   â”œâ”€â”€ ä»£ç å®ç°
   â”œâ”€â”€ æµ‹è¯•ç¼–å†™
   â”œâ”€â”€ æ–‡æ¡£æ›´æ–°
   â””â”€â”€ ä»£ç å®¡æŸ¥

4. åˆå¹¶é˜¶æ®µ
   â”œâ”€â”€ æœ€ç»ˆå®¡æŸ¥
   â”œâ”€â”€ æ€§èƒ½æµ‹è¯•
   â”œâ”€â”€ å…¼å®¹æ€§æ£€æŸ¥
   â””â”€â”€ åˆå¹¶å†³ç­–
```

#### å†³ç­–çŸ©é˜µ

```text
å†³ç­–ç±»å‹          | å†³ç­–è€…        | å†³ç­–æ–¹å¼
------------------|---------------|------------------
æ¶æ„å˜æ›´          | æ ¸å¿ƒç»´æŠ¤è€…    | ä¸€è‡´åŒæ„
API å˜æ›´          | æ ¸å¿ƒç»´æŠ¤è€…    | å¤šæ•°åŒæ„
Bug ä¿®å¤          | ç»´æŠ¤è€…        | å•ä¸ªæ‰¹å‡†
æ–‡æ¡£æ›´æ–°          | ç»´æŠ¤è€…        | å•ä¸ªæ‰¹å‡†
å‘å¸ƒå†³ç­–          | æ ¸å¿ƒç»´æŠ¤è€…    | ä¸€è‡´åŒæ„
ç¤¾åŒºè§„åˆ™          | æ‰€æœ‰ç»´æŠ¤è€…    | å¤šæ•°åŒæ„
```

### 3. è¡Œä¸ºå‡†åˆ™

#### ç¤¾åŒºè¡Œä¸ºå‡†åˆ™

```text
æˆ‘ä»¬æ‰¿è¯ºä¸ºæ¯ä¸ªäººæä¾›å‹å¥½ã€å®‰å…¨ã€åŒ…å®¹çš„ç¯å¢ƒï¼Œæ— è®ºï¼š
- æ€§åˆ«è®¤åŒå’Œè¡¨è¾¾
- æ€§å–å‘
- æ®‹ç–¾
- å¤–è²Œ
- èº«ä½“å¤§å°
- ç§æ—
- å¹´é¾„
- å®—æ•™
- å›½ç±

æœŸæœ›è¡Œä¸ºï¼š
- ä½¿ç”¨å‹å¥½å’ŒåŒ…å®¹çš„è¯­è¨€
- å°Šé‡ä¸åŒçš„è§‚ç‚¹å’Œç»éªŒ
- ä¼˜é›…åœ°æ¥å—å»ºè®¾æ€§æ‰¹è¯„
- å…³æ³¨å¯¹ç¤¾åŒºæœ€æœ‰åˆ©çš„äº‹æƒ…
- å¯¹å…¶ä»–ç¤¾åŒºæˆå‘˜è¡¨ç¤ºåŒç†å¿ƒ

ä¸å¯æ¥å—çš„è¡Œä¸ºï¼š
- ä½¿ç”¨æ€§åŒ–çš„è¯­è¨€æˆ–å›¾åƒ
- æŒ‘è¡…ã€ä¾®è¾±æˆ–è´¬æŸæ€§è¯„è®º
- å…¬å¼€æˆ–ç§äººéªšæ‰°
- æœªç»è®¸å¯å‘å¸ƒç§äººä¿¡æ¯
- å…¶ä»–åœ¨ä¸“ä¸šç¯å¢ƒä¸­ä¸å½“çš„è¡Œä¸º
```

#### å†²çªè§£å†³

```text
1. è‡ªæˆ‘è§£å†³
   â”œâ”€â”€ ç§ä¸‹æ²Ÿé€š
   â”œâ”€â”€ å¯»æ±‚ç†è§£
   â””â”€â”€ å¯»æ‰¾å…±åŒç‚¹

2. ç¤¾åŒºè°ƒè§£
   â”œâ”€â”€ è¯·æ±‚ç»´æŠ¤è€…å¸®åŠ©
   â”œâ”€â”€ ä¸­ç«‹æ–¹è°ƒè§£
   â””â”€â”€ å¯»æ‰¾è§£å†³æ–¹æ¡ˆ

3. æ­£å¼å¤„ç†
   â”œâ”€â”€ æŠ¥å‘Šè¿è§„è¡Œä¸º
   â”œâ”€â”€ è°ƒæŸ¥å’Œè¯„ä¼°
   â””â”€â”€ é‡‡å–é€‚å½“æªæ–½
```

## ğŸ“– å¼€å‘è€…èµ„æº

### 1. å­¦ä¹ èµ„æº

#### Rust å­¦ä¹ èµ„æº

```text
å®˜æ–¹èµ„æº:
â”œâ”€â”€ The Rust Book (https://doc.rust-lang.org/book/)
â”œâ”€â”€ Rust by Example (https://doc.rust-lang.org/rust-by-example/)
â”œâ”€â”€ Rustonomicon (https://doc.rust-lang.org/nomicon/)
â””â”€â”€ Rust Reference (https://doc.rust-lang.org/reference/)

å¼‚æ­¥ç¼–ç¨‹:
â”œâ”€â”€ Async Book (https://rust-lang.github.io/async-book/)
â”œâ”€â”€ Tokio Tutorial (https://tokio.rs/tokio/tutorial)
â””â”€â”€ Async-std Documentation (https://docs.rs/async-std/)

æ€§èƒ½ä¼˜åŒ–:
â”œâ”€â”€ The Rust Performance Book (https://nnethercote.github.io/perf-book/)
â”œâ”€â”€ Criterion.rs (https://bheisler.github.io/criterion.rs/book/)
â””â”€â”€ Flamegraph (https://github.com/flamegraph-rs/flamegraph)
```

#### OpenTelemetry å­¦ä¹ èµ„æº

```text
å®˜æ–¹æ–‡æ¡£:
â”œâ”€â”€ OpenTelemetry Documentation (https://opentelemetry.io/docs/)
â”œâ”€â”€ OTLP Specification (https://github.com/open-telemetry/opentelemetry-specification)
â””â”€â”€ OpenTelemetry Rust (https://opentelemetry.io/docs/instrumentation/rust/)

ç›¸å…³æ ‡å‡†:
â”œâ”€â”€ OpenTracing (https://opentracing.io/)
â”œâ”€â”€ OpenCensus (https://opencensus.io/)
â””â”€â”€ W3C Trace Context (https://www.w3.org/TR/trace-context/)
```

### 2. å¼€å‘å·¥å…·

#### è°ƒè¯•å·¥å…·

```rust
// ä½¿ç”¨ tracing è¿›è¡Œç»“æ„åŒ–æ—¥å¿—
use tracing::{info, warn, error, debug, span, Level};

#[tracing::instrument]
async fn process_batch(batch: &[Span]) -> Result<(), OtlpError> {
    let span = span!(Level::INFO, "process_batch", batch_size = batch.len());
    let _enter = span.enter();
    
    info!("å¼€å§‹å¤„ç†æ‰¹æ¬¡");
    
    for span in batch {
        debug!(span_id = %span.id, "å¤„ç†å•ä¸ª span");
        // å¤„ç†é€»è¾‘
    }
    
    info!("æ‰¹æ¬¡å¤„ç†å®Œæˆ");
    Ok(())
}

// ä½¿ç”¨ metrics è¿›è¡Œæ€§èƒ½ç›‘æ§
use metrics::{counter, histogram, gauge};

#[tracing::instrument]
async fn send_request(request: &Request) -> Result<Response, Error> {
    let start = std::time::Instant::now();
    
    let result = perform_request(request).await;
    
    let duration = start.elapsed();
    histogram!("request_duration", duration);
    
    match &result {
        Ok(_) => counter!("requests_success", 1),
        Err(_) => counter!("requests_error", 1),
    }
    
    result
}
```

#### æ€§èƒ½åˆ†æå·¥å…·

```bash
# ä½¿ç”¨ cargo-flamegraph è¿›è¡Œç«ç„°å›¾åˆ†æ
cargo install flamegraph
cargo flamegraph --bin otlp-client

# ä½¿ç”¨ cargo-profdata è¿›è¡Œæ€§èƒ½åˆ†æ
cargo install cargo-profdata
cargo profdata callgrind --bin otlp-client

# ä½¿ç”¨ heaptrack è¿›è¡Œå†…å­˜åˆ†æ
cargo install heaptrack
heaptrack cargo run --bin otlp-client
```

### 3. ç¤¾åŒºæ”¯æŒ

#### è·å–å¸®åŠ©

```text
é—®é¢˜æŠ¥å‘Š:
â”œâ”€â”€ GitHub Issues (https://github.com/your-org/otlp-rust/issues)
â”œâ”€â”€ Bug æŠ¥å‘Šæ¨¡æ¿
â”œâ”€â”€ åŠŸèƒ½è¯·æ±‚æ¨¡æ¿
â””â”€â”€ é—®é¢˜åˆ†ç±»æ ‡ç­¾

è®¨è®ºäº¤æµ:
â”œâ”€â”€ GitHub Discussions (https://github.com/your-org/otlp-rust/discussions)
â”œâ”€â”€ æŠ€æœ¯è®¨è®º
â”œâ”€â”€ ä½¿ç”¨é—®é¢˜
â””â”€â”€ åŠŸèƒ½å»ºè®®

å³æ—¶æ²Ÿé€š:
â”œâ”€â”€ Discord æœåŠ¡å™¨
â”œâ”€â”€ Slack é¢‘é“
â””â”€â”€ IRC é¢‘é“
```

#### è´¡çŒ®æŒ‡å—

```text
æ–°è´¡çŒ®è€…:
â”œâ”€â”€ Good First Issues æ ‡ç­¾
â”œâ”€â”€ æ–°æ‰‹æŒ‡å—
â”œâ”€â”€ å¯¼å¸ˆåˆ¶åº¦
â””â”€â”€ è´¡çŒ®å¥–åŠ±

æ–‡æ¡£è´¡çŒ®:
â”œâ”€â”€ æ–‡æ¡£æ”¹è¿›
â”œâ”€â”€ ç¿»è¯‘å·¥ä½œ
â”œâ”€â”€ ç¤ºä¾‹ç¼–å†™
â””â”€â”€ æ•™ç¨‹åˆ¶ä½œ

ç¤¾åŒºæ´»åŠ¨:
â”œâ”€â”€ æŠ€æœ¯åˆ†äº«
â”œâ”€â”€ ä»£ç å®¡æŸ¥
â”œâ”€â”€ é—®é¢˜è§£ç­”
â””â”€â”€ ç¤¾åŒºå»ºè®¾
```

### 4. å¼€å‘æœ€ä½³å®è·µ

#### ä»£ç è´¨é‡

```rust
// ä½¿ç”¨ clippy è¿›è¡Œä»£ç æ£€æŸ¥
#![deny(clippy::all, clippy::pedantic)]

// ä½¿ç”¨ rustfmt è¿›è¡Œä»£ç æ ¼å¼åŒ–
// åœ¨ Cargo.toml ä¸­é…ç½®
[package.metadata.rustfmt]
edition = "2021"
max_width = 100
tab_spaces = 4

// ä½¿ç”¨ cargo-machete ç§»é™¤æœªä½¿ç”¨çš„ä¾èµ–
cargo install cargo-machete
cargo machete

// ä½¿ç”¨ cargo-outdated æ£€æŸ¥è¿‡æ—¶çš„ä¾èµ–
cargo install cargo-outdated
cargo outdated
```

#### æµ‹è¯•ç­–ç•¥

```rust
// ä½¿ç”¨ mockall è¿›è¡Œ Mock æµ‹è¯•
use mockall::mock;

mock! {
    Transport {}
    
    #[async_trait]
    impl Transport for Transport {
        async fn send(&self, data: &[u8]) -> Result<(), Error>;
    }
}

// ä½¿ç”¨ tokio-test è¿›è¡Œå¼‚æ­¥æµ‹è¯•
use tokio_test;

#[tokio::test]
async fn test_async_function() {
    let result = async_function().await;
    assert!(result.is_ok());
}

// ä½¿ç”¨ proptest è¿›è¡Œå±æ€§æµ‹è¯•
use proptest::prelude::*;

proptest! {
    #[test]
    fn test_property(
        input in any::<u32>()
    ) {
        let result = function_under_test(input);
        assert!(result >= 0);
    }
}
```

#### æ€§èƒ½ä¼˜åŒ–

```rust
// ä½¿ç”¨é›¶æ‹·è´æŠ€æœ¯
use bytes::Bytes;

struct BatchProcessor {
    buffer: Bytes,
}

impl BatchProcessor {
    fn process_batch(&mut self, data: Bytes) -> Result<(), Error> {
        // ç›´æ¥ä½¿ç”¨ Bytesï¼Œé¿å…æ‹·è´
        self.buffer = data;
        Ok(())
    }
}

// ä½¿ç”¨å¯¹è±¡æ± å‡å°‘åˆ†é…
use object_pool::Pool;

struct ConnectionPool {
    pool: Pool<Connection>,
}

impl ConnectionPool {
    fn new() -> Self {
        Self {
            pool: Pool::new(100, || Connection::new()),
        }
    }
    
    fn get_connection(&self) -> PooledConnection<Connection> {
        self.pool.pull()
    }
}

// ä½¿ç”¨æ‰¹å¤„ç†æé«˜æ•ˆç‡
async fn batch_process(items: Vec<Item>) -> Result<(), Error> {
    const BATCH_SIZE: usize = 100;
    
    for chunk in items.chunks(BATCH_SIZE) {
        process_chunk(chunk).await?;
    }
    
    Ok(())
}
```

---

## ğŸ“š æ€»ç»“

æœ¬æŒ‡å—æ¶µç›–äº† OTLP Rust é¡¹ç›®çš„å®Œæ•´å¼€å‘æµç¨‹ï¼ŒåŒ…æ‹¬ï¼š

1. **å¼€å‘ç¯å¢ƒè®¾ç½®** - å®Œæ•´çš„å¼€å‘ç¯å¢ƒé…ç½®
2. **è´¡çŒ®æµç¨‹** - æ ‡å‡†åŒ–çš„è´¡çŒ®å’Œå®¡æŸ¥æµç¨‹
3. **ä»£ç è§„èŒƒ** - è¯¦ç»†çš„ä»£ç å’Œæ–‡æ¡£è§„èŒƒ
4. **æµ‹è¯•æŒ‡å—** - å…¨é¢çš„æµ‹è¯•ç­–ç•¥å’Œå·¥å…·
5. **å‘å¸ƒæµç¨‹** - è‡ªåŠ¨åŒ–çš„ç‰ˆæœ¬å‘å¸ƒæµç¨‹
6. **ç¤¾åŒºæ²»ç†** - é€æ˜çš„ç¤¾åŒºç®¡ç†å’Œå†³ç­–æµç¨‹
7. **å¼€å‘è€…èµ„æº** - ä¸°å¯Œçš„å­¦ä¹ èµ„æºå’Œå·¥å…·

é€šè¿‡éµå¾ªè¿™äº›æŒ‡å—ï¼Œæˆ‘ä»¬èƒ½å¤Ÿï¼š

- ä¿æŒä»£ç è´¨é‡å’Œä¸€è‡´æ€§
- æé«˜å¼€å‘æ•ˆç‡
- ç¡®ä¿é¡¹ç›®çš„å¯æŒç»­æ€§
- å»ºè®¾æ´»è·ƒçš„å¼€å‘è€…ç¤¾åŒº
- æä¾›é«˜è´¨é‡çš„å¼€æºè½¯ä»¶

æ¬¢è¿åŠ å…¥ OTLP Rust é¡¹ç›®ï¼Œä¸€èµ·æ„å»ºæ›´å¥½çš„å¯è§‚æµ‹æ€§å·¥å…·ï¼
