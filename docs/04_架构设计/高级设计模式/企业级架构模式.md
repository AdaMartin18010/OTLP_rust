# OTLP Rust 企业级架构模式

## 📚 概述

本文档详细介绍了OTLP Rust在企业级应用中的高级架构模式，包括微服务架构、事件驱动架构、CQRS模式、领域驱动设计等现代企业架构模式。

## 🏗️ 企业级架构模式概览

### 1. 架构模式分类

| 模式类型 | 适用场景 | 复杂度 | 性能 | 可扩展性 |
|----------|----------|--------|------|----------|
| **微服务架构** | 大型分布式系统 | 高 | 高 | 极高 |
| **事件驱动架构** | 异步处理系统 | 中 | 极高 | 高 |
| **CQRS模式** | 读写分离系统 | 高 | 极高 | 高 |
| **领域驱动设计** | 复杂业务系统 | 高 | 中 | 高 |
| **六边形架构** | 可测试系统 | 中 | 中 | 高 |
| **洋葱架构** | 依赖倒置系统 | 中 | 中 | 高 |

### 2. 架构演进路径

```text
单体架构 → 分层架构 → 微服务架构 → 云原生架构 → 服务网格架构
```

## 🔧 微服务架构模式

### 1. 微服务架构设计

```rust
// src/architecture/microservices/mod.rs
use std::collections::HashMap;
use tokio::sync::RwLock;
use serde::{Serialize, Deserialize};

pub mod service_registry;
pub mod service_discovery;
pub mod circuit_breaker;
pub mod load_balancer;
pub mod api_gateway;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServiceInstance {
    pub id: String,
    pub name: String,
    pub host: String,
    pub port: u16,
    pub health_check_url: String,
    pub metadata: HashMap<String, String>,
    pub status: ServiceStatus,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ServiceStatus {
    Healthy,
    Unhealthy,
    Starting,
    Stopping,
}

#[derive(Debug, Clone)]
pub struct MicroserviceArchitecture {
    pub services: RwLock<HashMap<String, Vec<ServiceInstance>>>,
    pub service_registry: service_registry::ServiceRegistry,
    pub circuit_breaker: circuit_breaker::CircuitBreaker,
    pub load_balancer: load_balancer::LoadBalancer,
}

impl MicroserviceArchitecture {
    pub async fn new() -> Self {
        Self {
            services: RwLock::new(HashMap::new()),
            service_registry: service_registry::ServiceRegistry::new(),
            circuit_breaker: circuit_breaker::CircuitBreaker::new(),
            load_balancer: load_balancer::LoadBalancer::new(),
        }
    }
    
    pub async fn register_service(&self, service: ServiceInstance) -> Result<(), Box<dyn std::error::Error>> {
        self.service_registry.register(service.clone()).await?;
        
        let mut services = self.services.write().await;
        services.entry(service.name.clone())
            .or_insert_with(Vec::new)
            .push(service);
        
        Ok(())
    }
    
    pub async fn discover_service(&self, service_name: &str) -> Result<Vec<ServiceInstance>, Box<dyn std::error::Error>> {
        self.service_registry.discover(service_name).await
    }
    
    pub async fn call_service(&self, service_name: &str, request: &[u8]) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        let instances = self.discover_service(service_name).await?;
        let instance = self.load_balancer.select_instance(&instances)?;
        
        if self.circuit_breaker.is_open(&instance.id).await {
            return Err("Circuit breaker is open".into());
        }
        
        match self.execute_request(&instance, request).await {
            Ok(response) => {
                self.circuit_breaker.record_success(&instance.id).await;
                Ok(response)
            }
            Err(e) => {
                self.circuit_breaker.record_failure(&instance.id).await;
                Err(e)
            }
        }
    }
    
    async fn execute_request(&self, instance: &ServiceInstance, request: &[u8]) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        // 实现服务调用逻辑
        let url = format!("http://{}:{}/api", instance.host, instance.port);
        let client = reqwest::Client::new();
        let response = client.post(&url)
            .body(request.to_vec())
            .send()
            .await?;
        
        Ok(response.bytes().await?.to_vec())
    }
}
```

### 2. 服务注册与发现

```rust
// src/architecture/microservices/service_registry.rs
use std::collections::HashMap;
use std::time::{Duration, Instant};
use tokio::sync::RwLock;
use tokio::time::interval;

pub struct ServiceRegistry {
    services: RwLock<HashMap<String, Vec<ServiceInstance>>>,
    health_check_interval: Duration,
}

impl ServiceRegistry {
    pub fn new() -> Self {
        Self {
            services: RwLock::new(HashMap::new()),
            health_check_interval: Duration::from_secs(30),
        }
    }
    
    pub async fn register(&self, service: ServiceInstance) -> Result<(), Box<dyn std::error::Error>> {
        let mut services = self.services.write().await;
        services.entry(service.name.clone())
            .or_insert_with(Vec::new)
            .retain(|s| s.id != service.id);
        services.entry(service.name.clone())
            .or_insert_with(Vec::new)
            .push(service);
        
        Ok(())
    }
    
    pub async fn unregister(&self, service_id: &str) -> Result<(), Box<dyn std::error::Error>> {
        let mut services = self.services.write().await;
        for service_list in services.values_mut() {
            service_list.retain(|s| s.id != service_id);
        }
        
        Ok(())
    }
    
    pub async fn discover(&self, service_name: &str) -> Result<Vec<ServiceInstance>, Box<dyn std::error::Error>> {
        let services = self.services.read().await;
        Ok(services.get(service_name)
            .cloned()
            .unwrap_or_default()
            .into_iter()
            .filter(|s| matches!(s.status, ServiceStatus::Healthy))
            .collect())
    }
    
    pub async fn start_health_check(&self) {
        let mut interval = interval(self.health_check_interval);
        
        loop {
            interval.tick().await;
            self.perform_health_check().await;
        }
    }
    
    async fn perform_health_check(&self) {
        let services = self.services.read().await;
        let mut services_to_update = Vec::new();
        
        for (service_name, instances) in services.iter() {
            for instance in instances {
                let health_status = self.check_instance_health(instance).await;
                if health_status != instance.status {
                    services_to_update.push((service_name.clone(), instance.id.clone(), health_status));
                }
            }
        }
        
        // 更新服务状态
        let mut services = self.services.write().await;
        for (service_name, instance_id, new_status) in services_to_update {
            if let Some(instances) = services.get_mut(&service_name) {
                if let Some(instance) = instances.iter_mut().find(|s| s.id == instance_id) {
                    instance.status = new_status;
                }
            }
        }
    }
    
    async fn check_instance_health(&self, instance: &ServiceInstance) -> ServiceStatus {
        let client = reqwest::Client::new();
        let url = format!("http://{}:{}", instance.host, instance.port);
        
        match client.get(&url)
            .timeout(Duration::from_secs(5))
            .send()
            .await
        {
            Ok(response) if response.status().is_success() => ServiceStatus::Healthy,
            _ => ServiceStatus::Unhealthy,
        }
    }
}
```

### 3. 熔断器模式

```rust
// src/architecture/microservices/circuit_breaker.rs
use std::collections::HashMap;
use std::time::{Duration, Instant};
use tokio::sync::RwLock;

#[derive(Debug, Clone)]
pub enum CircuitState {
    Closed,
    Open,
    HalfOpen,
}

pub struct CircuitBreaker {
    circuits: RwLock<HashMap<String, CircuitData>>,
    failure_threshold: u32,
    timeout_duration: Duration,
}

struct CircuitData {
    state: CircuitState,
    failure_count: u32,
    last_failure_time: Option<Instant>,
    success_count: u32,
}

impl CircuitBreaker {
    pub fn new() -> Self {
        Self {
            circuits: RwLock::new(HashMap::new()),
            failure_threshold: 5,
            timeout_duration: Duration::from_secs(60),
        }
    }
    
    pub async fn is_open(&self, service_id: &str) -> bool {
        let circuits = self.circuits.read().await;
        if let Some(circuit) = circuits.get(service_id) {
            match circuit.state {
                CircuitState::Open => {
                    if let Some(last_failure) = circuit.last_failure_time {
                        if last_failure.elapsed() > self.timeout_duration {
                            return false; // 可以尝试半开状态
                        }
                    }
                    true
                }
                CircuitState::HalfOpen => false,
                CircuitState::Closed => false,
            }
        } else {
            false
        }
    }
    
    pub async fn record_success(&self, service_id: &str) {
        let mut circuits = self.circuits.write().await;
        let circuit = circuits.entry(service_id.to_string()).or_insert_with(|| CircuitData {
            state: CircuitState::Closed,
            failure_count: 0,
            last_failure_time: None,
            success_count: 0,
        });
        
        match circuit.state {
            CircuitState::HalfOpen => {
                circuit.success_count += 1;
                if circuit.success_count >= 3 {
                    circuit.state = CircuitState::Closed;
                    circuit.failure_count = 0;
                    circuit.success_count = 0;
                }
            }
            CircuitState::Closed => {
                circuit.failure_count = 0;
            }
            CircuitState::Open => {
                circuit.state = CircuitState::HalfOpen;
                circuit.success_count = 1;
            }
        }
    }
    
    pub async fn record_failure(&self, service_id: &str) {
        let mut circuits = self.circuits.write().await;
        let circuit = circuits.entry(service_id.to_string()).or_insert_with(|| CircuitData {
            state: CircuitState::Closed,
            failure_count: 0,
            last_failure_time: None,
            success_count: 0,
        });
        
        circuit.failure_count += 1;
        circuit.last_failure_time = Some(Instant::now());
        
        if circuit.failure_count >= self.failure_threshold {
            circuit.state = CircuitState::Open;
        }
    }
}
```

## 🎯 事件驱动架构模式

### 1. 事件总线实现

```rust
// src/architecture/event_driven/event_bus.rs
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{broadcast, RwLock};
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Event {
    pub id: String,
    pub event_type: String,
    pub payload: serde_json::Value,
    pub timestamp: chrono::DateTime<chrono::Utc>,
    pub source: String,
}

pub type EventHandler = Arc<dyn Fn(Event) -> Result<(), Box<dyn std::error::Error>> + Send + Sync>;

pub struct EventBus {
    handlers: RwLock<HashMap<String, Vec<EventHandler>>>,
    event_sender: broadcast::Sender<Event>,
}

impl EventBus {
    pub fn new() -> Self {
        let (sender, _) = broadcast::channel(1000);
        
        Self {
            handlers: RwLock::new(HashMap::new()),
            event_sender: sender,
        }
    }
    
    pub fn subscribe<F>(&self, event_type: &str, handler: F) -> Result<(), Box<dyn std::error::Error>>
    where
        F: Fn(Event) -> Result<(), Box<dyn std::error::Error>> + Send + Sync + 'static,
    {
        let mut handlers = tokio::runtime::Handle::current().block_on(self.handlers.write());
        handlers.entry(event_type.to_string())
            .or_insert_with(Vec::new)
            .push(Arc::new(handler));
        
        Ok(())
    }
    
    pub async fn publish(&self, event: Event) -> Result<(), Box<dyn std::error::Error>> {
        // 广播事件
        self.event_sender.send(event.clone())?;
        
        // 调用同步处理器
        self.call_sync_handlers(&event).await?;
        
        Ok(())
    }
    
    async fn call_sync_handlers(&self, event: &Event) -> Result<(), Box<dyn std::error::Error>> {
        let handlers = self.handlers.read().await;
        if let Some(event_handlers) = handlers.get(&event.event_type) {
            for handler in event_handlers {
                if let Err(e) = handler(event.clone()) {
                    log::error!("Event handler failed: {}", e);
                }
            }
        }
        
        Ok(())
    }
    
    pub fn create_receiver(&self) -> broadcast::Receiver<Event> {
        self.event_sender.subscribe()
    }
}

// 事件处理器示例
pub struct OtlpEventProcessor {
    event_bus: Arc<EventBus>,
}

impl OtlpEventProcessor {
    pub fn new(event_bus: Arc<EventBus>) -> Self {
        Self { event_bus }
    }
    
    pub async fn start(&self) -> Result<(), Box<dyn std::error::Error>> {
        let mut receiver = self.event_bus.create_receiver();
        
        tokio::spawn(async move {
            while let Ok(event) = receiver.recv().await {
                match event.event_type.as_str() {
                    "trace.created" => {
                        Self::handle_trace_created(event).await;
                    }
                    "metric.updated" => {
                        Self::handle_metric_updated(event).await;
                    }
                    "log.error" => {
                        Self::handle_log_error(event).await;
                    }
                    _ => {
                        log::warn!("Unknown event type: {}", event.event_type);
                    }
                }
            }
        });
        
        Ok(())
    }
    
    async fn handle_trace_created(event: Event) {
        log::info!("Processing trace created event: {}", event.id);
        // 实现追踪数据处理逻辑
    }
    
    async fn handle_metric_updated(event: Event) {
        log::info!("Processing metric updated event: {}", event.id);
        // 实现指标数据处理逻辑
    }
    
    async fn handle_log_error(event: Event) {
        log::error!("Processing log error event: {}", event.id);
        // 实现错误日志处理逻辑
    }
}
```

### 2. 事件溯源模式

```rust
// src/architecture/event_driven/event_sourcing.rs
use std::collections::VecDeque;
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DomainEvent {
    pub event_id: String,
    pub aggregate_id: String,
    pub event_type: String,
    pub event_data: serde_json::Value,
    pub timestamp: DateTime<Utc>,
    pub version: u64,
}

pub trait Aggregate {
    fn apply_event(&mut self, event: &DomainEvent);
    fn get_id(&self) -> String;
    fn get_version(&self) -> u64;
}

pub struct EventStore {
    events: VecDeque<DomainEvent>,
    snapshots: std::collections::HashMap<String, serde_json::Value>,
}

impl EventStore {
    pub fn new() -> Self {
        Self {
            events: VecDeque::new(),
            snapshots: std::collections::HashMap::new(),
        }
    }
    
    pub fn append_event(&mut self, event: DomainEvent) -> Result<(), Box<dyn std::error::Error>> {
        self.events.push_back(event);
        Ok(())
    }
    
    pub fn get_events(&self, aggregate_id: &str, from_version: u64) -> Vec<DomainEvent> {
        self.events.iter()
            .filter(|e| e.aggregate_id == aggregate_id && e.version > from_version)
            .cloned()
            .collect()
    }
    
    pub fn save_snapshot(&mut self, aggregate_id: &str, snapshot: serde_json::Value) {
        self.snapshots.insert(aggregate_id.to_string(), snapshot);
    }
    
    pub fn get_snapshot(&self, aggregate_id: &str) -> Option<&serde_json::Value> {
        self.snapshots.get(aggregate_id)
    }
}

// 示例聚合根
#[derive(Debug, Clone)]
pub struct TraceAggregate {
    pub id: String,
    pub service_name: String,
    pub operation_name: String,
    pub status: String,
    pub version: u64,
}

impl Aggregate for TraceAggregate {
    fn apply_event(&mut self, event: &DomainEvent) {
        match event.event_type.as_str() {
            "TraceCreated" => {
                self.id = event.aggregate_id.clone();
                self.service_name = event.event_data["service_name"].as_str().unwrap_or("").to_string();
                self.operation_name = event.event_data["operation_name"].as_str().unwrap_or("").to_string();
                self.status = "started".to_string();
            }
            "TraceCompleted" => {
                self.status = event.event_data["status"].as_str().unwrap_or("completed").to_string();
            }
            "TraceFailed" => {
                self.status = "failed".to_string();
            }
            _ => {}
        }
        self.version = event.version;
    }
    
    fn get_id(&self) -> String {
        self.id.clone()
    }
    
    fn get_version(&self) -> u64 {
        self.version
    }
}

impl TraceAggregate {
    pub fn new(id: String, service_name: String, operation_name: String) -> Self {
        Self {
            id,
            service_name,
            operation_name,
            status: "started".to_string(),
            version: 0,
        }
    }
    
    pub fn start_trace(&mut self, service_name: String, operation_name: String) -> DomainEvent {
        self.version += 1;
        DomainEvent {
            event_id: uuid::Uuid::new_v4().to_string(),
            aggregate_id: self.id.clone(),
            event_type: "TraceCreated".to_string(),
            event_data: serde_json::json!({
                "service_name": service_name,
                "operation_name": operation_name,
                "timestamp": chrono::Utc::now()
            }),
            timestamp: chrono::Utc::now(),
            version: self.version,
        }
    }
    
    pub fn complete_trace(&mut self, status: String) -> DomainEvent {
        self.version += 1;
        DomainEvent {
            event_id: uuid::Uuid::new_v4().to_string(),
            aggregate_id: self.id.clone(),
            event_type: "TraceCompleted".to_string(),
            event_data: serde_json::json!({
                "status": status,
                "timestamp": chrono::Utc::now()
            }),
            timestamp: chrono::Utc::now(),
            version: self.version,
        }
    }
}
```

## 📊 CQRS模式实现

### 1. 命令查询职责分离

```rust
// src/architecture/cqrs/mod.rs
use serde::{Serialize, Deserialize};
use std::collections::HashMap;
use tokio::sync::RwLock;

pub mod command;
pub mod query;
pub mod command_handler;
pub mod query_handler;
pub mod event_store;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Command {
    pub command_id: String,
    pub command_type: String,
    pub aggregate_id: String,
    pub command_data: serde_json::Value,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Query {
    pub query_id: String,
    pub query_type: String,
    pub query_data: serde_json::Value,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

pub trait CommandHandler<T> {
    async fn handle(&self, command: Command) -> Result<Vec<DomainEvent>, Box<dyn std::error::Error>>;
}

pub trait QueryHandler<T> {
    async fn handle(&self, query: Query) -> Result<T, Box<dyn std::error::Error>>;
}

pub struct CqrsBus {
    command_handlers: RwLock<HashMap<String, Box<dyn CommandHandler<()> + Send + Sync>>>,
    query_handlers: RwLock<HashMap<String, Box<dyn QueryHandler<()> + Send + Sync>>>,
    event_store: Arc<event_store::EventStore>,
}

impl CqrsBus {
    pub fn new(event_store: Arc<event_store::EventStore>) -> Self {
        Self {
            command_handlers: RwLock::new(HashMap::new()),
            query_handlers: RwLock::new(HashMap::new()),
            event_store,
        }
    }
    
    pub async fn register_command_handler<H>(&self, command_type: &str, handler: H)
    where
        H: CommandHandler<()> + Send + Sync + 'static,
    {
        let mut handlers = self.command_handlers.write().await;
        handlers.insert(command_type.to_string(), Box::new(handler));
    }
    
    pub async fn register_query_handler<H>(&self, query_type: &str, handler: H)
    where
        H: QueryHandler<()> + Send + Sync + 'static,
    {
        let mut handlers = self.query_handlers.write().await;
        handlers.insert(query_type.to_string(), Box::new(handler));
    }
    
    pub async fn execute_command(&self, command: Command) -> Result<Vec<DomainEvent>, Box<dyn std::error::Error>> {
        let handlers = self.command_handlers.read().await;
        if let Some(handler) = handlers.get(&command.command_type) {
            let events = handler.handle(command).await?;
            
            // 保存事件到事件存储
            for event in &events {
                self.event_store.append_event(event.clone()).await?;
            }
            
            Ok(events)
        } else {
            Err(format!("No handler found for command type: {}", command.command_type).into())
        }
    }
    
    pub async fn execute_query<T>(&self, query: Query) -> Result<T, Box<dyn std::error::Error>>
    where
        T: serde::de::DeserializeOwned,
    {
        let handlers = self.query_handlers.read().await;
        if let Some(handler) = handlers.get(&query.query_type) {
            let result: T = serde_json::from_value(handler.handle(query).await?)?;
            Ok(result)
        } else {
            Err(format!("No handler found for query type: {}", query.query_type).into())
        }
    }
}
```

### 2. 读模型投影

```rust
// src/architecture/cqrs/read_models.rs
use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use tokio::sync::RwLock;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TraceReadModel {
    pub id: String,
    pub service_name: String,
    pub operation_name: String,
    pub status: String,
    pub duration: Option<u64>,
    pub start_time: chrono::DateTime<chrono::Utc>,
    pub end_time: Option<chrono::DateTime<chrono::Utc>>,
    pub tags: HashMap<String, String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MetricReadModel {
    pub id: String,
    pub name: String,
    pub value: f64,
    pub unit: String,
    pub timestamp: chrono::DateTime<chrono::Utc>,
    pub labels: HashMap<String, String>,
}

pub struct ReadModelProjection {
    traces: RwLock<HashMap<String, TraceReadModel>>,
    metrics: RwLock<HashMap<String, MetricReadModel>>,
}

impl ReadModelProjection {
    pub fn new() -> Self {
        Self {
            traces: RwLock::new(HashMap::new()),
            metrics: RwLock::new(HashMap::new()),
        }
    }
    
    pub async fn apply_event(&self, event: &DomainEvent) -> Result<(), Box<dyn std::error::Error>> {
        match event.event_type.as_str() {
            "TraceCreated" => {
                let trace = TraceReadModel {
                    id: event.aggregate_id.clone(),
                    service_name: event.event_data["service_name"].as_str().unwrap_or("").to_string(),
                    operation_name: event.event_data["operation_name"].as_str().unwrap_or("").to_string(),
                    status: "started".to_string(),
                    duration: None,
                    start_time: chrono::DateTime::parse_from_rfc3339(
                        event.event_data["timestamp"].as_str().unwrap_or("")
                    )?.with_timezone(&chrono::Utc),
                    end_time: None,
                    tags: HashMap::new(),
                };
                
                let mut traces = self.traces.write().await;
                traces.insert(event.aggregate_id.clone(), trace);
            }
            "TraceCompleted" => {
                let mut traces = self.traces.write().await;
                if let Some(trace) = traces.get_mut(&event.aggregate_id) {
                    trace.status = event.event_data["status"].as_str().unwrap_or("completed").to_string();
                    trace.end_time = Some(chrono::Utc::now());
                    if let Some(start_time) = trace.start_time.timestamp_millis() {
                        trace.duration = Some(chrono::Utc::now().timestamp_millis() as u64 - start_time as u64);
                    }
                }
            }
            "MetricUpdated" => {
                let metric = MetricReadModel {
                    id: event.aggregate_id.clone(),
                    name: event.event_data["name"].as_str().unwrap_or("").to_string(),
                    value: event.event_data["value"].as_f64().unwrap_or(0.0),
                    unit: event.event_data["unit"].as_str().unwrap_or("").to_string(),
                    timestamp: chrono::DateTime::parse_from_rfc3339(
                        event.event_data["timestamp"].as_str().unwrap_or("")
                    )?.with_timezone(&chrono::Utc),
                    labels: event.event_data["labels"].as_object()
                        .map(|obj| obj.iter()
                            .filter_map(|(k, v)| v.as_str().map(|s| (k.clone(), s.to_string())))
                            .collect())
                        .unwrap_or_default(),
                };
                
                let mut metrics = self.metrics.write().await;
                metrics.insert(event.aggregate_id.clone(), metric);
            }
            _ => {}
        }
        
        Ok(())
    }
    
    pub async fn get_trace(&self, id: &str) -> Option<TraceReadModel> {
        let traces = self.traces.read().await;
        traces.get(id).cloned()
    }
    
    pub async fn get_metrics_by_name(&self, name: &str) -> Vec<MetricReadModel> {
        let metrics = self.metrics.read().await;
        metrics.values()
            .filter(|m| m.name == name)
            .cloned()
            .collect()
    }
}
```

## 🎯 领域驱动设计

### 1. 领域模型

```rust
// src/architecture/ddd/domain_models.rs
use serde::{Serialize, Deserialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Service {
    pub id: ServiceId,
    pub name: String,
    pub version: String,
    pub environment: Environment,
    pub health_status: HealthStatus,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServiceId(String);

impl ServiceId {
    pub fn new(id: String) -> Self {
        Self(id)
    }
    
    pub fn value(&self) -> &str {
        &self.0
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Environment {
    Development,
    Staging,
    Production,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum HealthStatus {
    Healthy,
    Unhealthy,
    Unknown,
}

impl Service {
    pub fn new(id: ServiceId, name: String, version: String, environment: Environment) -> Self {
        Self {
            id,
            name,
            version,
            environment,
            health_status: HealthStatus::Unknown,
        }
    }
    
    pub fn update_health_status(&mut self, status: HealthStatus) {
        self.health_status = status;
    }
    
    pub fn is_healthy(&self) -> bool {
        matches!(self.health_status, HealthStatus::Healthy)
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Trace {
    pub id: TraceId,
    pub service_id: ServiceId,
    pub operation_name: String,
    pub start_time: chrono::DateTime<chrono::Utc>,
    pub end_time: Option<chrono::DateTime<chrono::Utc>>,
    pub status: TraceStatus,
    pub spans: Vec<Span>,
    pub tags: HashMap<String, String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TraceId(String);

impl TraceId {
    pub fn new(id: String) -> Self {
        Self(id)
    }
    
    pub fn value(&self) -> &str {
        &self.0
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TraceStatus {
    Started,
    Completed,
    Failed,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Span {
    pub id: SpanId,
    pub parent_id: Option<SpanId>,
    pub operation_name: String,
    pub start_time: chrono::DateTime<chrono::Utc>,
    pub end_time: Option<chrono::DateTime<chrono::Utc>>,
    pub tags: HashMap<String, String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SpanId(String);

impl SpanId {
    pub fn new(id: String) -> Self {
        Self(id)
    }
    
    pub fn value(&self) -> &str {
        &self.0
    }
}

impl Trace {
    pub fn new(id: TraceId, service_id: ServiceId, operation_name: String) -> Self {
        Self {
            id,
            service_id,
            operation_name,
            start_time: chrono::Utc::now(),
            end_time: None,
            status: TraceStatus::Started,
            spans: Vec::new(),
            tags: HashMap::new(),
        }
    }
    
    pub fn add_span(&mut self, span: Span) {
        self.spans.push(span);
    }
    
    pub fn complete(&mut self) {
        self.status = TraceStatus::Completed;
        self.end_time = Some(chrono::Utc::now());
    }
    
    pub fn fail(&mut self) {
        self.status = TraceStatus::Failed;
        self.end_time = Some(chrono::Utc::now());
    }
    
    pub fn duration(&self) -> Option<chrono::Duration> {
        if let Some(end_time) = self.end_time {
            Some(end_time - self.start_time)
        } else {
            None
        }
    }
}
```

## 🏛️ 六边形架构

### 1. 端口和适配器

```rust
// src/architecture/hexagonal/mod.rs
use serde::{Serialize, Deserialize};

pub mod ports;
pub mod adapters;
pub mod domain;

// 端口定义
pub trait TelemetryRepository {
    async fn save_trace(&self, trace: domain::Trace) -> Result<(), Box<dyn std::error::Error>>;
    async fn get_trace(&self, id: &str) -> Result<Option<domain::Trace>, Box<dyn std::error::Error>>;
    async fn get_traces_by_service(&self, service_id: &str) -> Result<Vec<domain::Trace>, Box<dyn std::error::Error>>;
}

pub trait NotificationService {
    async fn send_notification(&self, message: &str) -> Result<(), Box<dyn std::error::Error>>;
}

pub trait ConfigurationService {
    async fn get_config(&self, key: &str) -> Result<Option<String>, Box<dyn std::error::Error>>;
}

// 应用服务
pub struct TelemetryApplicationService {
    repository: Box<dyn TelemetryRepository + Send + Sync>,
    notification_service: Box<dyn NotificationService + Send + Sync>,
    config_service: Box<dyn ConfigurationService + Send + Sync>,
}

impl TelemetryApplicationService {
    pub fn new(
        repository: Box<dyn TelemetryRepository + Send + Sync>,
        notification_service: Box<dyn NotificationService + Send + Sync>,
        config_service: Box<dyn ConfigurationService + Send + Sync>,
    ) -> Self {
        Self {
            repository,
            notification_service,
            config_service,
        }
    }
    
    pub async fn create_trace(&self, service_id: &str, operation_name: &str) -> Result<domain::Trace, Box<dyn std::error::Error>> {
        let trace = domain::Trace::new(
            domain::TraceId::new(uuid::Uuid::new_v4().to_string()),
            domain::ServiceId::new(service_id.to_string()),
            operation_name.to_string(),
        );
        
        self.repository.save_trace(trace.clone()).await?;
        
        // 发送通知
        if let Ok(Some(notification_enabled)) = self.config_service.get_config("notification.enabled").await {
            if notification_enabled == "true" {
                let _ = self.notification_service.send_notification(&format!(
                    "New trace created: {} for service: {}", trace.id.value(), service_id
                )).await;
            }
        }
        
        Ok(trace)
    }
    
    pub async fn complete_trace(&self, trace_id: &str) -> Result<(), Box<dyn std::error::Error>> {
        if let Some(mut trace) = self.repository.get_trace(trace_id).await? {
            trace.complete();
            self.repository.save_trace(trace).await?;
        }
        
        Ok(())
    }
}
```

### 2. 适配器实现

```rust
// src/architecture/hexagonal/adapters.rs
use super::ports::{TelemetryRepository, NotificationService, ConfigurationService};
use super::domain;
use std::collections::HashMap;
use tokio::sync::RwLock;

// 内存存储适配器
pub struct InMemoryTelemetryRepository {
    traces: RwLock<HashMap<String, domain::Trace>>,
}

impl InMemoryTelemetryRepository {
    pub fn new() -> Self {
        Self {
            traces: RwLock::new(HashMap::new()),
        }
    }
}

#[async_trait::async_trait]
impl TelemetryRepository for InMemoryTelemetryRepository {
    async fn save_trace(&self, trace: domain::Trace) -> Result<(), Box<dyn std::error::Error>> {
        let mut traces = self.traces.write().await;
        traces.insert(trace.id.value().to_string(), trace);
        Ok(())
    }
    
    async fn get_trace(&self, id: &str) -> Result<Option<domain::Trace>, Box<dyn std::error::Error>> {
        let traces = self.traces.read().await;
        Ok(traces.get(id).cloned())
    }
    
    async fn get_traces_by_service(&self, service_id: &str) -> Result<Vec<domain::Trace>, Box<dyn std::error::Error>> {
        let traces = self.traces.read().await;
        Ok(traces.values()
            .filter(|trace| trace.service_id.value() == service_id)
            .cloned()
            .collect())
    }
}

// HTTP通知服务适配器
pub struct HttpNotificationService {
    webhook_url: String,
    client: reqwest::Client,
}

impl HttpNotificationService {
    pub fn new(webhook_url: String) -> Self {
        Self {
            webhook_url,
            client: reqwest::Client::new(),
        }
    }
}

#[async_trait::async_trait]
impl NotificationService for HttpNotificationService {
    async fn send_notification(&self, message: &str) -> Result<(), Box<dyn std::error::Error>> {
        let payload = serde_json::json!({
            "text": message,
            "timestamp": chrono::Utc::now().to_rfc3339()
        });
        
        self.client
            .post(&self.webhook_url)
            .json(&payload)
            .send()
            .await?;
        
        Ok(())
    }
}

// 环境变量配置服务适配器
pub struct EnvConfigurationService;

#[async_trait::async_trait]
impl ConfigurationService for EnvConfigurationService {
    async fn get_config(&self, key: &str) -> Result<Option<String>, Box<dyn std::error::Error>> {
        Ok(std::env::var(key).ok())
    }
}
```

## 📚 最佳实践总结

### 1. 架构选择指南

| 场景 | 推荐架构 | 原因 |
|------|----------|------|
| **小型项目** | 分层架构 | 简单、易维护 |
| **中型项目** | 六边形架构 | 可测试、可扩展 |
| **大型项目** | 微服务架构 | 高可扩展性 |
| **高并发系统** | 事件驱动架构 | 异步处理能力强 |
| **复杂业务** | 领域驱动设计 | 业务逻辑清晰 |
| **读写分离** | CQRS模式 | 性能优化 |

### 2. 实施建议

- **渐进式演进**: 从简单架构开始，逐步演进
- **领域驱动**: 以业务领域为核心设计架构
- **松耦合**: 保持组件间的松耦合关系
- **高内聚**: 相关功能聚合在一起
- **可测试**: 确保架构的可测试性
- **可扩展**: 设计时考虑未来的扩展需求

### 3. 性能考虑

- **异步处理**: 使用异步模式提高并发能力
- **缓存策略**: 合理使用缓存减少数据库访问
- **负载均衡**: 实现负载均衡提高系统吞吐量
- **资源池化**: 使用连接池等资源池化技术
- **监控告警**: 建立完善的监控告警体系

---

**企业级架构模式版本**: v1.0  
**最后更新**: 2025年1月27日  
**维护者**: OTLP 2025 文档团队
