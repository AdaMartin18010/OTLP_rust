# OTLP Rust ä¼ä¸šçº§æ¶æ„æ¨¡å¼

## ğŸ“š æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»äº†OTLP Ruståœ¨ä¼ä¸šçº§åº”ç”¨ä¸­çš„é«˜çº§æ¶æ„æ¨¡å¼ï¼ŒåŒ…æ‹¬å¾®æœåŠ¡æ¶æ„ã€äº‹ä»¶é©±åŠ¨æ¶æ„ã€CQRSæ¨¡å¼ã€é¢†åŸŸé©±åŠ¨è®¾è®¡ç­‰ç°ä»£ä¼ä¸šæ¶æ„æ¨¡å¼ã€‚

## ğŸ—ï¸ ä¼ä¸šçº§æ¶æ„æ¨¡å¼æ¦‚è§ˆ

### 1. æ¶æ„æ¨¡å¼åˆ†ç±»

| æ¨¡å¼ç±»å‹ | é€‚ç”¨åœºæ™¯ | å¤æ‚åº¦ | æ€§èƒ½ | å¯æ‰©å±•æ€§ |
|----------|----------|--------|------|----------|
| **å¾®æœåŠ¡æ¶æ„** | å¤§å‹åˆ†å¸ƒå¼ç³»ç»Ÿ | é«˜ | é«˜ | æé«˜ |
| **äº‹ä»¶é©±åŠ¨æ¶æ„** | å¼‚æ­¥å¤„ç†ç³»ç»Ÿ | ä¸­ | æé«˜ | é«˜ |
| **CQRSæ¨¡å¼** | è¯»å†™åˆ†ç¦»ç³»ç»Ÿ | é«˜ | æé«˜ | é«˜ |
| **é¢†åŸŸé©±åŠ¨è®¾è®¡** | å¤æ‚ä¸šåŠ¡ç³»ç»Ÿ | é«˜ | ä¸­ | é«˜ |
| **å…­è¾¹å½¢æ¶æ„** | å¯æµ‹è¯•ç³»ç»Ÿ | ä¸­ | ä¸­ | é«˜ |
| **æ´‹è‘±æ¶æ„** | ä¾èµ–å€’ç½®ç³»ç»Ÿ | ä¸­ | ä¸­ | é«˜ |

### 2. æ¶æ„æ¼”è¿›è·¯å¾„

```text
å•ä½“æ¶æ„ â†’ åˆ†å±‚æ¶æ„ â†’ å¾®æœåŠ¡æ¶æ„ â†’ äº‘åŸç”Ÿæ¶æ„ â†’ æœåŠ¡ç½‘æ ¼æ¶æ„
```

## ğŸ”§ å¾®æœåŠ¡æ¶æ„æ¨¡å¼

### 1. å¾®æœåŠ¡æ¶æ„è®¾è®¡

```rust
// src/architecture/microservices/mod.rs
use std::collections::HashMap;
use tokio::sync::RwLock;
use serde::{Serialize, Deserialize};

pub mod service_registry;
pub mod service_discovery;
pub mod circuit_breaker;
pub mod load_balancer;
pub mod api_gateway;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServiceInstance {
    pub id: String,
    pub name: String,
    pub host: String,
    pub port: u16,
    pub health_check_url: String,
    pub metadata: HashMap<String, String>,
    pub status: ServiceStatus,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ServiceStatus {
    Healthy,
    Unhealthy,
    Starting,
    Stopping,
}

#[derive(Debug, Clone)]
pub struct MicroserviceArchitecture {
    pub services: RwLock<HashMap<String, Vec<ServiceInstance>>>,
    pub service_registry: service_registry::ServiceRegistry,
    pub circuit_breaker: circuit_breaker::CircuitBreaker,
    pub load_balancer: load_balancer::LoadBalancer,
}

impl MicroserviceArchitecture {
    pub async fn new() -> Self {
        Self {
            services: RwLock::new(HashMap::new()),
            service_registry: service_registry::ServiceRegistry::new(),
            circuit_breaker: circuit_breaker::CircuitBreaker::new(),
            load_balancer: load_balancer::LoadBalancer::new(),
        }
    }
    
    pub async fn register_service(&self, service: ServiceInstance) -> Result<(), Box<dyn std::error::Error>> {
        self.service_registry.register(service.clone()).await?;
        
        let mut services = self.services.write().await;
        services.entry(service.name.clone())
            .or_insert_with(Vec::new)
            .push(service);
        
        Ok(())
    }
    
    pub async fn discover_service(&self, service_name: &str) -> Result<Vec<ServiceInstance>, Box<dyn std::error::Error>> {
        self.service_registry.discover(service_name).await
    }
    
    pub async fn call_service(&self, service_name: &str, request: &[u8]) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        let instances = self.discover_service(service_name).await?;
        let instance = self.load_balancer.select_instance(&instances)?;
        
        if self.circuit_breaker.is_open(&instance.id).await {
            return Err("Circuit breaker is open".into());
        }
        
        match self.execute_request(&instance, request).await {
            Ok(response) => {
                self.circuit_breaker.record_success(&instance.id).await;
                Ok(response)
            }
            Err(e) => {
                self.circuit_breaker.record_failure(&instance.id).await;
                Err(e)
            }
        }
    }
    
    async fn execute_request(&self, instance: &ServiceInstance, request: &[u8]) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        // å®ç°æœåŠ¡è°ƒç”¨é€»è¾‘
        let url = format!("http://{}:{}/api", instance.host, instance.port);
        let client = reqwest::Client::new();
        let response = client.post(&url)
            .body(request.to_vec())
            .send()
            .await?;
        
        Ok(response.bytes().await?.to_vec())
    }
}
```

### 2. æœåŠ¡æ³¨å†Œä¸å‘ç°

```rust
// src/architecture/microservices/service_registry.rs
use std::collections::HashMap;
use std::time::{Duration, Instant};
use tokio::sync::RwLock;
use tokio::time::interval;

pub struct ServiceRegistry {
    services: RwLock<HashMap<String, Vec<ServiceInstance>>>,
    health_check_interval: Duration,
}

impl ServiceRegistry {
    pub fn new() -> Self {
        Self {
            services: RwLock::new(HashMap::new()),
            health_check_interval: Duration::from_secs(30),
        }
    }
    
    pub async fn register(&self, service: ServiceInstance) -> Result<(), Box<dyn std::error::Error>> {
        let mut services = self.services.write().await;
        services.entry(service.name.clone())
            .or_insert_with(Vec::new)
            .retain(|s| s.id != service.id);
        services.entry(service.name.clone())
            .or_insert_with(Vec::new)
            .push(service);
        
        Ok(())
    }
    
    pub async fn unregister(&self, service_id: &str) -> Result<(), Box<dyn std::error::Error>> {
        let mut services = self.services.write().await;
        for service_list in services.values_mut() {
            service_list.retain(|s| s.id != service_id);
        }
        
        Ok(())
    }
    
    pub async fn discover(&self, service_name: &str) -> Result<Vec<ServiceInstance>, Box<dyn std::error::Error>> {
        let services = self.services.read().await;
        Ok(services.get(service_name)
            .cloned()
            .unwrap_or_default()
            .into_iter()
            .filter(|s| matches!(s.status, ServiceStatus::Healthy))
            .collect())
    }
    
    pub async fn start_health_check(&self) {
        let mut interval = interval(self.health_check_interval);
        
        loop {
            interval.tick().await;
            self.perform_health_check().await;
        }
    }
    
    async fn perform_health_check(&self) {
        let services = self.services.read().await;
        let mut services_to_update = Vec::new();
        
        for (service_name, instances) in services.iter() {
            for instance in instances {
                let health_status = self.check_instance_health(instance).await;
                if health_status != instance.status {
                    services_to_update.push((service_name.clone(), instance.id.clone(), health_status));
                }
            }
        }
        
        // æ›´æ–°æœåŠ¡çŠ¶æ€
        let mut services = self.services.write().await;
        for (service_name, instance_id, new_status) in services_to_update {
            if let Some(instances) = services.get_mut(&service_name) {
                if let Some(instance) = instances.iter_mut().find(|s| s.id == instance_id) {
                    instance.status = new_status;
                }
            }
        }
    }
    
    async fn check_instance_health(&self, instance: &ServiceInstance) -> ServiceStatus {
        let client = reqwest::Client::new();
        let url = format!("http://{}:{}", instance.host, instance.port);
        
        match client.get(&url)
            .timeout(Duration::from_secs(5))
            .send()
            .await
        {
            Ok(response) if response.status().is_success() => ServiceStatus::Healthy,
            _ => ServiceStatus::Unhealthy,
        }
    }
}
```

### 3. ç†”æ–­å™¨æ¨¡å¼

```rust
// src/architecture/microservices/circuit_breaker.rs
use std::collections::HashMap;
use std::time::{Duration, Instant};
use tokio::sync::RwLock;

#[derive(Debug, Clone)]
pub enum CircuitState {
    Closed,
    Open,
    HalfOpen,
}

pub struct CircuitBreaker {
    circuits: RwLock<HashMap<String, CircuitData>>,
    failure_threshold: u32,
    timeout_duration: Duration,
}

struct CircuitData {
    state: CircuitState,
    failure_count: u32,
    last_failure_time: Option<Instant>,
    success_count: u32,
}

impl CircuitBreaker {
    pub fn new() -> Self {
        Self {
            circuits: RwLock::new(HashMap::new()),
            failure_threshold: 5,
            timeout_duration: Duration::from_secs(60),
        }
    }
    
    pub async fn is_open(&self, service_id: &str) -> bool {
        let circuits = self.circuits.read().await;
        if let Some(circuit) = circuits.get(service_id) {
            match circuit.state {
                CircuitState::Open => {
                    if let Some(last_failure) = circuit.last_failure_time {
                        if last_failure.elapsed() > self.timeout_duration {
                            return false; // å¯ä»¥å°è¯•åŠå¼€çŠ¶æ€
                        }
                    }
                    true
                }
                CircuitState::HalfOpen => false,
                CircuitState::Closed => false,
            }
        } else {
            false
        }
    }
    
    pub async fn record_success(&self, service_id: &str) {
        let mut circuits = self.circuits.write().await;
        let circuit = circuits.entry(service_id.to_string()).or_insert_with(|| CircuitData {
            state: CircuitState::Closed,
            failure_count: 0,
            last_failure_time: None,
            success_count: 0,
        });
        
        match circuit.state {
            CircuitState::HalfOpen => {
                circuit.success_count += 1;
                if circuit.success_count >= 3 {
                    circuit.state = CircuitState::Closed;
                    circuit.failure_count = 0;
                    circuit.success_count = 0;
                }
            }
            CircuitState::Closed => {
                circuit.failure_count = 0;
            }
            CircuitState::Open => {
                circuit.state = CircuitState::HalfOpen;
                circuit.success_count = 1;
            }
        }
    }
    
    pub async fn record_failure(&self, service_id: &str) {
        let mut circuits = self.circuits.write().await;
        let circuit = circuits.entry(service_id.to_string()).or_insert_with(|| CircuitData {
            state: CircuitState::Closed,
            failure_count: 0,
            last_failure_time: None,
            success_count: 0,
        });
        
        circuit.failure_count += 1;
        circuit.last_failure_time = Some(Instant::now());
        
        if circuit.failure_count >= self.failure_threshold {
            circuit.state = CircuitState::Open;
        }
    }
}
```

## ğŸ¯ äº‹ä»¶é©±åŠ¨æ¶æ„æ¨¡å¼

### 1. äº‹ä»¶æ€»çº¿å®ç°

```rust
// src/architecture/event_driven/event_bus.rs
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{broadcast, RwLock};
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Event {
    pub id: String,
    pub event_type: String,
    pub payload: serde_json::Value,
    pub timestamp: chrono::DateTime<chrono::Utc>,
    pub source: String,
}

pub type EventHandler = Arc<dyn Fn(Event) -> Result<(), Box<dyn std::error::Error>> + Send + Sync>;

pub struct EventBus {
    handlers: RwLock<HashMap<String, Vec<EventHandler>>>,
    event_sender: broadcast::Sender<Event>,
}

impl EventBus {
    pub fn new() -> Self {
        let (sender, _) = broadcast::channel(1000);
        
        Self {
            handlers: RwLock::new(HashMap::new()),
            event_sender: sender,
        }
    }
    
    pub fn subscribe<F>(&self, event_type: &str, handler: F) -> Result<(), Box<dyn std::error::Error>>
    where
        F: Fn(Event) -> Result<(), Box<dyn std::error::Error>> + Send + Sync + 'static,
    {
        let mut handlers = tokio::runtime::Handle::current().block_on(self.handlers.write());
        handlers.entry(event_type.to_string())
            .or_insert_with(Vec::new)
            .push(Arc::new(handler));
        
        Ok(())
    }
    
    pub async fn publish(&self, event: Event) -> Result<(), Box<dyn std::error::Error>> {
        // å¹¿æ’­äº‹ä»¶
        self.event_sender.send(event.clone())?;
        
        // è°ƒç”¨åŒæ­¥å¤„ç†å™¨
        self.call_sync_handlers(&event).await?;
        
        Ok(())
    }
    
    async fn call_sync_handlers(&self, event: &Event) -> Result<(), Box<dyn std::error::Error>> {
        let handlers = self.handlers.read().await;
        if let Some(event_handlers) = handlers.get(&event.event_type) {
            for handler in event_handlers {
                if let Err(e) = handler(event.clone()) {
                    log::error!("Event handler failed: {}", e);
                }
            }
        }
        
        Ok(())
    }
    
    pub fn create_receiver(&self) -> broadcast::Receiver<Event> {
        self.event_sender.subscribe()
    }
}

// äº‹ä»¶å¤„ç†å™¨ç¤ºä¾‹
pub struct OtlpEventProcessor {
    event_bus: Arc<EventBus>,
}

impl OtlpEventProcessor {
    pub fn new(event_bus: Arc<EventBus>) -> Self {
        Self { event_bus }
    }
    
    pub async fn start(&self) -> Result<(), Box<dyn std::error::Error>> {
        let mut receiver = self.event_bus.create_receiver();
        
        tokio::spawn(async move {
            while let Ok(event) = receiver.recv().await {
                match event.event_type.as_str() {
                    "trace.created" => {
                        Self::handle_trace_created(event).await;
                    }
                    "metric.updated" => {
                        Self::handle_metric_updated(event).await;
                    }
                    "log.error" => {
                        Self::handle_log_error(event).await;
                    }
                    _ => {
                        log::warn!("Unknown event type: {}", event.event_type);
                    }
                }
            }
        });
        
        Ok(())
    }
    
    async fn handle_trace_created(event: Event) {
        log::info!("Processing trace created event: {}", event.id);
        // å®ç°è¿½è¸ªæ•°æ®å¤„ç†é€»è¾‘
    }
    
    async fn handle_metric_updated(event: Event) {
        log::info!("Processing metric updated event: {}", event.id);
        // å®ç°æŒ‡æ ‡æ•°æ®å¤„ç†é€»è¾‘
    }
    
    async fn handle_log_error(event: Event) {
        log::error!("Processing log error event: {}", event.id);
        // å®ç°é”™è¯¯æ—¥å¿—å¤„ç†é€»è¾‘
    }
}
```

### 2. äº‹ä»¶æº¯æºæ¨¡å¼

```rust
// src/architecture/event_driven/event_sourcing.rs
use std::collections::VecDeque;
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DomainEvent {
    pub event_id: String,
    pub aggregate_id: String,
    pub event_type: String,
    pub event_data: serde_json::Value,
    pub timestamp: DateTime<Utc>,
    pub version: u64,
}

pub trait Aggregate {
    fn apply_event(&mut self, event: &DomainEvent);
    fn get_id(&self) -> String;
    fn get_version(&self) -> u64;
}

pub struct EventStore {
    events: VecDeque<DomainEvent>,
    snapshots: std::collections::HashMap<String, serde_json::Value>,
}

impl EventStore {
    pub fn new() -> Self {
        Self {
            events: VecDeque::new(),
            snapshots: std::collections::HashMap::new(),
        }
    }
    
    pub fn append_event(&mut self, event: DomainEvent) -> Result<(), Box<dyn std::error::Error>> {
        self.events.push_back(event);
        Ok(())
    }
    
    pub fn get_events(&self, aggregate_id: &str, from_version: u64) -> Vec<DomainEvent> {
        self.events.iter()
            .filter(|e| e.aggregate_id == aggregate_id && e.version > from_version)
            .cloned()
            .collect()
    }
    
    pub fn save_snapshot(&mut self, aggregate_id: &str, snapshot: serde_json::Value) {
        self.snapshots.insert(aggregate_id.to_string(), snapshot);
    }
    
    pub fn get_snapshot(&self, aggregate_id: &str) -> Option<&serde_json::Value> {
        self.snapshots.get(aggregate_id)
    }
}

// ç¤ºä¾‹èšåˆæ ¹
#[derive(Debug, Clone)]
pub struct TraceAggregate {
    pub id: String,
    pub service_name: String,
    pub operation_name: String,
    pub status: String,
    pub version: u64,
}

impl Aggregate for TraceAggregate {
    fn apply_event(&mut self, event: &DomainEvent) {
        match event.event_type.as_str() {
            "TraceCreated" => {
                self.id = event.aggregate_id.clone();
                self.service_name = event.event_data["service_name"].as_str().unwrap_or("").to_string();
                self.operation_name = event.event_data["operation_name"].as_str().unwrap_or("").to_string();
                self.status = "started".to_string();
            }
            "TraceCompleted" => {
                self.status = event.event_data["status"].as_str().unwrap_or("completed").to_string();
            }
            "TraceFailed" => {
                self.status = "failed".to_string();
            }
            _ => {}
        }
        self.version = event.version;
    }
    
    fn get_id(&self) -> String {
        self.id.clone()
    }
    
    fn get_version(&self) -> u64 {
        self.version
    }
}

impl TraceAggregate {
    pub fn new(id: String, service_name: String, operation_name: String) -> Self {
        Self {
            id,
            service_name,
            operation_name,
            status: "started".to_string(),
            version: 0,
        }
    }
    
    pub fn start_trace(&mut self, service_name: String, operation_name: String) -> DomainEvent {
        self.version += 1;
        DomainEvent {
            event_id: uuid::Uuid::new_v4().to_string(),
            aggregate_id: self.id.clone(),
            event_type: "TraceCreated".to_string(),
            event_data: serde_json::json!({
                "service_name": service_name,
                "operation_name": operation_name,
                "timestamp": chrono::Utc::now()
            }),
            timestamp: chrono::Utc::now(),
            version: self.version,
        }
    }
    
    pub fn complete_trace(&mut self, status: String) -> DomainEvent {
        self.version += 1;
        DomainEvent {
            event_id: uuid::Uuid::new_v4().to_string(),
            aggregate_id: self.id.clone(),
            event_type: "TraceCompleted".to_string(),
            event_data: serde_json::json!({
                "status": status,
                "timestamp": chrono::Utc::now()
            }),
            timestamp: chrono::Utc::now(),
            version: self.version,
        }
    }
}
```

## ğŸ“Š CQRSæ¨¡å¼å®ç°

### 1. å‘½ä»¤æŸ¥è¯¢èŒè´£åˆ†ç¦»

```rust
// src/architecture/cqrs/mod.rs
use serde::{Serialize, Deserialize};
use std::collections::HashMap;
use tokio::sync::RwLock;

pub mod command;
pub mod query;
pub mod command_handler;
pub mod query_handler;
pub mod event_store;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Command {
    pub command_id: String,
    pub command_type: String,
    pub aggregate_id: String,
    pub command_data: serde_json::Value,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Query {
    pub query_id: String,
    pub query_type: String,
    pub query_data: serde_json::Value,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

pub trait CommandHandler<T> {
    async fn handle(&self, command: Command) -> Result<Vec<DomainEvent>, Box<dyn std::error::Error>>;
}

pub trait QueryHandler<T> {
    async fn handle(&self, query: Query) -> Result<T, Box<dyn std::error::Error>>;
}

pub struct CqrsBus {
    command_handlers: RwLock<HashMap<String, Box<dyn CommandHandler<()> + Send + Sync>>>,
    query_handlers: RwLock<HashMap<String, Box<dyn QueryHandler<()> + Send + Sync>>>,
    event_store: Arc<event_store::EventStore>,
}

impl CqrsBus {
    pub fn new(event_store: Arc<event_store::EventStore>) -> Self {
        Self {
            command_handlers: RwLock::new(HashMap::new()),
            query_handlers: RwLock::new(HashMap::new()),
            event_store,
        }
    }
    
    pub async fn register_command_handler<H>(&self, command_type: &str, handler: H)
    where
        H: CommandHandler<()> + Send + Sync + 'static,
    {
        let mut handlers = self.command_handlers.write().await;
        handlers.insert(command_type.to_string(), Box::new(handler));
    }
    
    pub async fn register_query_handler<H>(&self, query_type: &str, handler: H)
    where
        H: QueryHandler<()> + Send + Sync + 'static,
    {
        let mut handlers = self.query_handlers.write().await;
        handlers.insert(query_type.to_string(), Box::new(handler));
    }
    
    pub async fn execute_command(&self, command: Command) -> Result<Vec<DomainEvent>, Box<dyn std::error::Error>> {
        let handlers = self.command_handlers.read().await;
        if let Some(handler) = handlers.get(&command.command_type) {
            let events = handler.handle(command).await?;
            
            // ä¿å­˜äº‹ä»¶åˆ°äº‹ä»¶å­˜å‚¨
            for event in &events {
                self.event_store.append_event(event.clone()).await?;
            }
            
            Ok(events)
        } else {
            Err(format!("No handler found for command type: {}", command.command_type).into())
        }
    }
    
    pub async fn execute_query<T>(&self, query: Query) -> Result<T, Box<dyn std::error::Error>>
    where
        T: serde::de::DeserializeOwned,
    {
        let handlers = self.query_handlers.read().await;
        if let Some(handler) = handlers.get(&query.query_type) {
            let result: T = serde_json::from_value(handler.handle(query).await?)?;
            Ok(result)
        } else {
            Err(format!("No handler found for query type: {}", query.query_type).into())
        }
    }
}
```

### 2. è¯»æ¨¡å‹æŠ•å½±

```rust
// src/architecture/cqrs/read_models.rs
use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use tokio::sync::RwLock;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TraceReadModel {
    pub id: String,
    pub service_name: String,
    pub operation_name: String,
    pub status: String,
    pub duration: Option<u64>,
    pub start_time: chrono::DateTime<chrono::Utc>,
    pub end_time: Option<chrono::DateTime<chrono::Utc>>,
    pub tags: HashMap<String, String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MetricReadModel {
    pub id: String,
    pub name: String,
    pub value: f64,
    pub unit: String,
    pub timestamp: chrono::DateTime<chrono::Utc>,
    pub labels: HashMap<String, String>,
}

pub struct ReadModelProjection {
    traces: RwLock<HashMap<String, TraceReadModel>>,
    metrics: RwLock<HashMap<String, MetricReadModel>>,
}

impl ReadModelProjection {
    pub fn new() -> Self {
        Self {
            traces: RwLock::new(HashMap::new()),
            metrics: RwLock::new(HashMap::new()),
        }
    }
    
    pub async fn apply_event(&self, event: &DomainEvent) -> Result<(), Box<dyn std::error::Error>> {
        match event.event_type.as_str() {
            "TraceCreated" => {
                let trace = TraceReadModel {
                    id: event.aggregate_id.clone(),
                    service_name: event.event_data["service_name"].as_str().unwrap_or("").to_string(),
                    operation_name: event.event_data["operation_name"].as_str().unwrap_or("").to_string(),
                    status: "started".to_string(),
                    duration: None,
                    start_time: chrono::DateTime::parse_from_rfc3339(
                        event.event_data["timestamp"].as_str().unwrap_or("")
                    )?.with_timezone(&chrono::Utc),
                    end_time: None,
                    tags: HashMap::new(),
                };
                
                let mut traces = self.traces.write().await;
                traces.insert(event.aggregate_id.clone(), trace);
            }
            "TraceCompleted" => {
                let mut traces = self.traces.write().await;
                if let Some(trace) = traces.get_mut(&event.aggregate_id) {
                    trace.status = event.event_data["status"].as_str().unwrap_or("completed").to_string();
                    trace.end_time = Some(chrono::Utc::now());
                    if let Some(start_time) = trace.start_time.timestamp_millis() {
                        trace.duration = Some(chrono::Utc::now().timestamp_millis() as u64 - start_time as u64);
                    }
                }
            }
            "MetricUpdated" => {
                let metric = MetricReadModel {
                    id: event.aggregate_id.clone(),
                    name: event.event_data["name"].as_str().unwrap_or("").to_string(),
                    value: event.event_data["value"].as_f64().unwrap_or(0.0),
                    unit: event.event_data["unit"].as_str().unwrap_or("").to_string(),
                    timestamp: chrono::DateTime::parse_from_rfc3339(
                        event.event_data["timestamp"].as_str().unwrap_or("")
                    )?.with_timezone(&chrono::Utc),
                    labels: event.event_data["labels"].as_object()
                        .map(|obj| obj.iter()
                            .filter_map(|(k, v)| v.as_str().map(|s| (k.clone(), s.to_string())))
                            .collect())
                        .unwrap_or_default(),
                };
                
                let mut metrics = self.metrics.write().await;
                metrics.insert(event.aggregate_id.clone(), metric);
            }
            _ => {}
        }
        
        Ok(())
    }
    
    pub async fn get_trace(&self, id: &str) -> Option<TraceReadModel> {
        let traces = self.traces.read().await;
        traces.get(id).cloned()
    }
    
    pub async fn get_metrics_by_name(&self, name: &str) -> Vec<MetricReadModel> {
        let metrics = self.metrics.read().await;
        metrics.values()
            .filter(|m| m.name == name)
            .cloned()
            .collect()
    }
}
```

## ğŸ¯ é¢†åŸŸé©±åŠ¨è®¾è®¡

### 1. é¢†åŸŸæ¨¡å‹

```rust
// src/architecture/ddd/domain_models.rs
use serde::{Serialize, Deserialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Service {
    pub id: ServiceId,
    pub name: String,
    pub version: String,
    pub environment: Environment,
    pub health_status: HealthStatus,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServiceId(String);

impl ServiceId {
    pub fn new(id: String) -> Self {
        Self(id)
    }
    
    pub fn value(&self) -> &str {
        &self.0
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Environment {
    Development,
    Staging,
    Production,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum HealthStatus {
    Healthy,
    Unhealthy,
    Unknown,
}

impl Service {
    pub fn new(id: ServiceId, name: String, version: String, environment: Environment) -> Self {
        Self {
            id,
            name,
            version,
            environment,
            health_status: HealthStatus::Unknown,
        }
    }
    
    pub fn update_health_status(&mut self, status: HealthStatus) {
        self.health_status = status;
    }
    
    pub fn is_healthy(&self) -> bool {
        matches!(self.health_status, HealthStatus::Healthy)
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Trace {
    pub id: TraceId,
    pub service_id: ServiceId,
    pub operation_name: String,
    pub start_time: chrono::DateTime<chrono::Utc>,
    pub end_time: Option<chrono::DateTime<chrono::Utc>>,
    pub status: TraceStatus,
    pub spans: Vec<Span>,
    pub tags: HashMap<String, String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TraceId(String);

impl TraceId {
    pub fn new(id: String) -> Self {
        Self(id)
    }
    
    pub fn value(&self) -> &str {
        &self.0
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TraceStatus {
    Started,
    Completed,
    Failed,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Span {
    pub id: SpanId,
    pub parent_id: Option<SpanId>,
    pub operation_name: String,
    pub start_time: chrono::DateTime<chrono::Utc>,
    pub end_time: Option<chrono::DateTime<chrono::Utc>>,
    pub tags: HashMap<String, String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SpanId(String);

impl SpanId {
    pub fn new(id: String) -> Self {
        Self(id)
    }
    
    pub fn value(&self) -> &str {
        &self.0
    }
}

impl Trace {
    pub fn new(id: TraceId, service_id: ServiceId, operation_name: String) -> Self {
        Self {
            id,
            service_id,
            operation_name,
            start_time: chrono::Utc::now(),
            end_time: None,
            status: TraceStatus::Started,
            spans: Vec::new(),
            tags: HashMap::new(),
        }
    }
    
    pub fn add_span(&mut self, span: Span) {
        self.spans.push(span);
    }
    
    pub fn complete(&mut self) {
        self.status = TraceStatus::Completed;
        self.end_time = Some(chrono::Utc::now());
    }
    
    pub fn fail(&mut self) {
        self.status = TraceStatus::Failed;
        self.end_time = Some(chrono::Utc::now());
    }
    
    pub fn duration(&self) -> Option<chrono::Duration> {
        if let Some(end_time) = self.end_time {
            Some(end_time - self.start_time)
        } else {
            None
        }
    }
}
```

## ğŸ›ï¸ å…­è¾¹å½¢æ¶æ„

### 1. ç«¯å£å’Œé€‚é…å™¨

```rust
// src/architecture/hexagonal/mod.rs
use serde::{Serialize, Deserialize};

pub mod ports;
pub mod adapters;
pub mod domain;

// ç«¯å£å®šä¹‰
pub trait TelemetryRepository {
    async fn save_trace(&self, trace: domain::Trace) -> Result<(), Box<dyn std::error::Error>>;
    async fn get_trace(&self, id: &str) -> Result<Option<domain::Trace>, Box<dyn std::error::Error>>;
    async fn get_traces_by_service(&self, service_id: &str) -> Result<Vec<domain::Trace>, Box<dyn std::error::Error>>;
}

pub trait NotificationService {
    async fn send_notification(&self, message: &str) -> Result<(), Box<dyn std::error::Error>>;
}

pub trait ConfigurationService {
    async fn get_config(&self, key: &str) -> Result<Option<String>, Box<dyn std::error::Error>>;
}

// åº”ç”¨æœåŠ¡
pub struct TelemetryApplicationService {
    repository: Box<dyn TelemetryRepository + Send + Sync>,
    notification_service: Box<dyn NotificationService + Send + Sync>,
    config_service: Box<dyn ConfigurationService + Send + Sync>,
}

impl TelemetryApplicationService {
    pub fn new(
        repository: Box<dyn TelemetryRepository + Send + Sync>,
        notification_service: Box<dyn NotificationService + Send + Sync>,
        config_service: Box<dyn ConfigurationService + Send + Sync>,
    ) -> Self {
        Self {
            repository,
            notification_service,
            config_service,
        }
    }
    
    pub async fn create_trace(&self, service_id: &str, operation_name: &str) -> Result<domain::Trace, Box<dyn std::error::Error>> {
        let trace = domain::Trace::new(
            domain::TraceId::new(uuid::Uuid::new_v4().to_string()),
            domain::ServiceId::new(service_id.to_string()),
            operation_name.to_string(),
        );
        
        self.repository.save_trace(trace.clone()).await?;
        
        // å‘é€é€šçŸ¥
        if let Ok(Some(notification_enabled)) = self.config_service.get_config("notification.enabled").await {
            if notification_enabled == "true" {
                let _ = self.notification_service.send_notification(&format!(
                    "New trace created: {} for service: {}", trace.id.value(), service_id
                )).await;
            }
        }
        
        Ok(trace)
    }
    
    pub async fn complete_trace(&self, trace_id: &str) -> Result<(), Box<dyn std::error::Error>> {
        if let Some(mut trace) = self.repository.get_trace(trace_id).await? {
            trace.complete();
            self.repository.save_trace(trace).await?;
        }
        
        Ok(())
    }
}
```

### 2. é€‚é…å™¨å®ç°

```rust
// src/architecture/hexagonal/adapters.rs
use super::ports::{TelemetryRepository, NotificationService, ConfigurationService};
use super::domain;
use std::collections::HashMap;
use tokio::sync::RwLock;

// å†…å­˜å­˜å‚¨é€‚é…å™¨
pub struct InMemoryTelemetryRepository {
    traces: RwLock<HashMap<String, domain::Trace>>,
}

impl InMemoryTelemetryRepository {
    pub fn new() -> Self {
        Self {
            traces: RwLock::new(HashMap::new()),
        }
    }
}

#[async_trait::async_trait]
impl TelemetryRepository for InMemoryTelemetryRepository {
    async fn save_trace(&self, trace: domain::Trace) -> Result<(), Box<dyn std::error::Error>> {
        let mut traces = self.traces.write().await;
        traces.insert(trace.id.value().to_string(), trace);
        Ok(())
    }
    
    async fn get_trace(&self, id: &str) -> Result<Option<domain::Trace>, Box<dyn std::error::Error>> {
        let traces = self.traces.read().await;
        Ok(traces.get(id).cloned())
    }
    
    async fn get_traces_by_service(&self, service_id: &str) -> Result<Vec<domain::Trace>, Box<dyn std::error::Error>> {
        let traces = self.traces.read().await;
        Ok(traces.values()
            .filter(|trace| trace.service_id.value() == service_id)
            .cloned()
            .collect())
    }
}

// HTTPé€šçŸ¥æœåŠ¡é€‚é…å™¨
pub struct HttpNotificationService {
    webhook_url: String,
    client: reqwest::Client,
}

impl HttpNotificationService {
    pub fn new(webhook_url: String) -> Self {
        Self {
            webhook_url,
            client: reqwest::Client::new(),
        }
    }
}

#[async_trait::async_trait]
impl NotificationService for HttpNotificationService {
    async fn send_notification(&self, message: &str) -> Result<(), Box<dyn std::error::Error>> {
        let payload = serde_json::json!({
            "text": message,
            "timestamp": chrono::Utc::now().to_rfc3339()
        });
        
        self.client
            .post(&self.webhook_url)
            .json(&payload)
            .send()
            .await?;
        
        Ok(())
    }
}

// ç¯å¢ƒå˜é‡é…ç½®æœåŠ¡é€‚é…å™¨
pub struct EnvConfigurationService;

#[async_trait::async_trait]
impl ConfigurationService for EnvConfigurationService {
    async fn get_config(&self, key: &str) -> Result<Option<String>, Box<dyn std::error::Error>> {
        Ok(std::env::var(key).ok())
    }
}
```

## ğŸ“š æœ€ä½³å®è·µæ€»ç»“

### 1. æ¶æ„é€‰æ‹©æŒ‡å—

| åœºæ™¯ | æ¨èæ¶æ„ | åŸå›  |
|------|----------|------|
| **å°å‹é¡¹ç›®** | åˆ†å±‚æ¶æ„ | ç®€å•ã€æ˜“ç»´æŠ¤ |
| **ä¸­å‹é¡¹ç›®** | å…­è¾¹å½¢æ¶æ„ | å¯æµ‹è¯•ã€å¯æ‰©å±• |
| **å¤§å‹é¡¹ç›®** | å¾®æœåŠ¡æ¶æ„ | é«˜å¯æ‰©å±•æ€§ |
| **é«˜å¹¶å‘ç³»ç»Ÿ** | äº‹ä»¶é©±åŠ¨æ¶æ„ | å¼‚æ­¥å¤„ç†èƒ½åŠ›å¼º |
| **å¤æ‚ä¸šåŠ¡** | é¢†åŸŸé©±åŠ¨è®¾è®¡ | ä¸šåŠ¡é€»è¾‘æ¸…æ™° |
| **è¯»å†™åˆ†ç¦»** | CQRSæ¨¡å¼ | æ€§èƒ½ä¼˜åŒ– |

### 2. å®æ–½å»ºè®®

- **æ¸è¿›å¼æ¼”è¿›**: ä»ç®€å•æ¶æ„å¼€å§‹ï¼Œé€æ­¥æ¼”è¿›
- **é¢†åŸŸé©±åŠ¨**: ä»¥ä¸šåŠ¡é¢†åŸŸä¸ºæ ¸å¿ƒè®¾è®¡æ¶æ„
- **æ¾è€¦åˆ**: ä¿æŒç»„ä»¶é—´çš„æ¾è€¦åˆå…³ç³»
- **é«˜å†…èš**: ç›¸å…³åŠŸèƒ½èšåˆåœ¨ä¸€èµ·
- **å¯æµ‹è¯•**: ç¡®ä¿æ¶æ„çš„å¯æµ‹è¯•æ€§
- **å¯æ‰©å±•**: è®¾è®¡æ—¶è€ƒè™‘æœªæ¥çš„æ‰©å±•éœ€æ±‚

### 3. æ€§èƒ½è€ƒè™‘

- **å¼‚æ­¥å¤„ç†**: ä½¿ç”¨å¼‚æ­¥æ¨¡å¼æé«˜å¹¶å‘èƒ½åŠ›
- **ç¼“å­˜ç­–ç•¥**: åˆç†ä½¿ç”¨ç¼“å­˜å‡å°‘æ•°æ®åº“è®¿é—®
- **è´Ÿè½½å‡è¡¡**: å®ç°è´Ÿè½½å‡è¡¡æé«˜ç³»ç»Ÿååé‡
- **èµ„æºæ± åŒ–**: ä½¿ç”¨è¿æ¥æ± ç­‰èµ„æºæ± åŒ–æŠ€æœ¯
- **ç›‘æ§å‘Šè­¦**: å»ºç«‹å®Œå–„çš„ç›‘æ§å‘Šè­¦ä½“ç³»

---

**ä¼ä¸šçº§æ¶æ„æ¨¡å¼ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ27æ—¥  
**ç»´æŠ¤è€…**: OTLP 2025 æ–‡æ¡£å›¢é˜Ÿ
