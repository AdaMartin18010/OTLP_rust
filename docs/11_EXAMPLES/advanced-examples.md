# ğŸš€ é«˜çº§ç¤ºä¾‹

**ç‰ˆæœ¬**: 1.0  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ26æ—¥  
**éš¾åº¦**: â­â­â­ é«˜çº§  
**é¢„è®¡æ—¶é—´**: 5-8å°æ—¶  
**çŠ¶æ€**: ğŸŸ¢ æ´»è·ƒç»´æŠ¤

> **ç®€ä»‹**: OTLP Rust é«˜çº§ç¤ºä¾‹ - å¾®æœåŠ¡ã€åˆ†å¸ƒå¼è¿½è¸ªã€æ€§èƒ½ä¼˜åŒ–å’Œç”Ÿäº§ç¯å¢ƒé…ç½®ã€‚

---

## ğŸ“‹ ç›®å½•

- [ğŸš€ é«˜çº§ç¤ºä¾‹](#-é«˜çº§ç¤ºä¾‹)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ é«˜çº§ç¤ºä¾‹æ¦‚è§ˆ](#-é«˜çº§ç¤ºä¾‹æ¦‚è§ˆ)
    - [ç¤ºä¾‹å¤æ‚åº¦](#ç¤ºä¾‹å¤æ‚åº¦)
    - [å‰ç½®è¦æ±‚](#å‰ç½®è¦æ±‚)
  - [ğŸ—ï¸ å¾®æœåŠ¡æ¶æ„ç¤ºä¾‹](#ï¸-å¾®æœåŠ¡æ¶æ„ç¤ºä¾‹)
    - [æœåŠ¡æ¶æ„è®¾è®¡](#æœåŠ¡æ¶æ„è®¾è®¡)
  - [ğŸ”— åˆ†å¸ƒå¼è¿½è¸ªç¤ºä¾‹](#-åˆ†å¸ƒå¼è¿½è¸ªç¤ºä¾‹)
    - [è·¨æœåŠ¡ä¸Šä¸‹æ–‡ä¼ æ’­](#è·¨æœåŠ¡ä¸Šä¸‹æ–‡ä¼ æ’­)
  - [ğŸ“Š é«˜çº§æŒ‡æ ‡æ”¶é›†](#-é«˜çº§æŒ‡æ ‡æ”¶é›†)
    - [è‡ªå®šä¹‰æŒ‡æ ‡å’Œèšåˆ](#è‡ªå®šä¹‰æŒ‡æ ‡å’Œèšåˆ)
  - [ğŸ”§ è‡ªå®šä¹‰å¯¼å‡ºå™¨](#-è‡ªå®šä¹‰å¯¼å‡ºå™¨)
    - [å®ç°è‡ªå®šä¹‰åç«¯](#å®ç°è‡ªå®šä¹‰åç«¯)
  - [âš¡ æ€§èƒ½ä¼˜åŒ–ç¤ºä¾‹](#-æ€§èƒ½ä¼˜åŒ–ç¤ºä¾‹)
    - [é«˜æ€§èƒ½é…ç½®å’Œä¼˜åŒ–](#é«˜æ€§èƒ½é…ç½®å’Œä¼˜åŒ–)
  - [ğŸ›¡ï¸ å¯é æ€§æ¡†æ¶é›†æˆ](#ï¸-å¯é æ€§æ¡†æ¶é›†æˆ)
    - [é›†æˆå¯é æ€§æ¡†æ¶](#é›†æˆå¯é æ€§æ¡†æ¶)
  - [ğŸ­ ç”Ÿäº§ç¯å¢ƒé…ç½®](#-ç”Ÿäº§ç¯å¢ƒé…ç½®)
    - [å®Œæ•´ç”Ÿäº§é…ç½®](#å®Œæ•´ç”Ÿäº§é…ç½®)
  - [ğŸš€ ä¸‹ä¸€æ­¥](#-ä¸‹ä¸€æ­¥)
    - [è¿›é˜¶å­¦ä¹ è·¯å¾„](#è¿›é˜¶å­¦ä¹ è·¯å¾„)
    - [å®è·µé¡¹ç›®](#å®è·µé¡¹ç›®)
    - [ç›¸å…³èµ„æº](#ç›¸å…³èµ„æº)

---

## ğŸ¯ é«˜çº§ç¤ºä¾‹æ¦‚è§ˆ

### ç¤ºä¾‹å¤æ‚åº¦

| ç¤ºä¾‹ | éš¾åº¦ | é¢„è®¡æ—¶é—´ | ä¸»è¦æŠ€æœ¯ |
|------|------|----------|----------|
| å¾®æœåŠ¡æ¶æ„ | â­â­â­â­ | 45åˆ†é’Ÿ | æœåŠ¡å‘ç°ã€è´Ÿè½½å‡è¡¡ |
| åˆ†å¸ƒå¼è¿½è¸ª | â­â­â­â­ | 40åˆ†é’Ÿ | è·¨æœåŠ¡è¿½è¸ªã€ä¸Šä¸‹æ–‡ä¼ æ’­ |
| é«˜çº§æŒ‡æ ‡æ”¶é›† | â­â­â­ | 30åˆ†é’Ÿ | è‡ªå®šä¹‰æŒ‡æ ‡ã€èšåˆ |
| è‡ªå®šä¹‰å¯¼å‡ºå™¨ | â­â­â­â­â­ | 60åˆ†é’Ÿ | åè®®æ‰©å±•ã€è‡ªå®šä¹‰åç«¯ |
| æ€§èƒ½ä¼˜åŒ– | â­â­â­â­ | 35åˆ†é’Ÿ | æ‰¹å¤„ç†ã€è¿æ¥æ± ã€å‹ç¼© |
| å¯é æ€§æ¡†æ¶é›†æˆ | â­â­â­â­ | 50åˆ†é’Ÿ | æ–­è·¯å™¨ã€é‡è¯•ã€è¶…æ—¶ |
| ç”Ÿäº§ç¯å¢ƒé…ç½® | â­â­â­â­â­ | 60åˆ†é’Ÿ | å®Œæ•´ç”Ÿäº§é…ç½® |

### å‰ç½®è¦æ±‚

- âœ… å®ŒæˆåŸºç¡€ç¤ºä¾‹å­¦ä¹ 
- âœ… äº†è§£ Rust å¼‚æ­¥ç¼–ç¨‹
- âœ… ç†Ÿæ‚‰ OpenTelemetry æ¦‚å¿µ
- âœ… å…·å¤‡å¾®æœåŠ¡æ¶æ„ç»éªŒ

---

## ğŸ—ï¸ å¾®æœåŠ¡æ¶æ„ç¤ºä¾‹

### æœåŠ¡æ¶æ„è®¾è®¡

```rust
use otlp::core::EnhancedOtlpClient;
use opentelemetry::trace::{Tracer, SpanKind, StatusCode};
use std::collections::HashMap;
use std::time::Duration;

// å¾®æœåŠ¡æ¶æ„ç¤ºä¾‹
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("ğŸ—ï¸ å¾®æœåŠ¡æ¶æ„ç¤ºä¾‹");
    
    // åˆ›å»ºæœåŠ¡å‘ç°å®¢æˆ·ç«¯
    let service_discovery = ServiceDiscovery::new()
        .with_consul_endpoint("http://localhost:8500")
        .with_service_registry(true);
    
    // åˆ›å»ºè´Ÿè½½å‡è¡¡å™¨
    let load_balancer = LoadBalancer::new()
        .with_strategy(LoadBalancingStrategy::RoundRobin)
        .with_health_check_interval(Duration::from_secs(30));
    
    // åˆ›å»º OTLP å®¢æˆ·ç«¯
    let client = EnhancedOtlpClient::builder()
        .with_endpoint("http://localhost:4317")
        .with_service_name("microservices-demo")
        .with_service_discovery(service_discovery)
        .with_load_balancer(load_balancer)
        .build()
        .await?;
    
    // æ¨¡æ‹Ÿå¾®æœåŠ¡è°ƒç”¨é“¾
    simulate_microservice_call_chain(&client).await?;
    
    Ok(())
}

// æ¨¡æ‹Ÿå¾®æœåŠ¡è°ƒç”¨é“¾
async fn simulate_microservice_call_chain(
    client: &EnhancedOtlpClient,
) -> Result<(), Box<dyn std::error::Error>> {
    let tracer = client.tracer("api-gateway");
    
    // API Gateway å±‚
    let mut gateway_span = tracer.start_with_kind("api-gateway-request", SpanKind::Server);
    gateway_span.set_attribute("service.name", "api-gateway");
    gateway_span.set_attribute("http.method", "POST");
    gateway_span.set_attribute("http.url", "/api/v1/orders");
    
    // è°ƒç”¨ç”¨æˆ·æœåŠ¡
    let user_service_result = call_user_service(&client, &gateway_span).await?;
    
    // è°ƒç”¨è®¢å•æœåŠ¡
    let order_service_result = call_order_service(&client, &gateway_span).await?;
    
    // è°ƒç”¨æ”¯ä»˜æœåŠ¡
    let payment_service_result = call_payment_service(&client, &gateway_span).await?;
    
    // è°ƒç”¨é€šçŸ¥æœåŠ¡
    let notification_service_result = call_notification_service(&client, &gateway_span).await?;
    
    // å®Œæˆç½‘å…³ Span
    if user_service_result && order_service_result && payment_service_result && notification_service_result {
        gateway_span.set_status(StatusCode::Ok, "All services completed successfully".to_string());
    } else {
        gateway_span.set_status(StatusCode::Error, "Some services failed".to_string());
    }
    gateway_span.end();
    
    Ok(())
}

// ç”¨æˆ·æœåŠ¡è°ƒç”¨
async fn call_user_service(
    client: &EnhancedOtlpClient,
    parent_span: &Span,
) -> Result<bool, Box<dyn std::error::Error>> {
    let tracer = client.tracer("user-service");
    let mut span = tracer.start_with_kind("user-service-validate", SpanKind::Client);
    
    span.set_attribute("service.name", "user-service");
    span.set_attribute("operation", "validate_user");
    span.set_attribute("user.id", "12345");
    
    // æ¨¡æ‹ŸæœåŠ¡è°ƒç”¨
    tokio::time::sleep(Duration::from_millis(50)).await;
    
    // æ¨¡æ‹Ÿå¶å°”çš„å¤±è´¥
    let success = rand::random::<f64>() > 0.1;
    
    if success {
        span.set_status(StatusCode::Ok, "User validation successful".to_string());
        println!("âœ… ç”¨æˆ·æœåŠ¡è°ƒç”¨æˆåŠŸ");
    } else {
        span.set_status(StatusCode::Error, "User validation failed".to_string());
        println!("âŒ ç”¨æˆ·æœåŠ¡è°ƒç”¨å¤±è´¥");
    }
    
    span.end();
    Ok(success)
}

// è®¢å•æœåŠ¡è°ƒç”¨
async fn call_order_service(
    client: &EnhancedOtlpClient,
    parent_span: &Span,
) -> Result<bool, Box<dyn std::error::Error>> {
    let tracer = client.tracer("order-service");
    let mut span = tracer.start_with_kind("order-service-create", SpanKind::Client);
    
    span.set_attribute("service.name", "order-service");
    span.set_attribute("operation", "create_order");
    span.set_attribute("order.amount", 99.99);
    
    // æ¨¡æ‹ŸæœåŠ¡è°ƒç”¨
    tokio::time::sleep(Duration::from_millis(80)).await;
    
    let success = rand::random::<f64>() > 0.05;
    
    if success {
        span.set_status(StatusCode::Ok, "Order creation successful".to_string());
        println!("âœ… è®¢å•æœåŠ¡è°ƒç”¨æˆåŠŸ");
    } else {
        span.set_status(StatusCode::Error, "Order creation failed".to_string());
        println!("âŒ è®¢å•æœåŠ¡è°ƒç”¨å¤±è´¥");
    }
    
    span.end();
    Ok(success)
}

// æ”¯ä»˜æœåŠ¡è°ƒç”¨
async fn call_payment_service(
    client: &EnhancedOtlpClient,
    parent_span: &Span,
) -> Result<bool, Box<dyn std::error::Error>> {
    let tracer = client.tracer("payment-service");
    let mut span = tracer.start_with_kind("payment-service-process", SpanKind::Client);
    
    span.set_attribute("service.name", "payment-service");
    span.set_attribute("operation", "process_payment");
    span.set_attribute("payment.method", "credit_card");
    span.set_attribute("payment.amount", 99.99);
    
    // æ¨¡æ‹ŸæœåŠ¡è°ƒç”¨
    tokio::time::sleep(Duration::from_millis(120)).await;
    
    let success = rand::random::<f64>() > 0.08;
    
    if success {
        span.set_status(StatusCode::Ok, "Payment processing successful".to_string());
        println!("âœ… æ”¯ä»˜æœåŠ¡è°ƒç”¨æˆåŠŸ");
    } else {
        span.set_status(StatusCode::Error, "Payment processing failed".to_string());
        println!("âŒ æ”¯ä»˜æœåŠ¡è°ƒç”¨å¤±è´¥");
    }
    
    span.end();
    Ok(success)
}

// é€šçŸ¥æœåŠ¡è°ƒç”¨
async fn call_notification_service(
    client: &EnhancedOtlpClient,
    parent_span: &Span,
) -> Result<bool, Box<dyn std::error::Error>> {
    let tracer = client.tracer("notification-service");
    let mut span = tracer.start_with_kind("notification-service-send", SpanKind::Client);
    
    span.set_attribute("service.name", "notification-service");
    span.set_attribute("operation", "send_notification");
    span.set_attribute("notification.type", "email");
    
    // æ¨¡æ‹ŸæœåŠ¡è°ƒç”¨
    tokio::time::sleep(Duration::from_millis(30)).await;
    
    let success = rand::random::<f64>() > 0.02;
    
    if success {
        span.set_status(StatusCode::Ok, "Notification sent successfully".to_string());
        println!("âœ… é€šçŸ¥æœåŠ¡è°ƒç”¨æˆåŠŸ");
    } else {
        span.set_status(StatusCode::Error, "Notification sending failed".to_string());
        println!("âŒ é€šçŸ¥æœåŠ¡è°ƒç”¨å¤±è´¥");
    }
    
    span.end();
    Ok(success)
}
```

---

## ğŸ”— åˆ†å¸ƒå¼è¿½è¸ªç¤ºä¾‹

### è·¨æœåŠ¡ä¸Šä¸‹æ–‡ä¼ æ’­

```rust
use otlp::core::EnhancedOtlpClient;
use opentelemetry::trace::{Tracer, SpanKind, StatusCode, TraceContext};
use opentelemetry::propagation::{TextMapPropagator, TraceContextPropagator};
use std::collections::HashMap;

// åˆ†å¸ƒå¼è¿½è¸ªç¤ºä¾‹
async fn distributed_tracing_example() -> Result<(), Box<dyn std::error::Error>> {
    println!("ğŸ”— åˆ†å¸ƒå¼è¿½è¸ªç¤ºä¾‹");
    
    let client = EnhancedOtlpClient::builder()
        .with_endpoint("http://localhost:4317")
        .with_service_name("distributed-tracing-demo")
        .with_trace_context_propagation(true)
        .build()
        .await?;
    
    let tracer = client.tracer("main-service");
    
    // åˆ›å»ºæ ¹ Span
    let mut root_span = tracer.start_with_kind("distributed-operation", SpanKind::Server);
    root_span.set_attribute("service.name", "main-service");
    root_span.set_attribute("operation.id", "distributed-op-001");
    
    // æå–è¿½è¸ªä¸Šä¸‹æ–‡
    let trace_context = root_span.context();
    
    // æ¨¡æ‹Ÿè·¨æœåŠ¡è°ƒç”¨
    let service_a_result = call_service_a(&client, &trace_context).await?;
    let service_b_result = call_service_b(&client, &trace_context).await?;
    let service_c_result = call_service_c(&client, &trace_context).await?;
    
    // å®Œæˆæ ¹ Span
    if service_a_result && service_b_result && service_c_result {
        root_span.set_status(StatusCode::Ok, "All distributed operations completed".to_string());
    } else {
        root_span.set_status(StatusCode::Error, "Some distributed operations failed".to_string());
    }
    root_span.end();
    
    Ok(())
}

// æœåŠ¡ A è°ƒç”¨
async fn call_service_a(
    client: &EnhancedOtlpClient,
    parent_context: &TraceContext,
) -> Result<bool, Box<dyn std::error::Error>> {
    let tracer = client.tracer("service-a");
    
    // ä½¿ç”¨çˆ¶ä¸Šä¸‹æ–‡åˆ›å»ºå­ Span
    let mut span = tracer.start_with_context("service-a-operation", SpanKind::Client, parent_context);
    span.set_attribute("service.name", "service-a");
    span.set_attribute("operation", "data_processing");
    
    // æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
    tokio::time::sleep(Duration::from_millis(100)).await;
    
    // æ¨¡æ‹Ÿå­æ“ä½œ
    let sub_operation_result = perform_sub_operation(&tracer, &span.context()).await?;
    
    if sub_operation_result {
        span.set_status(StatusCode::Ok, "Service A operation successful".to_string());
        println!("âœ… æœåŠ¡ A æ“ä½œæˆåŠŸ");
    } else {
        span.set_status(StatusCode::Error, "Service A operation failed".to_string());
        println!("âŒ æœåŠ¡ A æ“ä½œå¤±è´¥");
    }
    
    span.end();
    Ok(sub_operation_result)
}

// æœåŠ¡ B è°ƒç”¨
async fn call_service_b(
    client: &EnhancedOtlpClient,
    parent_context: &TraceContext,
) -> Result<bool, Box<dyn std::error::Error>> {
    let tracer = client.tracer("service-b");
    
    let mut span = tracer.start_with_context("service-b-operation", SpanKind::Client, parent_context);
    span.set_attribute("service.name", "service-b");
    span.set_attribute("operation", "external_api_call");
    
    // æ¨¡æ‹Ÿå¤–éƒ¨ API è°ƒç”¨
    tokio::time::sleep(Duration::from_millis(150)).await;
    
    let success = rand::random::<f64>() > 0.1;
    
    if success {
        span.set_status(StatusCode::Ok, "Service B operation successful".to_string());
        println!("âœ… æœåŠ¡ B æ“ä½œæˆåŠŸ");
    } else {
        span.set_status(StatusCode::Error, "Service B operation failed".to_string());
        println!("âŒ æœåŠ¡ B æ“ä½œå¤±è´¥");
    }
    
    span.end();
    Ok(success)
}

// æœåŠ¡ C è°ƒç”¨
async fn call_service_c(
    client: &EnhancedOtlpClient,
    parent_context: &TraceContext,
) -> Result<bool, Box<dyn std::error::Error>> {
    let tracer = client.tracer("service-c");
    
    let mut span = tracer.start_with_context("service-c-operation", SpanKind::Client, parent_context);
    span.set_attribute("service.name", "service-c");
    span.set_attribute("operation", "database_operation");
    
    // æ¨¡æ‹Ÿæ•°æ®åº“æ“ä½œ
    tokio::time::sleep(Duration::from_millis(80)).await;
    
    let success = rand::random::<f64>() > 0.05;
    
    if success {
        span.set_status(StatusCode::Ok, "Service C operation successful".to_string());
        println!("âœ… æœåŠ¡ C æ“ä½œæˆåŠŸ");
    } else {
        span.set_status(StatusCode::Error, "Service C operation failed".to_string());
        println!("âŒ æœåŠ¡ C æ“ä½œå¤±è´¥");
    }
    
    span.end();
    Ok(success)
}

// å­æ“ä½œç¤ºä¾‹
async fn perform_sub_operation(
    tracer: &Tracer,
    parent_context: &TraceContext,
) -> Result<bool, Box<dyn std::error::Error>> {
    let mut span = tracer.start_with_context("sub-operation", SpanKind::Internal, parent_context);
    span.set_attribute("operation.type", "data_transformation");
    
    // æ¨¡æ‹Ÿæ•°æ®å¤„ç†
    tokio::time::sleep(Duration::from_millis(50)).await;
    
    let success = rand::random::<f64>() > 0.15;
    
    if success {
        span.set_status(StatusCode::Ok, "Sub operation successful".to_string());
    } else {
        span.set_status(StatusCode::Error, "Sub operation failed".to_string());
    }
    
    span.end();
    Ok(success)
}
```

---

## ğŸ“Š é«˜çº§æŒ‡æ ‡æ”¶é›†

### è‡ªå®šä¹‰æŒ‡æ ‡å’Œèšåˆ

```rust
use otlp::core::EnhancedOtlpClient;
use opentelemetry::metrics::{Meter, Counter, Histogram, Gauge, Unit};
use std::collections::HashMap;
use std::sync::atomic::{AtomicU64, AtomicF64, Ordering};

// é«˜çº§æŒ‡æ ‡æ”¶é›†ç¤ºä¾‹
async fn advanced_metrics_example() -> Result<(), Box<dyn std::error::Error>> {
    println!("ğŸ“Š é«˜çº§æŒ‡æ ‡æ”¶é›†ç¤ºä¾‹");
    
    let client = EnhancedOtlpClient::builder()
        .with_endpoint("http://localhost:4317")
        .with_service_name("advanced-metrics-demo")
        .with_custom_metrics_enabled(true)
        .build()
        .await?;
    
    let meter = client.meter("advanced-metrics");
    
    // åˆ›å»ºå¤æ‚æŒ‡æ ‡
    let metrics_collector = AdvancedMetricsCollector::new(&meter);
    
    // æ¨¡æ‹Ÿä¸šåŠ¡æ“ä½œ
    for i in 0..100 {
        metrics_collector.record_user_action("login", "web").await;
        metrics_collector.record_transaction(150.0 + i as f64, "credit_card").await;
        metrics_collector.record_api_call("/api/users", 200, Duration::from_millis(50 + i)).await;
        
        if i % 10 == 0 {
            metrics_collector.update_system_health(0.8 + (i as f64 * 0.001)).await;
        }
        
        tokio::time::sleep(Duration::from_millis(10)).await;
    }
    
    // è·å–èšåˆæŒ‡æ ‡
    let aggregated_metrics = metrics_collector.get_aggregated_metrics().await?;
    println!("ğŸ“ˆ èšåˆæŒ‡æ ‡: {:?}", aggregated_metrics);
    
    Ok(())
}

// é«˜çº§æŒ‡æ ‡æ”¶é›†å™¨
struct AdvancedMetricsCollector {
    meter: Meter,
    
    // ç”¨æˆ·è¡Œä¸ºæŒ‡æ ‡
    user_actions: Counter<u64>,
    user_sessions: Counter<u64>,
    
    // äº¤æ˜“æŒ‡æ ‡
    transaction_count: Counter<u64>,
    transaction_amount: Histogram<f64>,
    transaction_volume: Gauge<f64>,
    
    // API æŒ‡æ ‡
    api_requests: Counter<u64>,
    api_response_time: Histogram<f64>,
    api_error_rate: Gauge<f64>,
    
    // ç³»ç»Ÿå¥åº·æŒ‡æ ‡
    system_health: Gauge<f64>,
    active_users: Gauge<u64>,
    
    // å†…éƒ¨è®¡æ•°å™¨
    total_transactions: AtomicU64,
    total_revenue: AtomicF64,
}

impl AdvancedMetricsCollector {
    fn new(meter: &Meter) -> Self {
        Self {
            meter: meter.clone(),
            
            user_actions: meter
                .u64_counter("user_actions_total")
                .with_description("Total user actions")
                .with_unit(Unit::new("1"))
                .init(),
            
            user_sessions: meter
                .u64_counter("user_sessions_total")
                .with_description("Total user sessions")
                .with_unit(Unit::new("1"))
                .init(),
            
            transaction_count: meter
                .u64_counter("transactions_total")
                .with_description("Total transactions")
                .with_unit(Unit::new("1"))
                .init(),
            
            transaction_amount: meter
                .f64_histogram("transaction_amount")
                .with_description("Transaction amount distribution")
                .with_unit(Unit::new("USD"))
                .init(),
            
            transaction_volume: meter
                .f64_gauge("transaction_volume_total")
                .with_description("Total transaction volume")
                .with_unit(Unit::new("USD"))
                .init(),
            
            api_requests: meter
                .u64_counter("api_requests_total")
                .with_description("Total API requests")
                .with_unit(Unit::new("1"))
                .init(),
            
            api_response_time: meter
                .f64_histogram("api_response_time_seconds")
                .with_description("API response time")
                .with_unit(Unit::new("s"))
                .init(),
            
            api_error_rate: meter
                .f64_gauge("api_error_rate")
                .with_description("API error rate")
                .with_unit(Unit::new("1"))
                .init(),
            
            system_health: meter
                .f64_gauge("system_health_score")
                .with_description("System health score")
                .with_unit(Unit::new("1"))
                .init(),
            
            active_users: meter
                .u64_gauge("active_users")
                .with_description("Number of active users")
                .with_unit(Unit::new("1"))
                .init(),
            
            total_transactions: AtomicU64::new(0),
            total_revenue: AtomicF64::new(0.0),
        }
    }
    
    async fn record_user_action(&self, action: &str, platform: &str) {
        let mut attributes = HashMap::new();
        attributes.insert("action".to_string(), action.into());
        attributes.insert("platform".to_string(), platform.into());
        
        self.user_actions.add(1, &attributes);
        
        // æ›´æ–°æ´»è·ƒç”¨æˆ·æ•°
        self.active_users.record(100 + rand::random::<u64>() % 50, &attributes);
    }
    
    async fn record_transaction(&self, amount: f64, method: &str) {
        let mut attributes = HashMap::new();
        attributes.insert("method".to_string(), method.into());
        attributes.insert("currency".to_string(), "USD".into());
        
        self.transaction_count.add(1, &attributes);
        self.transaction_amount.record(amount, &attributes);
        
        // æ›´æ–°æ€»äº¤æ˜“é‡å’Œæ”¶å…¥
        let total_transactions = self.total_transactions.fetch_add(1, Ordering::Relaxed) + 1;
        let total_revenue = self.total_revenue.fetch_add(amount, Ordering::Relaxed) + amount;
        
        self.transaction_volume.record(total_revenue, &attributes);
    }
    
    async fn record_api_call(&self, endpoint: &str, status_code: u16, response_time: Duration) {
        let mut attributes = HashMap::new();
        attributes.insert("endpoint".to_string(), endpoint.into());
        attributes.insert("status_code".to_string(), status_code.to_string().into());
        
        self.api_requests.add(1, &attributes);
        self.api_response_time.record(response_time.as_secs_f64(), &attributes);
        
        // è®¡ç®—é”™è¯¯ç‡
        let error_rate = if status_code >= 400 { 1.0 } else { 0.0 };
        self.api_error_rate.record(error_rate, &attributes);
    }
    
    async fn update_system_health(&self, health_score: f64) {
        let mut attributes = HashMap::new();
        attributes.insert("component".to_string(), "overall".into());
        
        self.system_health.record(health_score, &attributes);
    }
    
    async fn get_aggregated_metrics(&self) -> Result<AggregatedMetrics, Box<dyn std::error::Error>> {
        Ok(AggregatedMetrics {
            total_transactions: self.total_transactions.load(Ordering::Relaxed),
            total_revenue: self.total_revenue.load(Ordering::Relaxed),
            avg_transaction_amount: self.total_revenue.load(Ordering::Relaxed) / 
                                  self.total_transactions.load(Ordering::Relaxed) as f64,
            system_health_score: 0.85, // æ¨¡æ‹Ÿå€¼
        })
    }
}

#[derive(Debug)]
struct AggregatedMetrics {
    total_transactions: u64,
    total_revenue: f64,
    avg_transaction_amount: f64,
    system_health_score: f64,
}
```

---

## ğŸ”§ è‡ªå®šä¹‰å¯¼å‡ºå™¨

### å®ç°è‡ªå®šä¹‰åç«¯

```rust
use otlp::core::{Exporter, ExportResult};
use otlp::data::{SpanData, MetricData, LogData};
use std::collections::HashMap;
use std::time::{Duration, SystemTime};

// è‡ªå®šä¹‰å¯¼å‡ºå™¨ç¤ºä¾‹
async fn custom_exporter_example() -> Result<(), Box<dyn std::error::Error>> {
    println!("ğŸ”§ è‡ªå®šä¹‰å¯¼å‡ºå™¨ç¤ºä¾‹");
    
    // åˆ›å»ºè‡ªå®šä¹‰å¯¼å‡ºå™¨
    let custom_exporter = CustomExporter::new()
        .with_endpoint("http://custom-backend:8080/api/v1/telemetry")
        .with_auth_token("your-auth-token")
        .with_batch_size(100)
        .with_timeout(Duration::from_secs(30));
    
    let client = EnhancedOtlpClient::builder()
        .with_endpoint("http://localhost:4317")
        .with_service_name("custom-exporter-demo")
        .with_custom_exporter(Box::new(custom_exporter))
        .build()
        .await?;
    
    // ä½¿ç”¨è‡ªå®šä¹‰å¯¼å‡ºå™¨
    let tracer = client.tracer("custom-exporter-test");
    let mut span = tracer.start("custom-exporter-operation");
    span.set_attribute("exporter.type", "custom");
    span.end();
    
    Ok(())
}

// è‡ªå®šä¹‰å¯¼å‡ºå™¨å®ç°
struct CustomExporter {
    endpoint: String,
    auth_token: String,
    batch_size: usize,
    timeout: Duration,
    client: reqwest::Client,
}

impl CustomExporter {
    fn new() -> Self {
        Self {
            endpoint: String::new(),
            auth_token: String::new(),
            batch_size: 100,
            timeout: Duration::from_secs(30),
            client: reqwest::Client::new(),
        }
    }
    
    fn with_endpoint(mut self, endpoint: &str) -> Self {
        self.endpoint = endpoint.to_string();
        self
    }
    
    fn with_auth_token(mut self, token: &str) -> Self {
        self.auth_token = token.to_string();
        self
    }
    
    fn with_batch_size(mut self, size: usize) -> Self {
        self.batch_size = size;
        self
    }
    
    fn with_timeout(mut self, timeout: Duration) -> Self {
        self.timeout = timeout;
        self
    }
}

#[async_trait]
impl Exporter for CustomExporter {
    async fn export_spans(&self, spans: Vec<SpanData>) -> Result<ExportResult, Box<dyn std::error::Error>> {
        println!("ğŸ“¤ å¯¼å‡º {} ä¸ª Span åˆ°è‡ªå®šä¹‰åç«¯", spans.len());
        
        // è½¬æ¢ Span æ•°æ®æ ¼å¼
        let custom_spans: Vec<CustomSpan> = spans.into_iter().map(|span| {
            CustomSpan {
                trace_id: span.trace_id,
                span_id: span.span_id,
                parent_span_id: span.parent_span_id,
                name: span.name,
                start_time: span.start_time,
                end_time: span.end_time,
                attributes: span.attributes,
                events: span.events,
                status: span.status,
            }
        }).collect();
        
        // å‘é€åˆ°è‡ªå®šä¹‰åç«¯
        let response = self.client
            .post(&format!("{}/spans", self.endpoint))
            .header("Authorization", format!("Bearer {}", self.auth_token))
            .header("Content-Type", "application/json")
            .json(&custom_spans)
            .timeout(self.timeout)
            .send()
            .await?;
        
        if response.status().is_success() {
            println!("âœ… Span å¯¼å‡ºæˆåŠŸ");
            Ok(ExportResult::Success)
        } else {
            println!("âŒ Span å¯¼å‡ºå¤±è´¥: {}", response.status());
            Ok(ExportResult::Failure)
        }
    }
    
    async fn export_metrics(&self, metrics: Vec<MetricData>) -> Result<ExportResult, Box<dyn std::error::Error>> {
        println!("ğŸ“Š å¯¼å‡º {} ä¸ªæŒ‡æ ‡åˆ°è‡ªå®šä¹‰åç«¯", metrics.len());
        
        // è½¬æ¢æŒ‡æ ‡æ•°æ®æ ¼å¼
        let custom_metrics: Vec<CustomMetric> = metrics.into_iter().map(|metric| {
            CustomMetric {
                name: metric.name,
                value: metric.value,
                timestamp: metric.timestamp,
                labels: metric.labels,
                metric_type: metric.metric_type,
            }
        }).collect();
        
        // å‘é€åˆ°è‡ªå®šä¹‰åç«¯
        let response = self.client
            .post(&format!("{}/metrics", self.endpoint))
            .header("Authorization", format!("Bearer {}", self.auth_token))
            .header("Content-Type", "application/json")
            .json(&custom_metrics)
            .timeout(self.timeout)
            .send()
            .await?;
        
        if response.status().is_success() {
            println!("âœ… æŒ‡æ ‡å¯¼å‡ºæˆåŠŸ");
            Ok(ExportResult::Success)
        } else {
            println!("âŒ æŒ‡æ ‡å¯¼å‡ºå¤±è´¥: {}", response.status());
            Ok(ExportResult::Failure)
        }
    }
    
    async fn export_logs(&self, logs: Vec<LogData>) -> Result<ExportResult, Box<dyn std::error::Error>> {
        println!("ğŸ“ å¯¼å‡º {} æ¡æ—¥å¿—åˆ°è‡ªå®šä¹‰åç«¯", logs.len());
        
        // è½¬æ¢æ—¥å¿—æ•°æ®æ ¼å¼
        let custom_logs: Vec<CustomLog> = logs.into_iter().map(|log| {
            CustomLog {
                timestamp: log.timestamp,
                level: log.severity,
                message: log.body,
                attributes: log.attributes,
                resource: log.resource,
            }
        }).collect();
        
        // å‘é€åˆ°è‡ªå®šä¹‰åç«¯
        let response = self.client
            .post(&format!("{}/logs", self.endpoint))
            .header("Authorization", format!("Bearer {}", self.auth_token))
            .header("Content-Type", "application/json")
            .json(&custom_logs)
            .timeout(self.timeout)
            .send()
            .await?;
        
        if response.status().is_success() {
            println!("âœ… æ—¥å¿—å¯¼å‡ºæˆåŠŸ");
            Ok(ExportResult::Success)
        } else {
            println!("âŒ æ—¥å¿—å¯¼å‡ºå¤±è´¥: {}", response.status());
            Ok(ExportResult::Failure)
        }
    }
}

// è‡ªå®šä¹‰æ•°æ®æ ¼å¼
#[derive(Serialize)]
struct CustomSpan {
    trace_id: String,
    span_id: String,
    parent_span_id: Option<String>,
    name: String,
    start_time: u64,
    end_time: u64,
    attributes: HashMap<String, String>,
    events: Vec<SpanEvent>,
    status: SpanStatus,
}

#[derive(Serialize)]
struct CustomMetric {
    name: String,
    value: f64,
    timestamp: u64,
    labels: HashMap<String, String>,
    metric_type: String,
}

#[derive(Serialize)]
struct CustomLog {
    timestamp: u64,
    level: String,
    message: String,
    attributes: HashMap<String, String>,
    resource: Option<HashMap<String, String>>,
}
```

---

## âš¡ æ€§èƒ½ä¼˜åŒ–ç¤ºä¾‹

### é«˜æ€§èƒ½é…ç½®å’Œä¼˜åŒ–

```rust
use otlp::core::EnhancedOtlpClient;
use otlp::config::*;
use std::time::Duration;
use tokio::task;

// æ€§èƒ½ä¼˜åŒ–ç¤ºä¾‹
async fn performance_optimization_example() -> Result<(), Box<dyn std::error::Error>> {
    println!("âš¡ æ€§èƒ½ä¼˜åŒ–ç¤ºä¾‹");
    
    // é«˜æ€§èƒ½é…ç½®
    let client = EnhancedOtlpClient::builder()
        .with_endpoint("http://localhost:4317")
        .with_service_name("performance-demo")
        
        // è¿æ¥ä¼˜åŒ–
        .with_grpc_transport()
        .with_compression(Compression::Gzip)
        .with_connection_pool_config(ConnectionPoolConfig {
            max_connections: 200,
            min_connections: 20,
            connection_timeout: Duration::from_secs(5),
            idle_timeout: Duration::from_secs(300),
            keep_alive: true,
        })
        
        // æ‰¹å¤„ç†ä¼˜åŒ–
        .with_batch_config(BatchConfig {
            max_batch_size: 2000,
            batch_timeout: Duration::from_millis(100),
            max_queue_size: 50000,
            strategy: BatchStrategy::Hybrid,
        })
        
        // é‡è¯•ä¼˜åŒ–
        .with_retry_config(RetryConfig {
            max_attempts: 3,
            initial_interval: Duration::from_millis(100),
            max_interval: Duration::from_secs(5),
            multiplier: 2.0,
            randomization_factor: 0.1,
            retryable_errors: vec![ErrorType::Network, ErrorType::Timeout],
        })
        
        // å†…å­˜ä¼˜åŒ–
        .with_memory_pool_config(MemoryPoolConfig {
            initial_size: 1024 * 1024,      // 1MB
            max_size: 100 * 1024 * 1024,     // 100MB
            chunk_size: 64 * 1024,          // 64KB
            growth_factor: 2.0,
            gc_threshold: 0.8,
        })
        
        // é›¶æ‹·è´ä¼˜åŒ–
        .with_zero_copy_enabled(true)
        
        .build()
        .await?;
    
    // æ€§èƒ½æµ‹è¯•
    let performance_test = PerformanceTest::new(client);
    performance_test.run_concurrent_test(1000).await?;
    performance_test.run_throughput_test(10000).await?;
    performance_test.run_latency_test(1000).await?;
    
    Ok(())
}

// æ€§èƒ½æµ‹è¯•å·¥å…·
struct PerformanceTest {
    client: EnhancedOtlpClient,
}

impl PerformanceTest {
    fn new(client: EnhancedOtlpClient) -> Self {
        Self { client }
    }
    
    // å¹¶å‘æµ‹è¯•
    async fn run_concurrent_test(&self, concurrent_requests: usize) -> Result<(), Box<dyn std::error::Error>> {
        println!("ğŸ”„ è¿è¡Œå¹¶å‘æµ‹è¯•: {} ä¸ªå¹¶å‘è¯·æ±‚", concurrent_requests);
        
        let start_time = std::time::Instant::now();
        let tracer = self.client.tracer("concurrent-test");
        
        let tasks: Vec<_> = (0..concurrent_requests)
            .map(|i| {
                let tracer = tracer.clone();
                task::spawn(async move {
                    let mut span = tracer.start("concurrent-operation");
                    span.set_attribute("request.id", i);
                    
                    // æ¨¡æ‹Ÿå·¥ä½œè´Ÿè½½
                    tokio::time::sleep(Duration::from_millis(10)).await;
                    
                    span.end();
                })
            })
            .collect();
        
        futures::future::join_all(tasks).await;
        
        let duration = start_time.elapsed();
        let throughput = concurrent_requests as f64 / duration.as_secs_f64();
        
        println!("âœ… å¹¶å‘æµ‹è¯•å®Œæˆ:");
        println!("  æ€»æ—¶é—´: {:?}", duration);
        println!("  ååé‡: {:.2} req/s", throughput);
        
        Ok(())
    }
    
    // ååé‡æµ‹è¯•
    async fn run_throughput_test(&self, total_requests: usize) -> Result<(), Box<dyn std::error::Error>> {
        println!("ğŸ“Š è¿è¡Œååé‡æµ‹è¯•: {} ä¸ªè¯·æ±‚", total_requests);
        
        let start_time = std::time::Instant::now();
        let tracer = self.client.tracer("throughput-test");
        
        for i in 0..total_requests {
            let mut span = tracer.start("throughput-operation");
            span.set_attribute("request.id", i);
            
            // æ¨¡æ‹Ÿå·¥ä½œè´Ÿè½½
            tokio::time::sleep(Duration::from_millis(1)).await;
            
            span.end();
            
            if i % 1000 == 0 {
                println!("  å¤„ç†äº† {} ä¸ªè¯·æ±‚", i);
            }
        }
        
        let duration = start_time.elapsed();
        let throughput = total_requests as f64 / duration.as_secs_f64();
        
        println!("âœ… ååé‡æµ‹è¯•å®Œæˆ:");
        println!("  æ€»æ—¶é—´: {:?}", duration);
        println!("  ååé‡: {:.2} req/s", throughput);
        
        Ok(())
    }
    
    // å»¶è¿Ÿæµ‹è¯•
    async fn run_latency_test(&self, sample_size: usize) -> Result<(), Box<dyn std::error::Error>> {
        println!("â±ï¸ è¿è¡Œå»¶è¿Ÿæµ‹è¯•: {} ä¸ªæ ·æœ¬", sample_size);
        
        let tracer = self.client.tracer("latency-test");
        let mut latencies = Vec::new();
        
        for i in 0..sample_size {
            let start_time = std::time::Instant::now();
            
            let mut span = tracer.start("latency-operation");
            span.set_attribute("sample.id", i);
            
            // æ¨¡æ‹Ÿå·¥ä½œè´Ÿè½½
            tokio::time::sleep(Duration::from_millis(5)).await;
            
            span.end();
            
            let latency = start_time.elapsed();
            latencies.push(latency);
        }
        
        // è®¡ç®—å»¶è¿Ÿç»Ÿè®¡
        latencies.sort();
        let p50 = latencies[sample_size / 2];
        let p95 = latencies[(sample_size * 95) / 100];
        let p99 = latencies[(sample_size * 99) / 100];
        let avg = latencies.iter().sum::<Duration>() / latencies.len() as u32;
        
        println!("âœ… å»¶è¿Ÿæµ‹è¯•å®Œæˆ:");
        println!("  å¹³å‡å»¶è¿Ÿ: {:?}", avg);
        println!("  P50å»¶è¿Ÿ: {:?}", p50);
        println!("  P95å»¶è¿Ÿ: {:?}", p95);
        println!("  P99å»¶è¿Ÿ: {:?}", p99);
        
        Ok(())
    }
}
```

---

## ğŸ›¡ï¸ å¯é æ€§æ¡†æ¶é›†æˆ

### é›†æˆå¯é æ€§æ¡†æ¶

```rust
use otlp::core::EnhancedOtlpClient;
use reliability::prelude::*;
use std::time::Duration;

// å¯é æ€§æ¡†æ¶é›†æˆç¤ºä¾‹
async fn reliability_framework_integration() -> Result<(), Box<dyn std::error::Error>> {
    println!("ğŸ›¡ï¸ å¯é æ€§æ¡†æ¶é›†æˆç¤ºä¾‹");
    
    // åˆå§‹åŒ–å¯é æ€§æ¡†æ¶
    reliability::init().await?;
    
    // åˆ›å»º OTLP å®¢æˆ·ç«¯
    let client = EnhancedOtlpClient::builder()
        .with_endpoint("http://localhost:4317")
        .with_service_name("reliability-demo")
        .with_reliability_framework_integration(true)
        .build()
        .await?;
    
    // åˆ›å»ºå¯é æ€§ç»„ä»¶
    let circuit_breaker = CircuitBreaker::new(5, Duration::from_secs(10));
    let retry_policy = RetryPolicy::new()
        .with_max_attempts(3)
        .with_initial_delay(Duration::from_millis(100))
        .with_max_delay(Duration::from_secs(5))
        .with_backoff_multiplier(2.0);
    let timeout = Timeout::new(Duration::from_secs(30));
    let bulkhead = Bulkhead::new(10);
    
    // æ¨¡æ‹Ÿä¸å¯é çš„æœåŠ¡è°ƒç”¨
    for i in 0..20 {
        println!("ğŸ”„ æ‰§è¡Œæ“ä½œ {}", i + 1);
        
        let result = circuit_breaker
            .execute_with_retry(&retry_policy, || {
                timeout.execute(|| {
                    bulkhead.execute(|| unreliable_service_call(i + 1))
                })
            })
            .await;
        
        match result {
            Ok(response) => println!("âœ… æ“ä½œæˆåŠŸ: {}", response),
            Err(e) => println!("âŒ æ“ä½œå¤±è´¥: {}", e),
        }
        
        tokio::time::sleep(Duration::from_millis(500)).await;
    }
    
    // è·å–å¯é æ€§æŒ‡æ ‡
    let reliability_metrics = reliability::get_metrics().await?;
    println!("ğŸ“Š å¯é æ€§æŒ‡æ ‡: {:?}", reliability_metrics);
    
    // å…³é—­å¯é æ€§æ¡†æ¶
    reliability::shutdown().await?;
    
    Ok(())
}

// ä¸å¯é çš„æœåŠ¡è°ƒç”¨
async fn unreliable_service_call(attempt: u32) -> Result<String, UnifiedError> {
    // æ¨¡æ‹Ÿå„ç§å¤±è´¥æƒ…å†µ
    let failure_rate = match attempt {
        1..=5 => 0.1,    // å‰5æ¬¡å¤±è´¥ç‡10%
        6..=10 => 0.3,   // ä¸­é—´5æ¬¡å¤±è´¥ç‡30%
        11..=15 => 0.5,  // å5æ¬¡å¤±è´¥ç‡50%
        _ => 0.2,        // å…¶ä½™å¤±è´¥ç‡20%
    };
    
    if rand::random::<f64>() < failure_rate {
        let error_type = rand::random::<u32>() % 4;
        match error_type {
            0 => Err(UnifiedError::Network("Network timeout".to_string())),
            1 => Err(UnifiedError::Timeout("Operation timeout".to_string())),
            2 => Err(UnifiedError::System("Internal server error".to_string())),
            _ => Err(UnifiedError::Business("Business logic error".to_string())),
        }
    } else {
        Ok(format!("Service call {} succeeded", attempt))
    }
}

// å¥åº·æ£€æŸ¥é›†æˆ
async fn health_check_integration() -> Result<(), Box<dyn std::error::Error>> {
    println!("ğŸ¥ å¥åº·æ£€æŸ¥é›†æˆç¤ºä¾‹");
    
    // åˆ›å»ºå¥åº·æ£€æŸ¥å™¨
    let health_checker = HealthChecker::new()
        .with_check_interval(Duration::from_secs(30))
        .with_timeout(Duration::from_secs(5))
        .with_retry_count(3);
    
    // æ·»åŠ å¥åº·æ£€æŸ¥
    health_checker.add_check("database", check_database_health).await?;
    health_checker.add_check("external_api", check_external_api_health).await?;
    health_checker.add_check("cache", check_cache_health).await?;
    
    // å¯åŠ¨å¥åº·æ£€æŸ¥
    health_checker.start().await?;
    
    // æ¨¡æ‹Ÿè¿è¡Œ
    tokio::time::sleep(Duration::from_secs(60)).await;
    
    // è·å–å¥åº·çŠ¶æ€
    let health_status = health_checker.get_health_status().await?;
    println!("ğŸ¥ å¥åº·çŠ¶æ€: {:?}", health_status);
    
    Ok(())
}

// å¥åº·æ£€æŸ¥å‡½æ•°
async fn check_database_health() -> Result<(), UnifiedError> {
    // æ¨¡æ‹Ÿæ•°æ®åº“å¥åº·æ£€æŸ¥
    tokio::time::sleep(Duration::from_millis(100)).await;
    
    if rand::random::<f64>() < 0.1 {
        Err(UnifiedError::System("Database connection failed".to_string()))
    } else {
        Ok(())
    }
}

async fn check_external_api_health() -> Result<(), UnifiedError> {
    // æ¨¡æ‹Ÿå¤–éƒ¨APIå¥åº·æ£€æŸ¥
    tokio::time::sleep(Duration::from_millis(200)).await;
    
    if rand::random::<f64>() < 0.05 {
        Err(UnifiedError::Network("External API unavailable".to_string()))
    } else {
        Ok(())
    }
}

async fn check_cache_health() -> Result<(), UnifiedError> {
    // æ¨¡æ‹Ÿç¼“å­˜å¥åº·æ£€æŸ¥
    tokio::time::sleep(Duration::from_millis(50)).await;
    
    if rand::random::<f64>() < 0.02 {
        Err(UnifiedError::System("Cache service down".to_string()))
    } else {
        Ok(())
    }
}
```

---

## ğŸ­ ç”Ÿäº§ç¯å¢ƒé…ç½®

### å®Œæ•´ç”Ÿäº§é…ç½®

```rust
use otlp::core::EnhancedOtlpClient;
use otlp::config::*;
use std::time::Duration;

// ç”Ÿäº§ç¯å¢ƒé…ç½®ç¤ºä¾‹
async fn production_configuration_example() -> Result<(), Box<dyn std::error::Error>> {
    println!("ğŸ­ ç”Ÿäº§ç¯å¢ƒé…ç½®ç¤ºä¾‹");
    
    // ç”Ÿäº§ç¯å¢ƒé…ç½®
    let production_config = ProductionConfig {
        // åŸºç¡€é…ç½®
        endpoint: "http://otel-collector:4317".to_string(),
        service_name: "production-app".to_string(),
        service_version: "1.0.0".to_string(),
        environment: "production".to_string(),
        
        // ä¼ è¾“é…ç½®
        transport: TransportConfig {
            protocol: TransportProtocol::Grpc,
            compression: Compression::Gzip,
            tls_config: Some(TlsConfig {
                enabled: true,
                cert_file: "/etc/ssl/certs/client.crt".to_string(),
                key_file: "/etc/ssl/private/client.key".to_string(),
                ca_file: "/etc/ssl/certs/ca.crt".to_string(),
            }),
        },
        
        // è¿æ¥é…ç½®
        connection: ConnectionConfig {
            connect_timeout: Duration::from_secs(10),
            request_timeout: Duration::from_secs(60),
            keep_alive_timeout: Duration::from_secs(60),
            max_idle_connections: 100,
            max_connections: 200,
        },
        
        // æ‰¹å¤„ç†é…ç½®
        batch: BatchConfig {
            max_batch_size: 1000,
            batch_timeout: Duration::from_millis(200),
            max_queue_size: 50000,
            strategy: BatchStrategy::Hybrid,
        },
        
        // é‡è¯•é…ç½®
        retry: RetryConfig {
            max_attempts: 3,
            initial_interval: Duration::from_millis(100),
            max_interval: Duration::from_secs(5),
            multiplier: 2.0,
            randomization_factor: 0.1,
            retryable_errors: vec![ErrorType::Network, ErrorType::Timeout],
        },
        
        // ç›‘æ§é…ç½®
        monitoring: MonitoringConfig {
            enable_performance_metrics: true,
            enable_resource_metrics: true,
            enable_custom_metrics: true,
            metrics_export_interval: Duration::from_secs(10),
            health_check_endpoint: Some("http://localhost:8080/health".to_string()),
        },
        
        // å®‰å…¨é…ç½®
        security: SecurityConfig {
            enable_authentication: true,
            auth_token: "your-production-token".to_string(),
            enable_encryption: true,
            encryption_key: "your-encryption-key".to_string(),
        },
        
        // æ—¥å¿—é…ç½®
        logging: LoggingConfig {
            log_level: LogLevel::Info,
            enable_structured_logging: true,
            enable_log_aggregation: true,
            log_format: LogFormat::Json,
        },
    };
    
    // åˆ›å»ºç”Ÿäº§å®¢æˆ·ç«¯
    let client = EnhancedOtlpClient::with_production_config(production_config).await?;
    
    // å¯åŠ¨ç”Ÿäº§ç›‘æ§
    start_production_monitoring(&client).await?;
    
    // æ¨¡æ‹Ÿç”Ÿäº§è´Ÿè½½
    simulate_production_load(&client).await?;
    
    Ok(())
}

// ç”Ÿäº§ç›‘æ§
async fn start_production_monitoring(client: &EnhancedOtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    println!("ğŸ“Š å¯åŠ¨ç”Ÿäº§ç›‘æ§");
    
    // å¯åŠ¨æ€§èƒ½ç›‘æ§
    let performance_monitor = client.get_performance_monitor().await?;
    performance_monitor.start().await?;
    
    // å¯åŠ¨å¥åº·æ£€æŸ¥
    let health_checker = client.get_health_checker().await?;
    health_checker.start().await?;
    
    // å¯åŠ¨å‘Šè­¦
    let alert_manager = client.get_alert_manager().await?;
    alert_manager.start().await?;
    
    println!("âœ… ç”Ÿäº§ç›‘æ§å¯åŠ¨å®Œæˆ");
    Ok(())
}

// æ¨¡æ‹Ÿç”Ÿäº§è´Ÿè½½
async fn simulate_production_load(client: &EnhancedOtlpClient) -> Result<(), Box<dyn std::error::Error>> {
    println!("ğŸ”„ æ¨¡æ‹Ÿç”Ÿäº§è´Ÿè½½");
    
    let tracer = client.tracer("production-component");
    let meter = client.meter("production-metrics");
    
    // åˆ›å»ºæŒ‡æ ‡
    let request_counter = meter.u64_counter("requests_total").init();
    let response_time_histogram = meter.f64_histogram("response_time_seconds").init();
    let error_counter = meter.u64_counter("errors_total").init();
    
    // æ¨¡æ‹ŸæŒç»­è´Ÿè½½
    for i in 0..1000 {
        let start_time = std::time::Instant::now();
        
        let mut span = tracer.start("production-operation");
        span.set_attribute("request.id", i);
        span.set_attribute("user.id", format!("user-{}", i % 100));
        
        // æ¨¡æ‹Ÿä¸šåŠ¡é€»è¾‘
        let result = simulate_business_operation(i).await;
        
        let duration = start_time.elapsed();
        
        // è®°å½•æŒ‡æ ‡
        let mut attributes = HashMap::new();
        attributes.insert("method".to_string(), "POST".into());
        attributes.insert("endpoint".to_string(), "/api/v1/data".into());
        
        request_counter.add(1, &attributes);
        response_time_histogram.record(duration.as_secs_f64(), &attributes);
        
        if result.is_err() {
            error_counter.add(1, &attributes);
            span.set_status(StatusCode::Error, "Operation failed".to_string());
        } else {
            span.set_status(StatusCode::Ok, "Operation successful".to_string());
        }
        
        span.end();
        
        // æ§åˆ¶è´Ÿè½½é¢‘ç‡
        tokio::time::sleep(Duration::from_millis(10)).await;
        
        if i % 100 == 0 {
            println!("  å¤„ç†äº† {} ä¸ªè¯·æ±‚", i);
        }
    }
    
    println!("âœ… ç”Ÿäº§è´Ÿè½½æ¨¡æ‹Ÿå®Œæˆ");
    Ok(())
}

// æ¨¡æ‹Ÿä¸šåŠ¡æ“ä½œ
async fn simulate_business_operation(request_id: u32) -> Result<String, Box<dyn std::error::Error>> {
    // æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
    let processing_time = Duration::from_millis(50 + (request_id % 100));
    tokio::time::sleep(processing_time).await;
    
    // æ¨¡æ‹Ÿå¶å°”çš„å¤±è´¥
    if rand::random::<f64>() < 0.05 {
        Err("Business operation failed".into())
    } else {
        Ok(format!("Operation {} completed", request_id))
    }
}

// ç”Ÿäº§é…ç½®ç»“æ„
#[derive(Debug)]
struct ProductionConfig {
    endpoint: String,
    service_name: String,
    service_version: String,
    environment: String,
    transport: TransportConfig,
    connection: ConnectionConfig,
    batch: BatchConfig,
    retry: RetryConfig,
    monitoring: MonitoringConfig,
    security: SecurityConfig,
    logging: LoggingConfig,
}

#[derive(Debug)]
struct TransportConfig {
    protocol: TransportProtocol,
    compression: Compression,
    tls_config: Option<TlsConfig>,
}

#[derive(Debug)]
struct ConnectionConfig {
    connect_timeout: Duration,
    request_timeout: Duration,
    keep_alive_timeout: Duration,
    max_idle_connections: usize,
    max_connections: usize,
}

#[derive(Debug)]
struct SecurityConfig {
    enable_authentication: bool,
    auth_token: String,
    enable_encryption: bool,
    encryption_key: String,
}

#[derive(Debug)]
struct LoggingConfig {
    log_level: LogLevel,
    enable_structured_logging: bool,
    enable_log_aggregation: bool,
    log_format: LogFormat,
}

#[derive(Debug)]
enum TransportProtocol {
    Http,
    Grpc,
}

#[derive(Debug)]
struct TlsConfig {
    enabled: bool,
    cert_file: String,
    key_file: String,
    ca_file: String,
}

#[derive(Debug)]
enum LogFormat {
    Json,
    Text,
}
```

---

## ğŸš€ ä¸‹ä¸€æ­¥

### è¿›é˜¶å­¦ä¹ è·¯å¾„

1. **å¾®æœåŠ¡æ¶æ„**: æ·±å…¥å­¦ä¹ å¾®æœåŠ¡ç›‘æ§å’Œè¿½è¸ª
2. **æ€§èƒ½ä¼˜åŒ–**: æŒæ¡é«˜çº§æ€§èƒ½è°ƒä¼˜æŠ€æœ¯
3. **å¯é æ€§å·¥ç¨‹**: å­¦ä¹ æ•…éšœæ³¨å…¥å’Œæ··æ²Œå·¥ç¨‹
4. **ç”Ÿäº§è¿ç»´**: æŒæ¡ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²å’Œè¿ç»´

### å®è·µé¡¹ç›®

1. **æ„å»ºç›‘æ§ç³»ç»Ÿ**: åˆ›å»ºå®Œæ•´çš„ç›‘æ§å’Œå‘Šè­¦ç³»ç»Ÿ
2. **æ€§èƒ½åŸºå‡†æµ‹è¯•**: å»ºç«‹æ€§èƒ½åŸºå‡†å’Œå›å½’æµ‹è¯•
3. **æ•…éšœæ¼”ç»ƒ**: å®æ–½æ··æ²Œå·¥ç¨‹å’Œæ•…éšœæ¼”ç»ƒ
4. **ç”Ÿäº§éƒ¨ç½²**: éƒ¨ç½²åˆ°ç”Ÿäº§ç¯å¢ƒå¹¶æŒç»­ä¼˜åŒ–

### ç›¸å…³èµ„æº

- ğŸ“– [æ€§èƒ½ä¼˜åŒ–æŒ‡å—](../guides/performance-optimization.md)
- ğŸ“Š [ç›‘æ§é…ç½®æŒ‡å—](../guides/monitoring.md)
- ğŸ›¡ï¸ [å¯é æ€§æ¡†æ¶æ–‡æ¡£](../api/reliability.md)
- ğŸš€ [éƒ¨ç½²æŒ‡å—](../guides/deployment.md)

---

*æœ€åæ›´æ–°: 2025å¹´10æœˆ20æ—¥*  
*ç‰ˆæœ¬: 1.0.0*
