# OpenTelemetry 安全最佳实践

> **最后更新**: 2025年10月8日  
> **目标读者**: 安全工程师、架构师、合规团队

---

## 目录

- [OpenTelemetry 安全最佳实践](#opentelemetry-安全最佳实践)
  - [目录](#目录)
  - [1. 安全概述](#1-安全概述)
    - [1.1 威胁模型](#11-威胁模型)
    - [1.2 安全原则](#12-安全原则)
  - [2. 传输安全](#2-传输安全)
    - [2.1 TLS/SSL配置](#21-tlsssl配置)
    - [2.2 mTLS双向认证](#22-mtls双向认证)
    - [2.3 证书管理](#23-证书管理)
  - [3. 认证与授权](#3-认证与授权)
    - [3.1 API Key认证](#31-api-key认证)
    - [3.2 OAuth2认证](#32-oauth2认证)
    - [3.3 RBAC授权](#33-rbac授权)
  - [4. 数据隐私](#4-数据隐私)
    - [4.1 敏感数据识别](#41-敏感数据识别)
    - [4.2 数据脱敏](#42-数据脱敏)
    - [4.3 PII处理](#43-pii处理)
  - [5. Collector安全](#5-collector安全)
    - [5.1 安全配置](#51-安全配置)
    - [5.2 访问控制](#52-访问控制)
    - [5.3 资源隔离](#53-资源隔离)
  - [6. Kubernetes安全](#6-kubernetes安全)
    - [6.1 RBAC配置](#61-rbac配置)
    - [6.2 Network Policy](#62-network-policy)
    - [6.3 Pod Security](#63-pod-security)
  - [7. 合规性](#7-合规性)
    - [7.1 GDPR合规](#71-gdpr合规)
    - [7.2 SOC2合规](#72-soc2合规)
    - [7.3 审计日志](#73-审计日志)
  - [8. 漏洞管理](#8-漏洞管理)
  - [9. 安全监控](#9-安全监控)
  - [10. 事件响应](#10-事件响应)
  - [11. 安全检查清单](#11-安全检查清单)
  - [12. 参考资源](#12-参考资源)

---

## 1. 安全概述

### 1.1 威胁模型

**潜在威胁**：

```text
1. 数据泄露 (Data Breach)
   攻击者: 外部攻击者、内部人员
   目标: 敏感遥测数据
   途径: 未加密传输、未授权访问
   
   影响:
   - 用户隐私泄露
   - 商业秘密泄露
   - 系统架构暴露

2. 中间人攻击 (MITM)
   攻击者: 网络攻击者
   目标: 拦截/篡改遥测数据
   途径: 未加密连接
   
   影响:
   - 数据完整性破坏
   - 错误的监控决策

3. 拒绝服务 (DoS)
   攻击者: 外部攻击者
   目标: Collector/后端
   途径: 大量恶意请求
   
   影响:
   - 服务不可用
   - 数据丢失

4. 未授权访问
   攻击者: 未授权用户
   目标: 查看/修改遥测数据
   途径: 弱认证/授权
   
   影响:
   - 数据泄露
   - 数据篡改

5. 依赖漏洞
   攻击者: 利用已知漏洞
   目标: SDK/Collector
   途径: 过期依赖
   
   影响:
   - 远程代码执行
   - 权限提升
```

### 1.2 安全原则

**核心原则**：

```text
1. 最小权限原则 (Least Privilege)
   - 仅授予必需权限
   - 默认拒绝

2. 深度防御 (Defense in Depth)
   - 多层安全控制
   - 单点失败不导致整体失败

3. 数据最小化 (Data Minimization)
   - 仅收集必要数据
   - 最短保留时间

4. 默认安全 (Secure by Default)
   - 默认启用安全特性
   - 强制TLS

5. 零信任 (Zero Trust)
   - 不信任任何网络
   - 始终验证
```

---

## 2. 传输安全

### 2.1 TLS/SSL配置

**SDK TLS配置 (Go)**：

```go
package main

import (
    "crypto/tls"
    "crypto/x509"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "google.golang.org/grpc/credentials"
)

func setupTLS() (*otlptracegrpc.Exporter, error) {
    // 1. 加载CA证书
    caCert, err := os.ReadFile("/path/to/ca.crt")
    if err != nil {
        return nil, err
    }
    
    caCertPool := x509.NewCertPool()
    caCertPool.AppendCertsFromPEM(caCert)
    
    // 2. 配置TLS
    tlsConfig := &tls.Config{
        RootCAs:            caCertPool,
        MinVersion:         tls.VersionTLS13,  // ✅ TLS 1.3
        InsecureSkipVerify: false,             // ✅ 验证证书
        ServerName:         "collector.example.com",
    }
    
    // 3. 创建Exporter
    exporter, err := otlptracegrpc.New(
        context.Background(),
        otlptracegrpc.WithEndpoint("collector.example.com:4317"),
        otlptracegrpc.WithTLSCredentials(
            credentials.NewTLS(tlsConfig),
        ),
    )
    
    return exporter, err
}

// ❌ 错误: 不安全配置
func insecureSetup() (*otlptracegrpc.Exporter, error) {
    return otlptracegrpc.New(
        context.Background(),
        otlptracegrpc.WithInsecure(),  // ❌ 明文传输!
    )
}
```

**Collector TLS配置**：

```yaml
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317
        # ✅ 启用TLS
        tls:
          # 服务器证书
          cert_file: /path/to/server.crt
          key_file: /path/to/server.key
          
          # 客户端CA (用于验证客户端证书)
          ca_file: /path/to/ca.crt
          
          # 客户端认证
          client_ca_file: /path/to/client-ca.crt
          
          # TLS版本
          min_version: "1.3"
          max_version: "1.3"
          
          # 加密套件 (TLS 1.2)
          cipher_suites:
            - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
            - TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
      
      http:
        endpoint: 0.0.0.0:4318
        tls:
          cert_file: /path/to/server.crt
          key_file: /path/to/server.key
          min_version: "1.3"

exporters:
  otlp:
    endpoint: backend:4317
    # ✅ 客户端TLS
    tls:
      insecure: false  # ✅ 验证证书
      ca_file: /path/to/ca.crt
      cert_file: /path/to/client.crt
      key_file: /path/to/client.key
```

### 2.2 mTLS双向认证

**完整mTLS配置**：

```yaml
# Collector配置
receivers:
  otlp:
    protocols:
      grpc:
        tls:
          # 服务器证书
          cert_file: /certs/collector.crt
          key_file: /certs/collector.key
          
          # 客户端CA (验证客户端)
          client_ca_file: /certs/client-ca.crt
          
          # ✅ 要求客户端证书
          require_client_certificate: true

exporters:
  otlp:
    endpoint: backend:4317
    tls:
      # 客户端证书
      cert_file: /certs/collector-client.crt
      key_file: /certs/collector-client.key
      
      # 服务器CA (验证服务器)
      ca_file: /certs/server-ca.crt
```

**Go SDK mTLS客户端**：

```go
// 加载客户端证书
clientCert, err := tls.LoadX509KeyPair(
    "/path/to/client.crt",
    "/path/to/client.key",
)

// 加载CA证书
caCert, _ := os.ReadFile("/path/to/ca.crt")
caCertPool := x509.NewCertPool()
caCertPool.AppendCertsFromPEM(caCert)

// TLS配置
tlsConfig := &tls.Config{
    Certificates: []tls.Certificate{clientCert},  // 客户端证书
    RootCAs:      caCertPool,                     // 服务器CA
    MinVersion:   tls.VersionTLS13,
}

exporter, err := otlptracegrpc.New(
    context.Background(),
    otlptracegrpc.WithEndpoint("collector:4317"),
    otlptracegrpc.WithTLSCredentials(
        credentials.NewTLS(tlsConfig),
    ),
)
```

### 2.3 证书管理

**证书生成 (开发环境)**：

```bash
# 1. 生成CA
openssl req -x509 -newkey rsa:4096 -days 365 -nodes \
  -keyout ca.key -out ca.crt \
  -subj "/CN=My CA"

# 2. 生成服务器证书
openssl req -newkey rsa:4096 -nodes \
  -keyout server.key -out server.csr \
  -subj "/CN=collector.example.com"

openssl x509 -req -days 365 -in server.csr \
  -CA ca.crt -CAkey ca.key -CAcreateserial \
  -out server.crt

# 3. 生成客户端证书
openssl req -newkey rsa:4096 -nodes \
  -keyout client.key -out client.csr \
  -subj "/CN=client"

openssl x509 -req -days 365 -in client.csr \
  -CA ca.crt -CAkey ca.key -CAcreateserial \
  -out client.crt
```

**Kubernetes证书管理 (cert-manager)**：

```yaml
# 安装cert-manager
apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: selfsigned-issuer
spec:
  selfSigned: {}

---
# CA证书
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: otel-ca
spec:
  isCA: true
  commonName: otel-ca
  secretName: otel-ca-secret
  issuerRef:
    name: selfsigned-issuer

---
# Collector证书
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: otel-collector
spec:
  secretName: otel-collector-tls
  dnsNames:
    - otel-collector
    - otel-collector.default.svc
    - otel-collector.default.svc.cluster.local
  issuerRef:
    name: ca-issuer
```

---

## 3. 认证与授权

### 3.1 API Key认证

**Collector配置**：

```yaml
extensions:
  # Bearer Token认证
  bearertokenauth:
    scheme: "Bearer"
    token: "your-secret-token-here"

receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317
        # 应用认证
        auth:
          authenticator: bearertokenauth

service:
  extensions: [bearertokenauth]
  pipelines:
    traces:
      receivers: [otlp]
```

**Go SDK配置**：

```go
import (
    "google.golang.org/grpc/metadata"
)

// 添加认证Header
ctx := metadata.AppendToOutgoingContext(
    context.Background(),
    "authorization", "Bearer your-secret-token-here",
)

exporter, err := otlptracegrpc.New(
    ctx,
    otlptracegrpc.WithEndpoint("collector:4317"),
)
```

### 3.2 OAuth2认证

**Collector OAuth2配置**：

```yaml
extensions:
  oauth2client:
    client_id: "collector-client"
    client_secret: "${OAUTH_CLIENT_SECRET}"
    token_url: "https://auth.example.com/oauth/token"
    scopes: ["telemetry.write"]

exporters:
  otlp:
    endpoint: backend:4317
    auth:
      authenticator: oauth2client

service:
  extensions: [oauth2client]
  pipelines:
    traces:
      exporters: [otlp]
```

### 3.3 RBAC授权

**Collector RBAC (自定义扩展)**：

```yaml
extensions:
  rbac:
    policies:
      - name: "allow_service_a"
        effect: "allow"
        principals:
          - "service-a"
        actions:
          - "traces.write"
          - "metrics.write"
        resources:
          - "traces/*"
          - "metrics/*"
      
      - name: "allow_service_b_traces"
        effect: "allow"
        principals:
          - "service-b"
        actions:
          - "traces.write"
        resources:
          - "traces/service-b/*"
```

---

## 4. 数据隐私

### 4.1 敏感数据识别

**常见敏感数据**：

```text
1. 个人身份信息 (PII)
   - 姓名: "John Doe"
   - 邮箱: "user@example.com"
   - 电话: "+1-555-0123"
   - 地址: "123 Main St"
   - 身份证: "123-45-6789"

2. 认证信息
   - 密码: "mypassword123"
   - API Key: "sk_live_abc123..."
   - Token: "eyJhbGc..."
   - Session ID: "sess_abc123"

3. 财务信息
   - 信用卡: "4532-1234-5678-9010"
   - 银行账号: "123456789"
   - 交易金额: "$1,234.56"

4. 健康信息 (PHI)
   - 病历号
   - 诊断信息
   - 处方信息

5. 商业秘密
   - 内部IP地址
   - 数据库凭证
   - 业务逻辑

识别方法:
- 正则表达式匹配
- 机器学习分类
- 关键字匹配
```

### 4.2 数据脱敏

**Collector脱敏处理器**：

```yaml
processors:
  # 属性处理器 - 删除敏感属性
  attributes:
    actions:
      # 删除密码
      - key: password
        action: delete
      
      # 删除Token
      - key: authorization
        action: delete
      
      # 删除信用卡
      - key: credit_card
        action: delete
      
      # 哈希邮箱
      - key: user.email
        action: hash
      
      # 哈希IP
      - key: client.ip
        action: hash
  
  # 转换处理器 - 复杂脱敏
  transform:
    trace_statements:
      # 脱敏HTTP请求头
      - context: span
        statements:
          # 删除Authorization header
          - delete_key(attributes, "http.request.header.authorization")
          - delete_key(attributes, "http.request.header.cookie")
          
          # 脱敏URL中的敏感参数
          - replace_pattern(attributes["http.url"], 
              "password=([^&]+)", "password=***")
          - replace_pattern(attributes["http.url"], 
              "token=([^&]+)", "token=***")

service:
  pipelines:
    traces:
      processors: [attributes, transform]
```

**SDK层脱敏 (Go)**：

```go
// 自定义SpanProcessor脱敏
type SanitizingProcessor struct {
    next trace.SpanProcessor
}

func (p *SanitizingProcessor) OnStart(
    ctx context.Context,
    s trace.ReadWriteSpan,
) {
    // 获取所有属性
    attrs := s.Attributes()
    
    // 删除敏感属性
    sensitiveKeys := []string{
        "password",
        "api_key",
        "authorization",
        "credit_card",
    }
    
    for _, key := range sensitiveKeys {
        for i, attr := range attrs {
            if attr.Key == attribute.Key(key) {
                // 删除
                attrs = append(attrs[:i], attrs[i+1:]...)
                break
            }
        }
    }
    
    // 脱敏邮箱
    for i, attr := range attrs {
        if attr.Key == "user.email" {
            email := attr.Value.AsString()
            // 哈希
            hash := sha256.Sum256([]byte(email))
            attrs[i].Value = attribute.StringValue(hex.EncodeToString(hash[:]))
        }
    }
    
    p.next.OnStart(ctx, s)
}

// 使用
tp := trace.NewTracerProvider(
    trace.WithSpanProcessor(&SanitizingProcessor{
        next: trace.NewBatchSpanProcessor(exporter),
    }),
)
```

### 4.3 PII处理

**GDPR合规示例**：

```yaml
processors:
  # 1. 数据最小化
  filter:
    spans:
      exclude:
        match_type: strict
        attributes:
          # 不收集PII属性
          - key: user.ssn
          - key: user.phone
          - key: user.address
  
  # 2. 数据脱敏
  attributes:
    actions:
      # 保留用户ID (假名化)
      - key: user.id
        action: hash
      
      # 删除邮箱
      - key: user.email
        action: delete
      
      # 保留IP但脱敏
      - key: client.ip
        action: hash
  
  # 3. 添加同意标记
  resource:
    attributes:
      - key: gdpr.consent
        value: true
        action: upsert

# 4. 数据保留 (通过后端配置)
# Jaeger/Elasticsearch: 保留30天
# 之后自动删除
```

---

## 5. Collector安全

### 5.1 安全配置

**强化Collector配置**：

```yaml
extensions:
  # 健康检查 (内部访问)
  health_check:
    endpoint: 127.0.0.1:13133
  
  # pprof (仅内部)
  pprof:
    endpoint: 127.0.0.1:1777
  
  # zpages (禁用或内部)
  # zpages:
  #   endpoint: 127.0.0.1:55679

receivers:
  otlp:
    protocols:
      grpc:
        # ✅ 绑定内网IP
        endpoint: 10.0.1.5:4317
        
        # ✅ 启用TLS
        tls:
          cert_file: /certs/server.crt
          key_file: /certs/server.key
          min_version: "1.3"
        
        # ✅ 认证
        auth:
          authenticator: bearertokenauth
        
        # ✅ 限流
        max_recv_msg_size_mib: 4
        max_concurrent_streams: 100

processors:
  # ✅ 内存保护
  memory_limiter:
    limit_mib: 1536
    spike_limit_mib: 384
  
  # ✅ 数据脱敏
  attributes:
    actions:
      - key: password
        action: delete

exporters:
  otlp:
    endpoint: backend:4317
    # ✅ 启用TLS
    tls:
      insecure: false
      cert_file: /certs/client.crt
      key_file: /certs/client.key
      ca_file: /certs/ca.crt

service:
  # ✅ 禁用遥测 (或限制)
  telemetry:
    logs:
      level: info
    metrics:
      level: none  # 或basic
```

### 5.2 访问控制

**Kubernetes Network Policy**：

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: otel-collector-policy
spec:
  podSelector:
    matchLabels:
      app: otel-collector
  policyTypes:
    - Ingress
    - Egress
  ingress:
    # 仅允许同namespace的Pod
    - from:
      - podSelector: {}
      ports:
      - protocol: TCP
        port: 4317
      - protocol: TCP
        port: 4318
  egress:
    # 仅允许访问后端
    - to:
      - podSelector:
          matchLabels:
            app: jaeger
      ports:
      - protocol: TCP
        port: 14250
    
    # 允许DNS
    - to:
      - namespaceSelector:
          matchLabels:
            name: kube-system
      ports:
      - protocol: UDP
        port: 53
```

### 5.3 资源隔离

**Pod Security**：

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: otel-collector
spec:
  # ✅ 安全上下文
  securityContext:
    runAsNonRoot: true
    runAsUser: 1000
    fsGroup: 2000
    seccompProfile:
      type: RuntimeDefault
  
  containers:
  - name: otel-collector
    image: otel/opentelemetry-collector:0.90.0
    
    # ✅ 容器安全上下文
    securityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      runAsNonRoot: true
      runAsUser: 1000
      capabilities:
        drop:
          - ALL
    
    # ✅ 资源限制
    resources:
      requests:
        cpu: 200m
        memory: 256Mi
      limits:
        cpu: 1000m
        memory: 512Mi
    
    # ✅ 只读文件系统
    volumeMounts:
    - name: config
      mountPath: /etc/otelcol
      readOnly: true
    - name: tmp
      mountPath: /tmp
  
  volumes:
  - name: config
    configMap:
      name: otel-collector-config
  - name: tmp
    emptyDir: {}
```

---

## 6. Kubernetes安全

### 6.1 RBAC配置

```yaml
# ServiceAccount
apiVersion: v1
kind: ServiceAccount
metadata:
  name: otel-collector
  namespace: observability

---
# ClusterRole (最小权限)
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: otel-collector
rules:
  # 仅读取Pod元数据
  - apiGroups: [""]
    resources: ["pods", "namespaces", "nodes"]
    verbs: ["get", "list", "watch"]

---
# ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: otel-collector
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: otel-collector
subjects:
  - kind: ServiceAccount
    name: otel-collector
    namespace: observability
```

### 6.2 Network Policy

```yaml
# 完整Network Policy
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: otel-collector-strict
spec:
  podSelector:
    matchLabels:
      app: otel-collector
  policyTypes:
    - Ingress
    - Egress
  
  ingress:
    # 仅允许应用发送遥测
    - from:
      - namespaceSelector:
          matchLabels:
            telemetry: enabled
      ports:
      - protocol: TCP
        port: 4317
      - protocol: TCP
        port: 4318
  
  egress:
    # 仅允许访问Jaeger
    - to:
      - podSelector:
          matchLabels:
            app: jaeger
      ports:
      - protocol: TCP
        port: 14250
    
    # 仅允许访问Prometheus
    - to:
      - podSelector:
          matchLabels:
            app: prometheus
      ports:
      - protocol: TCP
        port: 9090
    
    # DNS
    - to:
      - namespaceSelector: {}
        podSelector:
          matchLabels:
            k8s-app: kube-dns
      ports:
      - protocol: UDP
        port: 53
```

### 6.3 Pod Security

**Pod Security Standards**：

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: observability
  labels:
    # ✅ 启用Pod Security
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/audit: restricted
    pod-security.kubernetes.io/warn: restricted

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: otel-collector
  namespace: observability
spec:
  template:
    spec:
      # 符合restricted标准
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        seccompProfile:
          type: RuntimeDefault
      
      containers:
      - name: collector
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop: ["ALL"]
          readOnlyRootFilesystem: true
```

---

## 7. 合规性

### 7.1 GDPR合规

**GDPR要求与实现**：

```text
1. 数据最小化 (Data Minimization)
   要求: 仅收集必要数据
   实现:
   - 不收集PII属性
   - 使用假名化 (hash user.id)
   - 删除敏感HTTP header

2. 访问权 (Right of Access)
   要求: 用户可查询自己的数据
   实现:
   - 按user_id查询trace
   - 提供数据导出API

3. 删除权 (Right to Erasure)
   要求: 用户可删除自己的数据
   实现:
   - 提供数据删除API
   - 短保留期 (30天)

4. 数据可移植性 (Data Portability)
   要求: 以标准格式导出
   实现:
   - OTLP标准格式
   - JSON导出

5. 默认隐私 (Privacy by Default)
   要求: 默认最高隐私保护
   实现:
   - 默认脱敏PII
   - 默认启用TLS
   - 默认短保留期

配置示例:
processors:
  attributes:
    # 假名化
    - key: user.id
      action: hash
    # 删除PII
    - key: user.email
      action: delete
    - key: user.phone
      action: delete
```

### 7.2 SOC2合规

**SOC2控制点**：

```text
1. 访问控制 (CC6.1)
   - ✅ mTLS认证
   - ✅ RBAC授权
   - ✅ 最小权限

2. 逻辑和物理访问 (CC6.2)
   - ✅ Network Policy
   - ✅ 防火墙规则

3. 数据保护 (CC6.7)
   - ✅ TLS 1.3加密
   - ✅ 数据脱敏
   - ✅ 访问日志

4. 变更管理 (CC8.1)
   - ✅ 配置版本控制
   - ✅ GitOps部署
   - ✅ 变更审计

5. 监控 (CC7.2)
   - ✅ 系统监控
   - ✅ 告警配置
   - ✅ 事件响应
```

### 7.3 审计日志

**Collector审计日志**：

```yaml
extensions:
  # 文件日志
  file_storage:
    directory: /var/log/otelcol
    timeout: 10s

processors:
  # 审计处理器 (自定义)
  audit:
    log_file: /var/log/otelcol/audit.log
    events:
      - receiver.accept
      - receiver.refuse
      - exporter.send
      - exporter.fail
      - config.reload

service:
  telemetry:
    logs:
      level: info
      # 结构化日志
      encoding: json
      output_paths:
        - /var/log/otelcol/collector.log
        - stdout

# 审计日志示例:
{
  "timestamp": "2025-10-08T10:00:00Z",
  "event": "receiver.accept",
  "source_ip": "10.0.1.5",
  "service_name": "order-service",
  "span_count": 1024,
  "user_agent": "opentelemetry-go/1.24.0"
}
```

---

## 8. 漏洞管理

**依赖扫描**：

```bash
# 1. 扫描容器镜像
trivy image otel/opentelemetry-collector:0.90.0

# 2. 扫描依赖
go list -json -m all | nancy sleuth

# 3. 更新依赖
go get -u ./...
go mod tidy

# 4. 自动化 (GitHub Actions)
```

```yaml
# .github/workflows/security.yml
name: Security Scan

on:
  push:
  schedule:
    - cron: '0 0 * * *'  # 每天扫描

jobs:
  scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Run Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'otel/opentelemetry-collector:latest'
          format: 'sarif'
          output: 'trivy-results.sarif'
      
      - name: Upload to Security tab
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'
```

---

## 9. 安全监控

**关键安全指标**：

```yaml
# Prometheus告警规则
groups:
- name: security
  rules:
    # 1. 高拒绝率 (可能是攻击)
    - alert: HighRefuseRate
      expr: |
        rate(otelcol_receiver_refused_spans[5m]) > 100
      annotations:
        summary: "异常高的拒绝率，可能是DoS攻击"
    
    # 2. 认证失败
    - alert: AuthenticationFailure
      expr: |
        rate(otelcol_auth_failures[5m]) > 10
      annotations:
        summary: "认证失败率高，可能是暴力破解"
    
    # 3. 异常来源IP
    - alert: UnknownSourceIP
      expr: |
        otelcol_receiver_accepted_spans{source_ip!~"10\\..*|192\\.168\\..*"}
      annotations:
        summary: "来自未知IP的请求"
    
    # 4. TLS错误
    - alert: TLSErrors
      expr: |
        rate(otelcol_tls_errors[5m]) > 1
      annotations:
        summary: "TLS握手失败"
```

---

## 10. 事件响应

**安全事件响应流程**：

```text
1. 检测 (Detection)
   - 监控告警触发
   - 日志异常发现
   - 用户报告

2. 分类 (Triage)
   - 确定事件类型
   - 评估严重程度
   - 分配责任人

3. 遏制 (Containment)
   - 隔离受影响系统
   - 阻止攻击源
   - 停止数据泄露

4. 调查 (Investigation)
   - 分析审计日志
   - 确定影响范围
   - 识别根本原因

5. 恢复 (Recovery)
   - 修复漏洞
   - 恢复服务
   - 验证安全性

6. 总结 (Post-Incident)
   - 编写事件报告
   - 更新流程
   - 培训团队

示例:数据泄露响应
1. 检测: 发现未授权访问
2. 分类: P0严重事件
3. 遏制: 
   - 吊销泄露的API Key
   - 阻止攻击IP
   - 关闭公网访问
4. 调查:
   - 查询审计日志
   - 确定泄露范围
   - 通知受影响用户
5. 恢复:
   - 轮换所有凭证
   - 加固访问控制
   - 重新部署
6. 总结:
   - 编写事件报告
   - 更新安全政策
   - 安全培训
```

---

## 11. 安全检查清单

```text
✅ 传输安全
  □ 启用TLS 1.3
  □ 使用有效证书
  □ 配置mTLS (生产环境)
  □ 禁用不安全协议

✅ 认证授权
  □ 配置认证机制
  □ 使用强密码/Token
  □ 实施最小权限
  □ 定期轮换凭证

✅ 数据隐私
  □ 识别敏感数据
  □ 配置数据脱敏
  □ 删除PII
  □ 遵循GDPR/SOC2

✅ Collector安全
  □ 安全配置
  □ 资源限制
  □ Network Policy
  □ Pod Security

✅ Kubernetes安全
  □ RBAC配置
  □ ServiceAccount
  □ Network Policy
  □ Security Context

✅ 漏洞管理
  □ 定期扫描
  □ 及时更新
  □ 漏洞追踪
  □ 补丁管理

✅ 监控审计
  □ 安全监控
  □ 审计日志
  □ 告警配置
  □ 事件响应

✅ 合规性
  □ GDPR合规
  □ SOC2合规
  □ 数据保留政策
  □ 隐私政策
```

---

## 12. 参考资源

- **安全最佳实践**: <https://opentelemetry.io/docs/specs/otel/security/>
- **TLS配置**: <https://opentelemetry.io/docs/collector/configuration/#tls-configuration>
- **GDPR指南**: <https://gdpr.eu/>
- **SOC2框架**: <https://www.aicpa.org/soc>

---

**文档状态**: ✅ 完成  
**审核状态**: 待审核  
**相关文档**: [Collector架构](../04_核心组件/02_Collector架构.md), [性能优化](../05_采样与性能/02_性能优化实践.md)
