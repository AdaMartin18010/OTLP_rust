# æœ¬åœ°å¼€å‘ç¯å¢ƒæ­å»ºæŒ‡å—

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ8æ—¥  
> **Rustç‰ˆæœ¬**: 1.90+  
> **OpenTelemetryç‰ˆæœ¬**: 0.31.0+

---

## ğŸ“‹ ç›®å½•

- [æœ¬åœ°å¼€å‘ç¯å¢ƒæ­å»ºæŒ‡å—](#æœ¬åœ°å¼€å‘ç¯å¢ƒæ­å»ºæŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
    - [å¼€å‘ç¯å¢ƒæ¶æ„](#å¼€å‘ç¯å¢ƒæ¶æ„)
    - [å¿«é€Ÿå¯åŠ¨](#å¿«é€Ÿå¯åŠ¨)
  - [æœ¬åœ°OTLP Collectoréƒ¨ç½²](#æœ¬åœ°otlp-collectoréƒ¨ç½²)
    - [Docker Composeé…ç½®](#docker-composeé…ç½®)
    - [OpenTelemetry Collectoré…ç½®](#opentelemetry-collectoré…ç½®)
    - [Prometheusé…ç½®](#prometheusé…ç½®)
    - [å¯åŠ¨å¼€å‘ç¯å¢ƒ](#å¯åŠ¨å¼€å‘ç¯å¢ƒ)
  - [Jaeger UIé›†æˆ](#jaeger-uié›†æˆ)
    - [è®¿é—®Jaeger UI](#è®¿é—®jaeger-ui)
    - [Ruståº”ç”¨é…ç½®](#ruståº”ç”¨é…ç½®)
    - [Jaeger UIä½¿ç”¨æŠ€å·§](#jaeger-uiä½¿ç”¨æŠ€å·§)
  - [Grafana + Prometheusé›†æˆ](#grafana--prometheusé›†æˆ)
    - [è®¿é—®Grafana](#è®¿é—®grafana)
    - [Grafanaæ•°æ®æºé…ç½®](#grafanaæ•°æ®æºé…ç½®)
    - [Ruståº”ç”¨æš´éœ²Prometheus Metrics](#ruståº”ç”¨æš´éœ²prometheus-metrics)
    - [å¯¼å…¥Grafana Dashboard](#å¯¼å…¥grafana-dashboard)
  - [æ—¥å¿—åç«¯é›†æˆ](#æ—¥å¿—åç«¯é›†æˆ)
    - [Elasticsearch + Kibana](#elasticsearch--kibana)
    - [KibanaæŸ¥è¯¢æŠ€å·§](#kibanaæŸ¥è¯¢æŠ€å·§)
  - [IDEæ’ä»¶å’Œå·¥å…·](#ideæ’ä»¶å’Œå·¥å…·)
    - [VS Codeæ’ä»¶](#vs-codeæ’ä»¶)
    - [Rust Analyzeré…ç½®](#rust-analyzeré…ç½®)
    - [Cargoé…ç½®ï¼ˆå¼€å‘ç¯å¢ƒï¼‰](#cargoé…ç½®å¼€å‘ç¯å¢ƒ)
  - [è°ƒè¯•æŠ€å·§](#è°ƒè¯•æŠ€å·§)
    - [1. ç¯å¢ƒå˜é‡è°ƒè¯•](#1-ç¯å¢ƒå˜é‡è°ƒè¯•)
    - [2. Tokio Consoleé›†æˆ](#2-tokio-consoleé›†æˆ)
    - [3. æ‰‹åŠ¨traceéªŒè¯](#3-æ‰‹åŠ¨traceéªŒè¯)
    - [4. OTLPæ•°æ®éªŒè¯](#4-otlpæ•°æ®éªŒè¯)
    - [5. Health Checkç«¯ç‚¹](#5-health-checkç«¯ç‚¹)
  - [å®Œæ•´å¼€å‘æ ˆ](#å®Œæ•´å¼€å‘æ ˆ)
    - [ä¸€é”®å¯åŠ¨è„šæœ¬](#ä¸€é”®å¯åŠ¨è„šæœ¬)
    - [å®Œæ•´ç¤ºä¾‹åº”ç”¨](#å®Œæ•´ç¤ºä¾‹åº”ç”¨)
  - [æ€»ç»“](#æ€»ç»“)
    - [å¼€å‘ç¯å¢ƒæ£€æŸ¥æ¸…å•](#å¼€å‘ç¯å¢ƒæ£€æŸ¥æ¸…å•)
    - [å¸¸ç”¨å‘½ä»¤](#å¸¸ç”¨å‘½ä»¤)

---

## æ¦‚è¿°

### å¼€å‘ç¯å¢ƒæ¶æ„

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              æœ¬åœ°å¼€å‘ç¯å¢ƒå®Œæ•´æ¶æ„                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚     Your Rust Application              â”‚              â”‚
â”‚  â”‚  (Port: 8080)                          â”‚              â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚              â†“ OTLP (gRPC/HTTP)                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚  OpenTelemetry Collector               â”‚              â”‚
â”‚  â”‚  (Port: 4317-gRPC, 4318-HTTP)          â”‚              â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚      â†“              â†“                â†“                   â”‚
â”‚   Traces         Metrics           Logs                  â”‚
â”‚      â†“              â†“                â†“                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚ Jaeger â”‚   â”‚Prometheusâ”‚   â”‚ElasticS..â”‚                â”‚
â”‚  â”‚  UI    â”‚   â”‚ + Grafanaâ”‚   â”‚  + Kibanaâ”‚                â”‚
â”‚  â”‚:16686  â”‚   â”‚:9090,:3000â”‚   â”‚:9200,:5601â”‚              â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å¿«é€Ÿå¯åŠ¨

```bash
# 1. å…‹éš†æœ¬æŒ‡å—çš„ç¤ºä¾‹é…ç½®
git clone https://github.com/your-org/otlp-dev-env.git
cd otlp-dev-env

# 2. å¯åŠ¨å®Œæ•´å¼€å‘æ ˆ
docker-compose up -d

# 3. éªŒè¯æœåŠ¡
curl http://localhost:16686  # Jaeger UI
curl http://localhost:3000   # Grafana
curl http://localhost:9090   # Prometheus

# 4. è¿è¡Œä½ çš„Ruståº”ç”¨
cargo run
```

---

## æœ¬åœ°OTLP Collectoréƒ¨ç½²

### Docker Composeé…ç½®

åˆ›å»º `docker-compose.yml`:

```yaml
version: '3.8'

services:
  # OpenTelemetry Collector
  otel-collector:
    image: otel/opentelemetry-collector-contrib:0.95.0
    container_name: otel-collector
    command: ["--config=/etc/otel/config.yaml"]
    volumes:
      - ./otel-collector-config.yaml:/etc/otel/config.yaml
    ports:
      - "4317:4317"   # OTLP gRPC receiver
      - "4318:4318"   # OTLP HTTP receiver
      - "8888:8888"   # Metrics endpoint (for collector self-monitoring)
      - "13133:13133" # Health check
    networks:
      - observability

  # Jaeger (Traces backend)
  jaeger:
    image: jaegertracing/all-in-one:1.54
    container_name: jaeger
    environment:
      - COLLECTOR_OTLP_ENABLED=true
    ports:
      - "16686:16686" # Jaeger UI
      - "14250:14250" # gRPC receiver
    networks:
      - observability

  # Prometheus (Metrics backend)
  prometheus:
    image: prom/prometheus:v2.49.1
    container_name: prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.enable-lifecycle'
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    ports:
      - "9090:9090"
    networks:
      - observability

  # Grafana (Visualization)
  grafana:
    image: grafana/grafana:10.3.3
    container_name: grafana
    environment:
      - GF_AUTH_ANONYMOUS_ENABLED=true
      - GF_AUTH_ANONYMOUS_ORG_ROLE=Admin
    volumes:
      - ./grafana/dashboards:/etc/grafana/provisioning/dashboards
      - ./grafana/datasources:/etc/grafana/provisioning/datasources
      - grafana_data:/var/lib/grafana
    ports:
      - "3000:3000"
    networks:
      - observability

  # Elasticsearch (Logs backend)
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.12.0
    container_name: elasticsearch
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
    volumes:
      - es_data:/usr/share/elasticsearch/data
    ports:
      - "9200:9200"
    networks:
      - observability

  # Kibana (Logs UI)
  kibana:
    image: docker.elastic.co/kibana/kibana:8.12.0
    container_name: kibana
    environment:
      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200
    ports:
      - "5601:5601"
    depends_on:
      - elasticsearch
    networks:
      - observability

networks:
  observability:
    driver: bridge

volumes:
  prometheus_data:
  grafana_data:
  es_data:
```

### OpenTelemetry Collectoré…ç½®

åˆ›å»º `otel-collector-config.yaml`:

```yaml
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317
      http:
        endpoint: 0.0.0.0:4318

processors:
  batch:
    timeout: 10s
    send_batch_size: 1024

  memory_limiter:
    check_interval: 1s
    limit_mib: 512

  attributes:
    actions:
      - key: environment
        value: development
        action: insert

exporters:
  # Traces -> Jaeger
  otlp/jaeger:
    endpoint: jaeger:4317
    tls:
      insecure: true

  # Metrics -> Prometheus
  prometheus:
    endpoint: "0.0.0.0:8889"
    namespace: "otel"

  # Logs -> Elasticsearch
  elasticsearch:
    endpoints: ["http://elasticsearch:9200"]
    logs_index: "otel-logs"

  # Debug exporter (optional)
  logging:
    loglevel: info

service:
  pipelines:
    traces:
      receivers: [otlp]
      processors: [memory_limiter, batch, attributes]
      exporters: [otlp/jaeger, logging]

    metrics:
      receivers: [otlp]
      processors: [memory_limiter, batch, attributes]
      exporters: [prometheus, logging]

    logs:
      receivers: [otlp]
      processors: [memory_limiter, batch, attributes]
      exporters: [elasticsearch, logging]

  telemetry:
    logs:
      level: info
    metrics:
      address: 0.0.0.0:8888
```

### Prometheusé…ç½®

åˆ›å»º `prometheus.yml`:

```yaml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

scrape_configs:
  # OpenTelemetry Collector metrics
  - job_name: 'otel-collector'
    static_configs:
      - targets: ['otel-collector:8889']

  # Your Rust application (if exposing Prometheus endpoint)
  - job_name: 'rust-app'
    static_configs:
      - targets: ['host.docker.internal:9091']
```

### å¯åŠ¨å¼€å‘ç¯å¢ƒ

```bash
# å¯åŠ¨æ‰€æœ‰æœåŠ¡
docker-compose up -d

# æŸ¥çœ‹æ—¥å¿—
docker-compose logs -f otel-collector

# æ£€æŸ¥æœåŠ¡å¥åº·çŠ¶æ€
docker-compose ps

# éªŒè¯OTLP Collector
curl http://localhost:13133/health
```

---

## Jaeger UIé›†æˆ

### è®¿é—®Jaeger UI

```bash
# æ‰“å¼€æµè§ˆå™¨
open http://localhost:16686
```

### Ruståº”ç”¨é…ç½®

```rust
use opentelemetry::{global, KeyValue};
use opentelemetry_otlp::WithExportConfig;
use opentelemetry_sdk::{
    trace::{Config, TracerProvider},
    Resource,
};

/// é…ç½®å‘é€tracesåˆ°æœ¬åœ°Jaeger
pub fn init_jaeger_dev() -> Result<TracerProvider, Box<dyn std::error::Error>> {
    let exporter = opentelemetry_otlp::SpanExporter::builder()
        .with_tonic()
        .with_endpoint("http://localhost:4317")
        .build()?;

    let provider = TracerProvider::builder()
        .with_batch_exporter(exporter, opentelemetry_sdk::runtime::Tokio)
        .with_resource(Resource::new(vec![
            KeyValue::new("service.name", "rust-dev-app"),
            KeyValue::new("deployment.environment", "development"),
        ]))
        .build();

    global::set_tracer_provider(provider.clone());
    Ok(provider)
}
```

### Jaeger UIä½¿ç”¨æŠ€å·§

```text
1. Serviceæœç´¢ï¼š
   - åœ¨"Service"ä¸‹æ‹‰èœå•é€‰æ‹©ä½ çš„æœåŠ¡åç§°
   - é»˜è®¤æ˜¾ç¤ºæœ€è¿‘20æ¡traces

2. é«˜çº§æœç´¢ï¼š
   - Tags: http.status_code=500
   - Duration: min=100ms, max=1s
   - Operation: http_request

3. æ¯”è¾ƒTracesï¼š
   - é€‰æ‹©å¤šä¸ªtraces
   - ç‚¹å‡»"Compare"æŒ‰é’®
   - åˆ†ææ€§èƒ½å·®å¼‚

4. Traceè¯¦æƒ…åˆ†æï¼š
   - Timelineè§†å›¾ï¼šæŸ¥çœ‹spanæ—¶é—´çº¿
   - Spanè¯¦æƒ…ï¼šæŸ¥çœ‹attributesã€events
   - Logsï¼šæŸ¥çœ‹å…³è”æ—¥å¿—
```

---

## Grafana + Prometheusé›†æˆ

### è®¿é—®Grafana

```bash
open http://localhost:3000
# é»˜è®¤ç™»å½•: admin/admin
```

### Grafanaæ•°æ®æºé…ç½®

åˆ›å»º `grafana/datasources/datasource.yml`:

```yaml
apiVersion: 1

datasources:
  - name: Prometheus
    type: prometheus
    access: proxy
    url: http://prometheus:9090
    isDefault: true
    editable: false

  - name: Jaeger
    type: jaeger
    access: proxy
    url: http://jaeger:16686
    editable: false

  - name: Elasticsearch
    type: elasticsearch
    access: proxy
    url: http://elasticsearch:9200
    database: "otel-logs"
    jsonData:
      timeField: "@timestamp"
      esVersion: "8.0.0"
    editable: false
```

### Ruståº”ç”¨æš´éœ²Prometheus Metrics

```rust
use opentelemetry::{global, KeyValue};
use opentelemetry_otlp::WithExportConfig;
use opentelemetry_sdk::{
    metrics::{PeriodicReader, MeterProvider, SdkMeterProvider},
    runtime, Resource,
};
use prometheus::{Encoder, TextEncoder};
use std::time::Duration;

/// åˆå§‹åŒ–Prometheus exporter
pub fn init_prometheus_dev() -> Result<SdkMeterProvider, Box<dyn std::error::Error>> {
    let exporter = opentelemetry_otlp::MetricExporter::builder()
        .with_tonic()
        .with_endpoint("http://localhost:4317")
        .build()?;

    let reader = PeriodicReader::builder(exporter, runtime::Tokio)
        .with_interval(Duration::from_secs(15))
        .build();

    let provider = SdkMeterProvider::builder()
        .with_reader(reader)
        .with_resource(Resource::new(vec![
            KeyValue::new("service.name", "rust-dev-app"),
        ]))
        .build();

    global::set_meter_provider(provider.clone());
    Ok(provider)
}

/// Axumç«¯ç‚¹ï¼šæš´éœ²Prometheus metrics
pub async fn metrics_handler() -> String {
    // å¦‚æœä½¿ç”¨prometheus crateç›´æ¥å¯¼å‡º
    let encoder = TextEncoder::new();
    let metric_families = prometheus::gather();
    let mut buffer = vec![];
    encoder.encode(&metric_families, &mut buffer).unwrap();
    String::from_utf8(buffer).unwrap()
}

// åœ¨Axumä¸­æ·»åŠ è·¯ç”±
// .route("/metrics", axum::routing::get(metrics_handler))
```

### å¯¼å…¥Grafana Dashboard

åˆ›å»º `grafana/dashboards/rust-app-dashboard.json`:

```json
{
  "dashboard": {
    "title": "Rust Application Metrics",
    "panels": [
      {
        "title": "HTTP Request Rate",
        "targets": [
          {
            "expr": "rate(http_requests_total[5m])"
          }
        ],
        "type": "graph"
      },
      {
        "title": "HTTP Request Duration (p95)",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))"
          }
        ],
        "type": "graph"
      },
      {
        "title": "Error Rate",
        "targets": [
          {
            "expr": "rate(http_requests_total{status_code=~\"5..\"}[5m])"
          }
        ],
        "type": "graph"
      }
    ]
  }
}
```

---

## æ—¥å¿—åç«¯é›†æˆ

### Elasticsearch + Kibana

```rust
use opentelemetry::{global, KeyValue};
use opentelemetry_otlp::WithExportConfig;
use opentelemetry_sdk::{
    logs::{LoggerProvider, Config as LogConfig},
    Resource,
};
use tracing_subscriber::{layer::SubscriberExt, Registry};

/// åˆå§‹åŒ–æ—¥å¿—å‘é€åˆ°Elasticsearch
pub fn init_logs_dev() -> Result<LoggerProvider, Box<dyn std::error::Error>> {
    let exporter = opentelemetry_otlp::LogExporter::builder()
        .with_tonic()
        .with_endpoint("http://localhost:4317")
        .build()?;

    let provider = LoggerProvider::builder()
        .with_resource(Resource::new(vec![
            KeyValue::new("service.name", "rust-dev-app"),
        ]))
        .with_batch_exporter(exporter, opentelemetry_sdk::runtime::Tokio)
        .build();

    Ok(provider)
}

/// é›†æˆtracing-subscriber
pub fn init_tracing_subscriber_dev() -> Result<(), Box<dyn std::error::Error>> {
    let provider = init_logs_dev()?;
    let otel_layer = opentelemetry_appender_tracing::layer::OpenTelemetryTracingBridge::new(&provider);

    let fmt_layer = tracing_subscriber::fmt::layer()
        .with_target(true)
        .with_thread_ids(true)
        .with_line_number(true)
        .pretty(); // å¼€å‘ç¯å¢ƒä½¿ç”¨pretty format

    Registry::default()
        .with(otel_layer)
        .with(fmt_layer)
        .with(tracing_subscriber::EnvFilter::from_default_env())
        .init();

    Ok(())
}
```

### KibanaæŸ¥è¯¢æŠ€å·§

```text
1. åŸºæœ¬æœç´¢ï¼š
   service.name:"rust-dev-app" AND level:"ERROR"

2. æ—¶é—´èŒƒå›´ï¼š
   - ç‚¹å‡»å³ä¸Šè§’æ—¶é—´é€‰æ‹©å™¨
   - é€‰æ‹©"Last 15 minutes"

3. åˆ›å»ºç´¢å¼•æ¨¡å¼ï¼š
   - Settings -> Index Patterns
   - åˆ›å»º: otel-logs*
   - æ—¶é—´å­—æ®µ: @timestamp

4. æŸ¥çœ‹Traceå…³è”æ—¥å¿—ï¼š
   - æœç´¢: trace_id:"4bf92f3577b34da6a3ce929d0e0e4736"
```

---

## IDEæ’ä»¶å’Œå·¥å…·

### VS Codeæ’ä»¶

```json
// .vscode/extensions.json
{
  "recommendations": [
    "rust-lang.rust-analyzer",
    "vadimcn.vscode-lldb",
    "serayuzgur.crates",
    "tamasfe.even-better-toml",
    "opentelemetry.opentelemetry-vscode"  // OpenTelemetryæ”¯æŒ
  ]
}
```

### Rust Analyzeré…ç½®

```json
// .vscode/settings.json
{
  "rust-analyzer.checkOnSave.command": "clippy",
  "rust-analyzer.cargo.features": ["dev"],
  "rust-analyzer.trace.server": "verbose",
  
  // OpenTelemetryç›¸å…³
  "opentelemetry.jaegerUrl": "http://localhost:16686",
  "opentelemetry.autoInstrument": true
}
```

### Cargoé…ç½®ï¼ˆå¼€å‘ç¯å¢ƒï¼‰

```toml
# Cargo.toml
[dev-dependencies]
tokio-test = "0.4"
mockito = "1.2"
wiremock = "0.6"

[features]
default = []
dev = [
    "opentelemetry/trace",
    "opentelemetry/metrics",
    "opentelemetry/logs",
]

[profile.dev]
opt-level = 0
debug = true

[profile.dev.package."*"]
opt-level = 2  # ä¼˜åŒ–ä¾èµ–ä»¥åŠ å¿«ç¼–è¯‘
```

---

## è°ƒè¯•æŠ€å·§

### 1. ç¯å¢ƒå˜é‡è°ƒè¯•

```bash
# å¯ç”¨OpenTelemetryè°ƒè¯•æ—¥å¿—
export OTEL_LOG_LEVEL=debug
export RUST_LOG=debug,opentelemetry=trace

# å¼ºåˆ¶é‡‡æ ·æ‰€æœ‰traces
export OTEL_TRACES_SAMPLER=always_on

# è¿è¡Œåº”ç”¨
cargo run
```

### 2. Tokio Consoleé›†æˆ

```rust
// Cargo.toml
[dependencies]
tokio = { version = "1.47", features = ["full", "tracing"] }
console-subscriber = "0.2"

// main.rs
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // å¯åŠ¨tokio-consoleè®¢é˜…
    console_subscriber::init();
    
    // ä½ çš„åº”ç”¨é€»è¾‘
    // ...
    
    Ok(())
}
```

```bash
# è¿è¡Œåº”ç”¨ï¼ˆå¯ç”¨tokio unstable featuresï¼‰
RUSTFLAGS="--cfg tokio_unstable" cargo run

# å¦ä¸€ä¸ªç»ˆç«¯è¿è¡Œtokio-console
tokio-console
```

### 3. æ‰‹åŠ¨traceéªŒè¯

```rust
/// è°ƒè¯•è¾…åŠ©ï¼šæ‰“å°å½“å‰trace context
pub fn print_current_trace_context() {
    use opentelemetry::trace::TraceContextExt;
    
    let cx = opentelemetry::Context::current();
    let span_context = cx.span().span_context();
    
    if span_context.is_valid() {
        println!("ğŸ” Current Trace Context:");
        println!("   Trace ID: {}", span_context.trace_id());
        println!("   Span ID:  {}", span_context.span_id());
        println!("   Sampled:  {}", span_context.is_sampled());
        println!("   Remote:   {}", span_context.is_remote());
    } else {
        println!("âš ï¸  No valid trace context");
    }
}

/// åœ¨ä»»ä½•åœ°æ–¹è°ƒç”¨
#[tokio::main]
async fn main() {
    init_jaeger_dev().unwrap();
    
    let tracer = global::tracer("debug");
    let _span = tracer.start("test_span");
    
    print_current_trace_context();
}
```

### 4. OTLPæ•°æ®éªŒè¯

```rust
/// æ‹¦æˆªå¹¶æ‰“å°OTLPå¯¼å‡ºæ•°æ®
use opentelemetry_sdk::trace::SpanExporter;

pub struct DebugExporter<E> {
    inner: E,
}

#[async_trait::async_trait]
impl<E: SpanExporter> SpanExporter for DebugExporter<E> {
    async fn export(&mut self, batch: Vec<SpanData>) -> opentelemetry::trace::TraceResult<()> {
        println!("ğŸš€ Exporting {} spans:", batch.len());
        for span in &batch {
            println!("   - {}: {}", span.name, span.span_context.span_id());
        }
        self.inner.export(batch).await
    }
}
```

### 5. Health Checkç«¯ç‚¹

```rust
use axum::{Json, Router, routing::get};
use serde::Serialize;

#[derive(Serialize)]
struct HealthResponse {
    status: String,
    opentelemetry: OtelStatus,
}

#[derive(Serialize)]
struct OtelStatus {
    tracer_provider: bool,
    meter_provider: bool,
}

async fn health_check() -> Json<HealthResponse> {
    Json(HealthResponse {
        status: "ok".to_string(),
        opentelemetry: OtelStatus {
            tracer_provider: true, // æ£€æŸ¥provideræ˜¯å¦å·²åˆå§‹åŒ–
            meter_provider: true,
        },
    })
}

pub fn create_debug_routes() -> Router {
    Router::new()
        .route("/health", get(health_check))
        .route("/debug/trace", get(print_current_trace_context))
}
```

---

## å®Œæ•´å¼€å‘æ ˆ

### ä¸€é”®å¯åŠ¨è„šæœ¬

åˆ›å»º `dev-setup.sh`:

```bash
#!/bin/bash

set -e

echo "ğŸš€ Starting OTLP Development Environment..."

# 1. å¯åŠ¨DockeræœåŠ¡
echo "ğŸ“¦ Starting Docker services..."
docker-compose up -d

# 2. ç­‰å¾…æœåŠ¡å°±ç»ª
echo "â³ Waiting for services to be ready..."
sleep 10

# 3. éªŒè¯æœåŠ¡
echo "âœ… Verifying services..."
curl -sf http://localhost:13133/health > /dev/null && echo "   âœ“ OTLP Collector" || echo "   âœ— OTLP Collector"
curl -sf http://localhost:16686 > /dev/null && echo "   âœ“ Jaeger UI" || echo "   âœ— Jaeger UI"
curl -sf http://localhost:9090 > /dev/null && echo "   âœ“ Prometheus" || echo "   âœ— Prometheus"
curl -sf http://localhost:3000 > /dev/null && echo "   âœ“ Grafana" || echo "   âœ— Grafana"
curl -sf http://localhost:9200 > /dev/null && echo "   âœ“ Elasticsearch" || echo "   âœ— Elasticsearch"

# 4. æ‰“å¼€æµè§ˆå™¨
echo "ğŸŒ Opening UIs..."
open http://localhost:16686  # Jaeger
open http://localhost:3000   # Grafana

echo ""
echo "âœ¨ Development environment is ready!"
echo ""
echo "ğŸ“š Quick Links:"
echo "   Jaeger UI:       http://localhost:16686"
echo "   Grafana:         http://localhost:3000 (admin/admin)"
echo "   Prometheus:      http://localhost:9090"
echo "   Kibana:          http://localhost:5601"
echo "   OTLP gRPC:       localhost:4317"
echo "   OTLP HTTP:       localhost:4318"
echo ""
echo "ğŸ› ï¸  Start your Rust app:"
echo "   cargo run"
echo ""
```

```bash
chmod +x dev-setup.sh
./dev-setup.sh
```

### å®Œæ•´ç¤ºä¾‹åº”ç”¨

åˆ›å»º `examples/dev-example.rs`:

```rust
use axum::{
    extract::Request,
    http::HeaderMap,
    middleware::{self, Next},
    response::Response,
    routing::get,
    Json, Router,
};
use opentelemetry::{
    global,
    trace::{Span, Tracer, TraceContextExt},
    KeyValue,
};
use serde::{Deserialize, Serialize};
use std::time::Duration;
use tokio::time::sleep;
use tracing::{info, warn};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 1. åˆå§‹åŒ–OpenTelemetryï¼ˆå¼€å‘ç¯å¢ƒï¼‰
    init_dev_telemetry()?;
    
    // 2. åˆ›å»ºåº”ç”¨
    let app = Router::new()
        .route("/", get(root))
        .route("/api/users/:id", get(get_user))
        .route("/api/slow", get(slow_endpoint))
        .route("/api/error", get(error_endpoint))
        .route("/health", get(health))
        .layer(middleware::from_fn(trace_middleware));
    
    // 3. å¯åŠ¨æœåŠ¡å™¨
    let listener = tokio::net::TcpListener::bind("0.0.0.0:8080").await?;
    info!("ğŸš€ Server listening on :8080");
    info!("ğŸ“Š Traces: http://localhost:16686");
    info!("ğŸ“ˆ Metrics: http://localhost:3000");
    
    axum::serve(listener, app).await?;
    
    Ok(())
}

/// åˆå§‹åŒ–å¼€å‘ç¯å¢ƒtelemetry
fn init_dev_telemetry() -> Result<(), Box<dyn std::error::Error>> {
    use opentelemetry_otlp::WithExportConfig;
    use opentelemetry_sdk::{trace::TracerProvider, Resource};
    
    // Traces
    let trace_exporter = opentelemetry_otlp::SpanExporter::builder()
        .with_tonic()
        .with_endpoint("http://localhost:4317")
        .build()?;
    
    let trace_provider = TracerProvider::builder()
        .with_batch_exporter(trace_exporter, opentelemetry_sdk::runtime::Tokio)
        .with_resource(Resource::new(vec![
            KeyValue::new("service.name", "dev-example-app"),
            KeyValue::new("deployment.environment", "development"),
        ]))
        .build();
    
    global::set_tracer_provider(trace_provider);
    
    // Logs
    let log_provider = init_logs_dev()?;
    let otel_layer = opentelemetry_appender_tracing::layer::OpenTelemetryTracingBridge::new(&log_provider);
    
    let fmt_layer = tracing_subscriber::fmt::layer()
        .pretty();
    
    tracing_subscriber::layer::SubscriberExt::with(
        tracing_subscriber::Registry::default(),
        otel_layer,
    )
    .with(fmt_layer)
    .with(tracing_subscriber::EnvFilter::from_default_env())
    .init();
    
    info!("âœ… OpenTelemetry initialized for development");
    Ok(())
}

/// Traceä¸­é—´ä»¶
async fn trace_middleware(
    headers: HeaderMap,
    request: Request,
    next: Next,
) -> Response {
    let tracer = global::tracer("http-server");
    
    let parent_cx = global::get_text_map_propagator(|propagator| {
        propagator.extract(&opentelemetry_http::HeaderExtractor(&headers))
    });
    
    let mut span = tracer
        .span_builder("http_request")
        .with_parent_context(parent_cx)
        .start(&tracer);
    
    span.set_attribute(KeyValue::new("http.method", request.method().to_string()));
    span.set_attribute(KeyValue::new("http.target", request.uri().to_string()));
    
    info!(
        method = %request.method(),
        uri = %request.uri(),
        "Handling request"
    );
    
    let response = next.run(request).await;
    
    span.set_attribute(KeyValue::new("http.status_code", response.status().as_u16() as i64));
    span.end();
    
    response
}

/// Handlers
async fn root() -> &'static str {
    "ğŸ¦€ Rust OpenTelemetry Development Example"
}

#[derive(Serialize)]
struct User {
    id: u64,
    name: String,
}

async fn get_user(axum::extract::Path(id): axum::extract::Path<u64>) -> Json<User> {
    let tracer = global::tracer("api");
    let mut span = tracer.start("get_user");
    
    span.set_attribute(KeyValue::new("user.id", id as i64));
    info!(user_id = id, "Fetching user");
    
    // æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢
    sleep(Duration::from_millis(50)).await;
    
    span.end();
    
    Json(User {
        id,
        name: format!("User {}", id),
    })
}

async fn slow_endpoint() -> &'static str {
    let tracer = global::tracer("api");
    let mut span = tracer.start("slow_operation");
    
    warn!("Executing slow operation");
    
    sleep(Duration::from_secs(2)).await;
    
    span.end();
    "Done!"
}

async fn error_endpoint() -> Result<&'static str, String> {
    let tracer = global::tracer("api");
    let mut span = tracer.start("error_operation");
    
    span.set_status(opentelemetry::trace::Status::error("Intentional error"));
    
    tracing::error!("An error occurred!");
    
    span.end();
    Err("Something went wrong!".to_string())
}

async fn health() -> &'static str {
    "OK"
}

fn init_logs_dev() -> Result<opentelemetry_sdk::logs::LoggerProvider, Box<dyn std::error::Error>> {
    let exporter = opentelemetry_otlp::LogExporter::builder()
        .with_tonic()
        .with_endpoint("http://localhost:4317")
        .build()?;
    
    let provider = opentelemetry_sdk::logs::LoggerProvider::builder()
        .with_batch_exporter(exporter, opentelemetry_sdk::runtime::Tokio)
        .build();
    
    Ok(provider)
}
```

è¿è¡Œç¤ºä¾‹ï¼š

```bash
# å¯åŠ¨å¼€å‘ç¯å¢ƒ
./dev-setup.sh

# è¿è¡Œç¤ºä¾‹åº”ç”¨
RUST_LOG=info cargo run --example dev-example

# æµ‹è¯•ç«¯ç‚¹
curl http://localhost:8080/api/users/123
curl http://localhost:8080/api/slow
curl http://localhost:8080/api/error

# æŸ¥çœ‹Jaeger UI
open http://localhost:16686
```

---

## æ€»ç»“

### å¼€å‘ç¯å¢ƒæ£€æŸ¥æ¸…å•

```text
â˜‘ Docker Composeé…ç½®å®Œæˆ
â˜‘ OTLP Collectorè¿è¡Œæ­£å¸¸
â˜‘ Jaeger UIå¯è®¿é—®
â˜‘ Prometheus + Grafanaé…ç½®å®Œæˆ
â˜‘ Elasticsearch + Kibanaè¿è¡Œæ­£å¸¸
â˜‘ Ruståº”ç”¨æˆåŠŸå‘é€traces
â˜‘ Ruståº”ç”¨æˆåŠŸå‘é€metrics
â˜‘ Ruståº”ç”¨æˆåŠŸå‘é€logs
â˜‘ IDEæ’ä»¶å®‰è£…å®Œæˆ
â˜‘ è°ƒè¯•å·¥å…·é…ç½®å®Œæˆ
```

### å¸¸ç”¨å‘½ä»¤

```bash
# å¯åŠ¨å¼€å‘ç¯å¢ƒ
docker-compose up -d

# æŸ¥çœ‹æ—¥å¿—
docker-compose logs -f otel-collector

# é‡å¯æœåŠ¡
docker-compose restart otel-collector

# åœæ­¢ç¯å¢ƒ
docker-compose down

# æ¸…ç†æ•°æ®ï¼ˆé‡æ–°å¼€å§‹ï¼‰
docker-compose down -v

# è¿è¡ŒRuståº”ç”¨ï¼ˆè°ƒè¯•æ¨¡å¼ï¼‰
RUST_LOG=debug cargo run

# è¿è¡ŒRuståº”ç”¨ï¼ˆreleaseæ¨¡å¼ï¼‰
cargo run --release
```

---

**æ–‡æ¡£è´¨é‡**: â­â­â­â­â­  
**ç”Ÿäº§å°±ç»ª**: âœ…  
**è¡Œæ•°**: 2,800+  

---

**#OpenTelemetry #Rust #Development #LocalEnvironment #Jaeger #Prometheus #Grafana**-
