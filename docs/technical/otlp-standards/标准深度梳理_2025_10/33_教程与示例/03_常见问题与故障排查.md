# å¸¸è§é—®é¢˜ä¸æ•…éšœæ’æŸ¥

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´10æœˆ8æ—¥  
> **Rustç‰ˆæœ¬**: 1.90  
> **OpenTelemetryç‰ˆæœ¬**: 0.31.0  
> **æ–‡æ¡£ç±»å‹**: Troubleshooting Guide

---

## ğŸ“‹ ç›®å½•

- [å¸¸è§é—®é¢˜ä¸æ•…éšœæ’æŸ¥](#å¸¸è§é—®é¢˜ä¸æ•…éšœæ’æŸ¥)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
    - [æ–‡æ¡£ç”¨é€”](#æ–‡æ¡£ç”¨é€”)
    - [æ•…éšœæ’æŸ¥æµç¨‹](#æ•…éšœæ’æŸ¥æµç¨‹)
  - [å¸¸è§é—®é¢˜FAQ](#å¸¸è§é—®é¢˜faq)
    - [Q1: Spansæ²¡æœ‰æ˜¾ç¤ºåœ¨Jaegerä¸­](#q1-spansæ²¡æœ‰æ˜¾ç¤ºåœ¨jaegerä¸­)
    - [Q2: Metricsæ²¡æœ‰æ›´æ–°](#q2-metricsæ²¡æœ‰æ›´æ–°)
    - [Q3: æ—¥å¿—æ²¡æœ‰å‘é€åˆ°Elasticsearch](#q3-æ—¥å¿—æ²¡æœ‰å‘é€åˆ°elasticsearch)
    - [Q4: æ€§èƒ½ä¸¥é‡ä¸‹é™](#q4-æ€§èƒ½ä¸¥é‡ä¸‹é™)
    - [Q5: Contextä¼ æ’­å¤±è´¥](#q5-contextä¼ æ’­å¤±è´¥)
  - [Tracesæ•…éšœæ’æŸ¥](#tracesæ•…éšœæ’æŸ¥)
    - [è¯Šæ–­å·¥å…·](#è¯Šæ–­å·¥å…·)
    - [å¸¸è§é”™è¯¯åŠè§£å†³](#å¸¸è§é”™è¯¯åŠè§£å†³)
  - [Metricsæ•…éšœæ’æŸ¥](#metricsæ•…éšœæ’æŸ¥)
    - [è¯Šæ–­æ£€æŸ¥æ¸…å•](#è¯Šæ–­æ£€æŸ¥æ¸…å•)
  - [Logsæ•…éšœæ’æŸ¥](#logsæ•…éšœæ’æŸ¥)
    - [æ—¥å¿—çº§åˆ«é…ç½®](#æ—¥å¿—çº§åˆ«é…ç½®)
  - [æ€§èƒ½é—®é¢˜è¯Šæ–­](#æ€§èƒ½é—®é¢˜è¯Šæ–­)
    - [æ€§èƒ½åˆ†æå·¥å…·](#æ€§èƒ½åˆ†æå·¥å…·)
    - [æ€§èƒ½ä¼˜åŒ–å»ºè®®](#æ€§èƒ½ä¼˜åŒ–å»ºè®®)
  - [å®‰å…¨é—®é¢˜è¯Šæ–­](#å®‰å…¨é—®é¢˜è¯Šæ–­)
    - [TLSé…ç½®](#tlsé…ç½®)
  - [è°ƒè¯•æŠ€å·§](#è°ƒè¯•æŠ€å·§)
    - [1. å¯ç”¨è¯¦ç»†æ—¥å¿—](#1-å¯ç”¨è¯¦ç»†æ—¥å¿—)
    - [2. ä½¿ç”¨Debug Exporter](#2-ä½¿ç”¨debug-exporter)
    - [3. æ£€æŸ¥CollectorçŠ¶æ€](#3-æ£€æŸ¥collectorçŠ¶æ€)
    - [4. éªŒè¯æ•°æ®æµ](#4-éªŒè¯æ•°æ®æµ)
  - [ç¤¾åŒºèµ„æº](#ç¤¾åŒºèµ„æº)
    - [å®˜æ–¹èµ„æº](#å®˜æ–¹èµ„æº)
    - [æœ‰ç”¨çš„å·¥å…·](#æœ‰ç”¨çš„å·¥å…·)
    - [æœ€ä½³å®è·µæ£€æŸ¥æ¸…å•](#æœ€ä½³å®è·µæ£€æŸ¥æ¸…å•)
  - [æ€»ç»“](#æ€»ç»“)
    - [å¿«é€Ÿæ’æŸ¥æŒ‡å—](#å¿«é€Ÿæ’æŸ¥æŒ‡å—)
    - [è·å–å¸®åŠ©](#è·å–å¸®åŠ©)

---

## æ¦‚è¿°

### æ–‡æ¡£ç”¨é€”

æœ¬æ–‡æ¡£æä¾›OTLPå®æ–½è¿‡ç¨‹ä¸­å¸¸è§é—®é¢˜çš„è§£å†³æ–¹æ¡ˆå’Œæ•…éšœæ’æŸ¥æŒ‡å—ã€‚

### æ•…éšœæ’æŸ¥æµç¨‹

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Troubleshooting Workflow                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                 â”‚
â”‚  1. Identify Symptoms (è¯†åˆ«ç—‡çŠ¶)                 â”‚
â”‚     â””â”€ ä»€ä¹ˆä¸å·¥ä½œï¼Ÿ                              â”‚
â”‚     â””â”€ é”™è¯¯ä¿¡æ¯æ˜¯ä»€ä¹ˆï¼Ÿ                          â”‚
â”‚                                                 â”‚
â”‚  2. Check Basics (æ£€æŸ¥åŸºç¡€)                      â”‚
â”‚     â””â”€ é…ç½®æ˜¯å¦æ­£ç¡®ï¼Ÿ                            â”‚
â”‚     â””â”€ æœåŠ¡æ˜¯å¦è¿è¡Œï¼Ÿ                            â”‚
â”‚     â””â”€ ç½‘ç»œæ˜¯å¦è¿é€šï¼Ÿ                            â”‚
â”‚                                                 â”‚
â”‚  3. Collect Information (æ”¶é›†ä¿¡æ¯)               â”‚
â”‚     â””â”€ æ—¥å¿—                                     â”‚
â”‚     â””â”€ æŒ‡æ ‡                                     â”‚
â”‚     â””â”€ è¿½è¸ªæ•°æ®                                  â”‚
â”‚                                                 â”‚
â”‚  4. Analyze Root Cause (åˆ†ææ ¹å› )                â”‚
â”‚     â””â”€ ä½¿ç”¨å·¥å…·è¯Šæ–­                              â”‚
â”‚     â””â”€ å¯¹æ¯”æ­£å¸¸çŠ¶æ€                              â”‚
â”‚                                                 â”‚
â”‚  5. Implement Fix (å®æ–½ä¿®å¤)                     â”‚
â”‚     â””â”€ ä¿®æ”¹é…ç½®                                  â”‚
â”‚     â””â”€ æ›´æ–°ä»£ç                                   â”‚
â”‚     â””â”€ é‡å¯æœåŠ¡                                  â”‚
â”‚                                                 â”‚
â”‚  6. Verify Solution (éªŒè¯è§£å†³)                   â”‚
â”‚     â””â”€ æµ‹è¯•åŠŸèƒ½                                  â”‚
â”‚     â””â”€ ç›‘æ§ç¨³å®šæ€§                                â”‚
â”‚                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## å¸¸è§é—®é¢˜FAQ

### Q1: Spansæ²¡æœ‰æ˜¾ç¤ºåœ¨Jaegerä¸­

**ç—‡çŠ¶**:

- åº”ç”¨è¿è¡Œæ­£å¸¸
- æ²¡æœ‰æ˜æ˜¾é”™è¯¯
- Jaeger UIä¸­çœ‹ä¸åˆ°traces

**å¯èƒ½åŸå› å’Œè§£å†³æ–¹æ¡ˆ**:

```rust
// æ£€æŸ¥1: TracerProvideræ˜¯å¦æ­£ç¡®åˆå§‹åŒ–ï¼Ÿ
use opentelemetry::global;

fn check_tracer_provider() {
    let tracer = global::tracer("test");
    // å¦‚æœè¿”å›çš„æ˜¯NoopTracerï¼Œè¯´æ˜provideræœªåˆå§‹åŒ–
}

// æ£€æŸ¥2: æ˜¯å¦è°ƒç”¨äº†shutdownï¼Ÿ
async fn proper_shutdown(provider: TracerProvider) -> Result<(), Box<dyn std::error::Error>> {
    // âŒ é”™è¯¯ï¼šå¿˜è®°shutdown
    // drop(provider);
    
    // âœ… æ­£ç¡®ï¼šæ˜¾å¼shutdown
    provider.shutdown()?;
    
    // ç»™exporteræ—¶é—´å¯¼å‡ºæ•°æ®
    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
    Ok(())
}

// æ£€æŸ¥3: æ‰¹å¤„ç†æ˜¯å¦é…ç½®æ­£ç¡®ï¼Ÿ
use opentelemetry_sdk::trace::BatchConfig;
use std::time::Duration;

fn check_batch_config() -> BatchConfig {
    BatchConfig::default()
        .with_scheduled_delay(Duration::from_millis(500))  // ä¸è¦å¤ªé•¿
        .with_max_queue_size(2048)
        .with_max_export_batch_size(512)
}

// æ£€æŸ¥4: é‡‡æ ·å™¨é…ç½®
use opentelemetry_sdk::trace::Sampler;

fn check_sampler() -> Sampler {
    // âŒ å¦‚æœç”¨AlwaysOffï¼Œä»€ä¹ˆéƒ½ä¸ä¼šå¯¼å‡º
    // Sampler::AlwaysOff
    
    // âœ… å¼€å‘ç¯å¢ƒä½¿ç”¨AlwaysOn
    Sampler::AlwaysOn
}
```

**éªŒè¯æ–¹æ³•**:

```bash
# 1. æ£€æŸ¥OTLP Collectoræ—¥å¿—
docker logs otel-collector

# 2. æ£€æŸ¥Collectoræ˜¯å¦æ¥æ”¶åˆ°æ•°æ®
curl http://localhost:8888/metrics | grep otelcol_receiver_accepted_spans

# 3. å¯ç”¨debugæ—¥å¿—
RUST_LOG=opentelemetry=debug cargo run
```

### Q2: Metricsæ²¡æœ‰æ›´æ–°

**ç—‡çŠ¶**:

- Metricsåˆå§‹åŒ–æˆåŠŸ
- è°ƒç”¨äº†record/addæ–¹æ³•
- Prometheusä¸­çœ‹ä¸åˆ°æˆ–æ•°æ®ä¸æ›´æ–°

**è§£å†³æ–¹æ¡ˆ**:

```rust
// é—®é¢˜1: æœªé…ç½®PeriodicReader
use opentelemetry_sdk::metrics::{PeriodicReader, SdkMeterProvider};

fn correct_metrics_init() -> Result<SdkMeterProvider, Box<dyn std::error::Error>> {
    let exporter = opentelemetry_otlp::MetricExporter::builder()
        .with_tonic()
        .with_endpoint("http://localhost:4317")
        .build()?;

    // âœ… å¿…é¡»é…ç½®readerï¼Œå®šæœŸå¯¼å‡º
    let reader = PeriodicReader::builder(exporter, opentelemetry_sdk::runtime::Tokio)
        .with_interval(Duration::from_secs(60))  // å¯¼å‡ºé—´éš”
        .build();

    let provider = SdkMeterProvider::builder()
        .with_reader(reader)
        .build();

    Ok(provider)
}

// é—®é¢˜2: Observable metricsæ²¡æœ‰æ³¨å†Œå›è°ƒ
use opentelemetry::metrics::Meter;

fn correct_observable_usage(meter: &Meter) {
    let gauge = meter
        .f64_observable_gauge("my_gauge")
        .build();

    // âœ… å¿…é¡»æ³¨å†Œå›è°ƒ
    meter.register_callback(&[gauge.as_any()], move |observer| {
        observer.observe_f64(&gauge, 42.0, &[]);
    })?;
}

// é—®é¢˜3: æ ‡ç­¾åŸºæ•°è¿‡é«˜å¯¼è‡´è¢«ä¸¢å¼ƒ
fn avoid_high_cardinality() {
    let counter = global::meter("app").u64_counter("requests").build();

    // âŒ é«˜åŸºæ•°ï¼šuser_id
    counter.add(1, &[KeyValue::new("user_id", "12345")]);

    // âœ… ä½åŸºæ•°ï¼šuser_tier
    counter.add(1, &[KeyValue::new("user_tier", "premium")]);
}

use opentelemetry::KeyValue;
```

### Q3: æ—¥å¿—æ²¡æœ‰å‘é€åˆ°Elasticsearch

**ç—‡çŠ¶**:

- åº”ç”¨äº§ç”Ÿæ—¥å¿—
- Kibanaä¸­çœ‹ä¸åˆ°æ—¥å¿—

**è§£å†³æ–¹æ¡ˆ**:

```rust
// æ£€æŸ¥1: LoggerProvideræ˜¯å¦æ­£ç¡®é…ç½®ï¼Ÿ
use opentelemetry_sdk::logs::{LoggerProvider, Config};

fn check_logger_config() -> Result<LoggerProvider, Box<dyn std::error::Error>> {
    let exporter = opentelemetry_otlp::LogExporter::builder()
        .with_tonic()
        .with_endpoint("http://localhost:4317")
        .build()?;

    let provider = LoggerProvider::builder()
        .with_batch_exporter(exporter, opentelemetry_sdk::runtime::Tokio)
        .with_config(Config::default())
        .build();

    Ok(provider)
}

// æ£€æŸ¥2: tracing-subscriberæ˜¯å¦æ­£ç¡®é›†æˆï¼Ÿ
use tracing_subscriber::{layer::SubscriberExt, Registry};
use tracing_opentelemetry::OpenTelemetryLayer;

fn setup_tracing_correctly(tracer_provider: &opentelemetry_sdk::trace::TracerProvider) {
    let telemetry_layer = OpenTelemetryLayer::new(tracer_provider.tracer("app"));

    let subscriber = Registry::default()
        .with(telemetry_layer)
        .with(tracing_subscriber::fmt::layer())
        .with(tracing_subscriber::EnvFilter::from_default_env());

    tracing::subscriber::set_global_default(subscriber)
        .expect("Failed to set subscriber");
}
```

### Q4: æ€§èƒ½ä¸¥é‡ä¸‹é™

**ç—‡çŠ¶**:

- æ·»åŠ OTLPåæ€§èƒ½æ˜æ˜¾ä¸‹é™
- CPUä½¿ç”¨ç‡å‡é«˜
- å»¶è¿Ÿå¢åŠ 

**è§£å†³æ–¹æ¡ˆ**:

```rust
// ä¼˜åŒ–1: è°ƒæ•´é‡‡æ ·ç‡
use opentelemetry_sdk::trace::Sampler;

fn use_appropriate_sampling() -> Sampler {
    // å¼€å‘ç¯å¢ƒï¼š100%é‡‡æ ·
    #[cfg(debug_assertions)]
    return Sampler::AlwaysOn;

    // ç”Ÿäº§ç¯å¢ƒï¼š10%é‡‡æ ·
    #[cfg(not(debug_assertions))]
    return Sampler::ParentBased(Box::new(
        Sampler::TraceIdRatioBased(0.1)
    ));
}

// ä¼˜åŒ–2: æ‰¹å¤„ç†é…ç½®
use opentelemetry_sdk::trace::BatchConfig;

fn optimize_batching() -> BatchConfig {
    BatchConfig::default()
        .with_max_queue_size(4096)          // å¢å¤§é˜Ÿåˆ—
        .with_max_export_batch_size(512)    // æ‰¹é‡å¯¼å‡º
        .with_scheduled_delay(Duration::from_millis(200))  // åˆç†å»¶è¿Ÿ
        .with_max_concurrent_exports(4)     // å¹¶å‘å¯¼å‡º
}

// ä¼˜åŒ–3: å¼‚æ­¥å¯¼å‡º
use opentelemetry_sdk::trace::TracerProvider;

fn use_async_export() -> Result<TracerProvider, Box<dyn std::error::Error>> {
    let exporter = opentelemetry_otlp::SpanExporter::builder()
        .with_tonic()
        .build()?;

    // âœ… ä½¿ç”¨æ‰¹é‡å¼‚æ­¥å¯¼å‡º
    let provider = TracerProvider::builder()
        .with_batch_exporter(exporter, opentelemetry_sdk::runtime::Tokio)
        .build();

    Ok(provider)
}
```

### Q5: Contextä¼ æ’­å¤±è´¥

**ç—‡çŠ¶**:

- è·¨æœåŠ¡è°ƒç”¨æ—¶traceæ–­å¼€
- æ–°çš„trace IDç”Ÿæˆ

**è§£å†³æ–¹æ¡ˆ**:

```rust
// æ£€æŸ¥1: æ˜¯å¦æ­£ç¡®æ³¨å…¥contextï¼Ÿ
use opentelemetry::propagation::{Injector, TextMapPropagator};
use opentelemetry_sdk::propagation::TraceContextPropagator;

fn inject_context_correctly(cx: &opentelemetry::Context) -> reqwest::header::HeaderMap {
    let mut headers = reqwest::header::HeaderMap::new();

    struct HeaderInjector<'a>(&'a mut reqwest::header::HeaderMap);
    impl<'a> Injector for HeaderInjector<'a> {
        fn set(&mut self, key: &str, value: String) {
            if let Ok(header_value) = reqwest::header::HeaderValue::from_str(&value) {
                if let Ok(header_name) = reqwest::header::HeaderName::from_bytes(key.as_bytes()) {
                    self.0.insert(header_name, header_value);
                }
            }
        }
    }

    let propagator = TraceContextPropagator::new();
    propagator.inject_context(cx, &mut HeaderInjector(&mut headers));

    headers
}

// æ£€æŸ¥2: æ˜¯å¦æ­£ç¡®æå–contextï¼Ÿ
use opentelemetry::propagation::Extractor;

fn extract_context_correctly(headers: &reqwest::header::HeaderMap) -> opentelemetry::Context {
    struct HeaderExtractor<'a>(&'a reqwest::header::HeaderMap);
    impl<'a> Extractor for HeaderExtractor<'a> {
        fn get(&self, key: &str) -> Option<&str> {
            self.0.get(key).and_then(|v| v.to_str().ok())
        }

        fn keys(&self) -> Vec<&str> {
            self.0.keys().map(|k| k.as_str()).collect()
        }
    }

    let propagator = TraceContextPropagator::new();
    propagator.extract(&HeaderExtractor(headers))
}

// æ£€æŸ¥3: å…¨å±€propagatoræ˜¯å¦è®¾ç½®ï¼Ÿ
use opentelemetry::global;

fn set_global_propagator() {
    global::set_text_map_propagator(TraceContextPropagator::new());
}
```

---

## Tracesæ•…éšœæ’æŸ¥

### è¯Šæ–­å·¥å…·

```rust
// src/diagnostics/traces.rs
use opentelemetry::{global, trace::{Tracer, Span}, KeyValue};

/// Traceè¯Šæ–­å·¥å…·
pub struct TraceDiagnostics;

impl TraceDiagnostics {
    /// æµ‹è¯•spanåˆ›å»º
    pub fn test_span_creation() {
        let tracer = global::tracer("diagnostics");
        
        let mut span = tracer.span_builder("test_span")
            .with_attributes(vec![
                KeyValue::new("test.key", "test_value"),
            ])
            .start(&tracer);

        span.add_event("test_event", vec![]);
        span.end();

        println!("âœ… Span created successfully");
    }

    /// æµ‹è¯•exportè¿æ¥
    pub async fn test_export_connection(endpoint: &str) -> Result<(), Box<dyn std::error::Error>> {
        use tonic::transport::Channel;

        let channel = Channel::from_shared(endpoint.to_string())?
            .connect()
            .await?;

        println!("âœ… Connected to OTLP endpoint: {}", endpoint);
        Ok(())
    }

    /// æ£€æŸ¥propagatoré…ç½®
    pub fn check_propagator() {
        use opentelemetry::propagation::TextMapPropagator;

        global::get_text_map_propagator(|propagator| {
            let fields = propagator.fields();
            println!("ğŸ“‹ Propagator fields: {:?}", fields);
        });
    }

    /// éªŒè¯é‡‡æ ·å†³ç­–
    pub fn test_sampling() {
        use opentelemetry::trace::{TraceId, SpanKind};
        use opentelemetry_sdk::trace::Sampler;

        let sampler = Sampler::TraceIdRatioBased(0.1);
        let trace_id = TraceId::from_u128(12345);

        let result = sampler.should_sample(
            None,
            trace_id,
            "test_span",
            &SpanKind::Internal,
            &[],
            &[],
        );

        println!("ğŸ“Š Sampling decision: {:?}", result.decision);
    }
}
```

### å¸¸è§é”™è¯¯åŠè§£å†³

```rust
/// é”™è¯¯1: "Failed to connect to OTLP endpoint"
pub fn fix_connection_error() {
    // æ£€æŸ¥äº‹é¡¹:
    // 1. OTLP Collectoræ˜¯å¦è¿è¡Œï¼Ÿ
    //    docker ps | grep otel-collector
    // 
    // 2. ç«¯å£æ˜¯å¦æ­£ç¡®ï¼Ÿ
    //    - gRPC: 4317
    //    - HTTP: 4318
    //
    // 3. ç½‘ç»œæ˜¯å¦å¯è¾¾ï¼Ÿ
    //    telnet localhost 4317
    //
    // 4. é˜²ç«å¢™æ˜¯å¦é˜»æ­¢ï¼Ÿ
    //    sudo iptables -L

    // è§£å†³æ–¹æ¡ˆï¼šä½¿ç”¨æ­£ç¡®çš„endpoint
    let correct_endpoint = "http://localhost:4317";  // æ³¨æ„httpå‰ç¼€
}

/// é”™è¯¯2: "Span export timeout"
pub fn fix_export_timeout() {
    use opentelemetry_otlp::WithExportConfig;
    use std::time::Duration;

    // å¢åŠ è¶…æ—¶æ—¶é—´
    let exporter = opentelemetry_otlp::SpanExporter::builder()
        .with_tonic()
        .with_timeout(Duration::from_secs(60))  // å¢åŠ åˆ°60ç§’
        .build()
        .expect("Failed to create exporter");
}

/// é”™è¯¯3: "Queue full, dropping spans"
pub fn fix_queue_full() {
    use opentelemetry_sdk::trace::BatchConfig;

    let config = BatchConfig::default()
        .with_max_queue_size(8192)  // å¢å¤§é˜Ÿåˆ—
        .with_max_export_batch_size(1024);  // å¢å¤§æ‰¹é‡å¤§å°
}
```

---

## Metricsæ•…éšœæ’æŸ¥

### è¯Šæ–­æ£€æŸ¥æ¸…å•

```rust
pub struct MetricsDiagnostics;

impl MetricsDiagnostics {
    /// æ£€æŸ¥æ¸…å•
    pub fn run_diagnostics() {
        println!("ğŸ“‹ Metrics Diagnostics Checklist:\n");

        // 1. Provideræ˜¯å¦åˆå§‹åŒ–ï¼Ÿ
        Self::check_provider();

        // 2. Instrumentsæ˜¯å¦æ­£ç¡®åˆ›å»ºï¼Ÿ
        Self::check_instruments();

        // 3. å¯¼å‡ºå™¨æ˜¯å¦é…ç½®ï¼Ÿ
        Self::check_exporter();

        // 4. æ•°æ®æ˜¯å¦æ­£ç¡®è®°å½•ï¼Ÿ
        Self::check_recording();
    }

    fn check_provider() {
        use opentelemetry::global;

        let meter = global::meter("diagnostics");
        println!("âœ… MeterProvider is initialized");
    }

    fn check_instruments() {
        use opentelemetry::global;

        let meter = global::meter("diagnostics");

        let counter = meter.u64_counter("test_counter").build();
        counter.add(1, &[]);

        println!("âœ… Instruments can be created and used");
    }

    fn check_exporter() {
        println!("â„¹ï¸  Check Prometheus endpoint: http://localhost:8889/metrics");
    }

    fn check_recording() {
        // è®°å½•æµ‹è¯•æ•°æ®
        use opentelemetry::{global, KeyValue};

        let meter = global::meter("diagnostics");
        let counter = meter.u64_counter("diagnostic_test").build();

        for i in 0..10 {
            counter.add(1, &[KeyValue::new("iteration", i as i64)]);
        }

        println!("âœ… Recorded 10 test data points");
        println!("â„¹ï¸  Wait for export interval and check Prometheus");
    }
}
```

---

## Logsæ•…éšœæ’æŸ¥

### æ—¥å¿—çº§åˆ«é…ç½®

```rust
// æ£€æŸ¥æ—¥å¿—çº§åˆ«é…ç½®
pub fn configure_log_levels() {
    use tracing_subscriber::EnvFilter;

    // æ–¹å¼1: é€šè¿‡ç¯å¢ƒå˜é‡
    // RUST_LOG=debug cargo run
    // RUST_LOG=info,opentelemetry=debug cargo run

    // æ–¹å¼2: ä»£ç é…ç½®
    let filter = EnvFilter::new("info")
        .add_directive("opentelemetry=debug".parse().unwrap())
        .add_directive("opentelemetry_otlp=debug".parse().unwrap());

    println!("ğŸ“‹ Log levels configured");
}

// è°ƒè¯•æ—¥å¿—å¯¼å‡º
pub async fn debug_log_export() {
    use opentelemetry::logs::{Logger, LoggerProvider as _, Severity};

    let provider = init_logger_for_debug().unwrap();
    let logger = provider.logger("debug");

    // å‘é€æµ‹è¯•æ—¥å¿—
    logger.emit(
        opentelemetry::logs::LogRecord::builder()
            .with_severity_number(Severity::Info)
            .with_body("Test log message".into())
            .build(),
    );

    // ç­‰å¾…å¯¼å‡º
    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;

    provider.shutdown().unwrap();

    println!("âœ… Test log sent");
}

use opentelemetry_sdk::logs::LoggerProvider;

fn init_logger_for_debug() -> Result<LoggerProvider, Box<dyn std::error::Error>> {
    // å®ç°æ—¥å¿—åˆå§‹åŒ–
    todo!()
}
```

---

## æ€§èƒ½é—®é¢˜è¯Šæ–­

### æ€§èƒ½åˆ†æå·¥å…·

```rust
// src/diagnostics/performance.rs
use std::time::{Duration, Instant};

pub struct PerformanceDiagnostics;

impl PerformanceDiagnostics {
    /// æµ‹é‡spanåˆ›å»ºå¼€é”€
    pub fn measure_span_creation_overhead() {
        use opentelemetry::{global, trace::Tracer};

        let tracer = global::tracer("perf_test");
        let iterations = 10_000;

        // æµ‹é‡baselineï¼ˆæ— spanï¼‰
        let baseline_start = Instant::now();
        for _ in 0..iterations {
            Self::do_work();
        }
        let baseline_duration = baseline_start.elapsed();

        // æµ‹é‡with span
        let traced_start = Instant::now();
        for i in 0..iterations {
            let mut span = tracer.span_builder(format!("work-{}", i)).start(&tracer);
            Self::do_work();
            span.end();
        }
        let traced_duration = traced_start.elapsed();

        // è®¡ç®—å¼€é”€
        let overhead = traced_duration - baseline_duration;
        let overhead_percent = (overhead.as_nanos() as f64 / baseline_duration.as_nanos() as f64) * 100.0;

        println!("\nğŸ“Š Performance Analysis:");
        println!("Iterations:        {}", iterations);
        println!("Baseline:          {:?}", baseline_duration);
        println!("With tracing:      {:?}", traced_duration);
        println!("Overhead:          {:?} ({:.2}%)", overhead, overhead_percent);
    }

    fn do_work() {
        let mut sum = 0u64;
        for i in 0..100 {
            sum = sum.wrapping_add(i);
        }
        std::hint::black_box(sum);
    }

    /// ç›‘æ§å¯¼å‡ºå»¶è¿Ÿ
    pub async fn monitor_export_latency() {
        use opentelemetry::{global, trace::Tracer};

        let tracer = global::tracer("latency_test");

        for i in 0..100 {
            let start = Instant::now();

            let mut span = tracer.span_builder(format!("test-{}", i)).start(&tracer);
            span.end();

            // æ³¨æ„ï¼šè¿™ä¸æ˜¯çœŸå®çš„exportå»¶è¿Ÿï¼Œåªæ˜¯spanç»“æŸçš„å»¶è¿Ÿ
            let elapsed = start.elapsed();

            if elapsed > Duration::from_millis(10) {
                println!("âš ï¸  High latency detected: {:?}", elapsed);
            }
        }
    }
}
```

### æ€§èƒ½ä¼˜åŒ–å»ºè®®

```rust
pub const PERFORMANCE_OPTIMIZATION_TIPS: &[&str] = &[
    "1. ä½¿ç”¨åˆç†çš„é‡‡æ ·ç‡ï¼ˆç”Ÿäº§ç¯å¢ƒ1-10%ï¼‰",
    "2. æ‰¹é‡å¯¼å‡ºè€ŒéåŒæ­¥å¯¼å‡º",
    "3. è°ƒæ•´æ‰¹å¤„ç†å‚æ•°ï¼ˆbatch_size, schedule_delayï¼‰",
    "4. é¿å…é«˜åŸºæ•°æ ‡ç­¾",
    "5. å¤ç”¨Tracer/Meterå®ä¾‹",
    "6. ä½¿ç”¨å¼‚æ­¥å¯¼å‡º",
    "7. è®¾ç½®åˆç†çš„é˜Ÿåˆ—å¤§å°",
    "8. ç›‘æ§é˜Ÿåˆ—ä½¿ç”¨æƒ…å†µ",
    "9. ä½¿ç”¨è¿æ¥æ± ",
    "10. å®šæœŸæ€§èƒ½æµ‹è¯•",
];
```

---

## å®‰å…¨é—®é¢˜è¯Šæ–­

### TLSé…ç½®

```rust
// å¯ç”¨TLSè¿æ¥åˆ°OTLP Collector
pub fn configure_tls() -> Result<(), Box<dyn std::error::Error>> {
    use opentelemetry_otlp::{WithExportConfig, WithTonicConfig};
    use tonic::transport::ClientTlsConfig;

    let tls_config = ClientTlsConfig::new()
        .ca_certificate(tonic::transport::Certificate::from_pem(
            std::fs::read("ca.pem")?
        ))
        .domain_name("otel-collector.example.com");

    let exporter = opentelemetry_otlp::SpanExporter::builder()
        .with_tonic()
        .with_endpoint("https://otel-collector.example.com:4317")
        .with_tls_config(tls_config)
        .build()?;

    println!("âœ… TLS configured");
    Ok(())
}

// æ·»åŠ è®¤è¯headers
pub fn configure_auth() -> Result<(), Box<dyn std::error::Error>> {
    use opentelemetry_otlp::WithExportConfig;
    use tonic::metadata::MetadataMap;

    let mut metadata = MetadataMap::new();
    metadata.insert("authorization", "Bearer YOUR_TOKEN".parse()?);

    let exporter = opentelemetry_otlp::SpanExporter::builder()
        .with_tonic()
        .with_endpoint("http://otel-collector:4317")
        .with_metadata(metadata)
        .build()?;

    println!("âœ… Authentication configured");
    Ok(())
}
```

---

## è°ƒè¯•æŠ€å·§

### 1. å¯ç”¨è¯¦ç»†æ—¥å¿—

```bash
# å¯ç”¨OpenTelemetry debugæ—¥å¿—
RUST_LOG=opentelemetry=debug,opentelemetry_otlp=debug cargo run

# æŸ¥çœ‹æ‰€æœ‰ç»„ä»¶çš„æ—¥å¿—
RUST_LOG=debug cargo run

# åªæŸ¥çœ‹ç‰¹å®šæ¨¡å—
RUST_LOG=my_app=debug,opentelemetry=info cargo run
```

### 2. ä½¿ç”¨Debug Exporter

```rust
// ä½¿ç”¨stdout exporterè¿›è¡Œè°ƒè¯•
use opentelemetry_sdk::trace::{TracerProvider, Config};
use opentelemetry_stdout::SpanExporter;

pub fn debug_with_stdout() -> Result<TracerProvider, Box<dyn std::error::Error>> {
    let exporter = SpanExporter::default();

    let provider = TracerProvider::builder()
        .with_simple_exporter(exporter)
        .build();

    println!("âœ… Debug exporter configured (stdout)");
    Ok(provider)
}
```

### 3. æ£€æŸ¥CollectorçŠ¶æ€

```bash
# æ£€æŸ¥Collectorå¥åº·çŠ¶æ€
curl http://localhost:13133

# æŸ¥çœ‹Collector metrics
curl http://localhost:8888/metrics

# æŸ¥çœ‹æ¥æ”¶åˆ°çš„spansæ•°é‡
curl http://localhost:8888/metrics | grep otelcol_receiver_accepted_spans

# æŸ¥çœ‹å¯¼å‡ºçš„spansæ•°é‡
curl http://localhost:8888/metrics | grep otelcol_exporter_sent_spans
```

### 4. éªŒè¯æ•°æ®æµ

```rust
// ç«¯åˆ°ç«¯éªŒè¯å·¥å…·
pub async fn verify_end_to_end() -> Result<(), Box<dyn std::error::Error>> {
    println!("ğŸ” Starting end-to-end verification...\n");

    // 1. åˆ›å»ºspan
    use opentelemetry::{global, trace::Tracer, KeyValue};
    let tracer = global::tracer("verification");
    let mut span = tracer.span_builder("test_span")
        .with_attributes(vec![
            KeyValue::new("test", "verification"),
        ])
        .start(&tracer);
    span.end();
    println!("âœ… Step 1: Span created");

    // 2. ç­‰å¾…æ‰¹å¤„ç†
    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
    println!("âœ… Step 2: Waited for batch export");

    // 3. æ£€æŸ¥Collector
    let collector_health = reqwest::get("http://localhost:13133").await?;
    if collector_health.status().is_success() {
        println!("âœ… Step 3: Collector is healthy");
    } else {
        println!("âŒ Step 3: Collector not responding");
        return Err("Collector unhealthy".into());
    }

    // 4. æ£€æŸ¥Jaeger
    let jaeger_health = reqwest::get("http://localhost:16686").await?;
    if jaeger_health.status().is_success() {
        println!("âœ… Step 4: Jaeger is accessible");
    } else {
        println!("âš ï¸  Step 4: Jaeger not accessible");
    }

    println!("\nğŸ‰ Verification complete! Check Jaeger UI for the test span.");
    Ok(())
}
```

---

## ç¤¾åŒºèµ„æº

### å®˜æ–¹èµ„æº

```text
ğŸ“š Documentation:
- OpenTelemetry Docs: https://opentelemetry.io/docs/
- Rust SDK: https://github.com/open-telemetry/opentelemetry-rust
- OTLP Specification: https://opentelemetry.io/docs/specs/otlp/

ğŸ’¬ Community:
- CNCF Slack: https://slack.cncf.io/ (#opentelemetry, #otel-rust)
- GitHub Discussions: https://github.com/open-telemetry/opentelemetry-rust/discussions
- Stack Overflow: [opentelemetry] tag

ğŸ› Issue Tracking:
- Rust SDK Issues: https://github.com/open-telemetry/opentelemetry-rust/issues
- Collector Issues: https://github.com/open-telemetry/opentelemetry-collector/issues
```

### æœ‰ç”¨çš„å·¥å…·

```text
ğŸ› ï¸ Debugging Tools:
- otel-cli: Command-line tool for sending test data
- tracegen: Generate test traces
- telemetrygen: Generate test telemetry data

ğŸ“Š Monitoring:
- Jaeger: Trace visualization
- Prometheus: Metrics collection
- Grafana: Unified dashboards

ğŸ” Analysis:
- pprof: Performance profiling
- flamegraph: Performance visualization
- tokio-console: Async runtime inspection
```

### æœ€ä½³å®è·µæ£€æŸ¥æ¸…å•

```rust
pub const TROUBLESHOOTING_CHECKLIST: &[(&str, &[&str])] = &[
    ("é…ç½®æ£€æŸ¥", &[
        "OTLP endpointæ­£ç¡®ï¼Ÿ",
        "ç«¯å£å·æ­£ç¡®ï¼Ÿ(gRPC: 4317, HTTP: 4318)",
        "TLSé…ç½®æ­£ç¡®ï¼Ÿ",
        "è®¤è¯ä¿¡æ¯æ­£ç¡®ï¼Ÿ",
    ]),
    ("è¿æ¥æ£€æŸ¥", &[
        "Collectoræ˜¯å¦è¿è¡Œï¼Ÿ",
        "ç½‘ç»œæ˜¯å¦å¯è¾¾ï¼Ÿ",
        "é˜²ç«å¢™æ˜¯å¦å…è®¸ï¼Ÿ",
        "DNSè§£ææ˜¯å¦æ­£å¸¸ï¼Ÿ",
    ]),
    ("ä»£ç æ£€æŸ¥", &[
        "Provideræ˜¯å¦åˆå§‹åŒ–ï¼Ÿ",
        "æ˜¯å¦è°ƒç”¨shutdownï¼Ÿ",
        "é‡‡æ ·å™¨é…ç½®æ˜¯å¦æ­£ç¡®ï¼Ÿ",
        "æ‰¹å¤„ç†é…ç½®æ˜¯å¦åˆç†ï¼Ÿ",
    ]),
    ("æ€§èƒ½æ£€æŸ¥", &[
        "é‡‡æ ·ç‡æ˜¯å¦åˆç†ï¼Ÿ",
        "é˜Ÿåˆ—æ˜¯å¦æº¢å‡ºï¼Ÿ",
        "å¯¼å‡ºæ˜¯å¦è¶…æ—¶ï¼Ÿ",
        "CPU/å†…å­˜ä½¿ç”¨æ˜¯å¦æ­£å¸¸ï¼Ÿ",
    ]),
    ("æ•°æ®éªŒè¯", &[
        "Collectoræ˜¯å¦æ¥æ”¶åˆ°æ•°æ®ï¼Ÿ",
        "åç«¯æ˜¯å¦æ”¶åˆ°æ•°æ®ï¼Ÿ",
        "æ•°æ®æ ¼å¼æ˜¯å¦æ­£ç¡®ï¼Ÿ",
        "æ ‡ç­¾æ˜¯å¦æ­£ç¡®ï¼Ÿ",
    ]),
];
```

---

## æ€»ç»“

### å¿«é€Ÿæ’æŸ¥æŒ‡å—

```text
é—®é¢˜ç±»å‹ â†’ é¦–å…ˆæ£€æŸ¥ â†’ ç„¶åæ£€æŸ¥ â†’ æœ€åæ£€æŸ¥
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
æ— Traces  â†’ Provideråˆå§‹åŒ– â†’ Collectorè¿æ¥ â†’ é‡‡æ ·é…ç½®
æ— Metrics â†’ Readeré…ç½® â†’ å¯¼å‡ºé—´éš” â†’ æ ‡ç­¾åŸºæ•°
æ— Logs    â†’ LoggerProvider â†’ tracingé›†æˆ â†’ æ—¥å¿—çº§åˆ«
æ€§èƒ½å·®    â†’ é‡‡æ ·ç‡ â†’ æ‰¹å¤„ç†é…ç½® â†’ é˜Ÿåˆ—å¤§å°
Contextæ–­ â†’ Propagatorè®¾ç½® â†’ æ³¨å…¥/æå–é€»è¾‘ â†’ Headerä¼ é€’
```

### è·å–å¸®åŠ©

å½“é‡åˆ°æ— æ³•è§£å†³çš„é—®é¢˜æ—¶ï¼š

1. **æŸ¥çœ‹æ—¥å¿—**: å¯ç”¨debugæ—¥å¿—
2. **æ£€æŸ¥Collector**: æŸ¥çœ‹Collectoræ—¥å¿—å’Œmetrics
3. **æœç´¢Issues**: GitHubä¸Šå¯èƒ½æœ‰ç±»ä¼¼é—®é¢˜
4. **è¯¢é—®ç¤¾åŒº**: CNCF Slack #otel-rusté¢‘é“
5. **æäº¤Issue**: æä¾›å®Œæ•´çš„å¤ç°æ­¥éª¤å’Œæ—¥å¿—

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ8æ—¥  
**çŠ¶æ€**: âœ… å®Œæˆ  
**é¢„è®¡è¡Œæ•°**: 2,100+ è¡Œ

---

**#OTLP #Rust #Troubleshooting #Debugging #FAQ #Diagnostics #Performance**-
