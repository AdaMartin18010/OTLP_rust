# Â§öËØ≠Ë®ÄSDKÂçèÂêåÊúÄ‰Ω≥ÂÆûË∑µ

> **ÊñáÊ°£ÁâàÊú¨**: v1.0  
> **ÊúÄÂêéÊõ¥Êñ∞**: 2025Âπ¥10Êúà8Êó•  
> **RustÁâàÊú¨**: 1.90+  
> **OpenTelemetryÁâàÊú¨**: 0.31.0+

---

## üìã ÁõÆÂΩï

- [Â§öËØ≠Ë®ÄSDKÂçèÂêåÊúÄ‰Ω≥ÂÆûË∑µ](#Â§öËØ≠Ë®ÄsdkÂçèÂêåÊúÄ‰Ω≥ÂÆûË∑µ)
  - [üìã ÁõÆÂΩï](#-ÁõÆÂΩï)
  - [Ê¶ÇËø∞](#Ê¶ÇËø∞)
    - [Â§öËØ≠Ë®ÄÂæÆÊúçÂä°Êû∂ÊûÑÊåëÊàò](#Â§öËØ≠Ë®ÄÂæÆÊúçÂä°Êû∂ÊûÑÊåëÊàò)
    - [Ê†∏ÂøÉÂçèÂêåÁõÆÊ†á](#Ê†∏ÂøÉÂçèÂêåÁõÆÊ†á)
  - [Áªü‰∏ÄÈÖçÁΩÆÊ†áÂáÜ](#Áªü‰∏ÄÈÖçÁΩÆÊ†áÂáÜ)
    - [ÁéØÂ¢ÉÂèòÈáèÊ†áÂáÜÂåñ](#ÁéØÂ¢ÉÂèòÈáèÊ†áÂáÜÂåñ)
    - [RustÂÆûÁé∞ÔºöËØªÂèñÊ†áÂáÜÁéØÂ¢ÉÂèòÈáè](#rustÂÆûÁé∞ËØªÂèñÊ†áÂáÜÁéØÂ¢ÉÂèòÈáè)
    - [ÈÖçÁΩÆÊñá‰ª∂Ê†áÂáÜÂåñ](#ÈÖçÁΩÆÊñá‰ª∂Ê†áÂáÜÂåñ)
  - [ResourceÂ±ûÊÄßËßÑËåÉ](#resourceÂ±ûÊÄßËßÑËåÉ)
    - [Ê†áÂáÜResourceÂ±ûÊÄß](#Ê†áÂáÜresourceÂ±ûÊÄß)
    - [Ë∑®ËØ≠Ë®ÄResourceÂ±ûÊÄßÂØπÁÖß](#Ë∑®ËØ≠Ë®ÄresourceÂ±ûÊÄßÂØπÁÖß)
    - [KubernetesÁéØÂ¢ÉResourceËá™Âä®ÂèëÁé∞](#kubernetesÁéØÂ¢ÉresourceËá™Âä®ÂèëÁé∞)
  - [ÈááÊ†∑Á≠ñÁï•ÂçèË∞É](#ÈááÊ†∑Á≠ñÁï•ÂçèË∞É)
    - [ÈááÊ†∑ÂÜ≥Á≠ñ‰º†Êí≠](#ÈááÊ†∑ÂÜ≥Á≠ñ‰º†Êí≠)
    - [RustÂÆûÁé∞ÔºöParentBased Sampler](#rustÂÆûÁé∞parentbased-sampler)
    - [Â§öËØ≠Ë®ÄÈááÊ†∑Á≠ñÁï•ÂØπÁÖß](#Â§öËØ≠Ë®ÄÈááÊ†∑Á≠ñÁï•ÂØπÁÖß)
    - [Ëá™ÂÆö‰πâÈááÊ†∑Á≠ñÁï•ÂçèË∞É](#Ëá™ÂÆö‰πâÈááÊ†∑Á≠ñÁï•ÂçèË∞É)
  - [Êï∞ÊçÆ‰∏ÄËá¥ÊÄß‰øùËØÅ](#Êï∞ÊçÆ‰∏ÄËá¥ÊÄß‰øùËØÅ)
    - [Êó∂Èó¥Êà≥Á≤æÂ∫¶Áªü‰∏Ä](#Êó∂Èó¥Êà≥Á≤æÂ∫¶Áªü‰∏Ä)
    - [Span IDÂíåTrace IDÊ†ºÂºè](#span-idÂíåtrace-idÊ†ºÂºè)
    - [Span Status‰∏ÄËá¥ÊÄß](#span-status‰∏ÄËá¥ÊÄß)
  - [ÊÄßËÉΩ‰ºòÂåñÂçèË∞É](#ÊÄßËÉΩ‰ºòÂåñÂçèË∞É)
    - [ÊâπÈáèÂØºÂá∫ÈÖçÁΩÆÁªü‰∏Ä](#ÊâπÈáèÂØºÂá∫ÈÖçÁΩÆÁªü‰∏Ä)
    - [Âü∫Êï∞ÊéßÂà∂Á≠ñÁï•](#Âü∫Êï∞ÊéßÂà∂Á≠ñÁï•)
  - [ÁâàÊú¨ÂÖºÂÆπÊÄß](#ÁâàÊú¨ÂÖºÂÆπÊÄß)
    - [OpenTelemetryÂçèËÆÆÁâàÊú¨](#opentelemetryÂçèËÆÆÁâàÊú¨)
    - [SDKÁâàÊú¨Êé®Ëçê](#sdkÁâàÊú¨Êé®Ëçê)
  - [ÂÆåÊï¥ÈõÜÊàêÊ°à‰æã](#ÂÆåÊï¥ÈõÜÊàêÊ°à‰æã)
    - [Ê°à‰æãÔºöÁîµÂïÜÂæÆÊúçÂä°Êû∂ÊûÑ](#Ê°à‰æãÁîµÂïÜÂæÆÊúçÂä°Êû∂ÊûÑ)
    - [Rust API GatewayÂÆûÁé∞](#rust-api-gatewayÂÆûÁé∞)
    - [Docker ComposeÈÖçÁΩÆ](#docker-composeÈÖçÁΩÆ)
  - [ÊÄªÁªì](#ÊÄªÁªì)
    - [Ê†∏ÂøÉÊúÄ‰Ω≥ÂÆûË∑µ](#Ê†∏ÂøÉÊúÄ‰Ω≥ÂÆûË∑µ)
    - [Ê£ÄÊü•Ê∏ÖÂçï](#Ê£ÄÊü•Ê∏ÖÂçï)

---

## Ê¶ÇËø∞

### Â§öËØ≠Ë®ÄÂæÆÊúçÂä°Êû∂ÊûÑÊåëÊàò

Âú®Áé∞‰ª£ÂæÆÊúçÂä°Êû∂ÊûÑ‰∏≠Ôºå‰∏çÂêåÊúçÂä°ÂèØËÉΩ‰ΩøÁî®‰∏çÂêåÁºñÁ®ãËØ≠Ë®ÄÂÆûÁé∞Ôºö

```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 ÂæÆÊúçÂä°Êû∂ÊûÑÁ§∫‰æã                          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  API Gateway (Rust/Axum)                               ‚îÇ
‚îÇ         ‚Üì                                               ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ
‚îÇ  ‚îÇ User Service ‚îÇ Order Service‚îÇ Payment Svc  ‚îÇ       ‚îÇ
‚îÇ  ‚îÇ   (Go)       ‚îÇ   (Java)     ‚îÇ  (Python)    ‚îÇ       ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ
‚îÇ         ‚Üì              ‚Üì              ‚Üì                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ
‚îÇ  ‚îÇ   Redis      ‚îÇ  PostgreSQL  ‚îÇ   Kafka      ‚îÇ       ‚îÇ
‚îÇ  ‚îÇ  (Rust lib)  ‚îÇ (Java JDBC)  ‚îÇ (Python lib) ‚îÇ       ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ
‚îÇ         ‚Üì                                               ‚îÇ
‚îÇ  ML Inference Service (Node.js)                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Ê†∏ÂøÉÂçèÂêåÁõÆÊ†á

```text
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë          Â§öËØ≠Ë®ÄSDKÂçèÂêåÊ†∏ÂøÉÁõÆÊ†á                        ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  1. Áªü‰∏ÄÁöÑTrace Context‰º†Êí≠                           ‚ïë
‚ïë  2. ‰∏ÄËá¥ÁöÑResourceÂ±ûÊÄßÂëΩÂêç                            ‚ïë
‚ïë  3. ÂçèË∞ÉÁöÑÈááÊ†∑Á≠ñÁï•                                    ‚ïë
‚ïë  4. Áªü‰∏ÄÁöÑSemantic Conventions                        ‚ïë
‚ïë  5. ÂÖºÂÆπÁöÑÊï∞ÊçÆÊ†ºÂºè                                    ‚ïë
‚ïë  6. ‰∏ÄËá¥ÁöÑÊó∂Èó¥Êà≥Á≤æÂ∫¶                                  ‚ïë
‚ïë  7. Áªü‰∏ÄÁöÑÈîôËØØÂ§ÑÁêÜ                                    ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
```

---

## Áªü‰∏ÄÈÖçÁΩÆÊ†áÂáÜ

### ÁéØÂ¢ÉÂèòÈáèÊ†áÂáÜÂåñ

OpenTelemetryÂÆö‰πâ‰∫Ü‰∏ÄÂ•óÊ†áÂáÜÁéØÂ¢ÉÂèòÈáèÔºåÊâÄÊúâËØ≠Ë®ÄSDKÈÉΩÊîØÊåÅÔºö

```bash
# OTLP ExporterÈÖçÁΩÆ
export OTEL_EXPORTER_OTLP_ENDPOINT="http://localhost:4317"
export OTEL_EXPORTER_OTLP_PROTOCOL="grpc"  # Êàñ "http/protobuf"
export OTEL_EXPORTER_OTLP_TIMEOUT="10000"  # ÊØ´Áßí
export OTEL_EXPORTER_OTLP_HEADERS="api-key=secret"

# ServiceÈÖçÁΩÆ
export OTEL_SERVICE_NAME="my-service"
export OTEL_RESOURCE_ATTRIBUTES="deployment.environment=production,service.version=1.2.3"

# ÈááÊ†∑ÈÖçÁΩÆ
export OTEL_TRACES_SAMPLER="parentbased_traceidratio"
export OTEL_TRACES_SAMPLER_ARG="0.1"  # 10%ÈááÊ†∑Áéá

# PropagatorÈÖçÁΩÆ
export OTEL_PROPAGATORS="tracecontext,baggage"

# Êó•ÂøóÁ∫ßÂà´
export OTEL_LOG_LEVEL="info"
```

### RustÂÆûÁé∞ÔºöËØªÂèñÊ†áÂáÜÁéØÂ¢ÉÂèòÈáè

```rust
use opentelemetry::{global, KeyValue};
use opentelemetry_sdk::{
    propagation::{BaggagePropagator, TextMapCompositePropagator, TraceContextPropagator},
    trace::{Config, Sampler, TracerProvider},
    Resource,
};
use opentelemetry_otlp::WithExportConfig;
use std::time::Duration;

/// ‰ªéÁéØÂ¢ÉÂèòÈáèÂàùÂßãÂåñOpenTelemetryÔºàÈÅµÂæ™Ê†áÂáÜÔºâ
pub fn init_from_env() -> Result<TracerProvider, Box<dyn std::error::Error>> {
    // 1. ËØªÂèñOTEL_EXPORTER_OTLP_ENDPOINT
    let endpoint = std::env::var("OTEL_EXPORTER_OTLP_ENDPOINT")
        .unwrap_or_else(|_| "http://localhost:4317".to_string());
    
    // 2. ËØªÂèñOTEL_EXPORTER_OTLP_TIMEOUT
    let timeout_ms: u64 = std::env::var("OTEL_EXPORTER_OTLP_TIMEOUT")
        .unwrap_or_else(|_| "10000".to_string())
        .parse()?;
    
    // 3. ËØªÂèñOTEL_SERVICE_NAME
    let service_name = std:env::var("OTEL_SERVICE_NAME")
        .unwrap_or_else(|_| "unknown_service".to_string());
    
    // 4. ËØªÂèñOTEL_RESOURCE_ATTRIBUTES
    let mut resource_attrs = vec![
        KeyValue::new("service.name", service_name.clone()),
    ];
    
    if let Ok(attrs_str) = std::env::var("OTEL_RESOURCE_ATTRIBUTES") {
        for attr in attrs_str.split(',') {
            let parts: Vec<&str> = attr.split('=').collect();
            if parts.len() == 2 {
                resource_attrs.push(KeyValue::new(parts[0].to_string(), parts[1].to_string()));
            }
        }
    }
    
    let resource = Resource::new(resource_attrs);
    
    // 5. ÈÖçÁΩÆPropagator
    let propagators_str = std::env::var("OTEL_PROPAGATORS")
        .unwrap_or_else(|_| "tracecontext,baggage".to_string());
    
    let mut propagators: Vec<Box<dyn opentelemetry::propagation::TextMapPropagator + Send + Sync>> = vec![];
    
    for prop in propagators_str.split(',') {
        match prop.trim() {
            "tracecontext" => propagators.push(Box::new(TraceContextPropagator::new())),
            "baggage" => propagators.push(Box::new(BaggagePropagator::new())),
            _ => tracing::warn!("Unknown propagator: {}", prop),
        }
    }
    
    global::set_text_map_propagator(TextMapCompositePropagator::new(propagators));
    
    // 6. ÈÖçÁΩÆSampler
    let sampler = parse_sampler_from_env()?;
    
    // 7. ÂàõÂª∫Exporter
    let exporter = opentelemetry_otlp::SpanExporter::builder()
        .with_tonic()
        .with_endpoint(endpoint)
        .with_timeout(Duration::from_millis(timeout_ms))
        .build()?;
    
    // 8. ÂàõÂª∫TracerProvider
    let provider = TracerProvider::builder()
        .with_batch_exporter(exporter, opentelemetry_sdk::runtime::Tokio)
        .with_resource(resource)
        .with_config(Config::default().with_sampler(sampler))
        .build();
    
    global::set_tracer_provider(provider.clone());
    
    tracing::info!("‚úÖ OpenTelemetry initialized from environment variables");
    tracing::info!("   Service: {}", service_name);
    tracing::info!("   Endpoint: {}", endpoint);
    
    Ok(provider)
}

/// ‰ªéÁéØÂ¢ÉÂèòÈáèËß£ÊûêÈááÊ†∑Âô®
fn parse_sampler_from_env() -> Result<Sampler, Box<dyn std::error::Error>> {
    let sampler_type = std::env::var("OTEL_TRACES_SAMPLER")
        .unwrap_or_else(|_| "parentbased_always_on".to_string());
    
    match sampler_type.as_str() {
        "always_on" => Ok(Sampler::AlwaysOn),
        "always_off" => Ok(Sampler::AlwaysOff),
        "traceidratio" => {
            let ratio: f64 = std::env::var("OTEL_TRACES_SAMPLER_ARG")
                .unwrap_or_else(|_| "1.0".to_string())
                .parse()?;
            Ok(Sampler::TraceIdRatioBased(ratio))
        }
        "parentbased_always_on" => {
            Ok(Sampler::ParentBased(Box::new(Sampler::AlwaysOn)))
        }
        "parentbased_traceidratio" => {
            let ratio: f64 = std::env::var("OTEL_TRACES_SAMPLER_ARG")
                .unwrap_or_else(|_| "1.0".to_string())
                .parse()?;
            Ok(Sampler::ParentBased(Box::new(Sampler::TraceIdRatioBased(ratio))))
        }
        _ => {
            tracing::warn!("Unknown sampler: {}, using always_on", sampler_type);
            Ok(Sampler::AlwaysOn)
        }
    }
}
```

### ÈÖçÁΩÆÊñá‰ª∂Ê†áÂáÜÂåñ

**RustÊúçÂä°ÈÖçÁΩÆÔºàconfig.yamlÔºâ**:

```yaml
# config.yaml
opentelemetry:
  service_name: rust-api-gateway
  exporter:
    otlp:
      endpoint: http://otel-collector:4317
      protocol: grpc
      timeout: 10s
  resource:
    deployment.environment: production
    service.version: 1.2.3
    service.namespace: backend
  sampling:
    type: parentbased_traceidratio
    ratio: 0.1
  propagators:
    - tracecontext
    - baggage
```

**GoÊúçÂä°ÈÖçÁΩÆÔºàÂØπÂ∫îÁöÑconfig.yamlÔºâ**:

```yaml
# config.yaml (GoÊúçÂä°)
opentelemetry:
  service_name: go-user-service
  exporter:
    otlp:
      endpoint: http://otel-collector:4317
      protocol: grpc
      timeout: 10s
  resource:
    deployment.environment: production
    service.version: 2.5.0
    service.namespace: backend
  sampling:
    type: parentbased_traceidratio
    ratio: 0.1
  propagators:
    - tracecontext
    - baggage
```

**ÂÖ≥ÈîÆÁÇπ**ÔºöÈÖçÁΩÆÁªìÊûÑÂÆåÂÖ®‰∏ÄËá¥ÔºåÂè™Êúâ`service_name`Âíå`service.version`‰∏çÂêå„ÄÇ

---

## ResourceÂ±ûÊÄßËßÑËåÉ

### Ê†áÂáÜResourceÂ±ûÊÄß

ÊâÄÊúâÊúçÂä°Â∫î‰ΩøÁî®OpenTelemetryÂÆö‰πâÁöÑÊ†áÂáÜResourceÂ±ûÊÄßÔºö

```rust
use opentelemetry::{KeyValue};
use opentelemetry_sdk::Resource;

/// ÂàõÂª∫Ê†áÂáÜÂåñÁöÑResource
pub fn create_standard_resource(service_name: &str, service_version: &str) -> Resource {
    Resource::new(vec![
        // ÂøÖÈúÄÂ±ûÊÄß
        KeyValue::new("service.name", service_name.to_string()),
        KeyValue::new("service.version", service_version.to_string()),
        
        // Âº∫ÁÉàÊé®ËçêÂ±ûÊÄß
        KeyValue::new("deployment.environment", 
            std::env::var("ENV").unwrap_or_else(|_| "development".to_string())),
        KeyValue::new("service.namespace", "backend"),
        KeyValue::new("service.instance.id", uuid::Uuid::new_v4().to_string()),
        
        // ‰∏ªÊú∫‰ø°ÊÅØ
        KeyValue::new("host.name", 
            hostname::get().unwrap().to_string_lossy().to_string()),
        KeyValue::new("host.arch", std::env::consts::ARCH),
        KeyValue::new("os.type", std::env::consts::OS),
        
        // ËøõÁ®ã‰ø°ÊÅØ
        KeyValue::new("process.pid", std::process::id() as i64),
        KeyValue::new("process.runtime.name", "rust"),
        KeyValue::new("process.runtime.version", "1.90"),
        
        // Kubernetes (Â¶ÇÊûúËøêË°åÂú®K8s‰∏≠)
        KeyValue::new("k8s.namespace.name", 
            std::env::var("K8S_NAMESPACE").unwrap_or_default()),
        KeyValue::new("k8s.pod.name", 
            std::env::var("K8S_POD_NAME").unwrap_or_default()),
        KeyValue::new("k8s.deployment.name", 
            std::env::var("K8S_DEPLOYMENT_NAME").unwrap_or_default()),
        
        // ‰∫ëÂπ≥Âè∞ (AWSÁ§∫‰æã)
        KeyValue::new("cloud.provider", "aws"),
        KeyValue::new("cloud.region", 
            std::env::var("AWS_REGION").unwrap_or_default()),
        KeyValue::new("cloud.availability_zone", 
            std::env::var("AWS_AZ").unwrap_or_default()),
    ])
}
```

### Ë∑®ËØ≠Ë®ÄResourceÂ±ûÊÄßÂØπÁÖß

| Â±ûÊÄßÂêç | RustÁ§∫‰æã | GoÁ§∫‰æã | JavaÁ§∫‰æã | PythonÁ§∫‰æã |
|--------|----------|--------|----------|------------|
| `service.name` | "rust-gateway" | "go-user-service" | "java-order-service" | "python-ml-service" |
| `service.version` | env!("CARGO_PKG_VERSION") | version.Version | "1.0.0" | "2.3.1" |
| `deployment.environment` | "production" | "production" | "production" | "production" |
| `service.namespace` | "backend" | "backend" | "backend" | "ml" |
| `process.runtime.name` | "rust" | "go" | "java" | "python" |
| `process.runtime.version` | "1.90" | "1.22" | "17" | "3.11" |

### KubernetesÁéØÂ¢ÉResourceËá™Âä®ÂèëÁé∞

```rust
use opentelemetry_semantic_conventions as semcov;

/// ‰ªéKubernetesÁéØÂ¢ÉÂèòÈáèËá™Âä®ÂèëÁé∞ResourceÂ±ûÊÄß
pub fn create_k8s_resource(service_name: &str) -> Resource {
    let mut attrs = vec![
        KeyValue::new(semcov::resource::SERVICE_NAME, service_name.to_string()),
    ];
    
    // Kubernetes Downward APIÊ≥®ÂÖ•ÁöÑÁéØÂ¢ÉÂèòÈáè
    if let Ok(namespace) = std::env::var("K8S_NAMESPACE") {
        attrs.push(KeyValue::new(semcov::resource::K8S_NAMESPACE_NAME, namespace));
    }
    
    if let Ok(pod_name) = std::env::var("K8S_POD_NAME") {
        attrs.push(KeyValue::new(semcov::resource::K8S_POD_NAME, pod_name));
    }
    
    if let Ok(pod_uid) = std::env::var("K8S_POD_UID") {
        attrs.push(KeyValue::new(semcov::resource::K8S_POD_UID, pod_uid));
    }
    
    if let Ok(node_name) = std::env::var("K8S_NODE_NAME") {
        attrs.push(KeyValue::new(semcov::resource::K8S_NODE_NAME, node_name));
    }
    
    if let Ok(deployment) = std::env::var("K8S_DEPLOYMENT_NAME") {
        attrs.push(KeyValue::new("k8s.deployment.name", deployment));
    }
    
    Resource::new(attrs)
}
```

**ÂØπÂ∫îÁöÑK8s DeploymentÈÖçÁΩÆ**:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rust-gateway
spec:
  template:
    spec:
      containers:
      - name: rust-gateway
        env:
        - name: K8S_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: K8S_POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: K8S_POD_UID
          valueFrom:
            fieldRef:
              fieldPath: metadata.uid
        - name: K8S_NODE_NAME
          valueFrom:
            fieldRef:
              fieldPath: spec.nodeName
        - name: K8S_DEPLOYMENT_NAME
          value: "rust-gateway"
```

---

## ÈááÊ†∑Á≠ñÁï•ÂçèË∞É

### ÈááÊ†∑ÂÜ≥Á≠ñ‰º†Êí≠

ÂÖ≥ÈîÆÂéüÂàôÔºö**ÈááÊ†∑ÂÜ≥Á≠ñÂøÖÈ°ªÂú®ËØ∑Ê±ÇÈìæË∑ØÁöÑÁ¨¨‰∏Ä‰∏™ÊúçÂä°Ôºàroot spanÔºâÂÅöÂá∫ÔºåÂêéÁª≠ÊúçÂä°ÈÅµÂæ™ËØ•ÂÜ≥Á≠ñ**„ÄÇ

```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ          ÈááÊ†∑ÂÜ≥Á≠ñ‰º†Êí≠Á§∫‰æã                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  API Gateway (Rust)                                 ‚îÇ
‚îÇ    ‚Üì [ÈááÊ†∑ÂÜ≥Á≠ñ: YES, trace-flags=01]              ‚îÇ
‚îÇ  User Service (Go)                                  ‚îÇ
‚îÇ    ‚Üì [ÁªßÊâøÈááÊ†∑ÂÜ≥Á≠ñ: YES]                           ‚îÇ
‚îÇ  Order Service (Java)                               ‚îÇ
‚îÇ    ‚Üì [ÁªßÊâøÈááÊ†∑ÂÜ≥Á≠ñ: YES]                           ‚îÇ
‚îÇ  Payment Service (Python)                           ‚îÇ
‚îÇ    ‚Üì [ÁªßÊâøÈááÊ†∑ÂÜ≥Á≠ñ: YES]                           ‚îÇ
‚îÇ  ‚úÖ Êï¥‰∏™ÈìæË∑ØË¢´ÈááÊ†∑                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### RustÂÆûÁé∞ÔºöParentBased Sampler

```rust
use opentelemetry_sdk::trace::{Sampler, SamplerResult, Config};

/// Êé®ËçêÔºö‰ΩøÁî®ParentBased sampler
pub fn create_parent_based_sampler(root_ratio: f64) -> Sampler {
    // Ê†πspanÊåâratioÈááÊ†∑ÔºåÂ≠êspanÈÅµÂæ™Áà∂spanÂÜ≥Á≠ñ
    Sampler::ParentBased(Box::new(Sampler::TraceIdRatioBased(root_ratio)))
}

/// ÂàùÂßãÂåñTracerProvider with ParentBased sampler
pub fn init_with_parent_based_sampler(
    service_name: &str,
    sampling_ratio: f64,
) -> Result<TracerProvider, Box<dyn std::error::Error>> {
    let sampler = create_parent_based_sampler(sampling_ratio);
    
    let provider = TracerProvider::builder()
        .with_config(Config::default().with_sampler(sampler))
        .with_resource(Resource::new(vec![
            KeyValue::new("service.name", service_name.to_string()),
        ]))
        .build();
    
    global::set_tracer_provider(provider.clone());
    Ok(provider)
}
```

### Â§öËØ≠Ë®ÄÈááÊ†∑Á≠ñÁï•ÂØπÁÖß

**Rust (ParentBased + TraceIdRatio 10%)**:

```rust
Sampler::ParentBased(Box::new(Sampler::TraceIdRatioBased(0.1)))
```

**Go (Á≠â‰ª∑ÈÖçÁΩÆ)**:

```go
import (
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
)

sampler := sdktrace.ParentBased(sdktrace.TraceIDRatioBased(0.1))
```

**Java (Á≠â‰ª∑ÈÖçÁΩÆ)**:

```java
import io.opentelemetry.sdk.trace.samplers.Sampler;

Sampler sampler = Sampler.parentBased(Sampler.traceIdRatioBased(0.1));
```

**Python (Á≠â‰ª∑ÈÖçÁΩÆ)**:

```python
from opentelemetry.sdk.trace.sampling import ParentBased, TraceIdRatioBased

sampler = ParentBased(root=TraceIdRatioBased(0.1))
```

### Ëá™ÂÆö‰πâÈááÊ†∑Á≠ñÁï•ÂçèË∞É

```rust
use opentelemetry_sdk::trace::{Sampler, SamplerResult, ShouldSample};
use opentelemetry::trace::{SpanKind, TraceContextExt};

/// Ëá™ÂÆö‰πâÈááÊ†∑Âô®ÔºöÈîôËØØËØ∑Ê±Ç100%ÈááÊ†∑ÔºåÊ≠£Â∏∏ËØ∑Ê±Ç10%ÈááÊ†∑
pub struct ErrorAwareSampler {
    normal_ratio: f64,
}

impl ErrorAwareSampler {
    pub fn new(normal_ratio: f64) -> Self {
        Self { normal_ratio }
    }
}

impl ShouldSample for ErrorAwareSampler {
    fn should_sample(
        &self,
        parent_context: Option<&Context>,
        trace_id: opentelemetry::trace::TraceId,
        name: &str,
        span_kind: &SpanKind,
        attributes: &[KeyValue],
        links: &[opentelemetry::trace::Link],
    ) -> SamplerResult {
        // 1. Â¶ÇÊûúÊúâparentÔºåÈÅµÂæ™parentÁöÑÈááÊ†∑ÂÜ≥Á≠ñ
        if let Some(cx) = parent_context {
            if cx.span().span_context().is_sampled() {
                return SamplerResult {
                    decision: opentelemetry_sdk::trace::SamplingDecision::RecordAndSample,
                    attributes: vec![],
                    trace_state: cx.span().span_context().trace_state().clone(),
                };
            }
        }
        
        // 2. Ê£ÄÊü•ÊòØÂê¶ÊòØÈîôËØØspanÔºàÈÄöËøáÂ±ûÊÄßÂà§Êñ≠Ôºâ
        let is_error = attributes.iter().any(|kv| {
            kv.key.as_str() == "error" && kv.value.as_str() == "true"
        }) || name.contains("error") || name.contains("failed");
        
        if is_error {
            // ÈîôËØØËØ∑Ê±Ç100%ÈááÊ†∑
            return SamplerResult {
                decision: opentelemetry_sdk::trace::SamplingDecision::RecordAndSample,
                attributes: vec![KeyValue::new("sampling.reason", "error")],
                trace_state: Default::default(),
            };
        }
        
        // 3. Ê≠£Â∏∏ËØ∑Ê±ÇÊåâratioÈááÊ†∑
        let hash = trace_id.to_u128();
        let threshold = (u128::MAX as f64 * self.normal_ratio) as u128;
        
        if hash < threshold {
            SamplerResult {
                decision: opentelemetry_sdk::trace::SamplingDecision::RecordAndSample,
                attributes: vec![KeyValue::new("sampling.reason", "ratio")],
                trace_state: Default::default(),
            }
        } else {
            SamplerResult {
                decision: opentelemetry_sdk::trace::SamplingDecision::Drop,
                attributes: vec![],
                trace_state: Default::default(),
            }
        }
    }
}
```

---

## Êï∞ÊçÆ‰∏ÄËá¥ÊÄß‰øùËØÅ

### Êó∂Èó¥Êà≥Á≤æÂ∫¶Áªü‰∏Ä

ÊâÄÊúâOpenTelemetry SDK‰ΩøÁî®Á∫≥ÁßíÁ≤æÂ∫¶ÁöÑUnixÊó∂Èó¥Êà≥„ÄÇ

```rust
use std::time::{SystemTime, UNIX_EPOCH};

/// Ëé∑ÂèñÁ∫≥ÁßíÁ∫ßÊó∂Èó¥Êà≥Ôºà‰∏éÂÖ∂‰ªñËØ≠Ë®ÄSDK‰∏ÄËá¥Ôºâ
pub fn get_timestamp_nanos() -> u64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards")
        .as_nanos() as u64
}

/// Á§∫‰æãÔºöÊâãÂä®ËÆæÁΩÆspanÊó∂Èó¥
use opentelemetry::trace::{Tracer, Span};

pub fn create_span_with_custom_time() {
    let tracer = global::tracer("my-service");
    let start_time = SystemTime::now();
    
    let mut span = tracer
        .span_builder("custom_span")
        .with_start_time(start_time)
        .start(&tracer);
    
    // ... ‰∏öÂä°ÈÄªËæë
    
    let end_time = SystemTime::now();
    span.end_with_timestamp(end_time);
}
```

### Span IDÂíåTrace IDÊ†ºÂºè

```rust
/// Trace ID: 128‰Ωç (16Â≠óËäÇ)
/// Span ID: 64‰Ωç (8Â≠óËäÇ)

use opentelemetry::trace::{TraceId, SpanId};

pub fn validate_ids() {
    let trace_id = TraceId::from_hex("4bf92f3577b34da6a3ce929d0e0e4736").unwrap();
    let span_id = SpanId::from_hex("00f067aa0ba902b7").unwrap();
    
    println!("Trace ID length: {} bytes", trace_id.to_bytes().len()); // 16
    println!("Span ID length: {} bytes", span_id.to_bytes().len());   // 8
    
    // ÂçÅÂÖ≠ËøõÂà∂Ë°®Á§∫
    println!("Trace ID hex: {}", trace_id);  // 4bf92f3577b34da6a3ce929d0e0e4736
    println!("Span ID hex: {}", span_id);    // 00f067aa0ba902b7
}
```

### Span Status‰∏ÄËá¥ÊÄß

```rust
use opentelemetry::trace::{Status, StatusCode};

/// Ê≠£Á°ÆËÆæÁΩÆSpan StatusÔºà‰∏éÂÖ∂‰ªñËØ≠Ë®Ä‰∏ÄËá¥Ôºâ
pub fn set_span_status_correctly(span: &mut impl Span, error: Option<&str>) {
    match error {
        None => {
            // ÊàêÂäüÊÉÖÂÜµÔºö‰ΩøÁî®UnsetÊàñOk
            span.set_status(Status::Ok);
        }
        Some(err_msg) => {
            // ÈîôËØØÊÉÖÂÜµÔºö‰ΩøÁî®Error + ÈîôËØØ‰ø°ÊÅØ
            span.set_status(Status::error(err_msg.to_string()));
        }
    }
}

/// Á§∫‰æãÔºöHTTPËØ∑Ê±Çspan
pub async fn http_request_with_status() -> Result<(), Box<dyn std::error::Error>> {
    let tracer = global::tracer("http-client");
    let mut span = tracer.start("http_request");
    
    match reqwest::get("https://api.example.com/data").await {
        Ok(response) => {
            let status_code = response.status().as_u16();
            span.set_attribute(KeyValue::new("http.status_code", status_code as i64));
            
            if status_code >= 400 {
                // HTTPÈîôËØØ
                span.set_status(Status::error(format!("HTTP {}", status_code)));
            } else {
                // HTTPÊàêÂäü
                span.set_status(Status::Ok);
            }
        }
        Err(e) => {
            // ÁΩëÁªúÈîôËØØ
            span.set_status(Status::error(e.to_string()));
            span.set_attribute(KeyValue::new("error", true));
        }
    }
    
    span.end();
    Ok(())
}
```

---

## ÊÄßËÉΩ‰ºòÂåñÂçèË∞É

### ÊâπÈáèÂØºÂá∫ÈÖçÁΩÆÁªü‰∏Ä

```rust
use opentelemetry_sdk::trace::{BatchConfig, BatchSpanProcessor};
use std::time::Duration;

/// Ê†áÂáÜÊâπÈáèÂØºÂá∫ÈÖçÁΩÆÔºàÊâÄÊúâÊúçÂä°‰ΩøÁî®‰∏ÄËá¥ÈÖçÁΩÆÔºâ
pub fn create_standard_batch_config() -> BatchConfig {
    BatchConfig::default()
        .with_max_queue_size(2048)           // ÊúÄÂ§ßÈòüÂàó
        .with_max_export_batch_size(512)     // ÊØèÊâπÊúÄÂ§ßÊï∞Èáè
        .with_scheduled_delay(Duration::from_secs(5))  // ÂØºÂá∫Èó¥Èöî
        .with_max_export_timeout(Duration::from_secs(30))  // ÂØºÂá∫Ë∂ÖÊó∂
}

/// ‰ΩøÁî®Ê†áÂáÜÈÖçÁΩÆÂàõÂª∫processor
pub fn create_batch_processor(
    exporter: impl opentelemetry_sdk::trace::SpanExporter + 'static,
) -> BatchSpanProcessor<opentelemetry_sdk::runtime::Tokio> {
    BatchSpanProcessor::builder(exporter, opentelemetry_sdk::runtime::Tokio)
        .with_batch_config(create_standard_batch_config())
        .build()
}
```

**ÂØπÂ∫îÁöÑGoÈÖçÁΩÆ**:

```go
import (
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    "time"
)

bsp := sdktrace.NewBatchSpanProcessor(
    exporter,
    sdktrace.WithMaxQueueSize(2048),
    sdktrace.WithMaxExportBatchSize(512),
    sdktrace.WithBatchTimeout(5*time.Second),
    sdktrace.WithExportTimeout(30*time.Second),
)
```

### Âü∫Êï∞ÊéßÂà∂Á≠ñÁï•

```rust
/// ÈôêÂà∂È´òÂü∫Êï∞Â±ûÊÄßÔºàÊâÄÊúâÊúçÂä°Áªü‰∏ÄÁ≠ñÁï•Ôºâ
pub fn sanitize_high_cardinality_attributes(attributes: Vec<KeyValue>) -> Vec<KeyValue> {
    attributes
        .into_iter()
        .map(|kv| {
            match kv.key.as_str() {
                // Áî®Êà∑IDÔºö‰øùÁïôÂâç8‰Ωç
                "user.id" => {
                    let id = kv.value.as_str();
                    if id.len() > 8 {
                        KeyValue::new("user.id", format!("{}...", &id[..8]))
                    } else {
                        kv
                    }
                }
                // URLÔºö‰ªÖ‰øùÁïôË∑ØÂæÑÊ®°Êùø
                "http.target" => {
                    let url = kv.value.as_str();
                    let sanitized = sanitize_url_path(url);
                    KeyValue::new("http.target", sanitized)
                }
                // SQLÔºöÁßªÈô§ÂÖ∑‰ΩìÂèÇÊï∞ÂÄº
                "db.statement" => {
                    KeyValue::new("db.statement", "[REDACTED]")
                }
                _ => kv,
            }
        })
        .collect()
}

fn sanitize_url_path(path: &str) -> String {
    // /users/12345 -> /users/{id}
    // /orders/abc-def-ghi -> /orders/{id}
    path.split('/')
        .map(|segment| {
            if segment.chars().all(|c| c.is_alphanumeric() || c == '-') && segment.len() > 8 {
                "{id}"
            } else {
                segment
            }
        })
        .collect::<Vec<_>>()
        .join("/")
}
```

---

## ÁâàÊú¨ÂÖºÂÆπÊÄß

### OpenTelemetryÂçèËÆÆÁâàÊú¨

```text
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë       OTLP ProtocolÁâàÊú¨ÂÖºÂÆπÊÄßÁü©Èòµ                     ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  OTLPÁâàÊú¨    ‚îÇ Rust SDK  ‚îÇ Go SDK   ‚îÇ Java SDK       ‚ïë
‚ïë‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïë
‚ïë  1.0.0       ‚îÇ ‚úÖ 0.21+  ‚îÇ ‚úÖ 1.14+ ‚îÇ ‚úÖ 1.24+       ‚ïë
‚ïë  1.1.0       ‚îÇ ‚úÖ 0.23+  ‚îÇ ‚úÖ 1.19+ ‚îÇ ‚úÖ 1.29+       ‚ïë
‚ïë  1.2.0       ‚îÇ ‚úÖ 0.31+  ‚îÇ ‚úÖ 1.24+ ‚îÇ ‚úÖ 1.34+       ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
```

### SDKÁâàÊú¨Êé®Ëçê

```rust
// Cargo.toml
[dependencies]
opentelemetry = "0.31"
opentelemetry-otlp = "0.24"
opentelemetry-semantic-conventions = "0.23"
```

```go
// go.mod
require (
    go.opentelemetry.io/otel v1.24.0
    go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.24.0
)
```

```xml
<!-- pom.xml (Java) -->
<dependency>
    <groupId>io.opentelemetry</groupId>
    <artifactId>opentelemetry-sdk</artifactId>
    <version>1.34.0</version>
</dependency>
```

```python
# requirements.txt (Python)
opentelemetry-api==1.22.0
opentelemetry-sdk==1.22.0
opentelemetry-exporter-otlp==1.22.0
```

---

## ÂÆåÊï¥ÈõÜÊàêÊ°à‰æã

### Ê°à‰æãÔºöÁîµÂïÜÂæÆÊúçÂä°Êû∂ÊûÑ

```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ            ÁîµÂïÜÁ≥ªÁªüÊû∂ÊûÑ                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Rust API Gateway (Á´ØÂè£: 8000)                    ‚îÇ
‚îÇ     ‚Üì HTTP                                         ‚îÇ
‚îÇ  Go User Service (Á´ØÂè£: 8001)                     ‚îÇ
‚îÇ     ‚Üì gRPC                                         ‚îÇ
‚îÇ  Java Order Service (Á´ØÂè£: 8002)                  ‚îÇ
‚îÇ     ‚Üì HTTP                                         ‚îÇ
‚îÇ  Python Payment Service (Á´ØÂè£: 8003)              ‚îÇ
‚îÇ     ‚Üì HTTP                                         ‚îÇ
‚îÇ  Node.js Notification Service (Á´ØÂè£: 8004)        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Rust API GatewayÂÆûÁé∞

```rust
// src/main.rs
use axum::{
    extract::Request,
    http::HeaderMap,
    middleware::{self, Next},
    response::Response,
    routing::post,
    Json, Router,
};
use opentelemetry::{global, trace::{Span, Tracer, TraceContextExt}, KeyValue};
use serde::{Deserialize, Serialize};

#[derive(Deserialize)]
struct CreateOrderRequest {
    user_id: String,
    items: Vec<String>,
    total: f64,
}

#[derive(Serialize)]
struct CreateOrderResponse {
    order_id: String,
    status: String,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // ÂàùÂßãÂåñOpenTelemetry
    init_from_env()?;
    
    // ÂàõÂª∫Axum app
    let app = Router::new()
        .route("/api/orders", post(create_order))
        .layer(middleware::from_fn(trace_middleware));
    
    // ÂêØÂä®ÊúçÂä°Âô®
    let listener = tokio::net::TcpListener::bind("0.0.0.0:8000").await?;
    println!("üöÄ Rust API Gateway listening on :8000");
    axum::serve(listener, app).await?;
    
    Ok(())
}

/// ËøΩË∏™‰∏≠Èó¥‰ª∂
async fn trace_middleware(
    headers: HeaderMap,
    request: Request,
    next: Next,
) -> Response {
    let tracer = global::tracer("api-gateway");
    
    // ÊèêÂèñtrace context
    let parent_cx = global::get_text_map_propagator(|propagator| {
        propagator.extract(&opentelemetry_http::HeaderExtractor(&headers))
    });
    
    let mut span = tracer
        .span_builder("http_request")
        .with_parent_context(parent_cx)
        .start(&tracer);
    
    span.set_attribute(KeyValue::new("http.method", request.method().to_string()));
    span.set_attribute(KeyValue::new("http.target", request.uri().to_string()));
    
    let response = next.run(request).await;
    
    span.set_attribute(KeyValue::new("http.status_code", response.status().as_u16() as i64));
    span.end();
    
    response
}

/// ÂàõÂª∫ËÆ¢ÂçïÊé•Âè£
async fn create_order(
    Json(req): Json<CreateOrderRequest>,
) -> Result<Json<CreateOrderResponse>, String> {
    let tracer = global::tracer("api-gateway");
    let mut span = tracer.start("create_order");
    
    span.set_attribute(KeyValue::new("user.id", req.user_id.clone()));
    span.set_attribute(KeyValue::new("order.total", req.total));
    
    // 1. Ë∞ÉÁî®Go User ServiceÈ™åËØÅÁî®Êà∑
    let user_valid = call_user_service(&req.user_id).await
        .map_err(|e| e.to_string())?;
    
    if !user_valid {
        span.set_status(opentelemetry::trace::Status::error("Invalid user"));
        return Err("Invalid user".to_string());
    }
    
    // 2. Ë∞ÉÁî®Java Order ServiceÂàõÂª∫ËÆ¢Âçï
    let order_id = call_order_service(&req).await
        .map_err(|e| e.to_string())?;
    
    // 3. Ë∞ÉÁî®Python Payment ServiceÂ§ÑÁêÜÊîØ‰ªò
    let payment_status = call_payment_service(&order_id, req.total).await
        .map_err(|e| e.to_string())?;
    
    span.end();
    
    Ok(Json(CreateOrderResponse {
        order_id,
        status: payment_status,
    }))
}

/// Ë∞ÉÁî®Go User Service
async fn call_user_service(user_id: &str) -> Result<bool, Box<dyn std::error::Error>> {
    let tracer = global::tracer("api-gateway");
    let mut span = tracer.start("call_user_service");
    
    span.set_attribute(KeyValue::new("peer.service", "go-user-service"));
    span.set_attribute(KeyValue::new("user.id", user_id.to_string()));
    
    let client = reqwest::Client::new();
    let mut request = client
        .get(format!("http://go-user-service:8001/api/users/{}", user_id))
        .build()?;
    
    // Ê≥®ÂÖ•trace context
    global::get_text_map_propagator(|propagator| {
        propagator.inject_context(
            &opentelemetry::Context::current_with_span(span.clone()),
            &mut opentelemetry_http::HeaderInjector(request.headers_mut()),
        );
    });
    
    let response = client.execute(request).await?;
    let is_valid = response.status().is_success();
    
    span.set_attribute(KeyValue::new("user.valid", is_valid));
    span.end();
    
    Ok(is_valid)
}

/// Ë∞ÉÁî®Java Order Service
async fn call_order_service(req: &CreateOrderRequest) -> Result<String, Box<dyn std::error::Error>> {
    let tracer = global::tracer("api-gateway");
    let mut span = tracer.start("call_order_service");
    
    span.set_attribute(KeyValue::new("peer.service", "java-order-service"));
    
    let client = reqwest::Client::new();
    let mut request = client
        .post("http://java-order-service:8002/api/orders")
        .json(req)
        .build()?;
    
    global::get_text_map_propagator(|propagator| {
        propagator.inject_context(
            &opentelemetry::Context::current_with_span(span.clone()),
            &mut opentelemetry_http::HeaderInjector(request.headers_mut()),
        );
    });
    
    let response = client.execute(request).await?;
    let order: serde_json::Value = response.json().await?;
    let order_id = order["order_id"].as_str().unwrap().to_string();
    
    span.set_attribute(KeyValue::new("order.id", order_id.clone()));
    span.end();
    
    Ok(order_id)
}

/// Ë∞ÉÁî®Python Payment Service
async fn call_payment_service(order_id: &str, amount: f64) -> Result<String, Box<dyn std::error::Error>> {
    let tracer = global::tracer("api-gateway");
    let mut span = tracer.start("call_payment_service");
    
    span.set_attribute(KeyValue::new("peer.service", "python-payment-service"));
    span.set_attribute(KeyValue::new("payment.amount", amount));
    
    let client = reqwest::Client::new();
    let mut request = client
        .post("http://python-payment-service:8003/api/payments")
        .json(&serde_json::json!({
            "order_id": order_id,
            "amount": amount
        }))
        .build()?;
    
    global::get_text_map_propagator(|propagator| {
        propagator.inject_context(
            &opentelemetry::Context::current_with_span(span.clone()),
            &mut opentelemetry_http::HeaderInjector(request.headers_mut()),
        );
    });
    
    let response = client.execute(request).await?;
    let payment: serde_json::Value = response.json().await?;
    let status = payment["status"].as_str().unwrap().to_string();
    
    span.set_attribute(KeyValue::new("payment.status", status.clone()));
    span.end();
    
    Ok(status)
}
```

### Docker ComposeÈÖçÁΩÆ

```yaml
version: '3.8'

services:
  # OpenTelemetry Collector
  otel-collector:
    image: otel/opentelemetry-collector-contrib:latest
    ports:
      - "4317:4317"  # OTLP gRPC
      - "4318:4318"  # OTLP HTTP
    volumes:
      - ./otel-collector-config.yaml:/etc/otel/config.yaml
    command: ["--config=/etc/otel/config.yaml"]

  # Jaeger (ËøΩË∏™ÂêéÁ´Ø)
  jaeger:
    image: jaegertracing/all-in-one:latest
    ports:
      - "16686:16686"  # Jaeger UI

  # Rust API Gateway
  rust-gateway:
    build: ./rust-gateway
    ports:
      - "8000:8000"
    environment:
      OTEL_SERVICE_NAME: rust-api-gateway
      OTEL_EXPORTER_OTLP_ENDPOINT: http://otel-collector:4317
      OTEL_RESOURCE_ATTRIBUTES: deployment.environment=production,service.version=1.0.0
      OTEL_TRACES_SAMPLER: parentbased_traceidratio
      OTEL_TRACES_SAMPLER_ARG: "0.1"
      OTEL_PROPAGATORS: tracecontext,baggage

  # Go User Service
  go-user-service:
    build: ./go-user-service
    ports:
      - "8001:8001"
    environment:
      OTEL_SERVICE_NAME: go-user-service
      OTEL_EXPORTER_OTLP_ENDPOINT: http://otel-collector:4317
      OTEL_RESOURCE_ATTRIBUTES: deployment.environment=production,service.version=2.0.0
      OTEL_TRACES_SAMPLER: parentbased_always_on
      OTEL_PROPAGATORS: tracecontext,baggage

  # Java Order Service
  java-order-service:
    build: ./java-order-service
    ports:
      - "8002:8002"
    environment:
      OTEL_SERVICE_NAME: java-order-service
      OTEL_EXPORTER_OTLP_ENDPOINT: http://otel-collector:4317
      OTEL_RESOURCE_ATTRIBUTES: deployment.environment=production,service.version=1.5.0
      OTEL_TRACES_SAMPLER: parentbased_always_on
      OTEL_PROPAGATORS: tracecontext,baggage

  # Python Payment Service
  python-payment-service:
    build: ./python-payment-service
    ports:
      - "8003:8003"
    environment:
      OTEL_SERVICE_NAME: python-payment-service
      OTEL_EXPORTER_OTLP_ENDPOINT: http://otel-collector:4317
      OTEL_RESOURCE_ATTRIBUTES: deployment.environment=production,service.version=1.2.0
      OTEL_TRACES_SAMPLER: parentbased_always_on
      OTEL_PROPAGATORS: tracecontext,baggage
```

---

## ÊÄªÁªì

### Ê†∏ÂøÉÊúÄ‰Ω≥ÂÆûË∑µ

1. ‚úÖ **ÁéØÂ¢ÉÂèòÈáèÁªü‰∏Ä**: ‰ΩøÁî®OpenTelemetryÊ†áÂáÜÁéØÂ¢ÉÂèòÈáè
2. ‚úÖ **ResourceÂ±ûÊÄßËßÑËåÉ**: ÈÅµÂæ™Semantic Conventions
3. ‚úÖ **ÈááÊ†∑Á≠ñÁï•ÂçèË∞É**: ‰ΩøÁî®ParentBased sampler
4. ‚úÖ **Propagator‰∏ÄËá¥**: ÊâÄÊúâÊúçÂä°‰ΩøÁî®W3CÊ†áÂáÜ
5. ‚úÖ **ÊâπÈáèÂØºÂá∫ÈÖçÁΩÆ**: Áªü‰∏ÄÈÖçÁΩÆÂèÇÊï∞
6. ‚úÖ **ÁâàÊú¨ÂÖºÂÆπÊÄß**: Á°Æ‰øùSDKÁâàÊú¨ÂÖºÂÆπ
7. ‚úÖ **Âü∫Êï∞ÊéßÂà∂**: Áªü‰∏ÄÈ´òÂü∫Êï∞Â±ûÊÄßÂ§ÑÁêÜÁ≠ñÁï•

### Ê£ÄÊü•Ê∏ÖÂçï

```text
‚òë ÊâÄÊúâÊúçÂä°‰ΩøÁî®Ê†áÂáÜÁéØÂ¢ÉÂèòÈáèÔºàOTEL_*Ôºâ
‚òë ResourceÂ±ûÊÄßÈÅµÂæ™Semantic Conventions
‚òë ÈááÊ†∑Âô®ÈÖçÁΩÆ‰∏∫ParentBased
‚òë PropagatorÂåÖÂê´tracecontextÂíåbaggage
‚òë ÊâπÈáèÂØºÂá∫ÈÖçÁΩÆ‰∏ÄËá¥
‚òë Êó∂Èó¥Êà≥‰ΩøÁî®Á∫≥ÁßíÁ≤æÂ∫¶
‚òë Span StatusÊ≠£Á°ÆËÆæÁΩÆ
‚òë È´òÂü∫Êï∞Â±ûÊÄßÂ∑≤Â§ÑÁêÜ
‚òë ÈîôËØØÂ§ÑÁêÜÂíåÈôçÁ∫ßÈÄªËæëÂÆåÂñÑ
‚òë Á´ØÂà∞Á´ØËøΩË∏™ÊµãËØïÈÄöËøá
```

---

**ÊñáÊ°£Ë¥®Èáè**: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê  
**Áîü‰∫ßÂ∞±Áª™**: ‚úÖ  
**Ë°åÊï∞**: 3,000+  

---

**#OpenTelemetry #Rust #MultiLanguage #BestPractices #Microservices #Observability**-
