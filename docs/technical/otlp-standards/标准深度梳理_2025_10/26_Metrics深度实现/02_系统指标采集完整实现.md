# Rust ç³»ç»ŸæŒ‡æ ‡é‡‡é›†å®Œæ•´å®ç°

> **æ–‡æ¡£ç‰ˆæœ¬**: 1.0.0  
> **Rust ç‰ˆæœ¬**: 1.90+  
> **OpenTelemetry**: 0.31.0  
> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´10æœˆ8æ—¥  
> **æ–‡æ¡£ç±»å‹**: ç³»ç»Ÿç›‘æ§å’ŒæŒ‡æ ‡é‡‡é›†

---

## ğŸ“‹ ç›®å½•

- [Rust ç³»ç»ŸæŒ‡æ ‡é‡‡é›†å®Œæ•´å®ç°](#rust-ç³»ç»ŸæŒ‡æ ‡é‡‡é›†å®Œæ•´å®ç°)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. ç³»ç»ŸæŒ‡æ ‡æ¦‚è¿°](#1-ç³»ç»ŸæŒ‡æ ‡æ¦‚è¿°)
    - [1.1 ä¸ºä»€ä¹ˆéœ€è¦ç³»ç»ŸæŒ‡æ ‡ï¼Ÿ](#11-ä¸ºä»€ä¹ˆéœ€è¦ç³»ç»ŸæŒ‡æ ‡)
    - [1.2 ç³»ç»ŸæŒ‡æ ‡åˆ†ç±»](#12-ç³»ç»ŸæŒ‡æ ‡åˆ†ç±»)
    - [1.3 OpenTelemetry è¯­ä¹‰çº¦å®š](#13-opentelemetry-è¯­ä¹‰çº¦å®š)
  - [2. CPU æŒ‡æ ‡é‡‡é›†](#2-cpu-æŒ‡æ ‡é‡‡é›†)
    - [2.1 åŸºç¡€ CPU æŒ‡æ ‡](#21-åŸºç¡€-cpu-æŒ‡æ ‡)
    - [2.2 CPU è´Ÿè½½ï¼ˆLoad Averageï¼‰](#22-cpu-è´Ÿè½½load-average)
    - [2.3 CPU æ—¶é—´åˆ†ç±»ï¼ˆç”¨æˆ·æ€ã€ç³»ç»Ÿæ€ã€ç©ºé—²ï¼‰](#23-cpu-æ—¶é—´åˆ†ç±»ç”¨æˆ·æ€ç³»ç»Ÿæ€ç©ºé—²)
  - [3. å†…å­˜æŒ‡æ ‡é‡‡é›†](#3-å†…å­˜æŒ‡æ ‡é‡‡é›†)
    - [3.1 ç³»ç»Ÿå†…å­˜æŒ‡æ ‡](#31-ç³»ç»Ÿå†…å­˜æŒ‡æ ‡)
    - [3.2 Linux è¯¦ç»†å†…å­˜æŒ‡æ ‡](#32-linux-è¯¦ç»†å†…å­˜æŒ‡æ ‡)
  - [4. ç£ç›˜ I/O æŒ‡æ ‡](#4-ç£ç›˜-io-æŒ‡æ ‡)
    - [4.1 ç£ç›˜ä½¿ç”¨é‡](#41-ç£ç›˜ä½¿ç”¨é‡)
    - [4.2 ç£ç›˜ I/O ååå’Œ IOPS](#42-ç£ç›˜-io-ååå’Œ-iops)
  - [5. ç½‘ç»œæŒ‡æ ‡](#5-ç½‘ç»œæŒ‡æ ‡)
    - [5.1 ç½‘ç»œ I/Oï¼ˆæ”¶å‘å­—èŠ‚æ•°ï¼‰](#51-ç½‘ç»œ-ioæ”¶å‘å­—èŠ‚æ•°)
    - [5.2 ç½‘ç»œè¿æ¥æ•°](#52-ç½‘ç»œè¿æ¥æ•°)
  - [6. è¿›ç¨‹æŒ‡æ ‡](#6-è¿›ç¨‹æŒ‡æ ‡)
    - [6.1 å½“å‰è¿›ç¨‹æŒ‡æ ‡](#61-å½“å‰è¿›ç¨‹æŒ‡æ ‡)
    - [6.2 è¿›ç¨‹è¿è¡Œæ—¶é—´](#62-è¿›ç¨‹è¿è¡Œæ—¶é—´)
  - [7. Tokio Runtime æŒ‡æ ‡](#7-tokio-runtime-æŒ‡æ ‡)
    - [7.1 åŸºç¡€ Tokio æŒ‡æ ‡](#71-åŸºç¡€-tokio-æŒ‡æ ‡)
    - [7.2 è¯¦ç»† Worker æŒ‡æ ‡](#72-è¯¦ç»†-worker-æŒ‡æ ‡)
  - [8. è‡ªå®šä¹‰ä¸šåŠ¡æŒ‡æ ‡](#8-è‡ªå®šä¹‰ä¸šåŠ¡æŒ‡æ ‡)
    - [8.1 HTTP æœåŠ¡æŒ‡æ ‡](#81-http-æœåŠ¡æŒ‡æ ‡)
    - [8.2 æ•°æ®åº“è¿æ¥æ± æŒ‡æ ‡](#82-æ•°æ®åº“è¿æ¥æ± æŒ‡æ ‡)
  - [9. æŒ‡æ ‡èšåˆå’Œæ±‡æ€»](#9-æŒ‡æ ‡èšåˆå’Œæ±‡æ€»)
    - [9.1 æŒ‡æ ‡èšåˆå™¨](#91-æŒ‡æ ‡èšåˆå™¨)
    - [9.2 å®šæœŸå¯¼å‡ºç»Ÿè®¡æ‘˜è¦](#92-å®šæœŸå¯¼å‡ºç»Ÿè®¡æ‘˜è¦)
  - [10. å®Œæ•´ç›‘æ§æ ˆå®ç°](#10-å®Œæ•´ç›‘æ§æ ˆå®ç°)
    - [10.1 ç»¼åˆç›‘æ§ç³»ç»Ÿ](#101-ç»¼åˆç›‘æ§ç³»ç»Ÿ)
    - [10.2 å®Œæ•´ç¤ºä¾‹ï¼šç›‘æ§ Web æœåŠ¡](#102-å®Œæ•´ç¤ºä¾‹ç›‘æ§-web-æœåŠ¡)
    - [10.3 ä¾èµ–é…ç½®](#103-ä¾èµ–é…ç½®)
  - [ğŸ“Š æ€»ç»“](#-æ€»ç»“)
    - [å®Œæˆå†…å®¹](#å®Œæˆå†…å®¹)
    - [å…³é”®è¦ç‚¹](#å…³é”®è¦ç‚¹)

---

## 1. ç³»ç»ŸæŒ‡æ ‡æ¦‚è¿°

### 1.1 ä¸ºä»€ä¹ˆéœ€è¦ç³»ç»ŸæŒ‡æ ‡ï¼Ÿ

ç³»ç»ŸæŒ‡æ ‡å¸®åŠ©æˆ‘ä»¬ï¼š

- **ç›‘æ§èµ„æºä½¿ç”¨** - CPUã€å†…å­˜ã€ç£ç›˜ã€ç½‘ç»œ
- **é¢„æµ‹å®¹é‡éœ€æ±‚** - æå‰å‘ç°èµ„æºç“¶é¢ˆ
- **æ•…éšœè¯Šæ–­** - å¿«é€Ÿå®šä½ç³»ç»Ÿé—®é¢˜
- **æ€§èƒ½ä¼˜åŒ–** - è¯†åˆ«ä¼˜åŒ–æœºä¼š
- **å‘Šè­¦å’Œè‡ªåŠ¨åŒ–** - è§¦å‘è‡ªåŠ¨æ‰©ç¼©å®¹

### 1.2 ç³»ç»ŸæŒ‡æ ‡åˆ†ç±»

| ç±»åˆ« | æŒ‡æ ‡ç¤ºä¾‹ | ç”¨é€” |
|------|---------|------|
| **CPU** | ä½¿ç”¨ç‡ã€è´Ÿè½½ã€æ ¸å¿ƒæ•° | CPU ç“¶é¢ˆæ£€æµ‹ |
| **å†…å­˜** | ä½¿ç”¨é‡ã€å¯ç”¨é‡ã€ç¼“å­˜ | å†…å­˜æ³„æ¼æ£€æµ‹ |
| **ç£ç›˜** | I/O ååã€IOPSã€ä½¿ç”¨ç‡ | ç£ç›˜ç“¶é¢ˆæ£€æµ‹ |
| **ç½‘ç»œ** | å¸¦å®½ã€ä¸¢åŒ…ç‡ã€è¿æ¥æ•° | ç½‘ç»œæ€§èƒ½åˆ†æ |
| **è¿›ç¨‹** | å†…å­˜ã€çº¿ç¨‹æ•°ã€æ–‡ä»¶æè¿°ç¬¦ | è¿›ç¨‹å¥åº·ç›‘æ§ |
| **Runtime** | åç¨‹æ•°ã€ä»»åŠ¡é˜Ÿåˆ—ã€è°ƒåº¦å»¶è¿Ÿ | å¼‚æ­¥æ€§èƒ½åˆ†æ |

### 1.3 OpenTelemetry è¯­ä¹‰çº¦å®š

éµå¾ª [OpenTelemetry ç³»ç»ŸæŒ‡æ ‡è¯­ä¹‰çº¦å®š](https://opentelemetry.io/docs/specs/semconv/system/system-metrics/):

```text
system.cpu.utilization              CPU ä½¿ç”¨ç‡ (0-1)
system.memory.usage                 å†…å­˜ä½¿ç”¨é‡ (bytes)
system.disk.io                      ç£ç›˜ I/O (bytes)
system.network.io                   ç½‘ç»œ I/O (bytes)
process.cpu.utilization             è¿›ç¨‹ CPU ä½¿ç”¨ç‡
process.memory.usage                è¿›ç¨‹å†…å­˜ä½¿ç”¨
```

---

## 2. CPU æŒ‡æ ‡é‡‡é›†

### 2.1 åŸºç¡€ CPU æŒ‡æ ‡

```rust
use opentelemetry::{global, metrics::Meter, KeyValue};
use sysinfo::{System, SystemExt, CpuExt, CpuRefreshKind};
use std::sync::{Arc, Mutex};
use std::time::Duration;

pub struct CpuMetrics {
    system: Arc<Mutex<System>>,
}

impl CpuMetrics {
    pub fn new(meter: &Meter) -> Self {
        let system = Arc::new(Mutex::new(System::new_all()));

        // 1. æ•´ä½“ CPU ä½¿ç”¨ç‡
        let system_clone = system.clone();
        meter
            .f64_observable_gauge("system.cpu.utilization")
            .with_description("Overall CPU utilization")
            .with_unit("1")  // 0.0 - 1.0
            .with_callback(move |observer| {
                let mut sys = system_clone.lock().unwrap();
                sys.refresh_cpu();
                
                let usage = sys.global_cpu_info().cpu_usage() as f64 / 100.0;
                observer.observe(usage, &[]);
            })
            .build();

        // 2. æ¯ä¸ªæ ¸å¿ƒçš„ CPU ä½¿ç”¨ç‡
        let system_clone = system.clone();
        meter
            .f64_observable_gauge("system.cpu.utilization.per_core")
            .with_description("Per-core CPU utilization")
            .with_unit("1")
            .with_callback(move |observer| {
                let mut sys = system_clone.lock().unwrap();
                sys.refresh_cpu();
                
                for (idx, cpu) in sys.cpus().iter().enumerate() {
                    let usage = cpu.cpu_usage() as f64 / 100.0;
                    observer.observe(usage, &[
                        KeyValue::new("cpu", idx as i64),
                        KeyValue::new("cpu.name", cpu.name().to_string()),
                    ]);
                }
            })
            .build();

        // 3. CPU æ ¸å¿ƒæ•°ï¼ˆé™æ€ä¿¡æ¯ï¼‰
        let cpu_count = system.lock().unwrap().cpus().len() as u64;
        meter
            .u64_observable_gauge("system.cpu.logical.count")
            .with_description("Number of logical CPU cores")
            .with_unit("cores")
            .with_callback(move |observer| {
                observer.observe(cpu_count, &[]);
            })
            .build();

        Self { system }
    }

    /// è·å–å½“å‰ CPU ä½¿ç”¨ç‡ï¼ˆåŒæ­¥æ–¹æ³•ï¼Œç”¨äºå³æ—¶æŸ¥è¯¢ï¼‰
    pub fn get_cpu_usage(&self) -> f64 {
        let mut sys = self.system.lock().unwrap();
        sys.refresh_cpu();
        sys.global_cpu_info().cpu_usage() as f64 / 100.0
    }
}
```

### 2.2 CPU è´Ÿè½½ï¼ˆLoad Averageï¼‰

```rust
use sysinfo::System;

pub struct LoadAverageMetrics;

impl LoadAverageMetrics {
    pub fn new(meter: &Meter) -> Self {
        // Load Averageï¼ˆ1åˆ†é’Ÿã€5åˆ†é’Ÿã€15åˆ†é’Ÿï¼‰
        meter
            .f64_observable_gauge("system.cpu.load_average.1m")
            .with_description("1-minute load average")
            .with_unit("load")
            .with_callback(move |observer| {
                let load = System::load_average();
                observer.observe(load.one, &[]);
            })
            .build();

        meter
            .f64_observable_gauge("system.cpu.load_average.5m")
            .with_description("5-minute load average")
            .with_unit("load")
            .with_callback(move |observer| {
                let load = System::load_average();
                observer.observe(load.five, &[]);
            })
            .build();

        meter
            .f64_observable_gauge("system.cpu.load_average.15m")
            .with_description("15-minute load average")
            .with_unit("load")
            .with_callback(move |observer| {
                let load = System::load_average();
                observer.observe(load.fifteen, &[]);
            })
            .build();

        Self
    }
}
```

### 2.3 CPU æ—¶é—´åˆ†ç±»ï¼ˆç”¨æˆ·æ€ã€ç³»ç»Ÿæ€ã€ç©ºé—²ï¼‰

```rust
#[cfg(target_os = "linux")]
pub struct CpuTimeMetrics;

#[cfg(target_os = "linux")]
impl CpuTimeMetrics {
    pub fn new(meter: &Meter) -> Self {
        use procfs::CpuTime;

        // CPU æ—¶é—´ï¼ˆç”¨æˆ·æ€ã€ç³»ç»Ÿæ€ã€ç©ºé—²ï¼‰
        meter
            .u64_observable_counter("system.cpu.time")
            .with_description("CPU time in different states")
            .with_unit("s")
            .with_callback(move |observer| {
                if let Ok(stat) = procfs::KernelStats::new() {
                    let cpu = &stat.total;
                    
                    observer.observe(cpu.user, &[KeyValue::new("state", "user")]);
                    observer.observe(cpu.system, &[KeyValue::new("state", "system")]);
                    observer.observe(cpu.idle, &[KeyValue::new("state", "idle")]);
                    observer.observe(cpu.iowait.unwrap_or(0), &[KeyValue::new("state", "iowait")]);
                }
            })
            .build();

        Self
    }
}
```

---

## 3. å†…å­˜æŒ‡æ ‡é‡‡é›†

### 3.1 ç³»ç»Ÿå†…å­˜æŒ‡æ ‡

```rust
pub struct MemoryMetrics {
    system: Arc<Mutex<System>>,
}

impl MemoryMetrics {
    pub fn new(meter: &Meter) -> Self {
        let system = Arc::new(Mutex::new(System::new_all()));

        // 1. æ€»å†…å­˜
        let system_clone = system.clone();
        meter
            .u64_observable_gauge("system.memory.usage")
            .with_description("Memory usage by state")
            .with_unit("bytes")
            .with_callback(move |observer| {
                let mut sys = system_clone.lock().unwrap();
                sys.refresh_memory();

                // å·²ä½¿ç”¨å†…å­˜
                observer.observe(sys.used_memory(), &[
                    KeyValue::new("state", "used"),
                ]);

                // å¯ç”¨å†…å­˜
                observer.observe(sys.available_memory(), &[
                    KeyValue::new("state", "free"),
                ]);

                // æ€»å†…å­˜
                observer.observe(sys.total_memory(), &[
                    KeyValue::new("state", "total"),
                ]);
            })
            .build();

        // 2. å†…å­˜ä½¿ç”¨ç‡ï¼ˆç™¾åˆ†æ¯”ï¼‰
        let system_clone = system.clone();
        meter
            .f64_observable_gauge("system.memory.utilization")
            .with_description("Memory utilization percentage")
            .with_unit("1")  // 0.0 - 1.0
            .with_callback(move |observer| {
                let mut sys = system_clone.lock().unwrap();
                sys.refresh_memory();

                let total = sys.total_memory() as f64;
                let used = sys.used_memory() as f64;
                let utilization = if total > 0.0 { used / total } else { 0.0 };

                observer.observe(utilization, &[]);
            })
            .build();

        // 3. Swap å†…å­˜
        let system_clone = system.clone();
        meter
            .u64_observable_gauge("system.memory.swap")
            .with_description("Swap memory usage")
            .with_unit("bytes")
            .with_callback(move |observer| {
                let mut sys = system_clone.lock().unwrap();
                sys.refresh_memory();

                observer.observe(sys.used_swap(), &[
                    KeyValue::new("state", "used"),
                ]);
                observer.observe(sys.total_swap(), &[
                    KeyValue::new("state", "total"),
                ]);
            })
            .build();

        Self { system }
    }

    /// è·å–å†…å­˜ä½¿ç”¨ä¿¡æ¯ï¼ˆåŒæ­¥ï¼‰
    pub fn get_memory_info(&self) -> MemoryInfo {
        let mut sys = self.system.lock().unwrap();
        sys.refresh_memory();

        MemoryInfo {
            total: sys.total_memory(),
            used: sys.used_memory(),
            available: sys.available_memory(),
            utilization: sys.used_memory() as f64 / sys.total_memory() as f64,
        }
    }
}

#[derive(Debug, Clone)]
pub struct MemoryInfo {
    pub total: u64,
    pub used: u64,
    pub available: u64,
    pub utilization: f64,
}
```

### 3.2 Linux è¯¦ç»†å†…å­˜æŒ‡æ ‡

```rust
#[cfg(target_os = "linux")]
pub struct LinuxMemoryMetrics;

#[cfg(target_os = "linux")]
impl LinuxMemoryMetrics {
    pub fn new(meter: &Meter) -> Self {
        use procfs::Meminfo;

        meter
            .u64_observable_gauge("system.linux.memory.detailed")
            .with_description("Detailed Linux memory statistics")
            .with_unit("bytes")
            .with_callback(move |observer| {
                if let Ok(meminfo) = Meminfo::new() {
                    // å¯ç”¨å†…å­˜
                    if let Some(available) = meminfo.mem_available {
                        observer.observe(available * 1024, &[
                            KeyValue::new("type", "available"),
                        ]);
                    }

                    // Buffers
                    if let Some(buffers) = meminfo.buffers {
                        observer.observe(buffers * 1024, &[
                            KeyValue::new("type", "buffers"),
                        ]);
                    }

                    // Cached
                    if let Some(cached) = meminfo.cached {
                        observer.observe(cached * 1024, &[
                            KeyValue::new("type", "cached"),
                        ]);
                    }

                    // Slab
                    if let Some(slab) = meminfo.slab {
                        observer.observe(slab * 1024, &[
                            KeyValue::new("type", "slab"),
                        ]);
                    }
                }
            })
            .build();

        Self
    }
}
```

---

## 4. ç£ç›˜ I/O æŒ‡æ ‡

### 4.1 ç£ç›˜ä½¿ç”¨é‡

```rust
pub struct DiskMetrics {
    system: Arc<Mutex<System>>,
}

impl DiskMetrics {
    pub fn new(meter: &Meter) -> Self {
        use sysinfo::{DiskExt, DisksExt};

        let system = Arc<Mutex::new(System::new_all())>;

        // ç£ç›˜ä½¿ç”¨é‡
        let system_clone = system.clone();
        meter
            .u64_observable_gauge("system.filesystem.usage")
            .with_description("Filesystem disk space usage")
            .with_unit("bytes")
            .with_callback(move |observer| {
                let mut sys = system_clone.lock().unwrap();
                sys.refresh_disks_list();

                for disk in sys.disks() {
                    let mount_point = disk.mount_point().to_string_lossy().to_string();
                    let device = disk.name().to_string_lossy().to_string();

                    // æ€»ç©ºé—´
                    observer.observe(disk.total_space(), &[
                        KeyValue::new("mountpoint", mount_point.clone()),
                        KeyValue::new("device", device.clone()),
                        KeyValue::new("state", "total"),
                    ]);

                    // å¯ç”¨ç©ºé—´
                    observer.observe(disk.available_space(), &[
                        KeyValue::new("mountpoint", mount_point.clone()),
                        KeyValue::new("device", device.clone()),
                        KeyValue::new("state", "free"),
                    ]);

                    // å·²ç”¨ç©ºé—´
                    let used = disk.total_space() - disk.available_space();
                    observer.observe(used, &[
                        KeyValue::new("mountpoint", mount_point),
                        KeyValue::new("device", device),
                        KeyValue::new("state", "used"),
                    ]);
                }
            })
            .build();

        // ç£ç›˜ä½¿ç”¨ç‡
        let system_clone = system.clone();
        meter
            .f64_observable_gauge("system.filesystem.utilization")
            .with_description("Filesystem utilization percentage")
            .with_unit("1")
            .with_callback(move |observer| {
                let mut sys = system_clone.lock().unwrap();
                sys.refresh_disks_list();

                for disk in sys.disks() {
                    let total = disk.total_space() as f64;
                    let available = disk.available_space() as f64;
                    let utilization = if total > 0.0 {
                        (total - available) / total
                    } else {
                        0.0
                    };

                    observer.observe(utilization, &[
                        KeyValue::new("mountpoint", disk.mount_point().to_string_lossy().to_string()),
                        KeyValue::new("device", disk.name().to_string_lossy().to_string()),
                    ]);
                }
            })
            .build();

        Self { system }
    }
}
```

### 4.2 ç£ç›˜ I/O ååå’Œ IOPS

```rust
#[cfg(target_os = "linux")]
pub struct DiskIOMetrics {
    prev_stats: Arc<Mutex<HashMap<String, procfs::DiskStat>>>,
    prev_time: Arc<Mutex<Instant>>,
}

#[cfg(target_os = "linux")]
impl DiskIOMetrics {
    pub fn new(meter: &Meter) -> Self {
        use procfs::diskstats;
        use std::collections::HashMap;
        use std::time::Instant;

        let prev_stats = Arc::new(Mutex::new(HashMap::new()));
        let prev_time = Arc::new(Mutex::new(Instant::now()));

        // ç£ç›˜ I/O å­—èŠ‚æ•°
        let prev_stats_clone = prev_stats.clone();
        let prev_time_clone = prev_time.clone();
        meter
            .u64_observable_counter("system.disk.io")
            .with_description("Disk I/O in bytes")
            .with_unit("bytes")
            .with_callback(move |observer| {
                if let Ok(stats) = diskstats() {
                    let mut prev = prev_stats_clone.lock().unwrap();
                    let mut prev_t = prev_time_clone.lock().unwrap();
                    let now = Instant::now();
                    let elapsed = now.duration_since(*prev_t).as_secs_f64();

                    for stat in stats {
                        let device = stat.name.clone();
                        
                        if let Some(prev_stat) = prev.get(&device) {
                            // è¯»å–å­—èŠ‚æ•°ï¼ˆsector * 512ï¼‰
                            let read_bytes = (stat.sectors_read - prev_stat.sectors_read) * 512;
                            observer.observe(read_bytes, &[
                                KeyValue::new("device", device.clone()),
                                KeyValue::new("direction", "read"),
                            ]);

                            // å†™å…¥å­—èŠ‚æ•°
                            let write_bytes = (stat.sectors_written - prev_stat.sectors_written) * 512;
                            observer.observe(write_bytes, &[
                                KeyValue::new("device", device.clone()),
                                KeyValue::new("direction", "write"),
                            ]);
                        }

                        prev.insert(device, stat);
                    }

                    *prev_t = now;
                }
            })
            .build();

        // ç£ç›˜ IOPS
        let prev_stats_clone = prev_stats.clone();
        meter
            .u64_observable_gauge("system.disk.operations")
            .with_description("Disk operations (IOPS)")
            .with_unit("operations")
            .with_callback(move |observer| {
                if let Ok(stats) = diskstats() {
                    let prev = prev_stats_clone.lock().unwrap();

                    for stat in stats {
                        if let Some(prev_stat) = prev.get(&stat.name) {
                            let read_ops = stat.reads - prev_stat.reads;
                            let write_ops = stat.writes - prev_stat.writes;

                            observer.observe(read_ops, &[
                                KeyValue::new("device", stat.name.clone()),
                                KeyValue::new("direction", "read"),
                            ]);

                            observer.observe(write_ops, &[
                                KeyValue::new("device", stat.name),
                                KeyValue::new("direction", "write"),
                            ]);
                        }
                    }
                }
            })
            .build();

        Self { prev_stats, prev_time }
    }
}
```

---

## 5. ç½‘ç»œæŒ‡æ ‡

### 5.1 ç½‘ç»œ I/Oï¼ˆæ”¶å‘å­—èŠ‚æ•°ï¼‰

```rust
pub struct NetworkMetrics {
    system: Arc<Mutex<System>>,
}

impl NetworkMetrics {
    pub fn new(meter: &Meter) -> Self {
        use sysinfo::{NetworksExt, NetworkExt};

        let system = Arc::new(Mutex::new(System::new_all()));

        // ç½‘ç»œæ”¶å‘å­—èŠ‚æ•°
        let system_clone = system.clone();
        meter
            .u64_observable_counter("system.network.io")
            .with_description("Network I/O in bytes")
            .with_unit("bytes")
            .with_callback(move |observer| {
                let mut sys = system_clone.lock().unwrap();
                sys.refresh_networks_list();

                for (interface, data) in sys.networks() {
                    // æ¥æ”¶å­—èŠ‚æ•°
                    observer.observe(data.total_received(), &[
                        KeyValue::new("device", interface.clone()),
                        KeyValue::new("direction", "receive"),
                    ]);

                    // å‘é€å­—èŠ‚æ•°
                    observer.observe(data.total_transmitted(), &[
                        KeyValue::new("device", interface.clone()),
                        KeyValue::new("direction", "transmit"),
                    ]);
                }
            })
            .build();

        // ç½‘ç»œé”™è¯¯å’Œä¸¢åŒ…
        let system_clone = system.clone();
        meter
            .u64_observable_counter("system.network.errors")
            .with_description("Network errors")
            .with_unit("errors")
            .with_callback(move |observer| {
                let mut sys = system_clone.lock().unwrap();
                sys.refresh_networks_list();

                for (interface, data) in sys.networks() {
                    observer.observe(data.total_errors_on_received(), &[
                        KeyValue::new("device", interface.clone()),
                        KeyValue::new("direction", "receive"),
                    ]);

                    observer.observe(data.total_errors_on_transmitted(), &[
                        KeyValue::new("device", interface.clone()),
                        KeyValue::new("direction", "transmit"),
                    ]);
                }
            })
            .build();

        Self { system }
    }
}
```

### 5.2 ç½‘ç»œè¿æ¥æ•°

```rust
#[cfg(target_os = "linux")]
pub struct NetworkConnectionMetrics;

#[cfg(target_os = "linux")]
impl NetworkConnectionMetrics {
    pub fn new(meter: &Meter) -> Self {
        use procfs::net::{TcpState, tcp};

        meter
            .u64_observable_gauge("system.network.connections")
            .with_description("Number of network connections by state")
            .with_unit("connections")
            .with_callback(move |observer| {
                if let Ok(tcp) = tcp() {
                    use std::collections::HashMap;
                    let mut state_counts: HashMap<TcpState, u64> = HashMap::new();

                    for entry in tcp {
                        *state_counts.entry(entry.state).or_insert(0) += 1;
                    }

                    for (state, count) in state_counts {
                        observer.observe(count, &[
                            KeyValue::new("protocol", "tcp"),
                            KeyValue::new("state", format!("{:?}", state).to_lowercase()),
                        ]);
                    }
                }
            })
            .build();

        Self
    }
}
```

---

## 6. è¿›ç¨‹æŒ‡æ ‡

### 6.1 å½“å‰è¿›ç¨‹æŒ‡æ ‡

```rust
pub struct ProcessMetrics {
    system: Arc<Mutex<System>>,
    pid: sysinfo::Pid,
}

impl ProcessMetrics {
    pub fn new(meter: &Meter) -> Self {
        let system = Arc::new(Mutex::new(System::new_all()));
        let pid = sysinfo::get_current_pid().unwrap();

        // è¿›ç¨‹ CPU ä½¿ç”¨ç‡
        let system_clone = system.clone();
        meter
            .f64_observable_gauge("process.cpu.utilization")
            .with_description("Process CPU utilization")
            .with_unit("1")
            .with_callback(move |observer| {
                let mut sys = system_clone.lock().unwrap();
                sys.refresh_process(pid);

                if let Some(process) = sys.process(pid) {
                    let usage = process.cpu_usage() as f64 / 100.0;
                    observer.observe(usage, &[]);
                }
            })
            .build();

        // è¿›ç¨‹å†…å­˜ä½¿ç”¨
        let system_clone = system.clone();
        meter
            .u64_observable_gauge("process.memory.usage")
            .with_description("Process memory usage")
            .with_unit("bytes")
            .with_callback(move |observer| {
                let mut sys = system_clone.lock().unwrap();
                sys.refresh_process(pid);

                if let Some(process) = sys.process(pid) {
                    observer.observe(process.memory(), &[
                        KeyValue::new("type", "rss"),
                    ]);
                    observer.observe(process.virtual_memory(), &[
                        KeyValue::new("type", "vms"),
                    ]);
                }
            })
            .build();

        // è¿›ç¨‹çº¿ç¨‹æ•°
        let system_clone = system.clone();
        meter
            .u64_observable_gauge("process.threads")
            .with_description("Number of threads")
            .with_unit("threads")
            .with_callback(move |observer| {
                let mut sys = system_clone.lock().unwrap();
                sys.refresh_process(pid);

                if let Some(process) = sys.process(pid) {
                    // sysinfo ä¸ç›´æ¥æä¾›çº¿ç¨‹æ•°ï¼Œä½¿ç”¨ procfs
                    #[cfg(target_os = "linux")]
                    if let Ok(stat) = procfs::process::Process::myself().and_then(|p| p.stat()) {
                        observer.observe(stat.num_threads as u64, &[]);
                    }
                }
            })
            .build();

        // è¿›ç¨‹æ‰“å¼€çš„æ–‡ä»¶æè¿°ç¬¦
        #[cfg(target_os = "linux")]
        {
            meter
                .u64_observable_gauge("process.open_file_descriptors")
                .with_description("Number of open file descriptors")
                .with_unit("descriptors")
                .with_callback(move |observer| {
                    if let Ok(process) = procfs::process::Process::myself() {
                        if let Ok(fds) = process.fd_count() {
                            observer.observe(fds as u64, &[]);
                        }
                    }
                })
                .build();
        }

        Self { system, pid }
    }
}
```

### 6.2 è¿›ç¨‹è¿è¡Œæ—¶é—´

```rust
pub struct ProcessRuntimeMetrics;

impl ProcessRuntimeMetrics {
    pub fn new(meter: &Meter) -> Self {
        let start_time = std::time::Instant::now();

        meter
            .u64_observable_gauge("process.runtime.uptime")
            .with_description("Process uptime")
            .with_unit("seconds")
            .with_callback(move |observer| {
                let uptime = start_time.elapsed().as_secs();
                observer.observe(uptime, &[]);
            })
            .build();

        Self
    }
}
```

---

## 7. Tokio Runtime æŒ‡æ ‡

### 7.1 åŸºç¡€ Tokio æŒ‡æ ‡

```rust
use tokio::runtime::RuntimeMetrics;
use std::sync::Arc;

pub struct TokioMetrics {
    handle: tokio::runtime::Handle,
}

impl TokioMetrics {
    pub fn new(meter: &Meter) -> Self {
        let handle = tokio::runtime::Handle::current();

        // å·¥ä½œçº¿ç¨‹æ•°
        let handle_clone = handle.clone();
        meter
            .u64_observable_gauge("tokio.runtime.workers")
            .with_description("Number of Tokio worker threads")
            .with_unit("threads")
            .with_callback(move |observer| {
                let metrics = handle_clone.metrics();
                observer.observe(metrics.num_workers() as u64, &[]);
            })
            .build();

        // æ´»è·ƒä»»åŠ¡æ•°
        let handle_clone = handle.clone();
        meter
            .u64_observable_gauge("tokio.runtime.active_tasks")
            .with_description("Number of active tasks")
            .with_unit("tasks")
            .with_callback(move |observer| {
                let metrics = handle_clone.metrics();
                observer.observe(metrics.num_alive_tasks() as u64, &[]);
            })
            .build();

        // é˜»å¡çº¿ç¨‹æ•°
        let handle_clone = handle.clone();
        meter
            .u64_observable_gauge("tokio.runtime.blocking_threads")
            .with_description("Number of blocking threads")
            .with_unit("threads")
            .with_callback(move |observer| {
                let metrics = handle_clone.metrics();
                observer.observe(metrics.num_blocking_threads() as u64, &[]);
            })
            .build();

        // ç©ºé—²é˜»å¡çº¿ç¨‹æ•°
        let handle_clone = handle.clone();
        meter
            .u64_observable_gauge("tokio.runtime.idle_blocking_threads")
            .with_description("Number of idle blocking threads")
            .with_unit("threads")
            .with_callback(move |observer| {
                let metrics = handle_clone.metrics();
                observer.observe(metrics.num_idle_blocking_threads() as u64, &[]);
            })
            .build();

        Self { handle }
    }

    /// è·å– Tokio æŒ‡æ ‡å¿«ç…§ï¼ˆåŒæ­¥ï¼‰
    pub fn get_snapshot(&self) -> TokioMetricsSnapshot {
        let metrics = self.handle.metrics();
        
        TokioMetricsSnapshot {
            workers: metrics.num_workers(),
            active_tasks: metrics.num_alive_tasks(),
            blocking_threads: metrics.num_blocking_threads(),
            idle_blocking_threads: metrics.num_idle_blocking_threads(),
        }
    }
}

#[derive(Debug, Clone)]
pub struct TokioMetricsSnapshot {
    pub workers: usize,
    pub active_tasks: usize,
    pub blocking_threads: usize,
    pub idle_blocking_threads: usize,
}
```

### 7.2 è¯¦ç»† Worker æŒ‡æ ‡

```rust
pub struct TokioWorkerMetrics {
    handle: tokio::runtime::Handle,
}

impl TokioWorkerMetrics {
    pub fn new(meter: &Meter) -> Self {
        let handle = tokio::runtime::Handle::current();

        // æ¯ä¸ª Worker çš„ä»»åŠ¡é˜Ÿåˆ—é•¿åº¦
        let handle_clone = handle.clone();
        meter
            .u64_observable_gauge("tokio.worker.queue_depth")
            .with_description("Worker queue depth")
            .with_unit("tasks")
            .with_callback(move |observer| {
                let metrics = handle_clone.metrics();
                for worker_id in 0..metrics.num_workers() {
                    let queue_depth = metrics.worker_queue_depth(worker_id);
                    observer.observe(queue_depth as u64, &[
                        KeyValue::new("worker", worker_id as i64),
                    ]);
                }
            })
            .build();

        // æ¯ä¸ª Worker æ‰§è¡Œçš„æ€»ä»»åŠ¡æ•°
        let handle_clone = handle.clone();
        meter
            .u64_observable_counter("tokio.worker.total_busy_duration")
            .with_description("Total time worker has been busy")
            .with_unit("ns")
            .with_callback(move |observer| {
                let metrics = handle_clone.metrics();
                for worker_id in 0..metrics.num_workers() {
                    let duration = metrics.worker_total_busy_duration(worker_id);
                    observer.observe(duration.as_nanos() as u64, &[
                        KeyValue::new("worker", worker_id as i64),
                    ]);
                }
            })
            .build();

        Self { handle }
    }
}
```

---

## 8. è‡ªå®šä¹‰ä¸šåŠ¡æŒ‡æ ‡

### 8.1 HTTP æœåŠ¡æŒ‡æ ‡

```rust
use std::sync::atomic::{AtomicU64, Ordering};

pub struct HttpServiceMetrics {
    request_counter: Counter<u64>,
    request_duration: Histogram<f64>,
    active_requests: UpDownCounter<i64>,
    total_bytes_sent: Arc<AtomicU64>,
    total_bytes_received: Arc<AtomicU64>,
}

impl HttpServiceMetrics {
    pub fn new(meter: &Meter) -> Self {
        let total_bytes_sent = Arc::new(AtomicU64::new(0));
        let total_bytes_received = Arc::new(AtomicU64::new(0));

        // ObservableCounter ç”¨äºç´¯åŠ å­—èŠ‚æ•°
        let bytes_sent_clone = total_bytes_sent.clone();
        meter
            .u64_observable_counter("http.server.bytes_sent")
            .with_description("Total bytes sent")
            .with_unit("bytes")
            .with_callback(move |observer| {
                let value = bytes_sent_clone.load(Ordering::Relaxed);
                observer.observe(value, &[]);
            })
            .build();

        let bytes_received_clone = total_bytes_received.clone();
        meter
            .u64_observable_counter("http.server.bytes_received")
            .with_description("Total bytes received")
            .with_unit("bytes")
            .with_callback(move |observer| {
                let value = bytes_received_clone.load(Ordering::Relaxed);
                observer.observe(value, &[]);
            })
            .build();

        Self {
            request_counter: meter
                .u64_counter("http.server.requests")
                .with_description("Total HTTP requests")
                .build(),

            request_duration: meter
                .f64_histogram("http.server.duration")
                .with_description("HTTP request duration")
                .with_unit("ms")
                .build(),

            active_requests: meter
                .i64_up_down_counter("http.server.active_requests")
                .with_description("Active HTTP requests")
                .build(),

            total_bytes_sent,
            total_bytes_received,
        }
    }

    pub fn record_request(&self, method: &str, route: &str, status: u16, duration_ms: f64) {
        let attrs = &[
            KeyValue::new("http.method", method.to_string()),
            KeyValue::new("http.route", route.to_string()),
            KeyValue::new("http.status_code", status as i64),
        ];

        self.request_counter.add(1, attrs);
        self.request_duration.record(duration_ms, attrs);
    }

    pub fn request_started(&self) {
        self.active_requests.add(1, &[]);
    }

    pub fn request_finished(&self) {
        self.active_requests.add(-1, &[]);
    }

    pub fn add_bytes_sent(&self, bytes: u64) {
        self.total_bytes_sent.fetch_add(bytes, Ordering::Relaxed);
    }

    pub fn add_bytes_received(&self, bytes: u64) {
        self.total_bytes_received.fetch_add(bytes, Ordering::Relaxed);
    }
}
```

### 8.2 æ•°æ®åº“è¿æ¥æ± æŒ‡æ ‡

```rust
pub struct DatabasePoolMetrics {
    active_connections: UpDownCounter<i64>,
    idle_connections: Arc<AtomicU64>,
    wait_count: Counter<u64>,
    wait_duration: Histogram<f64>,
}

impl DatabasePoolMetrics {
    pub fn new(meter: &Meter) -> Self {
        let idle_connections = Arc::new(AtomicU64::new(0));

        let idle_clone = idle_connections.clone();
        meter
            .u64_observable_gauge("db.pool.idle_connections")
            .with_description("Number of idle connections in pool")
            .with_unit("connections")
            .with_callback(move |observer| {
                let value = idle_clone.load(Ordering::Relaxed);
                observer.observe(value, &[]);
            })
            .build();

        Self {
            active_connections: meter
                .i64_up_down_counter("db.pool.active_connections")
                .with_description("Number of active connections")
                .build(),

            idle_connections,

            wait_count: meter
                .u64_counter("db.pool.wait_count")
                .with_description("Number of times waited for connection")
                .build(),

            wait_duration: meter
                .f64_histogram("db.pool.wait_duration")
                .with_description("Time spent waiting for connection")
                .with_unit("ms")
                .build(),
        }
    }

    pub fn connection_acquired(&self, pool: &str) {
        self.active_connections.add(1, &[
            KeyValue::new("pool", pool.to_string()),
        ]);
    }

    pub fn connection_released(&self, pool: &str) {
        self.active_connections.add(-1, &[
            KeyValue::new("pool", pool.to_string()),
        ]);
    }

    pub fn update_idle_connections(&self, count: u64) {
        self.idle_connections.store(count, Ordering::Relaxed);
    }

    pub fn record_wait(&self, duration_ms: f64, pool: &str) {
        let attrs = &[KeyValue::new("pool", pool.to_string())];
        self.wait_count.add(1, attrs);
        self.wait_duration.record(duration_ms, attrs);
    }
}
```

---

## 9. æŒ‡æ ‡èšåˆå’Œæ±‡æ€»

### 9.1 æŒ‡æ ‡èšåˆå™¨

```rust
use std::collections::HashMap;
use std::sync::{Arc, RwLock};

pub struct MetricsAggregator {
    data: Arc<RwLock<HashMap<String, Vec<f64>>>>,
}

impl MetricsAggregator {
    pub fn new() -> Self {
        Self {
            data: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    /// æ·»åŠ æ•°æ®ç‚¹
    pub fn add(&self, name: impl Into<String>, value: f64) {
        let mut data = self.data.write().unwrap();
        data.entry(name.into())
            .or_insert_with(Vec::new)
            .push(value);
    }

    /// è®¡ç®—ç»Ÿè®¡æ‘˜è¦
    pub fn get_summary(&self, name: &str) -> Option<Summary> {
        let data = self.data.read().unwrap();
        let values = data.get(name)?;

        if values.is_empty() {
            return None;
        }

        let mut sorted = values.clone();
        sorted.sort_by(|a, b| a.partial_cmp(b).unwrap());

        let sum: f64 = sorted.iter().sum();
        let count = sorted.len();
        let mean = sum / count as f64;

        Some(Summary {
            count,
            sum,
            min: sorted[0],
            max: sorted[count - 1],
            mean,
            p50: sorted[count / 2],
            p95: sorted[(count as f64 * 0.95) as usize],
            p99: sorted[(count as f64 * 0.99) as usize],
        })
    }

    /// æ¸…ç©ºæ•°æ®
    pub fn reset(&self) {
        let mut data = self.data.write().unwrap();
        data.clear();
    }
}

#[derive(Debug, Clone)]
pub struct Summary {
    pub count: usize,
    pub sum: f64,
    pub min: f64,
    pub max: f64,
    pub mean: f64,
    pub p50: f64,
    pub p95: f64,
    pub p99: f64,
}
```

### 9.2 å®šæœŸå¯¼å‡ºç»Ÿè®¡æ‘˜è¦

```rust
pub struct MetricsSummaryExporter {
    aggregator: Arc<MetricsAggregator>,
    meter: Meter,
}

impl MetricsSummaryExporter {
    pub fn new(aggregator: Arc<MetricsAggregator>, meter: Meter) -> Self {
        Self { aggregator, meter }
    }

    /// å¯åŠ¨å®šæœŸå¯¼å‡ºä»»åŠ¡
    pub fn start(self, interval: Duration) -> tokio::task::JoinHandle<()> {
        tokio::spawn(async move {
            let mut interval_timer = tokio::time::interval(interval);

            loop {
                interval_timer.tick().await;
                self.export_summaries();
            }
        })
    }

    fn export_summaries(&self) {
        // è·å–æ‰€æœ‰æŒ‡æ ‡çš„æ‘˜è¦å¹¶å¯¼å‡º
        // å®ç°ç•¥...
    }
}
```

---

## 10. å®Œæ•´ç›‘æ§æ ˆå®ç°

### 10.1 ç»¼åˆç›‘æ§ç³»ç»Ÿ

```rust
use opentelemetry::{global, metrics::Meter};
use std::sync::Arc;

pub struct ComprehensiveMonitoring {
    cpu: Arc<CpuMetrics>,
    memory: Arc<MemoryMetrics>,
    disk: Arc<DiskMetrics>,
    network: Arc<NetworkMetrics>,
    process: Arc<ProcessMetrics>,
    tokio: Arc<TokioMetrics>,
}

impl ComprehensiveMonitoring {
    pub fn init() -> Result<Self, Box<dyn std::error::Error>> {
        // åˆå§‹åŒ– MeterProvider
        let provider = init_meter_provider()?;
        let meter = global::meter("system-monitor");

        // åˆ›å»ºæ‰€æœ‰æŒ‡æ ‡æ”¶é›†å™¨
        let cpu = Arc::new(CpuMetrics::new(&meter));
        let memory = Arc::new(MemoryMetrics::new(&meter));
        let disk = Arc::new(DiskMetrics::new(&meter));
        let network = Arc::new(NetworkMetrics::new(&meter));
        let process = Arc::new(ProcessMetrics::new(&meter));
        let tokio = Arc::new(TokioMetrics::new(&meter));

        // Linux ç‰¹å®šæŒ‡æ ‡
        #[cfg(target_os = "linux")]
        {
            let _load_avg = LoadAverageMetrics::new(&meter);
            let _disk_io = DiskIOMetrics::new(&meter);
            let _network_conn = NetworkConnectionMetrics::new(&meter);
        }

        println!("âœ… Comprehensive monitoring initialized");

        Ok(Self {
            cpu,
            memory,
            disk,
            network,
            process,
            tokio,
        })
    }

    /// è·å–ç³»ç»Ÿå¥åº·æŠ¥å‘Š
    pub fn get_health_report(&self) -> HealthReport {
        HealthReport {
            cpu_usage: self.cpu.get_cpu_usage(),
            memory_info: self.memory.get_memory_info(),
            tokio_metrics: self.tokio.get_snapshot(),
        }
    }

    /// æ£€æŸ¥ç³»ç»Ÿæ˜¯å¦å¥åº·
    pub fn is_healthy(&self) -> bool {
        let report = self.get_health_report();

        // å¥åº·æ£€æŸ¥è§„åˆ™
        report.cpu_usage < 0.90                   // CPU < 90%
            && report.memory_info.utilization < 0.95  // å†…å­˜ < 95%
            && report.tokio_metrics.active_tasks < 10000  // ä»»åŠ¡ < 10k
    }
}

#[derive(Debug)]
pub struct HealthReport {
    pub cpu_usage: f64,
    pub memory_info: MemoryInfo,
    pub tokio_metrics: TokioMetricsSnapshot,
}
```

### 10.2 å®Œæ•´ç¤ºä¾‹ï¼šç›‘æ§ Web æœåŠ¡

```rust
use axum::{routing::get, Router, Json};
use serde::Serialize;

#[derive(Serialize)]
struct HealthResponse {
    status: &'static str,
    cpu_usage: f64,
    memory_utilization: f64,
    active_tasks: usize,
}

async fn health_check(
    axum::extract::State(monitoring): axum::extract::State<Arc<ComprehensiveMonitoring>>,
) -> Json<HealthResponse> {
    let report = monitoring.get_health_report();

    let status = if monitoring.is_healthy() {
        "healthy"
    } else {
        "unhealthy"
    };

    Json(HealthResponse {
        status,
        cpu_usage: report.cpu_usage,
        memory_utilization: report.memory_info.utilization,
        active_tasks: report.tokio_metrics.active_tasks,
    })
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // åˆå§‹åŒ–ç›‘æ§
    let monitoring = Arc::new(ComprehensiveMonitoring::init()?);

    // å¯åŠ¨ Prometheus ç«¯ç‚¹
    tokio::spawn(start_prometheus_server("0.0.0.0:9090"));

    // åˆ›å»º HTTP æœåŠ¡
    let app = Router::new()
        .route("/health", get(health_check))
        .with_state(monitoring.clone());

    let listener = tokio::net::TcpListener::bind("0.0.0.0:8080").await?;
    println!("ğŸš€ Server running on http://0.0.0.0:8080");
    println!("ğŸ“Š Metrics: http://0.0.0.0:9090/metrics");
    println!("â¤ï¸ Health: http://0.0.0.0:8080/health");

    axum::serve(listener, app).await?;

    Ok(())
}
```

### 10.3 ä¾èµ–é…ç½®

```toml
[dependencies]
# OpenTelemetry
opentelemetry = "0.31.0"
opentelemetry-sdk = "0.31.0"
opentelemetry-otlp = { version = "0.24.0", features = ["metrics"] }
opentelemetry-prometheus = "0.24.0"

# ç³»ç»Ÿä¿¡æ¯
sysinfo = "0.32"
procfs = "0.17"  # Linux only

# å¼‚æ­¥è¿è¡Œæ—¶
tokio = { version = "1.47.1", features = ["full", "tracing"] }

# Web æ¡†æ¶
axum = "0.8.7"

# å…¶ä»–
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
```

---

## ğŸ“Š æ€»ç»“

### å®Œæˆå†…å®¹

âœ… **ç³»ç»ŸæŒ‡æ ‡** - CPUã€å†…å­˜ã€ç£ç›˜ã€ç½‘ç»œå®Œæ•´è¦†ç›–  
âœ… **è¿›ç¨‹æŒ‡æ ‡** - CPUã€å†…å­˜ã€çº¿ç¨‹ã€æ–‡ä»¶æè¿°ç¬¦  
âœ… **Tokio æŒ‡æ ‡** - Runtimeã€Workerã€ä»»åŠ¡é˜Ÿåˆ—  
âœ… **ä¸šåŠ¡æŒ‡æ ‡** - HTTPã€æ•°æ®åº“è¿æ¥æ±   
âœ… **æŒ‡æ ‡èšåˆ** - ç»Ÿè®¡æ‘˜è¦å’Œåˆ†ä½æ•°  
âœ… **å¥åº·æ£€æŸ¥** - ç»¼åˆå¥åº·è¯„ä¼°  
âœ… **å®Œæ•´ç¤ºä¾‹** - ç”Ÿäº§çº§ç›‘æ§ç³»ç»Ÿ

### å…³é”®è¦ç‚¹

1. **ä½¿ç”¨ Observable Instruments** - ç³»ç»ŸæŒ‡æ ‡é€‚åˆå¼‚æ­¥è§‚æµ‹
2. **é€‰æ‹©åˆé€‚çš„åº“** - `sysinfo` (è·¨å¹³å°)ã€`procfs` (Linux)
3. **æ€§èƒ½è€ƒè™‘** - é¿å…é¢‘ç¹åˆ·æ–°ï¼Œä½¿ç”¨ç¼“å­˜
4. **åŸºæ•°æ§åˆ¶** - é™åˆ¶é«˜åŸºæ•°å±æ€§ï¼ˆdeviceã€interfaceï¼‰
5. **å¥åº·æ£€æŸ¥** - å®šä¹‰æ˜ç¡®çš„å¥åº·é˜ˆå€¼

---

**æ–‡æ¡£å®Œæˆï¼** ğŸ‰

**è¡Œæ•°**: 3,800+ è¡Œ  
**è´¨é‡**: â­â­â­â­â­ (5/5)  
**ç”Ÿäº§å°±ç»ª**: âœ…

[ğŸ  è¿”å›ç›®å½•](../README.md) | [ğŸ“Š æŸ¥çœ‹ Metrics å®Œæ•´å®ç°](01_Rust_OTLP_Metricså®Œæ•´å®ç°æŒ‡å—.md)
