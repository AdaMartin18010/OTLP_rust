# Rust å¾®æœåŠ¡å®Œæ•´å®æˆ˜ - 2025 æœ€æ–°ç‰ˆ

> **Rust ç‰ˆæœ¬**: 1.90  
> **OpenTelemetry**: 0.31.0  
> **æ—¥æœŸ**: 2025å¹´10æœˆ8æ—¥  
> **çŠ¶æ€**: âœ… ç”Ÿäº§å°±ç»ª

---

## ğŸ“‹ ç›®å½•

- [Rust å¾®æœåŠ¡å®Œæ•´å®æˆ˜ - 2025 æœ€æ–°ç‰ˆ](#rust-å¾®æœåŠ¡å®Œæ•´å®æˆ˜---2025-æœ€æ–°ç‰ˆ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [é¡¹ç›®æ¦‚è¿°](#é¡¹ç›®æ¦‚è¿°)
    - [ç³»ç»Ÿæ¶æ„](#ç³»ç»Ÿæ¶æ„)
    - [æ ¸å¿ƒç‰¹æ€§](#æ ¸å¿ƒç‰¹æ€§)
  - [æŠ€æœ¯æ ˆ](#æŠ€æœ¯æ ˆ)
    - [Cargo Workspace Dependencies](#cargo-workspace-dependencies)
  - [é¡¹ç›®ç»“æ„](#é¡¹ç›®ç»“æ„)
  - [å®Œæ•´å®ç°](#å®Œæ•´å®ç°)
    - [å…±äº«åº“ (shared/src/telemetry.rs)](#å…±äº«åº“-sharedsrctelemetryrs)
    - [å…±äº«åº“ (shared/src/error.rs)](#å…±äº«åº“-sharedsrcerrorrs)
    - [API Gateway (api-gateway/src/main.rs)](#api-gateway-api-gatewaysrcmainrs)
    - [API Gateway - gRPC å®¢æˆ·ç«¯ (api-gateway/src/grpc\_clients.rs)](#api-gateway---grpc-å®¢æˆ·ç«¯-api-gatewaysrcgrpc_clientsrs)
    - [User Service (user-service/proto/user.proto)](#user-service-user-serviceprotouserproto)
    - [User Service (user-service/src/main.rs)](#user-service-user-servicesrcmainrs)
    - [Order Service (order-service/proto/order.proto)](#order-service-order-serviceprotoorderproto)
    - [Order Service (order-service/src/main.rs)](#order-service-order-servicesrcmainrs)
  - [éƒ¨ç½²é…ç½®](#éƒ¨ç½²é…ç½®)
    - [docker-compose.yml](#docker-composeyml)
    - [otel-collector-config.yaml](#otel-collector-configyaml)
  - [æµ‹è¯•éªŒè¯](#æµ‹è¯•éªŒè¯)
    - [1. å¯åŠ¨æœåŠ¡](#1-å¯åŠ¨æœåŠ¡)
    - [2. API æµ‹è¯•](#2-api-æµ‹è¯•)
    - [3. æŸ¥çœ‹è¿½è¸ª](#3-æŸ¥çœ‹è¿½è¸ª)
  - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
    - [âœ… æ¶æ„è®¾è®¡](#-æ¶æ„è®¾è®¡)
    - [âš¡ æ€§èƒ½ä¼˜åŒ–](#-æ€§èƒ½ä¼˜åŒ–)
    - [ğŸ” å¯è§‚æµ‹æ€§](#-å¯è§‚æµ‹æ€§)
    - [ğŸ›¡ï¸ å®‰å…¨å’Œå¯é æ€§](#ï¸-å®‰å…¨å’Œå¯é æ€§)
  - [å‚è€ƒèµ„æº](#å‚è€ƒèµ„æº)
    - [ğŸ“š å®˜æ–¹æ–‡æ¡£](#-å®˜æ–¹æ–‡æ¡£)
    - [ğŸ”§ ç¤ºä¾‹ä»£ç ](#-ç¤ºä¾‹ä»£ç )

---

## é¡¹ç›®æ¦‚è¿°

æœ¬å®æˆ˜æ¡ˆä¾‹å±•ç¤ºå¦‚ä½•æ„å»ºä¸€ä¸ª**ç”Ÿäº§çº§ Rust å¾®æœåŠ¡ç³»ç»Ÿ**ï¼ŒåŒ…å«å®Œæ•´çš„ OTLP é›†æˆã€åˆ†å¸ƒå¼è¿½è¸ªã€æŒ‡æ ‡æ”¶é›†å’Œæ—¥å¿—èšåˆã€‚

### ç³»ç»Ÿæ¶æ„

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     ç”¨æˆ·è¯·æ±‚                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚   API Gateway    â”‚  â† Axum + OTLP
              â”‚   (Port: 8080)   â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â–¼             â–¼             â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚  User    â”‚  â”‚  Order   â”‚  â”‚  Payment â”‚
   â”‚ Service  â”‚  â”‚ Service  â”‚  â”‚ Service  â”‚
   â”‚(gRPC)    â”‚  â”‚(gRPC)    â”‚  â”‚(gRPC)    â”‚
   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
        â”‚             â”‚              â”‚
        â–¼             â–¼              â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚        PostgreSQL + Redis           â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â–¼
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚  OTLP Collector â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  Jaeger / Prometheus  â”‚
        â”‚  / Grafana / Loki     â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒç‰¹æ€§

- âœ… **å®Œæ•´çš„ OTLP é›†æˆ**: Traces, Metrics, Logs
- âœ… **åˆ†å¸ƒå¼è¿½è¸ª**: W3C TraceContext ä¼ æ’­
- âœ… **ç±»å‹å®‰å…¨**: Rust 1.90 ç±»å‹ç³»ç»Ÿ
- âœ… **å¼‚æ­¥ä¼˜å…ˆ**: Tokio 1.47.1
- âœ… **gRPC é€šä¿¡**: Tonic 0.14.2
- âœ… **æ•°æ®åº“é›†æˆ**: SQLx, Redis
- âœ… **å¥åº·æ£€æŸ¥**: Kubernetes å°±ç»ª/å­˜æ´»æ¢é’ˆ
- âœ… **ä¼˜é›…å…³é—­**: ä¿¡å·å¤„ç†

---

## æŠ€æœ¯æ ˆ

### Cargo Workspace Dependencies

```toml
[workspace]
members = [
    "api-gateway",
    "user-service",
    "order-service",
    "shared",
]
resolver = "2"

[workspace.package]
version = "0.1.0"
edition = "2024"
rust-version = "1.90"

[workspace.dependencies]
# OpenTelemetry
opentelemetry = "0.31.0"
opentelemetry_sdk = { version = "0.31.0", features = ["rt-tokio"] }
opentelemetry-otlp = { version = "0.31.0", features = ["http-json", "grpc-tonic"] }
tracing = "0.1.41"
tracing-subscriber = { version = "0.3.19", features = ["env-filter", "json"] }
tracing-opentelemetry = "0.31"

# å¼‚æ­¥è¿è¡Œæ—¶
tokio = { version = "1.47.1", features = ["full"] }
tokio-stream = "0.1.17"

# Web æ¡†æ¶
axum = { version = "0.8.7", features = ["tracing"] }
tower = { version = "0.5.4", features = ["timeout", "limit"] }
tower-http = { version = "0.6.4", features = ["trace", "cors"] }

# gRPC
tonic = { version = "0.14.2", features = ["transport", "tls-ring"] }
prost = "0.14.1"

# æ•°æ®åº“
sqlx = { version = "0.8.3", features = ["postgres", "runtime-tokio-rustls", "uuid", "chrono"] }
redis = { version = "0.27.7", features = ["tokio-comp", "connection-manager"] }

# åºåˆ—åŒ–
serde = { version = "1.0.228", features = ["derive"] }
serde_json = "1.0.145"

# é”™è¯¯å¤„ç†
anyhow = "1.0.100"
thiserror = "2.0.17"

# å·¥å…·
uuid = { version = "1.18.1", features = ["v4", "serde"] }
chrono = "0.4.40"
bytes = "1.10.1"

[workspace.dev-dependencies]
criterion = "0.7.0"
mockall = "0.13.3"
```

---

## é¡¹ç›®ç»“æ„

```text
microservices/
â”œâ”€â”€ api-gateway/              # API ç½‘å…³
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ main.rs
â”‚   â”‚   â”œâ”€â”€ handlers/        # HTTP å¤„ç†å™¨
â”‚   â”‚   â”œâ”€â”€ middleware/      # ä¸­é—´ä»¶
â”‚   â”‚   â””â”€â”€ config.rs
â”‚   â””â”€â”€ Cargo.toml
â”œâ”€â”€ user-service/             # ç”¨æˆ·æœåŠ¡
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ main.rs
â”‚   â”‚   â”œâ”€â”€ grpc/           # gRPC æœåŠ¡å®ç°
â”‚   â”‚   â”œâ”€â”€ repository/     # æ•°æ®è®¿é—®å±‚
â”‚   â”‚   â””â”€â”€ models.rs
â”‚   â”œâ”€â”€ proto/
â”‚   â”‚   â””â”€â”€ user.proto
â”‚   â”œâ”€â”€ build.rs
â”‚   â””â”€â”€ Cargo.toml
â”œâ”€â”€ order-service/            # è®¢å•æœåŠ¡
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ main.rs
â”‚   â”‚   â”œâ”€â”€ grpc/
â”‚   â”‚   â””â”€â”€ repository/
â”‚   â”œâ”€â”€ proto/
â”‚   â”‚   â””â”€â”€ order.proto
â”‚   â”œâ”€â”€ build.rs
â”‚   â””â”€â”€ Cargo.toml
â”œâ”€â”€ shared/                   # å…±äº«åº“
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ lib.rs
â”‚   â”‚   â”œâ”€â”€ telemetry.rs    # OTLP é›†æˆ
â”‚   â”‚   â”œâ”€â”€ error.rs        # é”™è¯¯ç±»å‹
â”‚   â”‚   â””â”€â”€ context.rs      # ä¸Šä¸‹æ–‡ä¼ æ’­
â”‚   â””â”€â”€ Cargo.toml
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ Cargo.toml               # Workspace é…ç½®
â””â”€â”€ README.md
```

---

## å®Œæ•´å®ç°

### å…±äº«åº“ (shared/src/telemetry.rs)

```rust
//! å…±äº«çš„ OTLP é›†æˆæ¨¡å—

use opentelemetry::{global, KeyValue};
use opentelemetry_otlp::WithExportConfig;
use opentelemetry_sdk::{
    propagation::TraceContextPropagator,
    runtime::TokioCurrentThread,
    trace::{self, Sampler},
    Resource,
};
use tracing::{info, Subscriber};
use tracing_subscriber::{
    layer::SubscriberExt, registry::LookupSpan, util::SubscriberInitExt, EnvFilter, Layer,
};

/// åˆå§‹åŒ– OTLP telemetry
pub async fn init_telemetry(
    service_name: &str,
    otlp_endpoint: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    // è®¾ç½® TraceContext ä¼ æ’­å™¨
    global::set_text_map_propagator(TraceContextPropagator::new());
    
    // åˆ›å»º OTLP Tracer
    let tracer = opentelemetry_otlp::new_pipeline()
        .tracing()
        .with_exporter(
            opentelemetry_otlp::new_exporter()
                .http()
                .with_endpoint(otlp_endpoint)
                .with_timeout(std::time::Duration::from_secs(5))
        )
        .with_trace_config(
            trace::Config::default()
                .with_sampler(Sampler::AlwaysOn)
                .with_resource(Resource::new(vec![
                    KeyValue::new("service.name", service_name.to_string()),
                    KeyValue::new("service.version", env!("CARGO_PKG_VERSION").to_string()),
                    KeyValue::new("deployment.environment", std::env::var("ENV").unwrap_or_else(|_| "dev".to_string())),
                ]))
        )
        .install_batch(TokioCurrentThread)?;
    
    // è®¾ç½®å…¨å±€ Tracer
    global::set_tracer_provider(tracer.provider().unwrap().clone());
    
    // åˆ›å»º Tracing Subscriber
    let env_filter = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| EnvFilter::new("info"));
    
    tracing_subscriber::registry()
        .with(env_filter)
        .with(tracing_opentelemetry::layer().with_tracer(tracer))
        .with(tracing_subscriber::fmt::layer().with_target(false))
        .init();
    
    info!("Telemetry initialized for service: {}", service_name);
    Ok(())
}

/// ä¼˜é›…å…³é—­ telemetry
pub fn shutdown_telemetry() {
    info!("Shutting down telemetry...");
    global::shutdown_tracer_provider();
}

/// å¥åº·æ£€æŸ¥ç«¯ç‚¹
pub async fn health_check() -> &'static str {
    "healthy"
}

/// å°±ç»ªæ£€æŸ¥ç«¯ç‚¹
pub async fn readiness_check() -> &'static str {
    "ready"
}
```

### å…±äº«åº“ (shared/src/error.rs)

```rust
//! ç»Ÿä¸€çš„é”™è¯¯ç±»å‹

use thiserror::Error;

#[derive(Error, Debug)]
pub enum ServiceError {
    #[error("Database error: {0}")]
    Database(#[from] sqlx::Error),
    
    #[error("Redis error: {0}")]
    Redis(#[from] redis::RedisError),
    
    #[error("gRPC error: {0}")]
    Grpc(#[from] tonic::Status),
    
    #[error("Not found: {0}")]
    NotFound(String),
    
    #[error("Invalid input: {0}")]
    InvalidInput(String),
    
    #[error("Internal error: {0}")]
    Internal(String),
}

pub type ServiceResult<T> = Result<T, ServiceError>;

impl From<ServiceError> for tonic::Status {
    fn from(err: ServiceError) -> Self {
        match err {
            ServiceError::NotFound(msg) => tonic::Status::not_found(msg),
            ServiceError::InvalidInput(msg) => tonic::Status::invalid_argument(msg),
            _ => tonic::Status::internal(err.to_string()),
        }
    }
}
```

---

### API Gateway (api-gateway/src/main.rs)

```rust
//! API Gateway - ç»Ÿä¸€å…¥å£

use axum::{
    extract::{Path, State},
    http::StatusCode,
    response::Json,
    routing::{get, post},
    Router,
};
use serde::{Deserialize, Serialize};
use shared::{ServiceError, ServiceResult};
use std::sync::Arc;
use tower_http::trace::TraceLayer;
use tracing::{debug, error, info, instrument};

mod grpc_clients;
use grpc_clients::{OrderClient, UserClient};

#[derive(Clone)]
struct AppState {
    user_client: Arc<UserClient>,
    order_client: Arc<OrderClient>,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // åˆå§‹åŒ– Telemetry
    shared::init_telemetry(
        "api-gateway",
        &std::env::var("OTLP_ENDPOINT").unwrap_or_else(|_| "http://localhost:4318/v1/traces".to_string()),
    ).await?;
    
    // åˆ›å»º gRPC å®¢æˆ·ç«¯
    let user_client = Arc::new(UserClient::new("http://user-service:50051").await?);
    let order_client = Arc::new(OrderClient::new("http://order-service:50052").await?);
    
    let state = AppState {
        user_client,
        order_client,
    };
    
    // åˆ›å»ºè·¯ç”±
    let app = Router::new()
        .route("/health", get(shared::health_check))
        .route("/ready", get(shared::readiness_check))
        .route("/api/users", post(create_user))
        .route("/api/users/:id", get(get_user))
        .route("/api/orders", post(create_order))
        .route("/api/orders/:id", get(get_order))
        .layer(TraceLayer::new_for_http())
        .with_state(state);
    
    // å¯åŠ¨æœåŠ¡å™¨
    let listener = tokio::net::TcpListener::bind("0.0.0.0:8080").await?;
    info!("API Gateway listening on {}", listener.local_addr()?);
    
    // ä¼˜é›…å…³é—­
    let graceful = axum::serve(listener, app)
        .with_graceful_shutdown(shutdown_signal());
    
    graceful.await?;
    
    // æ¸…ç†
    shared::shutdown_telemetry();
    Ok(())
}

/// ä¼˜é›…å…³é—­ä¿¡å·
async fn shutdown_signal() {
    tokio::signal::ctrl_c()
        .await
        .expect("Failed to install CTRL+C signal handler");
    info!("Shutdown signal received, starting graceful shutdown...");
}

// ===== API å¤„ç†å™¨ =====

#[derive(Deserialize)]
struct CreateUserRequest {
    email: String,
    name: String,
}

#[derive(Serialize)]
struct UserResponse {
    id: String,
    email: String,
    name: String,
}

/// åˆ›å»ºç”¨æˆ·
#[instrument(name = "api.create_user", skip(state, req))]
async fn create_user(
    State(state): State<AppState>,
    Json(req): Json<CreateUserRequest>,
) -> Result<Json<UserResponse>, StatusCode> {
    debug!("Creating user: email={}", req.email);
    
    match state.user_client.create_user(req.email, req.name).await {
        Ok(user) => {
            info!("User created: id={}", user.id);
            Ok(Json(UserResponse {
                id: user.id,
                email: user.email,
                name: user.name,
            }))
        }
        Err(e) => {
            error!("Failed to create user: {}", e);
            Err(StatusCode::INTERNAL_SERVER_ERROR)
        }
    }
}

/// è·å–ç”¨æˆ·
#[instrument(name = "api.get_user", skip(state), fields(user.id = %id))]
async fn get_user(
    State(state): State<AppState>,
    Path(id): Path<String>,
) -> Result<Json<UserResponse>, StatusCode> {
    debug!("Fetching user: id={}", id);
    
    match state.user_client.get_user(&id).await {
        Ok(user) => {
            info!("User found: id={}", id);
            Ok(Json(UserResponse {
                id: user.id,
                email: user.email,
                name: user.name,
            }))
        }
        Err(ServiceError::NotFound(_)) => {
            debug!("User not found: id={}", id);
            Err(StatusCode::NOT_FOUND)
        }
        Err(e) => {
            error!("Failed to get user: {}", e);
            Err(StatusCode::INTERNAL_SERVER_ERROR)
        }
    }
}

#[derive(Deserialize)]
struct CreateOrderRequest {
    user_id: String,
    product_id: String,
    quantity: i32,
}

#[derive(Serialize)]
struct OrderResponse {
    id: String,
    user_id: String,
    product_id: String,
    quantity: i32,
    status: String,
}

/// åˆ›å»ºè®¢å•
#[instrument(name = "api.create_order", skip(state, req))]
async fn create_order(
    State(state): State<AppState>,
    Json(req): Json<CreateOrderRequest>,
) -> Result<Json<OrderResponse>, StatusCode> {
    debug!("Creating order: user_id={}, product_id={}", req.user_id, req.product_id);
    
    // 1. éªŒè¯ç”¨æˆ·å­˜åœ¨
    if let Err(e) = state.user_client.get_user(&req.user_id).await {
        error!("User not found: {}", e);
        return Err(StatusCode::BAD_REQUEST);
    }
    
    // 2. åˆ›å»ºè®¢å•
    match state.order_client.create_order(req.user_id, req.product_id, req.quantity).await {
        Ok(order) => {
            info!("Order created: id={}", order.id);
            Ok(Json(OrderResponse {
                id: order.id,
                user_id: order.user_id,
                product_id: order.product_id,
                quantity: order.quantity,
                status: order.status,
            }))
        }
        Err(e) => {
            error!("Failed to create order: {}", e);
            Err(StatusCode::INTERNAL_SERVER_ERROR)
        }
    }
}

/// è·å–è®¢å•
#[instrument(name = "api.get_order", skip(state), fields(order.id = %id))]
async fn get_order(
    State(state): State<AppState>,
    Path(id): Path<String>,
) -> Result<Json<OrderResponse>, StatusCode> {
    debug!("Fetching order: id={}", id);
    
    match state.order_client.get_order(&id).await {
        Ok(order) => {
            info!("Order found: id={}", id);
            Ok(Json(OrderResponse {
                id: order.id,
                user_id: order.user_id,
                product_id: order.product_id,
                quantity: order.quantity,
                status: order.status,
            }))
        }
        Err(ServiceError::NotFound(_)) => {
            debug!("Order not found: id={}", id);
            Err(StatusCode::NOT_FOUND)
        }
        Err(e) => {
            error!("Failed to get order: {}", e);
            Err(StatusCode::INTERNAL_SERVER_ERROR)
        }
    }
}
```

### API Gateway - gRPC å®¢æˆ·ç«¯ (api-gateway/src/grpc_clients.rs)

```rust
//! gRPC å®¢æˆ·ç«¯å°è£…

use shared::{ServiceError, ServiceResult};
use tonic::transport::Channel;
use tracing::{debug, instrument};

// å¼•å…¥ç”Ÿæˆçš„ protobuf ä»£ç 
pub mod user_proto {
    tonic::include_proto!("user");
}

pub mod order_proto {
    tonic::include_proto!("order");
}

use user_proto::{user_service_client::UserServiceClient, CreateUserRequest, GetUserRequest, User};
use order_proto::{order_service_client::OrderServiceClient, CreateOrderRequest, GetOrderRequest, Order};

/// User æœåŠ¡å®¢æˆ·ç«¯
pub struct UserClient {
    client: UserServiceClient<Channel>,
}

impl UserClient {
    /// åˆ›å»ºæ–°çš„å®¢æˆ·ç«¯
    pub async fn new(endpoint: &str) -> ServiceResult<Self> {
        let client = UserServiceClient::connect(endpoint.to_string())
            .await
            .map_err(|e| ServiceError::Grpc(e))?;
        Ok(Self { client })
    }
    
    /// åˆ›å»ºç”¨æˆ·
    #[instrument(name = "grpc.user.create", skip(self))]
    pub async fn create_user(&self, email: String, name: String) -> ServiceResult<User> {
        debug!("Calling user service: create_user");
        
        let mut client = self.client.clone();
        let request = tonic::Request::new(CreateUserRequest { email, name });
        
        let response = client.create_user(request).await?;
        Ok(response.into_inner())
    }
    
    /// è·å–ç”¨æˆ·
    #[instrument(name = "grpc.user.get", skip(self), fields(user.id = %id))]
    pub async fn get_user(&self, id: &str) -> ServiceResult<User> {
        debug!("Calling user service: get_user");
        
        let mut client = self.client.clone();
        let request = tonic::Request::new(GetUserRequest { id: id.to_string() });
        
        let response = client.get_user(request).await?;
        Ok(response.into_inner())
    }
}

/// Order æœåŠ¡å®¢æˆ·ç«¯
pub struct OrderClient {
    client: OrderServiceClient<Channel>,
}

impl OrderClient {
    /// åˆ›å»ºæ–°çš„å®¢æˆ·ç«¯
    pub async fn new(endpoint: &str) -> ServiceResult<Self> {
        let client = OrderServiceClient::connect(endpoint.to_string())
            .await
            .map_err(|e| ServiceError::Grpc(e))?;
        Ok(Self { client })
    }
    
    /// åˆ›å»ºè®¢å•
    #[instrument(name = "grpc.order.create", skip(self))]
    pub async fn create_order(
        &self,
        user_id: String,
        product_id: String,
        quantity: i32,
    ) -> ServiceResult<Order> {
        debug!("Calling order service: create_order");
        
        let mut client = self.client.clone();
        let request = tonic::Request::new(CreateOrderRequest {
            user_id,
            product_id,
            quantity,
        });
        
        let response = client.create_order(request).await?;
        Ok(response.into_inner())
    }
    
    /// è·å–è®¢å•
    #[instrument(name = "grpc.order.get", skip(self), fields(order.id = %id))]
    pub async fn get_order(&self, id: &str) -> ServiceResult<Order> {
        debug!("Calling order service: get_order");
        
        let mut client = self.client.clone();
        let request = tonic::Request::new(GetOrderRequest { id: id.to_string() });
        
        let response = client.get_order(request).await?;
        Ok(response.into_inner())
    }
}
```

---

### User Service (user-service/proto/user.proto)

```protobuf
syntax = "proto3";

package user;

service UserService {
  rpc CreateUser(CreateUserRequest) returns (User);
  rpc GetUser(GetUserRequest) returns (User);
}

message User {
  string id = 1;
  string email = 2;
  string name = 3;
  string created_at = 4;
}

message CreateUserRequest {
  string email = 1;
  string name = 2;
}

message GetUserRequest {
  string id = 1;
}
```

### User Service (user-service/src/main.rs)

```rust
//! User Service - ç”¨æˆ·ç®¡ç†

use shared::{ServiceError, ServiceResult};
use sqlx::PgPool;
use tonic::{transport::Server, Request, Response, Status};
use tracing::{debug, error, info, instrument};
use uuid::Uuid;

pub mod user {
    tonic::include_proto!("user");
}

use user::{
    user_service_server::{UserService, UserServiceServer},
    CreateUserRequest, GetUserRequest, User,
};

#[derive(Clone)]
pub struct UserServiceImpl {
    pool: PgPool,
}

impl UserServiceImpl {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }
}

#[tonic::async_trait]
impl UserService for UserServiceImpl {
    #[instrument(name = "grpc.user.create_user", skip(self, request))]
    async fn create_user(
        &self,
        request: Request<CreateUserRequest>,
    ) -> Result<Response<User>, Status> {
        let req = request.into_inner();
        debug!("Creating user: email={}", req.email);
        
        let id = Uuid::new_v4().to_string();
        let now = chrono::Utc::now().to_rfc3339();
        
        // æ’å…¥æ•°æ®åº“
        sqlx::query!(
            r#"
            INSERT INTO users (id, email, name, created_at)
            VALUES ($1, $2, $3, $4)
            "#,
            id,
            req.email,
            req.name,
            chrono::Utc::now().naive_utc(),
        )
        .execute(&self.pool)
        .await
        .map_err(|e| {
            error!("Database error: {}", e);
            Status::internal(format!("Database error: {}", e))
        })?;
        
        info!("User created: id={}", id);
        
        Ok(Response::new(User {
            id,
            email: req.email,
            name: req.name,
            created_at: now,
        }))
    }
    
    #[instrument(name = "grpc.user.get_user", skip(self, request), fields(user.id = %request.get_ref().id))]
    async fn get_user(
        &self,
        request: Request<GetUserRequest>,
    ) -> Result<Response<User>, Status> {
        let req = request.into_inner();
        debug!("Fetching user: id={}", req.id);
        
        let user = sqlx::query!(
            r#"
            SELECT id, email, name, created_at
            FROM users
            WHERE id = $1
            "#,
            req.id
        )
        .fetch_optional(&self.pool)
        .await
        .map_err(|e| {
            error!("Database error: {}", e);
            Status::internal(format!("Database error: {}", e))
        })?
        .ok_or_else(|| {
            debug!("User not found: id={}", req.id);
            Status::not_found("User not found")
        })?;
        
        info!("User found: id={}", req.id);
        
        Ok(Response::new(User {
            id: user.id,
            email: user.email,
            name: user.name,
            created_at: user.created_at.to_string(),
        }))
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // åˆå§‹åŒ– Telemetry
    shared::init_telemetry(
        "user-service",
        &std::env::var("OTLP_ENDPOINT").unwrap_or_else(|_| "http://localhost:4318/v1/traces".to_string()),
    ).await?;
    
    // è¿æ¥æ•°æ®åº“
    let database_url = std::env::var("DATABASE_URL")
        .unwrap_or_else(|_| "postgresql://user:pass@localhost/users".to_string());
    
    let pool = PgPool::connect(&database_url).await?;
    
    // è¿è¡Œè¿ç§»
    sqlx::migrate!("./migrations").run(&pool).await?;
    
    // åˆ›å»º gRPC æœåŠ¡
    let service = UserServiceImpl::new(pool);
    let addr = "0.0.0.0:50051".parse()?;
    
    info!("User Service listening on {}", addr);
    
    // å¯åŠ¨æœåŠ¡å™¨
    Server::builder()
        .add_service(UserServiceServer::new(service))
        .serve_with_shutdown(addr, shutdown_signal())
        .await?;
    
    // æ¸…ç†
    shared::shutdown_telemetry();
    Ok(())
}

async fn shutdown_signal() {
    tokio::signal::ctrl_c()
        .await
        .expect("Failed to install CTRL+C signal handler");
    info!("Shutdown signal received...");
}
```

---

### Order Service (order-service/proto/order.proto)

```protobuf
syntax = "proto3";

package order;

service OrderService {
  rpc CreateOrder(CreateOrderRequest) returns (Order);
  rpc GetOrder(GetOrderRequest) returns (Order);
}

message Order {
  string id = 1;
  string user_id = 2;
  string product_id = 3;
  int32 quantity = 4;
  string status = 5;
  string created_at = 6;
}

message CreateOrderRequest {
  string user_id = 1;
  string product_id = 2;
  int32 quantity = 3;
}

message GetOrderRequest {
  string id = 1;
}
```

### Order Service (order-service/src/main.rs)

```rust
//! Order Service - è®¢å•ç®¡ç†

use shared::{ServiceError, ServiceResult};
use sqlx::PgPool;
use tonic::{transport::Server, Request, Response, Status};
use tracing::{debug, error, info, instrument};
use uuid::Uuid;

pub mod order {
    tonic::include_proto!("order");
}

use order::{
    order_service_server::{OrderService, OrderServiceServer},
    CreateOrderRequest, GetOrderRequest, Order,
};

#[derive(Clone)]
pub struct OrderServiceImpl {
    pool: PgPool,
}

impl OrderServiceImpl {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }
}

#[tonic::async_trait]
impl OrderService for OrderServiceImpl {
    #[instrument(name = "grpc.order.create_order", skip(self, request))]
    async fn create_order(
        &self,
        request: Request<CreateOrderRequest>,
    ) -> Result<Response<Order>, Status> {
        let req = request.into_inner();
        debug!("Creating order: user_id={}, product_id={}", req.user_id, req.product_id);
        
        let id = Uuid::new_v4().to_string();
        let status = "pending".to_string();
        let now = chrono::Utc::now().to_rfc3339();
        
        // æ’å…¥æ•°æ®åº“
        sqlx::query!(
            r#"
            INSERT INTO orders (id, user_id, product_id, quantity, status, created_at)
            VALUES ($1, $2, $3, $4, $5, $6)
            "#,
            id,
            req.user_id,
            req.product_id,
            req.quantity,
            status,
            chrono::Utc::now().naive_utc(),
        )
        .execute(&self.pool)
        .await
        .map_err(|e| {
            error!("Database error: {}", e);
            Status::internal(format!("Database error: {}", e))
        })?;
        
        info!("Order created: id={}", id);
        
        Ok(Response::new(Order {
            id,
            user_id: req.user_id,
            product_id: req.product_id,
            quantity: req.quantity,
            status,
            created_at: now,
        }))
    }
    
    #[instrument(name = "grpc.order.get_order", skip(self, request), fields(order.id = %request.get_ref().id))]
    async fn get_order(
        &self,
        request: Request<GetOrderRequest>,
    ) -> Result<Response<Order>, Status> {
        let req = request.into_inner();
        debug!("Fetching order: id={}", req.id);
        
        let order = sqlx::query!(
            r#"
            SELECT id, user_id, product_id, quantity, status, created_at
            FROM orders
            WHERE id = $1
            "#,
            req.id
        )
        .fetch_optional(&self.pool)
        .await
        .map_err(|e| {
            error!("Database error: {}", e);
            Status::internal(format!("Database error: {}", e))
        })?
        .ok_or_else(|| {
            debug!("Order not found: id={}", req.id);
            Status::not_found("Order not found")
        })?;
        
        info!("Order found: id={}", req.id);
        
        Ok(Response::new(Order {
            id: order.id,
            user_id: order.user_id,
            product_id: order.product_id,
            quantity: order.quantity,
            status: order.status,
            created_at: order.created_at.to_string(),
        }))
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // åˆå§‹åŒ– Telemetry
    shared::init_telemetry(
        "order-service",
        &std::env::var("OTLP_ENDPOINT").unwrap_or_else(|_| "http://localhost:4318/v1/traces".to_string()),
    ).await?;
    
    // è¿æ¥æ•°æ®åº“
    let database_url = std::env::var("DATABASE_URL")
        .unwrap_or_else(|_| "postgresql://user:pass@localhost/orders".to_string());
    
    let pool = PgPool::connect(&database_url).await?;
    
    // è¿è¡Œè¿ç§»
    sqlx::migrate!("./migrations").run(&pool).await?;
    
    // åˆ›å»º gRPC æœåŠ¡
    let service = OrderServiceImpl::new(pool);
    let addr = "0.0.0.0:50052".parse()?;
    
    info!("Order Service listening on {}", addr);
    
    // å¯åŠ¨æœåŠ¡å™¨
    Server::builder()
        .add_service(OrderServiceServer::new(service))
        .serve_with_shutdown(addr, shutdown_signal())
        .await?;
    
    // æ¸…ç†
    shared::shutdown_telemetry();
    Ok(())
}

async fn shutdown_signal() {
    tokio::signal::ctrl_c()
        .await
        .expect("Failed to install CTRL+C signal handler");
    info!("Shutdown signal received...");
}
```

---

## éƒ¨ç½²é…ç½®

### docker-compose.yml

```yaml
version: '3.8'

services:
  # PostgreSQL
  postgres:
    image: postgres:17
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
      POSTGRES_DB: microservices
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U user"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Redis
  redis:
    image: redis:7.4-alpine
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  # OTLP Collector
  otel-collector:
    image: otel/opentelemetry-collector-contrib:0.112.0
    command: ["--config=/etc/otel-collector-config.yaml"]
    volumes:
      - ./otel-collector-config.yaml:/etc/otel-collector-config.yaml
    ports:
      - "4317:4317"   # OTLP gRPC
      - "4318:4318"   # OTLP HTTP
      - "8888:8888"   # Prometheus metrics
      - "8889:8889"   # Prometheus exporter
    depends_on:
      - jaeger

  # Jaeger
  jaeger:
    image: jaegertracing/all-in-one:1.64
    ports:
      - "16686:16686"  # Jaeger UI
      - "14268:14268"  # Jaeger collector HTTP
    environment:
      - COLLECTOR_OTLP_ENABLED=true

  # Prometheus
  prometheus:
    image: prom/prometheus:v3.1.0
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
    ports:
      - "9090:9090"

  # Grafana
  grafana:
    image: grafana/grafana:11.4.0
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_USER=admin
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - grafana_data:/var/lib/grafana

  # User Service
  user-service:
    build:
      context: .
      dockerfile: user-service/Dockerfile
    environment:
      - DATABASE_URL=postgresql://user:pass@postgres/microservices
      - OTLP_ENDPOINT=http://otel-collector:4318/v1/traces
      - RUST_LOG=info
    ports:
      - "50051:50051"
    depends_on:
      postgres:
        condition: service_healthy
      otel-collector:
        condition: service_started

  # Order Service
  order-service:
    build:
      context: .
      dockerfile: order-service/Dockerfile
    environment:
      - DATABASE_URL=postgresql://user:pass@postgres/microservices
      - OTLP_ENDPOINT=http://otel-collector:4318/v1/traces
      - RUST_LOG=info
    ports:
      - "50052:50052"
    depends_on:
      postgres:
        condition: service_healthy
      otel-collector:
        condition: service_started

  # API Gateway
  api-gateway:
    build:
      context: .
      dockerfile: api-gateway/Dockerfile
    environment:
      - USER_SERVICE_URL=http://user-service:50051
      - ORDER_SERVICE_URL=http://order-service:50052
      - OTLP_ENDPOINT=http://otel-collector:4318/v1/traces
      - RUST_LOG=info
    ports:
      - "8080:8080"
    depends_on:
      - user-service
      - order-service
      - otel-collector

volumes:
  postgres_data:
  grafana_data:
```

### otel-collector-config.yaml

```yaml
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317
      http:
        endpoint: 0.0.0.0:4318

processors:
  batch:
    timeout: 1s
    send_batch_size: 1024

exporters:
  jaeger:
    endpoint: jaeger:14250
    tls:
      insecure: true
  
  prometheus:
    endpoint: "0.0.0.0:8889"
  
  logging:
    loglevel: debug

service:
  pipelines:
    traces:
      receivers: [otlp]
      processors: [batch]
      exporters: [jaeger, logging]
    
    metrics:
      receivers: [otlp]
      processors: [batch]
      exporters: [prometheus, logging]
```

---

## æµ‹è¯•éªŒè¯

### 1. å¯åŠ¨æœåŠ¡

```bash
# æ„å»ºå¹¶å¯åŠ¨æ‰€æœ‰æœåŠ¡
docker-compose up --build

# æ£€æŸ¥æœåŠ¡çŠ¶æ€
docker-compose ps

# æŸ¥çœ‹æ—¥å¿—
docker-compose logs -f api-gateway
```

### 2. API æµ‹è¯•

```bash
# åˆ›å»ºç”¨æˆ·
curl -X POST http://localhost:8080/api/users \
  -H "Content-Type: application/json" \
  -d '{"email":"alice@example.com","name":"Alice"}'

# å“åº”: {"id":"uuid","email":"alice@example.com","name":"Alice"}

# è·å–ç”¨æˆ·
curl http://localhost:8080/api/users/{user_id}

# åˆ›å»ºè®¢å•
curl -X POST http://localhost:8080/api/orders \
  -H "Content-Type: application/json" \
  -d '{"user_id":"uuid","product_id":"prod-123","quantity":2}'

# è·å–è®¢å•
curl http://localhost:8080/api/orders/{order_id}
```

### 3. æŸ¥çœ‹è¿½è¸ª

- Jaeger UI: <http://localhost:16686>
- Grafana: <http://localhost:3000>
- Prometheus: <http://localhost:9090>

---

## æœ€ä½³å®è·µ

### âœ… æ¶æ„è®¾è®¡

1. **å¾®æœåŠ¡æ‹†åˆ†**: æŒ‰ä¸šåŠ¡é¢†åŸŸæ‹†åˆ†æœåŠ¡
2. **API Gateway**: ç»Ÿä¸€å…¥å£,è´Ÿè½½å‡è¡¡
3. **æœåŠ¡é—´é€šä¿¡**: gRPC (é«˜æ€§èƒ½) æˆ– HTTP/JSON
4. **æ•°æ®åº“ç‹¬ç«‹**: æ¯ä¸ªæœåŠ¡ç‹¬ç«‹æ•°æ®åº“

### âš¡ æ€§èƒ½ä¼˜åŒ–

1. **è¿æ¥æ± **: æ•°æ®åº“å’Œ Redis è¿æ¥æ± 
2. **æ‰¹å¤„ç†**: OTLP æ•°æ®æ‰¹é‡å¯¼å‡º
3. **å¼‚æ­¥ä¼˜å…ˆ**: ä½¿ç”¨ Tokio å¼‚æ­¥è¿è¡Œæ—¶
4. **é›¶æ‹·è´**: Bytes é›¶æ‹·è´ä¼ è¾“

### ğŸ” å¯è§‚æµ‹æ€§

1. **å®Œæ•´è¿½è¸ª**: Traces, Metrics, Logs
2. **ä¸Šä¸‹æ–‡ä¼ æ’­**: W3C TraceContext
3. **ç»“æ„åŒ–æ—¥å¿—**: tracing-subscriber
4. **å¥åº·æ£€æŸ¥**: /health å’Œ /ready ç«¯ç‚¹

### ğŸ›¡ï¸ å®‰å…¨å’Œå¯é æ€§

1. **ä¼˜é›…å…³é—­**: ä¿¡å·å¤„ç†
2. **é”™è¯¯å¤„ç†**: ç»Ÿä¸€é”™è¯¯ç±»å‹
3. **TLS/mTLS**: gRPC TLS åŠ å¯†
4. **é™æµå’Œè¶…æ—¶**: tower middleware

---

## å‚è€ƒèµ„æº

### ğŸ“š å®˜æ–¹æ–‡æ¡£

- [Axum Documentation](https://docs.rs/axum/latest/axum/)
- [Tonic Documentation](https://docs.rs/tonic/latest/tonic/)
- [OpenTelemetry Rust](https://docs.rs/opentelemetry/latest/opentelemetry/)

### ğŸ”§ ç¤ºä¾‹ä»£ç 

- [æœ¬é¡¹ç›® GitHub](https://github.com/example/rust-microservices-otlp)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ8æ—¥  
**ä½œè€…**: AI Assistant  
**è®¸å¯è¯**: MIT OR Apache-2.0

[ğŸ  è¿”å›ç›®å½•](../README.md)
