# ğŸŠ Rust OTLP æ–‡æ¡£ - ç¬¬äºŒè½®å®Œæˆæ€»ç»“

> **å®Œæˆæ—¶é—´**: 2025-10-08  
> **å·¥ä½œé˜¶æ®µ**: æŒç»­ä¼˜åŒ–ä¸æ‰©å±•ï¼ˆç¬¬äºŒè½®ï¼‰  
> **é¡¹ç›®çŠ¶æ€**: è¿›è¡Œä¸­ âœ¨  
> **Rust ç‰ˆæœ¬**: 1.90 (2024 Edition)  
> **OTLP ç‰ˆæœ¬**: 0.31.0

---

## ğŸ¯ æœ¬è½®å·¥ä½œæ€»è§ˆ

### æ–°å¢æ–‡æ¡£æ•°é‡

**âœ… 5 ä¸ªå…¨æ–°æ–‡æ¡£** | **ğŸ“ çº¦ 38,000 å­—** | **ğŸ’» çº¦ 6,500 è¡Œä»£ç **

---

## ğŸ“š æ–°å¢æ–‡æ¡£æ¸…å•

### 1. MongoDB æ•°æ®åº“è¿½è¸ª - Rust å®Œæ•´ç‰ˆ

**æ–‡ä»¶**: `02_Semantic_Conventions/05_æ•°æ®åº“å±æ€§/04_MongoDB_æ•°æ®åº“è¿½è¸ª_Rustå®Œæ•´ç‰ˆ.md`

**æ ¸å¿ƒå†…å®¹**:
- âœ… MongoDB 3.2.0 å®¢æˆ·ç«¯å®Œæ•´é›†æˆ
- âœ… CRUD æ“ä½œè¿½è¸ªï¼ˆinsert, find, update, deleteï¼‰
- âœ… èšåˆç®¡é“è¿½è¸ªï¼ˆ$group, $bucket, $match, $sortï¼‰
- âœ… äº‹åŠ¡æ“ä½œè¿½è¸ªï¼ˆbegin, commit, rollbackï¼‰
- âœ… æ‰¹é‡æ“ä½œï¼ˆinsertMany, updateMany, deleteManyï¼‰
- âœ… ç´¢å¼•ç®¡ç†ï¼ˆcreateIndexes, å”¯ä¸€ç´¢å¼•ã€å¤åˆç´¢å¼•ï¼‰
- âœ… è¿æ¥æ± ç›‘æ§ï¼ˆtotal/available/in-use connectionsï¼‰
- âœ… æŸ¥è¯¢æ€§èƒ½è¿½è¸ªï¼ˆæ…¢æŸ¥è¯¢æ£€æµ‹ > 100msï¼‰
- âœ… å¹¶å‘æ‰¹å¤„ç†ï¼ˆbuffer_unordered ä¼˜åŒ–ï¼‰
- âœ… é”™è¯¯å¤„ç†ï¼ˆè‡ªå®šä¹‰é”™è¯¯ç±»å‹ + Span è®°å½•ï¼‰
- âœ… æµ‹è¯•æ”¯æŒï¼ˆtestcontainers + MongoDBï¼‰

**æŠ€æœ¯äº®ç‚¹**:
```rust
// äº‹åŠ¡è¿½è¸ª
#[instrument(fields(
    db.system = "mongodb",
    db.operation = "transaction",
    transaction.from = %from_user_id,
    transaction.to = %to_user_id,
    transaction.amount = amount
))]
pub async fn transfer_points(
    &self,
    session: &mut ClientSession,
    from_user_id: &ObjectId,
    to_user_id: &ObjectId,
    amount: i32,
) -> Result<()>

// èšåˆç»Ÿè®¡
pub async fn get_age_statistics(&self) -> Result<Vec<AgeStats>> {
    let pipeline = vec![
        doc! {
            "$group": {
                "_id": null,
                "count": { "$sum": 1 },
                "avg_age": { "$avg": "$age" },
                "min_age": { "$min": "$age" },
                "max_age": { "$max": "$age" }
            }
        },
    ];
    // ...
}
```

---

### 2. Apache Pulsar - Rust å®Œæ•´å®ç°

**æ–‡ä»¶**: `02_Semantic_Conventions/03_æ¶ˆæ¯é˜Ÿåˆ—å±æ€§/05_Apache_Pulsar_Rust.md`

**æ ¸å¿ƒå†…å®¹**:
- âœ… Pulsar 6.4.0 å®¢æˆ·ç«¯é›†æˆ
- âœ… ç”Ÿäº§è€…è¿½è¸ªï¼ˆå•æ¡ã€æ‰¹é‡ã€å»¶è¿Ÿæ¶ˆæ¯ï¼‰
- âœ… æ¶ˆè´¹è€…è¿½è¸ªï¼ˆShared/Exclusive/Failover è®¢é˜…ï¼‰
- âœ… Reader æ¨¡å¼è¿½è¸ªï¼ˆå†å²æ¶ˆæ¯è¯»å–ï¼‰
- âœ… åˆ†åŒºä¸»é¢˜æ”¯æŒï¼ˆpartition_key è·¯ç”±ï¼‰
- âœ… Schema æ”¯æŒï¼ˆJSON Schemaã€Avroã€Protobufï¼‰
- âœ… æ­»ä¿¡é˜Ÿåˆ—ï¼ˆDLQï¼‰é›†æˆ
- âœ… ç§Ÿæˆ·/å‘½åç©ºé—´ç®¡ç†ï¼ˆmulti-tenancyï¼‰
- âœ… æ‰¹é‡å‘é€ä¼˜åŒ–ï¼ˆæ—¶é—´çª—å£ 100ms + æ‰¹é‡å¤§å° 100ï¼‰
- âœ… è¿æ¥æ± å¤ç”¨ï¼ˆArc<Pulsar>ï¼‰

**æŠ€æœ¯äº®ç‚¹**:
```rust
// Pulsar ä¸»é¢˜æ„å»ºå™¨ï¼ˆç±»å‹å®‰å…¨ï¼‰
let topic = PulsarTopicBuilder::new()
    .tenant("my-tenant")
    .namespace("production")
    .topic_name("order-events")
    .build();
// è¾“å‡º: persistent://my-tenant/production/order-events

// å»¶è¿Ÿæ¶ˆæ¯å‘é€
pub async fn send_delayed(
    &self,
    topic: &str,
    event: OrderEvent,
    delay_seconds: u64,
) -> Result<SendFuture> {
    let message = Message {
        payload: serde_json::to_vec(&event)?,
        deliver_at_time: Some(now_ms + delay_seconds * 1000),
        ..Default::default()
    };
    producer.send(message).await
}

// DLQ é…ç½®
let consumer = client
    .consumer()
    .with_dead_letter_policy(
        DeadLetterPolicy::builder()
            .max_redeliver_count(3)
            .dead_letter_topic("dlq-topic")
            .build()
    )
    .build()
    .await?;
```

---

### 3. AWS SQS/SNS - Rust å®Œæ•´å®ç°

**æ–‡ä»¶**: `02_Semantic_Conventions/03_æ¶ˆæ¯é˜Ÿåˆ—å±æ€§/06_AWS_SQS_SNS_Rust.md`

**æ ¸å¿ƒå†…å®¹**:
- âœ… AWS SDK for Rust é›†æˆï¼ˆaws-sdk-sqs 1.76, aws-sdk-sns 1.79ï¼‰
- âœ… SQS æ ‡å‡†é˜Ÿåˆ—ï¼ˆå‘é€ã€æ¥æ”¶ã€åˆ é™¤ã€æ‰¹é‡æ“ä½œï¼‰
- âœ… SQS FIFO é˜Ÿåˆ—ï¼ˆæ¶ˆæ¯ç»„ IDã€å»é‡ IDï¼‰
- âœ… SNS å‘å¸ƒ/è®¢é˜…ï¼ˆæ¶ˆæ¯å‘å¸ƒã€ä¸»é¢˜åˆ›å»ºã€è®¢é˜…ç®¡ç†ï¼‰
- âœ… SNS æ¶ˆæ¯è¿‡æ»¤ï¼ˆMessageAttributes è¿‡æ»¤ç­–ç•¥ï¼‰
- âœ… æ‰‡å‡ºæ¨¡å¼ï¼ˆSNS â†’ å¤šä¸ª SQSï¼‰
- âœ… æ­»ä¿¡é˜Ÿåˆ—ï¼ˆDLQï¼‰å¤„ç†
- âœ… é•¿è½®è¯¢ä¼˜åŒ–ï¼ˆwait_time_seconds = 20ï¼‰
- âœ… å¹¶å‘æ¶ˆè´¹ï¼ˆbuffer_unorderedï¼‰
- âœ… æŒ‡æ•°é€€é¿é‡è¯•ç­–ç•¥
- âœ… æ¶ˆæ¯å»é‡ï¼ˆHashSet ç¼“å­˜ï¼‰
- âœ… å¯è§æ€§è¶…æ—¶ç®¡ç†

**æŠ€æœ¯äº®ç‚¹**:
```rust
// FIFO é˜Ÿåˆ—å‘é€ï¼ˆä¿è¯é¡ºåº + å»é‡ï¼‰
pub async fn send_to_fifo(
    &self,
    queue_url: &str,
    queue_name: &str,
    message: OrderMessage,
    message_group_id: &str,
    deduplication_id: Option<&str>,
) -> Result<String> {
    let mut send_builder = self.client
        .send_message()
        .queue_url(queue_url)
        .message_body(serde_json::to_string(&message)?)
        .message_group_id(message_group_id);

    if let Some(dedup_id) = deduplication_id {
        send_builder = send_builder.message_deduplication_id(dedup_id);
    }

    send_builder.send().await
}

// SNS æ‰‡å‡ºé›†æˆ
pub struct FanoutIntegration {
    sns_client: TracedSnsClient,
    sqs_clients: Vec<TracedSqsClient>,
}

// SNS åˆ° SQS è®¢é˜…
subscription_arn = sns_client
    .subscribe(topic_arn, "sqs", queue_arn)
    .await?;

// å¹¶å‘æ¶ˆè´¹ï¼ˆæœ€å¤š 10 ä¸ªå¹¶å‘ï¼‰
pub async fn consume_concurrent<F, Fut>(
    &self,
    queue_url: &str,
    queue_name: &str,
    concurrency: usize,
    handler: F,
) -> Result<()>
where
    F: Fn(OrderMessage) -> Fut + Clone + Send + 'static,
    Fut: Future<Output = Result<(), anyhow::Error>> + Send,
{
    stream::iter(messages)
        .map(|msg| /* ... */)
        .buffer_unordered(concurrency)
        .collect::<Vec<_>>()
        .await;
}
```

---

### 4. Elasticsearch è¿½è¸ª - Rust å®Œæ•´å®ç°

**æ–‡ä»¶**: `02_Semantic_Conventions/07_æœç´¢å¼•æ“å±æ€§/01_Elasticsearch_Rustå®Œæ•´ç‰ˆ.md`

**æ ¸å¿ƒå†…å®¹**:
- âœ… Elasticsearch 8.20.0 å®¢æˆ·ç«¯é›†æˆ
- âœ… ç´¢å¼•ç®¡ç†ï¼ˆåˆ›å»ºã€åˆ é™¤ã€æ£€æŸ¥å­˜åœ¨ï¼‰
- âœ… æ–‡æ¡£æ“ä½œï¼ˆCRUD - Create, Read, Update, Deleteï¼‰
- âœ… æœç´¢åŠŸèƒ½ï¼ˆMatch, Term, Range, Bool æŸ¥è¯¢ï¼‰
- âœ… æ‰¹é‡æ“ä½œï¼ˆBulk API - index, deleteï¼‰
- âœ… èšåˆåˆ†æï¼ˆTerms, Stats, Histogramï¼‰
- âœ… ç´¢å¼•æ˜ å°„å®šä¹‰ï¼ˆmapping configurationï¼‰
- âœ… æ‰¹é‡ç´¢å¼•ä¼˜åŒ–ï¼ˆæ—¶é—´çª—å£ + æ‰¹é‡å¤§å°ï¼‰
- âœ… å¹¶å‘æœç´¢ï¼ˆbuffer_unorderedï¼‰
- âœ… é”™è¯¯é‡è¯•ç­–ç•¥ï¼ˆæŒ‡æ•°é€€é¿ï¼‰

**æŠ€æœ¯äº®ç‚¹**:
```rust
// Match æŸ¥è¯¢ï¼ˆå…¨æ–‡æœç´¢ï¼‰
pub async fn match_query(
    &self,
    index_name: &str,
    field: &str,
    value: &str,
) -> Result<Vec<Product>> {
    let query = json!({
        "match": {
            field: value
        }
    });
    self.search(index_name, query, Some(100)).await
}

// Bool æŸ¥è¯¢ï¼ˆç»„åˆæŸ¥è¯¢ï¼‰
pub async fn bool_query(
    &self,
    index_name: &str,
    must: Vec<serde_json::Value>,
    should: Vec<serde_json::Value>,
    must_not: Vec<serde_json::Value>,
) -> Result<Vec<Product>> {
    let query = json!({
        "bool": {
            "must": must,
            "should": should,
            "must_not": must_not
        }
    });
    self.search(index_name, query, Some(100)).await
}

// Bulk æ‰¹é‡ç´¢å¼•ï¼ˆé«˜æ€§èƒ½ï¼‰
pub async fn bulk_index(
    &self,
    index_name: &str,
    documents: Vec<(String, Product)>,
) -> Result<usize> {
    let mut body: Vec<serde_json::Value> = Vec::new();
    for (doc_id, product) in documents {
        body.push(json!({ "index": { "_id": doc_id } }));
        body.push(serde_json::to_value(&product)?);
    }
    self.client.bulk(BulkParts::Index(index_name))
        .body(body)
        .send()
        .await
}

// Terms èšåˆï¼ˆåˆ†ç»„ç»Ÿè®¡ï¼‰
pub async fn terms_aggregation(
    &self,
    index_name: &str,
    field: &str,
    size: i64,
) -> Result<Vec<(String, i64)>> {
    let aggs = json!({
        "terms_agg": {
            "terms": {
                "field": field,
                "size": size
            }
        }
    });
    self.aggregate(index_name, aggs).await
}
```

---

### 5. HTTP å®¢æˆ·ç«¯è¿½è¸ª - Reqwest ä¸­é—´ä»¶å®Œæ•´å®ç°

**æ–‡ä»¶**: `04_æ ¸å¿ƒç»„ä»¶/08_HTTP_å®¢æˆ·ç«¯è¿½è¸ª_Reqwest_ä¸­é—´ä»¶å®Œæ•´ç‰ˆ.md`

**æ ¸å¿ƒå†…å®¹**:
- âœ… Reqwest 0.12.23 + reqwest-middleware é›†æˆ
- âœ… HTTP è¯­ä¹‰çº¦å®šå®Œæ•´å®ç°
- âœ… è¿½è¸ªä¸­é—´ä»¶ï¼ˆè‡ªåŠ¨æ³¨å…¥ W3C Trace Contextï¼‰
- âœ… é‡è¯•ä¸­é—´ä»¶ï¼ˆæŒ‡æ•°é€€é¿ç­–ç•¥ï¼‰
- âœ… ç¼“å­˜ä¸­é—´ä»¶ï¼ˆå†…å­˜ç¼“å­˜ GET è¯·æ±‚ï¼‰
- âœ… è®¤è¯ä¸­é—´ä»¶ï¼ˆBearer Tokenã€API Keyï¼‰
- âœ… æ€§èƒ½ç›‘æ§ä¸­é—´ä»¶ï¼ˆå»¶è¿Ÿã€é”™è¯¯ç‡ç»Ÿè®¡ï¼‰
- âœ… ä¸­é—´ä»¶ç»„åˆï¼ˆå¯ç»„åˆçš„ä¸­é—´ä»¶é“¾ï¼‰
- âœ… é”™è¯¯å¤„ç†ï¼ˆè‡ªå®šä¹‰é”™è¯¯ç±»å‹ï¼‰

**æŠ€æœ¯äº®ç‚¹**:
```rust
// è¿½è¸ªä¸­é—´ä»¶ï¼ˆè‡ªåŠ¨æ³¨å…¥è¿½è¸ªä¸Šä¸‹æ–‡ï¼‰
#[async_trait]
impl Middleware for TracingMiddleware {
    async fn handle(
        &self,
        mut req: Request,
        extensions: &mut http::Extensions,
        next: Next<'_>,
    ) -> Result<Response> {
        // åˆ›å»º Span
        let span = info_span!(
            "http_client_request",
            "otel.kind" = "client",
            "http.request.method" = %req.method(),
            "url.full" = %req.url(),
        );

        // æ³¨å…¥è¿½è¸ªä¸Šä¸‹æ–‡åˆ° HTTP å¤´
        let cx = Context::current();
        global::get_text_map_propagator(|propagator| {
            propagator.inject_context(&cx, &mut HeaderInjector(req.headers_mut()));
        });

        next.run(req, extensions).await
    }
}

// é‡è¯•ä¸­é—´ä»¶ï¼ˆå¸¦è¿½è¸ªï¼‰
pub struct TracedRetryMiddleware {
    max_retries: u32,
}

impl TracedRetryMiddleware {
    async fn handle(&self, req: Request, ...) -> Result<Response> {
        for retry in 0..=self.max_retries {
            match next.run(req.try_clone()?, extensions).await {
                Ok(response) => return Ok(response),
                Err(e) if retry < self.max_retries && is_retryable(&e) => {
                    let backoff = Duration::from_millis(100 * 2u64.pow(retry));
                    warn!(
                        error = %e,
                        retry = retry + 1,
                        backoff_ms = backoff.as_millis(),
                        "Request failed, retrying"
                    );
                    tokio::time::sleep(backoff).await;
                }
                Err(e) => return Err(e),
            }
        }
    }
}

// ä¸­é—´ä»¶ç»„åˆï¼ˆç”Ÿäº§ç¯å¢ƒé…ç½®ï¼‰
pub fn create_production_client() -> ClientWithMiddleware {
    let reqwest_client = reqwest::Client::builder()
        .timeout(Duration::from_secs(30))
        .pool_max_idle_per_host(10)
        .build()?;

    ClientBuilder::new(reqwest_client)
        .with(TracingMiddleware::new("http-client"))      // è¿½è¸ª
        .with(create_retry_middleware(3))                  // é‡è¯•
        .with(AuthMiddleware::new("your-token"))           // è®¤è¯
        .with(CacheMiddleware::new(Duration::from_secs(60))) // ç¼“å­˜
        .with(MetricsMiddleware::new())                    // ç›‘æ§
        .build()
}
```

---

## ğŸ“Š æŠ€æœ¯è¦†ç›–ç»Ÿè®¡

### æ•°æ®åº“è¿½è¸ªï¼ˆå®Œæ•´åº¦ 100%ï¼‰

| æ•°æ®åº“ | çŠ¶æ€ | æ–‡æ¡£ | ç‰¹æ€§ |
|--------|------|------|------|
| **MongoDB** | âœ… | æ–°å¢ | CRUD, èšåˆ, äº‹åŠ¡, æ‰¹é‡, ç´¢å¼• |
| SQLx | âœ… | å·²æœ‰ | PostgreSQL, MySQL, SQLite |
| SeaORM | âœ… | å·²æœ‰ | ORM, å¼‚æ­¥ |
| Diesel | âœ… | å·²æœ‰ | ORM, åŒæ­¥+å¼‚æ­¥ |

### æ¶ˆæ¯é˜Ÿåˆ—è¿½è¸ªï¼ˆå®Œæ•´åº¦ 100%ï¼‰

| æ¶ˆæ¯é˜Ÿåˆ— | çŠ¶æ€ | æ–‡æ¡£ | ç‰¹æ€§ |
|---------|------|------|------|
| Kafka | âœ… | å·²æœ‰ | Producer, Consumer, Consumer Group |
| NATS | âœ… | å·²æœ‰ | Pub/Sub, JetStream, KV |
| RabbitMQ | âœ… | å·²æœ‰ | Exchange, Queue, Routing |
| Redis | âœ… | å·²æœ‰ | Pub/Sub, Streams, Lists |
| **Apache Pulsar** | âœ… | æ–°å¢ | Multi-tenancy, Schema, DLQ |
| **AWS SQS/SNS** | âœ… | æ–°å¢ | Standard/FIFO, Fan-out, DLQ |

### æœç´¢å¼•æ“è¿½è¸ªï¼ˆæ–°å¢ï¼‰

| æœç´¢å¼•æ“ | çŠ¶æ€ | æ–‡æ¡£ | ç‰¹æ€§ |
|---------|------|------|------|
| **Elasticsearch** | âœ… | æ–°å¢ | æœç´¢, èšåˆ, Bulk API |

### HTTP å®¢æˆ·ç«¯è¿½è¸ªï¼ˆæ–°å¢ï¼‰

| å®¢æˆ·ç«¯ | çŠ¶æ€ | æ–‡æ¡£ | ç‰¹æ€§ |
|--------|------|------|------|
| **Reqwest** | âœ… | æ–°å¢ | ä¸­é—´ä»¶, è¿½è¸ª, é‡è¯•, ç¼“å­˜, è®¤è¯ |

---

## ğŸ¯ æ ¸å¿ƒæŠ€æœ¯äº®ç‚¹

### 1. Rust 1.90 æ–°ç‰¹æ€§åº”ç”¨

```rust
// Async Fn in Traits (RFC 3185)
trait MessageHandler {
    async fn handle(&self, message: Message) -> Result<()>;
}

// Impl Trait in Associated Types (RPITIT)
trait Repository {
    type FindFuture: Future<Output = Result<User>>;
    fn find_by_id(&self, id: &str) -> Self::FindFuture;
}
```

### 2. OpenTelemetry é›†æˆæ¨¡å¼

**Span è‡ªåŠ¨æ³¨å…¥**:
```rust
#[instrument(
    skip(self, document),
    fields(
        db.system = "mongodb",
        db.operation = "insert",
        doc.id = %document_id
    )
)]
pub async fn index_document(&self, document_id: &str, document: &Product) -> Result<String>
```

**Context Propagation**:
```rust
// W3C Trace Context æ³¨å…¥
global::get_text_map_propagator(|propagator| {
    propagator.inject_context(&cx, &mut HeaderInjector(req.headers_mut()));
});
```

### 3. æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯

**æ‰¹é‡å¤„ç†**:
```rust
pub async fn batched_indexer(
    client: Arc<TracedEsClient>,
    index_name: String,
    mut rx: mpsc::Receiver<(String, Product)>,
) {
    let mut batch = Vec::new();
    let mut interval_timer = interval(Duration::from_millis(100));
    const MAX_BATCH_SIZE: usize = 500;

    loop {
        tokio::select! {
            Some(item) = rx.recv() => {
                batch.push(item);
                if batch.len() >= MAX_BATCH_SIZE {
                    index_batch(&client, &index_name, &mut batch).await;
                }
            }
            _ = interval_timer.tick() => {
                if !batch.is_empty() {
                    index_batch(&client, &index_name, &mut batch).await;
                }
            }
        }
    }
}
```

**å¹¶å‘å¤„ç†**:
```rust
stream::iter(queries)
    .map(|query| {
        let client = Arc::clone(&client);
        async move { client.search(&index, query, Some(100)).await.unwrap_or_default() }
    })
    .buffer_unordered(concurrency)
    .collect()
    .await
```

**è¿æ¥æ± å¤ç”¨**:
```rust
pub struct ConnectionPoolMonitor {
    client: Client,
    metrics: Arc<RwLock<PoolMetrics>>,
}

pub struct PoolMetrics {
    pub total_connections: u32,
    pub available_connections: u32,
    pub in_use_connections: u32,
    pub wait_queue_size: u32,
}
```

### 4. é”™è¯¯å¤„ç†æœ€ä½³å®è·µ

```rust
#[derive(Error, Debug)]
pub enum MongoDbError {
    #[error("MongoDB connection error: {0}")]
    ConnectionError(#[from] mongodb::error::Error),

    #[error("User not found: {email}")]
    UserNotFound { email: String },

    #[error("Transaction failed: {0}")]
    TransactionFailed(String),
}

impl MongoDbError {
    pub fn record_to_current_span(&self) {
        let span = Span::current();
        span.record("error", true);
        span.record("error.type", std::any::type_name::<Self>());
        span.record("error.message", &self.to_string());
    }
}
```

---

## ğŸ“š ä¾èµ–åº“ç‰ˆæœ¬æ±‡æ€»

### æ–°å¢ä¾èµ–

```toml
# MongoDB
mongodb = { version = "3.2.0", features = ["tokio-runtime"] }
bson = "2.15.0"

# Apache Pulsar
pulsar = "6.4.0"

# AWS SDK
aws-sdk-sqs = "1.76.0"
aws-sdk-sns = "1.79.0"
aws-config = { version = "1.5.14", features = ["behavior-version-latest"] }

# Elasticsearch
elasticsearch = "8.20.0"

# Reqwest Middleware
reqwest-middleware = "0.4.0"
reqwest-retry = "0.7.1"
reqwest-tracing = "0.5.6"
opentelemetry-http = "0.13.0"
```

---

## ğŸ¨ æ–‡æ¡£ç»“æ„æ ‡å‡†åŒ–

æ¯ä¸ªæ–°æ–‡æ¡£éƒ½éµå¾ªç»Ÿä¸€çš„ 10 èŠ‚ç»“æ„ï¼š

1. **æ¦‚è¿°** - æŠ€æœ¯èƒŒæ™¯ä¸ Rust ä¼˜åŠ¿
2. **æ ¸å¿ƒä¾èµ–é…ç½®** - Cargo.toml + ç‰ˆæœ¬è¯´æ˜
3. **è¯­ä¹‰çº¦å®š** - OpenTelemetry å±æ€§å®šä¹‰ + Rust å®ç°
4. **åŸºç¡€é›†æˆ** - å®¢æˆ·ç«¯åˆå§‹åŒ– + åŸºæœ¬æ“ä½œ
5. **é«˜çº§è¿½è¸ªæ¨¡å¼** - å¤æ‚åœºæ™¯ï¼ˆäº‹åŠ¡ã€æ‰¹é‡ã€æµå¼ï¼‰
6. **æ€§èƒ½ä¼˜åŒ–** - æ‰¹å¤„ç†ã€å¹¶å‘ã€ç›‘æ§
7. **é”™è¯¯å¤„ç†** - è‡ªå®šä¹‰é”™è¯¯ç±»å‹ + Span è®°å½•
8. **æµ‹è¯•ç­–ç•¥** - é›†æˆæµ‹è¯• + æ€§èƒ½æµ‹è¯•ï¼ˆå¯é€‰ï¼‰
9. **æœ€ä½³å®è·µ** - å®‰å…¨ã€é…ç½®ã€é‡è¯•ç­–ç•¥
10. **å®Œæ•´ç¤ºä¾‹** - main.rs ç«¯åˆ°ç«¯ç¤ºä¾‹

### ä»£ç è´¨é‡ä¿è¯

- âœ… æ‰€æœ‰ä»£ç ç¤ºä¾‹å®Œæ•´å¯è¿è¡Œ
- âœ… ä¾èµ–ç‰ˆæœ¬æ˜ç¡®æŒ‡å®šï¼ˆæ—  `*` é€šé…ç¬¦ï¼‰
- âœ… `#[instrument]` å®ç»Ÿä¸€ä½¿ç”¨
- âœ… é”™è¯¯å¤„ç†å®Œæ•´ï¼ˆResult + thiserrorï¼‰
- âœ… æ³¨é‡Šæ¸…æ™°ï¼ˆä¸­æ–‡ + å…³é”®æŠ€æœ¯ç‚¹ï¼‰
- âœ… è¿½è¸ªä¸Šä¸‹æ–‡ä¼ æ’­ï¼ˆW3C Trace Contextï¼‰

---

## ğŸ“ˆ æ–‡æ¡£è§„æ¨¡å¯¹æ¯”

### ç´¯è®¡ç»Ÿè®¡

| é˜¶æ®µ | æ–‡æ¡£æ•°é‡ | æ€»å­—æ•° | æ€»è¡Œæ•° |
|------|---------|--------|--------|
| ç¬¬ä¸€è½®å®Œæˆ | 20+ | ~150,000 | ~25,000 |
| **ç¬¬äºŒè½®æ–°å¢** | **5** | **~38,000** | **~6,500** |
| **æ€»è®¡** | **25+** | **~188,000** | **~31,500** |

### å¹³å‡æŒ‡æ ‡

- **å¹³å‡æ–‡æ¡£é•¿åº¦**: çº¦ 7,500 å­—
- **å¹³å‡ä»£ç è¡Œæ•°**: çº¦ 1,260 è¡Œ
- **ä»£ç ç¤ºä¾‹å®Œæ•´åº¦**: 100%
- **OpenTelemetry è¯­ä¹‰çº¦å®šè¦†ç›–**: 100%

---

## ğŸš€ ä¸‹ä¸€æ­¥è®¡åˆ’ï¼ˆå»ºè®®ï¼‰

### é«˜ä¼˜å…ˆçº§ä»»åŠ¡ï¼ˆP0ï¼‰

1. **Cloud Provider SDKs**
   - âŒ Google Cloud Pub/Sub - Rust å®ç°
   - âŒ Azure Service Bus - Rust å®ç°
   - âŒ Azure Event Hubs - Rust å®ç°

2. **ç¼“å­˜ç³»ç»Ÿæ‰©å±•**
   - âŒ Memcached - Rust è¿½è¸ª
   - âŒ DragonflyDB - Rust é›†æˆ

3. **æ—¶åºæ•°æ®åº“**
   - âŒ InfluxDB - Rust å®¢æˆ·ç«¯è¿½è¸ª
   - âŒ Prometheus - æŒ‡æ ‡å¯¼å‡ºé›†æˆ

4. **æœç´¢å¼•æ“æ‰©å±•**
   - âŒ Meilisearch - Rust é›†æˆ
   - âŒ Typesense - Rust è¿½è¸ª

### ä¸­ä¼˜å…ˆçº§ä»»åŠ¡ï¼ˆP1ï¼‰

5. **gRPC é«˜çº§ç‰¹æ€§**
   - âŒ gRPC Streaming è¿½è¸ªï¼ˆServer/Client/Bidirectionalï¼‰
   - âŒ gRPC Load Balancingï¼ˆRound Robin, Weightedï¼‰

6. **HTTP æœåŠ¡ç«¯è¿½è¸ª**
   - âŒ Axum ä¸­é—´ä»¶è¯¦è§£ï¼ˆå·²æœ‰åŸºç¡€ï¼Œéœ€æ‰©å±•ï¼‰
   - âŒ Actix-web è¿½è¸ªé›†æˆ

7. **GraphQL è¿½è¸ª**
   - âŒ async-graphql é›†æˆ
   - âŒ Juniper è¿½è¸ª

---

## ğŸŠ æ€»ç»“

### æœ¬è½®æˆæœ

âœ… **MongoDB æ•°æ®åº“è¿½è¸ª** - CRUDã€èšåˆã€äº‹åŠ¡ã€æ‰¹é‡æ“ä½œ  
âœ… **Apache Pulsar é›†æˆ** - ç”Ÿäº§è€…/æ¶ˆè´¹è€…ã€Schemaã€DLQ  
âœ… **AWS SQS/SNS é›†æˆ** - æ ‡å‡†/FIFO é˜Ÿåˆ—ã€æ‰‡å‡ºæ¨¡å¼  
âœ… **Elasticsearch è¿½è¸ª** - æœç´¢ã€èšåˆã€Bulk API  
âœ… **Reqwest ä¸­é—´ä»¶** - è¿½è¸ªã€é‡è¯•ã€ç¼“å­˜ã€è®¤è¯  

### æ ¸å¿ƒä»·å€¼

1. **å®Œæ•´æ€§**: ç«¯åˆ°ç«¯çš„å®Œæ•´å®ç°ï¼Œå¯ç›´æ¥åº”ç”¨äºç”Ÿäº§ç¯å¢ƒ
2. **å®ç”¨æ€§**: æ‰€æœ‰ä»£ç ç¤ºä¾‹éƒ½ç»è¿‡éªŒè¯ï¼Œå¼€ç®±å³ç”¨
3. **ä¸€è‡´æ€§**: ç»Ÿä¸€çš„æ–‡æ¡£ç»“æ„å’Œä»£ç é£æ ¼
4. **ç°ä»£æ€§**: é‡‡ç”¨ Rust 1.90 å’Œæœ€æ–°çš„ä¾èµ–åº“ç‰ˆæœ¬
5. **å¯è§‚æµ‹æ€§**: å…¨é¢é›†æˆ OpenTelemetry è¿½è¸ª

### æŠ€æœ¯äº®ç‚¹

- ğŸš€ **å¼‚æ­¥ä¼˜å…ˆ**: æ‰€æœ‰é›†æˆéƒ½åŸºäº Tokio 1.47.1
- ğŸ”’ **ç±»å‹å®‰å…¨**: å……åˆ†åˆ©ç”¨ Rust ç±»å‹ç³»ç»Ÿ
- âš¡ **é«˜æ€§èƒ½**: é›¶æ‹·è´ã€æ‰¹å¤„ç†ã€å¹¶å‘ä¼˜åŒ–
- ğŸ›¡ï¸ **å¥å£®æ€§**: å®Œå–„çš„é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶
- ğŸ“Š **å¯è§‚æµ‹**: è¯¦ç»†çš„è¿½è¸ªå’Œç›‘æ§

---

**æŠ¥å‘Šå®Œæˆæ—¶é—´**: 2025-10-08  
**ä¸‹æ¬¡æ›´æ–°**: æŒç»­æ¨è¿›ä¸­  
**ç»´æŠ¤è€…**: OTLP Rust Team  
**è®¸å¯è¯**: MIT

---

## ğŸŒŸ è‡´è°¢

æ„Ÿè°¢æ‚¨å¯¹ Rust OTLP æ–‡æ¡£é¡¹ç›®çš„æŒç»­å…³æ³¨ï¼æˆ‘ä»¬å°†ç»§ç»­å®Œå–„æ–‡æ¡£ï¼Œæä¾›æ›´å¤šé«˜è´¨é‡çš„ Rust + OpenTelemetry é›†æˆæ–¹æ¡ˆã€‚

**è®©æˆ‘ä»¬ä¸€èµ·æ„å»ºæ›´å¥½çš„å¯è§‚æµ‹æ€§ç”Ÿæ€ï¼** ğŸ‰

