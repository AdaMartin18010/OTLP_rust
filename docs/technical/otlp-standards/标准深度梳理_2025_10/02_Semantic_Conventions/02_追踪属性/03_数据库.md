# 数据库语义约定详解

> **Semantic Conventions版本**: v1.27.0  
> **稳定性**: Stable (核心属性), Experimental (部分特定属性)  
> **最后更新**: 2025年10月8日

---

## 目录

- [数据库语义约定详解](#数据库语义约定详解)
  - [目录](#目录)
  - [1. 概述](#1-概述)
  - [2. 通用数据库属性](#2-通用数据库属性)
    - [2.1 必需属性](#21-必需属性)
    - [2.2 推荐属性](#22-推荐属性)
    - [2.3 条件必需属性](#23-条件必需属性)
  - [3. 数据库系统枚举](#3-数据库系统枚举)
  - [4. SQL数据库](#4-sql数据库)
    - [4.1 SQL特定属性](#41-sql特定属性)
    - [4.2 语句脱敏](#42-语句脱敏)
    - [4.3 SQL示例](#43-sql示例)
  - [5. NoSQL数据库](#5-nosql数据库)
    - [5.1 MongoDB](#51-mongodb)
    - [5.2 Cassandra](#52-cassandra)
    - [5.3 Redis](#53-redis)
    - [5.4 Elasticsearch](#54-elasticsearch)
  - [6. 连接池属性](#6-连接池属性)
  - [7. 实现示例](#7-实现示例)
    - [7.1 PostgreSQL (Go)](#71-postgresql-go)
    - [7.2 MongoDB (Go)](#72-mongodb-go)
    - [7.3 Redis (Go)](#73-redis-go)
  - [8. 最佳实践](#8-最佳实践)
  - [9. 参考资源](#9-参考资源)

## 1. 概述

**数据库语义约定适用于**：

```text
1. 关系型数据库 (SQL)
   - PostgreSQL, MySQL, Oracle
   - SQL Server, MariaDB
   - SQLite

2. NoSQL数据库
   - 文档: MongoDB, Couchbase
   - 键值: Redis, Memcached
   - 列族: Cassandra, HBase
   - 图: Neo4j, ArangoDB

3. 搜索引擎
   - Elasticsearch, OpenSearch
   - Solr

4. 时序数据库
   - InfluxDB, Prometheus
   - TimescaleDB
```

---

## 2. 通用数据库属性

### 2.1 必需属性

**所有数据库操作必需的属性**：

| 属性名 | 类型 | 描述 | 示例 |
|--------|------|------|------|
| `db.system` | string | 数据库系统标识 | `postgresql`, `mongodb` |

**db.system 作用**：

```text
1. 标识数据库类型
   - 用于后端分类统计
   - 区分不同数据库的行为

2. 影响其他属性
   - 不同db.system有不同的特定属性
   - 决定db.statement的语法

3. 性能分析
   - 按数据库类型分组
   - 比较不同数据库性能
```

### 2.2 推荐属性

**推荐的通用数据库属性**：

| 属性名 | 类型 | 描述 | 示例 |
|--------|------|------|------|
| `db.name` | string | 数据库名称 | `myapp_production` |
| `db.operation` | string | 操作类型 | `SELECT`, `INSERT`, `find` |
| `db.statement` | string | 数据库语句 | `SELECT * FROM users WHERE id = ?` |
| `server.address` | string | 数据库服务器地址 | `db.example.com` |
| `server.port` | int | 数据库端口 | `5432`, `27017` |

**db.operation 指南**：

```text
SQL数据库:
- SELECT
- INSERT
- UPDATE
- DELETE
- BEGIN
- COMMIT
- ROLLBACK

NoSQL:
MongoDB:
- find
- insert
- update
- delete
- aggregate

Redis:
- GET
- SET
- DEL
- INCR
- HGET

通用规则:
- 使用数据库的标准操作名
- 大写 (SQL) 或小写 (NoSQL)
- 如果无法确定,使用 "query"
```

### 2.3 条件必需属性

**特定场景必需的属性**：

| 属性名 | 类型 | 条件 | 示例 |
|--------|------|------|------|
| `db.user` | string | 如果与连接不同 | `readonly_user` |
| `network.peer.address` | string | 如果与server.address不同 | `10.0.0.5` |
| `network.peer.port` | int | 如果与server.port不同 | `5433` |

---

## 3. 数据库系统枚举

**db.system 标准值**：

```text
关系型数据库 (SQL):
- mysql
- postgresql
- oracle
- mssql (Microsoft SQL Server)
- mariadb
- db2
- sqlite
- h2
- derby
- hive

NoSQL 文档数据库:
- mongodb
- couchbase
- cosmosdb

NoSQL 键值存储:
- redis
- memcached

NoSQL 列族:
- cassandra
- hbase
- scylla

NoSQL 图数据库:
- neo4j
- arangodb
- orientdb

搜索引擎:
- elasticsearch
- opensearch
- solr

时序数据库:
- influxdb
- prometheus
- timescaledb

云服务:
- dynamodb (AWS)
- spanner (GCP)
- cosmosdb (Azure)

其他:
- other_sql (SQL,但未列出)
- other_nosql (NoSQL,但未列出)
```

---

## 4. SQL数据库

### 4.1 SQL特定属性

**SQL数据库专用属性**：

| 属性名 | 类型 | 描述 | 示例 |
|--------|------|------|------|
| `db.sql.table` | string | 主表名 | `users`, `orders` |

**db.sql.table 使用规则**：

```text
单表操作:
SELECT * FROM users WHERE id = 1
→ db.sql.table: "users"

多表JOIN:
SELECT u.*, o.* FROM users u JOIN orders o ON u.id = o.user_id
→ db.sql.table: "users" (主表,通常是FROM后的第一个表)

子查询:
SELECT * FROM (SELECT * FROM users) AS u
→ db.sql.table: "users"

无表查询:
SELECT 1
→ db.sql.table: (不设置)

注意事项:
- 只记录主表,不记录所有表
- 使用table name,不包含schema
- 如果有schema: db.name="mydb", db.sql.table="users"
```

### 4.2 语句脱敏

**db.statement 脱敏规则**：

```text
目标: 移除敏感数据,保留查询结构

原始SQL:
SELECT * FROM users WHERE email = 'user@example.com' AND password = 'secret123'

脱敏方式1 (占位符):
SELECT * FROM users WHERE email = ? AND password = ?

脱敏方式2 (命名占位符):
SELECT * FROM users WHERE email = $1 AND password = $2

脱敏方式3 (省略值):
SELECT * FROM users WHERE email = [REDACTED] AND password = [REDACTED]

推荐: 使用占位符 (方式1或2)

脱敏配置:
db.statement.sanitize: true
db.statement.max_length: 2048
```

**自动脱敏示例**：

```go
func sanitizeSQL(query string, args []interface{}) string {
    // 方式1: 替换为占位符
    sanitized := query
    for range args {
        sanitized = strings.Replace(sanitized, "?", "?", 1)
    }
    return sanitized
}

// 使用prepared statement (自动脱敏)
stmt, _ := db.Prepare("SELECT * FROM users WHERE email = ? AND password = ?")
// span记录: SELECT * FROM users WHERE email = ? AND password = ?
```

### 4.3 SQL示例

**PostgreSQL示例**：

```text
操作: SELECT查询
属性:
  db.system: "postgresql"
  db.name: "myapp_production"
  db.operation: "SELECT"
  db.sql.table: "users"
  db.statement: "SELECT id, name, email FROM users WHERE created_at > $1 LIMIT $2"
  server.address: "db.example.com"
  server.port: 5432
  network.protocol.version: "14.5"

操作: INSERT
属性:
  db.system: "postgresql"
  db.name: "myapp_production"
  db.operation: "INSERT"
  db.sql.table: "orders"
  db.statement: "INSERT INTO orders (user_id, total, status) VALUES ($1, $2, $3)"
  server.address: "db.example.com"
  server.port: 5432

操作: UPDATE
属性:
  db.system: "postgresql"
  db.name: "myapp_production"
  db.operation: "UPDATE"
  db.sql.table: "users"
  db.statement: "UPDATE users SET last_login = $1 WHERE id = $2"
  server.address: "db.example.com"
  server.port: 5432
```

---

## 5. NoSQL数据库

### 5.1 MongoDB

**MongoDB特定属性**：

| 属性名 | 类型 | 描述 | 示例 |
|--------|------|------|------|
| `db.mongodb.collection` | string | 集合名 | `users`, `products` |

**MongoDB示例**：

```text
操作: find查询
属性:
  db.system: "mongodb"
  db.name: "myapp"
  db.operation: "find"
  db.mongodb.collection: "users"
  db.statement: '{"email": "?"}' (脱敏)
  server.address: "mongodb.example.com"
  server.port: 27017

操作: aggregate
属性:
  db.system: "mongodb"
  db.name: "myapp"
  db.operation: "aggregate"
  db.mongodb.collection: "orders"
  db.statement: '[{"$match": {"status": "?"}}, {"$group": {"_id": "$user_id", "total": {"$sum": "$amount"}}}]'
  server.address: "mongodb.example.com"
  server.port: 27017

操作: insertOne
属性:
  db.system: "mongodb"
  db.name: "myapp"
  db.operation: "insert"
  db.mongodb.collection: "users"
  db.statement: '{"name": "?", "email": "?"}'
  server.address: "mongodb.example.com"
  server.port: 27017
```

### 5.2 Cassandra

**Cassandra特定属性**：

| 属性名 | 类型 | 描述 | 示例 |
|--------|------|------|------|
| `db.cassandra.keyspace` | string | Keyspace名 | `mykeyspace` |
| `db.cassandra.table` | string | 表名 | `users` |
| `db.cassandra.consistency_level` | string | 一致性级别 | `QUORUM` |

**Cassandra示例**：

```text
操作: SELECT
属性:
  db.system: "cassandra"
  db.name: "mykeyspace" (或使用db.cassandra.keyspace)
  db.operation: "SELECT"
  db.cassandra.keyspace: "mykeyspace"
  db.cassandra.table: "users"
  db.cassandra.consistency_level: "QUORUM"
  db.statement: "SELECT * FROM users WHERE user_id = ?"
  server.address: "cassandra.example.com"
  server.port: 9042
```

### 5.3 Redis

**Redis特定属性**：

| 属性名 | 类型 | 描述 | 示例 |
|--------|------|------|------|
| `db.redis.database_index` | int | 数据库索引 | `0`, `1` |

**Redis示例**：

```text
操作: GET
属性:
  db.system: "redis"
  db.operation: "GET"
  db.redis.database_index: 0
  db.statement: "GET user:123"
  server.address: "redis.example.com"
  server.port: 6379

操作: SETEX
属性:
  db.system: "redis"
  db.operation: "SETEX"
  db.redis.database_index: 0
  db.statement: "SETEX session:abc123 3600 [REDACTED]"
  server.address: "redis.example.com"
  server.port: 6379

操作: HGETALL
属性:
  db.system: "redis"
  db.operation: "HGETALL"
  db.redis.database_index: 0
  db.statement: "HGETALL user:123"
  server.address: "redis.example.com"
  server.port: 6379
```

### 5.4 Elasticsearch

**Elasticsearch特定属性**：

| 属性名 | 类型 | 描述 | 示例 |
|--------|------|------|------|
| `db.elasticsearch.index` | string | 索引名 | `products`, `logs-2025-10` |

**Elasticsearch示例**：

```text
操作: search
属性:
  db.system: "elasticsearch"
  db.operation: "search"
  db.elasticsearch.index: "products"
  db.statement: '{"query": {"match": {"name": "?"}}}'
  server.address: "es.example.com"
  server.port: 9200
  http.request.method: "POST"
  http.response.status_code: 200
```

---

## 6. 连接池属性

**数据库连接池状态**：

```text
通用属性 (可选):
db.connection_string: "postgresql://db.example.com:5432/myapp"
  (脱敏: 移除密码)

连接池指标:
db.client.connections.usage (UpDownCounter):
- state: idle
- state: used

db.client.connections.max (UpDownCounter):
- 最大连接数

db.client.connections.wait_time (Histogram):
- 等待连接的时间

示例:
db.client.connections.usage{state="idle"} = 5
db.client.connections.usage{state="used"} = 3
db.client.connections.max = 10
```

---

## 7. 实现示例

### 7.1 PostgreSQL (Go)

```go
package main

import (
    "context"
    "database/sql"
    "fmt"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

type TracedDB struct {
    db     *sql.DB
    tracer trace.Tracer
}

func NewTracedDB(db *sql.DB) *TracedDB {
    return &TracedDB{
        db:     db,
        tracer: otel.Tracer("database"),
    }
}

func (tdb *TracedDB) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
    // 提取操作和表名
    operation := extractOperation(query)
    tableName := extractTableName(query)
    
    // 创建span
    ctx, span := tdb.tracer.Start(ctx, fmt.Sprintf("DB %s", operation),
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            // 必需属性
            semconv.DBSystemPostgreSQL,
            
            // 推荐属性
            semconv.DBName("myapp_production"),
            semconv.DBOperation(operation),
            semconv.DBStatement(sanitizeSQL(query)),
            semconv.ServerAddress("db.example.com"),
            semconv.ServerPort(5432),
        ),
    )
    
    if tableName != "" {
        span.SetAttributes(semconv.DBSQLTable(tableName))
    }
    
    defer span.End()
    
    // 执行查询
    rows, err := tdb.db.QueryContext(ctx, query, args...)
    
    if err != nil {
        span.SetStatus(codes.Error, err.Error())
        span.RecordError(err)
        return nil, err
    }
    
    span.SetStatus(codes.Ok, "")
    return rows, nil
}

func extractOperation(query string) string {
    query = strings.TrimSpace(strings.ToUpper(query))
    if strings.HasPrefix(query, "SELECT") {
        return "SELECT"
    } else if strings.HasPrefix(query, "INSERT") {
        return "INSERT"
    } else if strings.HasPrefix(query, "UPDATE") {
        return "UPDATE"
    } else if strings.HasPrefix(query, "DELETE") {
        return "DELETE"
    }
    return "query"
}

func extractTableName(query string) string {
    // 简化实现: 提取FROM后或INSERT INTO后的表名
    // 实际实现应使用SQL parser
    query = strings.ToUpper(query)
    
    if idx := strings.Index(query, "FROM "); idx != -1 {
        rest := query[idx+5:]
        parts := strings.Fields(rest)
        if len(parts) > 0 {
            return strings.ToLower(parts[0])
        }
    }
    
    if idx := strings.Index(query, "INSERT INTO "); idx != -1 {
        rest := query[idx+12:]
        parts := strings.Fields(rest)
        if len(parts) > 0 {
            return strings.ToLower(parts[0])
        }
    }
    
    return ""
}

func sanitizeSQL(query string) string {
    // 实际实现应使用专业的SQL sanitizer
    // 这里仅作示例
    return query // 如果使用prepared statement,query已经是占位符形式
}
```

### 7.2 MongoDB (Go)

```go
package main

import (
    "context"
    "fmt"
    
    "go.mongodb.org/mongo-driver/mongo"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

type TracedMongoCollection struct {
    coll   *mongo.Collection
    tracer trace.Tracer
}

func NewTracedMongoCollection(coll *mongo.Collection) *TracedMongoCollection {
    return &TracedMongoCollection{
        coll:   coll,
        tracer: otel.Tracer("mongodb"),
    }
}

func (tc *TracedMongoCollection) FindOne(ctx context.Context, filter interface{}) *mongo.SingleResult {
    // 创建span
    ctx, span := tc.tracer.Start(ctx, "MongoDB find",
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            semconv.DBSystemMongoDB,
            semconv.DBName(tc.coll.Database().Name()),
            semconv.DBOperation("find"),
            attribute.String("db.mongodb.collection", tc.coll.Name()),
            semconv.DBStatement(sanitizeMongoFilter(filter)),
            semconv.ServerAddress("mongodb.example.com"),
            semconv.ServerPort(27017),
        ),
    )
    defer span.End()
    
    // 执行查询
    result := tc.coll.FindOne(ctx, filter)
    
    if result.Err() != nil && result.Err() != mongo.ErrNoDocuments {
        span.SetStatus(codes.Error, result.Err().Error())
        span.RecordError(result.Err())
    } else {
        span.SetStatus(codes.Ok, "")
    }
    
    return result
}

func sanitizeMongoFilter(filter interface{}) string {
    // 将filter转为JSON字符串,脱敏值
    // 实际实现应遍历BSON文档替换值
    return fmt.Sprintf("%v", filter) // 简化实现
}
```

### 7.3 Redis (Go)

```go
package main

import (
    "context"
    "fmt"
    "strings"
    
    "github.com/redis/go-redis/v9"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

type TracedRedisClient struct {
    client *redis.Client
    tracer trace.Tracer
}

func NewTracedRedisClient(client *redis.Client) *TracedRedisClient {
    return &TracedRedisClient{
        client: client,
        tracer: otel.Tracer("redis"),
    }
}

func (trc *TracedRedisClient) Get(ctx context.Context, key string) *redis.StringCmd {
    // 创建span
    ctx, span := trc.tracer.Start(ctx, "Redis GET",
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            semconv.DBSystemRedis,
            semconv.DBOperation("GET"),
            attribute.Int("db.redis.database_index", 0),
            semconv.DBStatement(fmt.Sprintf("GET %s", key)),
            semconv.ServerAddress("redis.example.com"),
            semconv.ServerPort(6379),
        ),
    )
    defer span.End()
    
    // 执行命令
    cmd := trc.client.Get(ctx, key)
    
    if cmd.Err() != nil && cmd.Err() != redis.Nil {
        span.SetStatus(codes.Error, cmd.Err().Error())
        span.RecordError(cmd.Err())
    } else {
        span.SetStatus(codes.Ok, "")
    }
    
    return cmd
}

func (trc *TracedRedisClient) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.StatusCmd {
    // 创建span
    ctx, span := trc.tracer.Start(ctx, "Redis SET",
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            semconv.DBSystemRedis,
            semconv.DBOperation("SET"),
            attribute.Int("db.redis.database_index", 0),
            semconv.DBStatement(fmt.Sprintf("SET %s [REDACTED]", key)),
            semconv.ServerAddress("redis.example.com"),
            semconv.ServerPort(6379),
        ),
    )
    defer span.End()
    
    // 执行命令
    cmd := trc.client.Set(ctx, key, value, expiration)
    
    if cmd.Err() != nil {
        span.SetStatus(codes.Error, cmd.Err().Error())
        span.RecordError(cmd.Err())
    } else {
        span.SetStatus(codes.Ok, "")
    }
    
    return cmd
}
```

---

## 8. 最佳实践

```text
1. db.system
   ✅ 总是设置db.system
   ✅ 使用标准值
   ❌ 不要使用自定义值

2. db.statement
   ✅ 使用占位符脱敏
   ✅ 限制长度 (≤ 2048字节)
   ❌ 不要记录密码、信用卡号
   ❌ 不要记录完整的大文档

3. db.operation
   ✅ 使用标准操作名
   ✅ 大写 (SQL) 或小写 (NoSQL)
   ✅ 简洁明了

4. 表名/集合名
   ✅ 记录主表/集合
   ✅ 避免高基数 (如动态表名)
   ❌ 不要记录所有JOIN表

5. 性能
   ✅ 避免解析SQL (使用prepared statement)
   ✅ 缓存db.system等静态属性
   ✅ 批量操作记录一个span

6. 错误处理
   ✅ 数据库错误设置Span状态ERROR
   ✅ 记录错误码 (如: PostgreSQL SQLSTATE)
   ✅ 区分连接错误和查询错误

7. 安全
   ❌ 不要记录数据库密码
   ❌ 不要记录敏感查询结果
   ✅ 使用db.statement.sanitize
   ✅ 遵循GDPR等法规
```

---

## 9. 参考资源

- **Semantic Conventions (Database)**: <https://opentelemetry.io/docs/specs/semconv/database/database-spans/>
- **SQL Conventions**: <https://opentelemetry.io/docs/specs/semconv/database/sql/>
- **MongoDB Conventions**: <https://opentelemetry.io/docs/specs/semconv/database/mongodb/>
- **Redis Conventions**: <https://opentelemetry.io/docs/specs/semconv/database/redis/>

---

**文档状态**: ✅ 完成  
**审核状态**: 待审核  
**下一步**: [04_消息队列.md](./04_消息队列.md)
